{- !!! DO NOT EDIT THIS FILE MANUALLY !!! -}

module Proto.Io.Haveno.Protobuffer.Internals_ exposing (FieldNumbersProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message, FieldNumbersProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message, FieldNumbersProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message, FieldNumbersProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message, FieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message, FieldNumbersProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message, FieldNumbersProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message, FieldNumbersProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message, FieldNumbersProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message, FieldNumbersProto__Io__Haveno__Protobuffer__Tradable__Message__Message, FieldNumbersProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message, Proto__Io__Haveno__Protobuffer__AccountAgeWitness, Proto__Io__Haveno__Protobuffer__AccountAgeWitnessStore, Proto__Io__Haveno__Protobuffer__AccountExistsReply, Proto__Io__Haveno__Protobuffer__AccountExistsRequest, Proto__Io__Haveno__Protobuffer__AchTransferAccountPayload, Proto__Io__Haveno__Protobuffer__AckMessage, Proto__Io__Haveno__Protobuffer__AddConnectionReply, Proto__Io__Haveno__Protobuffer__AddConnectionRequest, Proto__Io__Haveno__Protobuffer__AddDataMessage, Proto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage, Proto__Io__Haveno__Protobuffer__AddressBalanceInfo, Proto__Io__Haveno__Protobuffer__AddressEntry, Proto__Io__Haveno__Protobuffer__AddressEntryList, Proto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload, Proto__Io__Haveno__Protobuffer__Alert, Proto__Io__Haveno__Protobuffer__AliPayAccountPayload, Proto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload, Proto__Io__Haveno__Protobuffer__ArbitrationDisputeList, Proto__Io__Haveno__Protobuffer__Arbitrator, Proto__Io__Haveno__Protobuffer__ArbitratorTrade, Proto__Io__Haveno__Protobuffer__Attachment, Proto__Io__Haveno__Protobuffer__AustraliaPayidPayload, Proto__Io__Haveno__Protobuffer__AutoConfirmSettings, Proto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription, Proto__Io__Haveno__Protobuffer__BackupAccountReply, Proto__Io__Haveno__Protobuffer__BackupAccountRequest, Proto__Io__Haveno__Protobuffer__BalancesInfo, Proto__Io__Haveno__Protobuffer__BankAccountPayload, Proto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message, Proto__Io__Haveno__Protobuffer__BizumAccountPayload, Proto__Io__Haveno__Protobuffer__BlockChainExplorer, Proto__Io__Haveno__Protobuffer__BtcBalanceInfo, Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes, Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes_(..), Proto__Io__Haveno__Protobuffer__BuyerAsMakerTrade, Proto__Io__Haveno__Protobuffer__BuyerAsTakerTrade, Proto__Io__Haveno__Protobuffer__ByteArray, Proto__Io__Haveno__Protobuffer__CancelOfferReply, Proto__Io__Haveno__Protobuffer__CancelOfferRequest, Proto__Io__Haveno__Protobuffer__CapitualAccountPayload, Proto__Io__Haveno__Protobuffer__CashAppAccountPayload, Proto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload, Proto__Io__Haveno__Protobuffer__CashDepositAccountPayload, Proto__Io__Haveno__Protobuffer__CelPayAccountPayload, Proto__Io__Haveno__Protobuffer__ChangePasswordReply, Proto__Io__Haveno__Protobuffer__ChangePasswordRequest, Proto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload, Proto__Io__Haveno__Protobuffer__ChatMessage, Proto__Io__Haveno__Protobuffer__CheckConnectionReply, Proto__Io__Haveno__Protobuffer__CheckConnectionRequest, Proto__Io__Haveno__Protobuffer__CheckConnectionsReply, Proto__Io__Haveno__Protobuffer__CheckConnectionsRequest, Proto__Io__Haveno__Protobuffer__CloseAccountReply, Proto__Io__Haveno__Protobuffer__CloseAccountRequest, Proto__Io__Haveno__Protobuffer__CloseConnectionMessage, Proto__Io__Haveno__Protobuffer__CompleteTradeReply, Proto__Io__Haveno__Protobuffer__CompleteTradeRequest, Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply, Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest, Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply, Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest, Proto__Io__Haveno__Protobuffer__Contract, Proto__Io__Haveno__Protobuffer__ContractInfo, Proto__Io__Haveno__Protobuffer__Country, Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload, Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message, Proto__Io__Haveno__Protobuffer__CreateAccountReply, Proto__Io__Haveno__Protobuffer__CreateAccountRequest, Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply, Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest, Proto__Io__Haveno__Protobuffer__CreatePaymentAccountReply, Proto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest, Proto__Io__Haveno__Protobuffer__CreateXmrTxReply, Proto__Io__Haveno__Protobuffer__CreateXmrTxRequest, Proto__Io__Haveno__Protobuffer__CryptoCurrency, Proto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload, Proto__Io__Haveno__Protobuffer__Currency, Proto__Io__Haveno__Protobuffer__DataAndSeqNrPair, Proto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey, Proto__Io__Haveno__Protobuffer__DeleteAccountReply, Proto__Io__Haveno__Protobuffer__DeleteAccountRequest, Proto__Io__Haveno__Protobuffer__DepositRequest, Proto__Io__Haveno__Protobuffer__DepositResponse, Proto__Io__Haveno__Protobuffer__DepositsConfirmedMessage, Proto__Io__Haveno__Protobuffer__Dispute, Proto__Io__Haveno__Protobuffer__DisputeClosedMessage, Proto__Io__Haveno__Protobuffer__DisputeOpenedMessage, Proto__Io__Haveno__Protobuffer__DisputeResult, Proto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload, Proto__Io__Haveno__Protobuffer__EncryptedConnection, Proto__Io__Haveno__Protobuffer__EncryptedConnectionList, Proto__Io__Haveno__Protobuffer__F2FAccountPayload, Proto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload, Proto__Io__Haveno__Protobuffer__FileTransferPart, Proto__Io__Haveno__Protobuffer__Filter, Proto__Io__Haveno__Protobuffer__GetAddressBalanceReply, Proto__Io__Haveno__Protobuffer__GetAddressBalanceRequest, Proto__Io__Haveno__Protobuffer__GetBalancesReply, Proto__Io__Haveno__Protobuffer__GetBalancesRequest, Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply, Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest, Proto__Io__Haveno__Protobuffer__GetChatMessagesReply, Proto__Io__Haveno__Protobuffer__GetChatMessagesRequest, Proto__Io__Haveno__Protobuffer__GetConnectionReply, Proto__Io__Haveno__Protobuffer__GetConnectionRequest, Proto__Io__Haveno__Protobuffer__GetConnectionsReply, Proto__Io__Haveno__Protobuffer__GetConnectionsRequest, Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply, Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest, Proto__Io__Haveno__Protobuffer__GetDataResponse, Proto__Io__Haveno__Protobuffer__GetDisputeReply, Proto__Io__Haveno__Protobuffer__GetDisputeRequest, Proto__Io__Haveno__Protobuffer__GetDisputesReply, Proto__Io__Haveno__Protobuffer__GetDisputesRequest, Proto__Io__Haveno__Protobuffer__GetFundingAddressesReply, Proto__Io__Haveno__Protobuffer__GetFundingAddressesRequest, Proto__Io__Haveno__Protobuffer__GetInventoryRequest, Proto__Io__Haveno__Protobuffer__GetInventoryResponse, Proto__Io__Haveno__Protobuffer__GetMethodHelpReply, Proto__Io__Haveno__Protobuffer__GetMethodHelpRequest, Proto__Io__Haveno__Protobuffer__GetMyOfferReply, Proto__Io__Haveno__Protobuffer__GetMyOfferRequest, Proto__Io__Haveno__Protobuffer__GetMyOffersReply, Proto__Io__Haveno__Protobuffer__GetMyOffersRequest, Proto__Io__Haveno__Protobuffer__GetOfferReply, Proto__Io__Haveno__Protobuffer__GetOfferRequest, Proto__Io__Haveno__Protobuffer__GetOffersReply, Proto__Io__Haveno__Protobuffer__GetOffersRequest, Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply, Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest, Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply, Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest, Proto__Io__Haveno__Protobuffer__GetPaymentAccountsReply, Proto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest, Proto__Io__Haveno__Protobuffer__GetPaymentMethodsReply, Proto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest, Proto__Io__Haveno__Protobuffer__GetPeersRequest, Proto__Io__Haveno__Protobuffer__GetPeersResponse, Proto__Io__Haveno__Protobuffer__GetTradeReply, Proto__Io__Haveno__Protobuffer__GetTradeRequest, Proto__Io__Haveno__Protobuffer__GetTradeStatisticsReply, Proto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest, Proto__Io__Haveno__Protobuffer__GetTradesReply, Proto__Io__Haveno__Protobuffer__GetTradesRequest, Proto__Io__Haveno__Protobuffer__GetUpdatedDataRequest, Proto__Io__Haveno__Protobuffer__GetVersionReply, Proto__Io__Haveno__Protobuffer__GetVersionRequest, Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply, Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest, Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply, Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest, Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply, Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest, Proto__Io__Haveno__Protobuffer__GetXmrSeedReply, Proto__Io__Haveno__Protobuffer__GetXmrSeedRequest, Proto__Io__Haveno__Protobuffer__GetXmrTxsReply, Proto__Io__Haveno__Protobuffer__GetXmrTxsRequest, Proto__Io__Haveno__Protobuffer__HalCashAccountPayload, Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload, Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message, Proto__Io__Haveno__Protobuffer__IgnoredMailboxMap, Proto__Io__Haveno__Protobuffer__ImpsAccountPayload, Proto__Io__Haveno__Protobuffer__InitMultisigRequest, Proto__Io__Haveno__Protobuffer__InitTradeRequest, Proto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload, Proto__Io__Haveno__Protobuffer__InteracETransferAccountPayload, Proto__Io__Haveno__Protobuffer__IsAccountOpenReply, Proto__Io__Haveno__Protobuffer__IsAccountOpenRequest, Proto__Io__Haveno__Protobuffer__IsAppInitializedReply, Proto__Io__Haveno__Protobuffer__IsAppInitializedRequest, Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply, Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest, Proto__Io__Haveno__Protobuffer__JapanBankAccountPayload, Proto__Io__Haveno__Protobuffer__LockWalletReply, Proto__Io__Haveno__Protobuffer__LockWalletRequest, Proto__Io__Haveno__Protobuffer__MailboxItem, Proto__Io__Haveno__Protobuffer__MailboxMessageList, Proto__Io__Haveno__Protobuffer__MailboxStoragePayload, Proto__Io__Haveno__Protobuffer__MapValue, Proto__Io__Haveno__Protobuffer__MarketAlertFilter, Proto__Io__Haveno__Protobuffer__MarketDepthInfo, Proto__Io__Haveno__Protobuffer__MarketDepthReply, Proto__Io__Haveno__Protobuffer__MarketDepthRequest, Proto__Io__Haveno__Protobuffer__MarketPriceInfo, Proto__Io__Haveno__Protobuffer__MarketPriceReply, Proto__Io__Haveno__Protobuffer__MarketPriceRequest, Proto__Io__Haveno__Protobuffer__MarketPricesReply, Proto__Io__Haveno__Protobuffer__MarketPricesRequest, Proto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage, Proto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage, Proto__Io__Haveno__Protobuffer__MediationDisputeList, Proto__Io__Haveno__Protobuffer__Mediator, Proto__Io__Haveno__Protobuffer__MockMailboxPayload, Proto__Io__Haveno__Protobuffer__MockPayload, Proto__Io__Haveno__Protobuffer__MoneseAccountPayload, Proto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload, Proto__Io__Haveno__Protobuffer__MoneyGramAccountPayload, Proto__Io__Haveno__Protobuffer__NationalBankAccountPayload, Proto__Io__Haveno__Protobuffer__NavigationPath, Proto__Io__Haveno__Protobuffer__NeftAccountPayload, Proto__Io__Haveno__Protobuffer__NequiAccountPayload, Proto__Io__Haveno__Protobuffer__NetworkEnvelope, Proto__Io__Haveno__Protobuffer__NetworkEnvelope_(..), Proto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message, Proto__Io__Haveno__Protobuffer__NodeAddress, Proto__Io__Haveno__Protobuffer__NotificationMessage, Proto__Io__Haveno__Protobuffer__OKPayAccountPayload, Proto__Io__Haveno__Protobuffer__Offer, Proto__Io__Haveno__Protobuffer__OfferAvailabilityRequest, Proto__Io__Haveno__Protobuffer__OfferAvailabilityResponse, Proto__Io__Haveno__Protobuffer__OfferInfo, Proto__Io__Haveno__Protobuffer__OfferPayload, Proto__Io__Haveno__Protobuffer__OpenAccountReply, Proto__Io__Haveno__Protobuffer__OpenAccountRequest, Proto__Io__Haveno__Protobuffer__OpenDisputeReply, Proto__Io__Haveno__Protobuffer__OpenDisputeRequest, Proto__Io__Haveno__Protobuffer__OpenOffer, Proto__Io__Haveno__Protobuffer__PaxumAccountPayload, Proto__Io__Haveno__Protobuffer__PayByMailAccountPayload, Proto__Io__Haveno__Protobuffer__PayPalAccountPayload, Proto__Io__Haveno__Protobuffer__PaymentAccount, Proto__Io__Haveno__Protobuffer__PaymentAccountFilter, Proto__Io__Haveno__Protobuffer__PaymentAccountForm, Proto__Io__Haveno__Protobuffer__PaymentAccountFormField, Proto__Io__Haveno__Protobuffer__PaymentAccountList, Proto__Io__Haveno__Protobuffer__PaymentAccountPayload, Proto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message, Proto__Io__Haveno__Protobuffer__PaymentMethod, Proto__Io__Haveno__Protobuffer__PaymentReceivedMessage, Proto__Io__Haveno__Protobuffer__PaymentSentMessage, Proto__Io__Haveno__Protobuffer__PayseraAccountPayload, Proto__Io__Haveno__Protobuffer__PaytmAccountPayload, Proto__Io__Haveno__Protobuffer__Peer, Proto__Io__Haveno__Protobuffer__PeerList, Proto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload, Proto__Io__Haveno__Protobuffer__PersistableEnvelope, Proto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message, Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload, Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message, Proto__Io__Haveno__Protobuffer__Ping, Proto__Io__Haveno__Protobuffer__PixAccountPayload, Proto__Io__Haveno__Protobuffer__Pong, Proto__Io__Haveno__Protobuffer__PopmoneyAccountPayload, Proto__Io__Haveno__Protobuffer__PostOfferReply, Proto__Io__Haveno__Protobuffer__PostOfferRequest, Proto__Io__Haveno__Protobuffer__PreferencesPayload, Proto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage, Proto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest, Proto__Io__Haveno__Protobuffer__PriceAlertFilter, Proto__Io__Haveno__Protobuffer__PrivateNotificationMessage, Proto__Io__Haveno__Protobuffer__PrivateNotificationPayload, Proto__Io__Haveno__Protobuffer__ProcessModel, Proto__Io__Haveno__Protobuffer__PromptPayAccountPayload, Proto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry, Proto__Io__Haveno__Protobuffer__ProtectedStorageEntry, Proto__Io__Haveno__Protobuffer__PubKeyRing, Proto__Io__Haveno__Protobuffer__RawTransactionInput, Proto__Io__Haveno__Protobuffer__RefreshOfferMessage, Proto__Io__Haveno__Protobuffer__RefundAgent, Proto__Io__Haveno__Protobuffer__RefundDisputeList, Proto__Io__Haveno__Protobuffer__Region, Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply, Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest, Proto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest, Proto__Io__Haveno__Protobuffer__RelayXmrTxReply, Proto__Io__Haveno__Protobuffer__RelayXmrTxRequest, Proto__Io__Haveno__Protobuffer__RemoveConnectionReply, Proto__Io__Haveno__Protobuffer__RemoveConnectionRequest, Proto__Io__Haveno__Protobuffer__RemoveDataMessage, Proto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage, Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply, Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest, Proto__Io__Haveno__Protobuffer__RemovedPayloadsMap, Proto__Io__Haveno__Protobuffer__ResolveDisputeReply, Proto__Io__Haveno__Protobuffer__ResolveDisputeRequest, Proto__Io__Haveno__Protobuffer__RestoreAccountReply, Proto__Io__Haveno__Protobuffer__RestoreAccountRequest, Proto__Io__Haveno__Protobuffer__RevolutAccountPayload, Proto__Io__Haveno__Protobuffer__RtgsAccountPayload, Proto__Io__Haveno__Protobuffer__SameBankAccountPayload, Proto__Io__Haveno__Protobuffer__SatispayAccountPayload, Proto__Io__Haveno__Protobuffer__SealedAndSigned, Proto__Io__Haveno__Protobuffer__SellerAsMakerTrade, Proto__Io__Haveno__Protobuffer__SellerAsTakerTrade, Proto__Io__Haveno__Protobuffer__SendBtcRequest, Proto__Io__Haveno__Protobuffer__SendChatMessageReply, Proto__Io__Haveno__Protobuffer__SendChatMessageRequest, Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply, Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest, Proto__Io__Haveno__Protobuffer__SendNotificationReply, Proto__Io__Haveno__Protobuffer__SendNotificationRequest, Proto__Io__Haveno__Protobuffer__SepaAccountPayload, Proto__Io__Haveno__Protobuffer__SepaInstantAccountPayload, Proto__Io__Haveno__Protobuffer__SequenceNumberEntry, Proto__Io__Haveno__Protobuffer__SequenceNumberMap, Proto__Io__Haveno__Protobuffer__SetAutoSwitchReply, Proto__Io__Haveno__Protobuffer__SetAutoSwitchRequest, Proto__Io__Haveno__Protobuffer__SetConnectionReply, Proto__Io__Haveno__Protobuffer__SetConnectionRequest, Proto__Io__Haveno__Protobuffer__SetWalletPasswordReply, Proto__Io__Haveno__Protobuffer__SetWalletPasswordRequest, Proto__Io__Haveno__Protobuffer__SignContractRequest, Proto__Io__Haveno__Protobuffer__SignContractResponse, Proto__Io__Haveno__Protobuffer__SignOfferRequest, Proto__Io__Haveno__Protobuffer__SignOfferResponse, Proto__Io__Haveno__Protobuffer__SignedOffer, Proto__Io__Haveno__Protobuffer__SignedOfferList, Proto__Io__Haveno__Protobuffer__SignedWitness, Proto__Io__Haveno__Protobuffer__SignedWitnessStore, Proto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload, Proto__Io__Haveno__Protobuffer__StartCheckingConnectionReply, Proto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest, Proto__Io__Haveno__Protobuffer__StartXmrNodeReply, Proto__Io__Haveno__Protobuffer__StartXmrNodeRequest, Proto__Io__Haveno__Protobuffer__StopCheckingConnectionReply, Proto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest, Proto__Io__Haveno__Protobuffer__StopReply, Proto__Io__Haveno__Protobuffer__StopRequest, Proto__Io__Haveno__Protobuffer__StopXmrNodeReply, Proto__Io__Haveno__Protobuffer__StopXmrNodeRequest, Proto__Io__Haveno__Protobuffer__StorageEntryWrapper, Proto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message, Proto__Io__Haveno__Protobuffer__StoragePayload, Proto__Io__Haveno__Protobuffer__StoragePayload__Message__Message, Proto__Io__Haveno__Protobuffer__StrikeAccountPayload, Proto__Io__Haveno__Protobuffer__SwiftAccountPayload, Proto__Io__Haveno__Protobuffer__SwishAccountPayload, Proto__Io__Haveno__Protobuffer__TakeOfferReply, Proto__Io__Haveno__Protobuffer__TakeOfferRequest, Proto__Io__Haveno__Protobuffer__TikkieAccountPayload, Proto__Io__Haveno__Protobuffer__Tradable, Proto__Io__Haveno__Protobuffer__TradableList, Proto__Io__Haveno__Protobuffer__Tradable__Message__Message, Proto__Io__Haveno__Protobuffer__Trade, Proto__Io__Haveno__Protobuffer__TradeCurrency, Proto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message, Proto__Io__Haveno__Protobuffer__TradeInfo, Proto__Io__Haveno__Protobuffer__TradePeer, Proto__Io__Haveno__Protobuffer__TradeStatistics3, Proto__Io__Haveno__Protobuffer__TradeStatistics3Store, Proto__Io__Haveno__Protobuffer__TraditionalCurrency, Proto__Io__Haveno__Protobuffer__TransferwiseAccountPayload, Proto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload, Proto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload, Proto__Io__Haveno__Protobuffer__UnlockWalletReply, Proto__Io__Haveno__Protobuffer__UnlockWalletRequest, Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply, Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest, Proto__Io__Haveno__Protobuffer__UpholdAccountPayload, Proto__Io__Haveno__Protobuffer__UpiAccountPayload, Proto__Io__Haveno__Protobuffer__UrlConnection, Proto__Io__Haveno__Protobuffer__UserPayload, Proto__Io__Haveno__Protobuffer__ValidateFormFieldReply, Proto__Io__Haveno__Protobuffer__ValidateFormFieldRequest, Proto__Io__Haveno__Protobuffer__VenmoAccountPayload, Proto__Io__Haveno__Protobuffer__VerseAccountPayload, Proto__Io__Haveno__Protobuffer__WeChatPayAccountPayload, Proto__Io__Haveno__Protobuffer__WesternUnionAccountPayload, Proto__Io__Haveno__Protobuffer__WithdrawFundsReply, Proto__Io__Haveno__Protobuffer__WithdrawFundsRequest, Proto__Io__Haveno__Protobuffer__XmrAddressEntry, Proto__Io__Haveno__Protobuffer__XmrAddressEntryList, Proto__Io__Haveno__Protobuffer__XmrBalanceInfo, Proto__Io__Haveno__Protobuffer__XmrDestination, Proto__Io__Haveno__Protobuffer__XmrIncomingTransfer, Proto__Io__Haveno__Protobuffer__XmrNodeSettings, Proto__Io__Haveno__Protobuffer__XmrOutgoingTransfer, Proto__Io__Haveno__Protobuffer__XmrTx, Proto__Io__Haveno__Protobuffer__ZelleAccountPayload, decodeProto__Io__Haveno__Protobuffer__AccountAgeWitness, decodeProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore, decodeProto__Io__Haveno__Protobuffer__AccountExistsReply, decodeProto__Io__Haveno__Protobuffer__AccountExistsRequest, decodeProto__Io__Haveno__Protobuffer__AchTransferAccountPayload, decodeProto__Io__Haveno__Protobuffer__AckMessage, decodeProto__Io__Haveno__Protobuffer__AddConnectionReply, decodeProto__Io__Haveno__Protobuffer__AddConnectionRequest, decodeProto__Io__Haveno__Protobuffer__AddDataMessage, decodeProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage, decodeProto__Io__Haveno__Protobuffer__AddressBalanceInfo, decodeProto__Io__Haveno__Protobuffer__AddressEntry, decodeProto__Io__Haveno__Protobuffer__AddressEntryList, decodeProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload, decodeProto__Io__Haveno__Protobuffer__Alert, decodeProto__Io__Haveno__Protobuffer__AliPayAccountPayload, decodeProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload, decodeProto__Io__Haveno__Protobuffer__ArbitrationDisputeList, decodeProto__Io__Haveno__Protobuffer__Arbitrator, decodeProto__Io__Haveno__Protobuffer__ArbitratorTrade, decodeProto__Io__Haveno__Protobuffer__Attachment, decodeProto__Io__Haveno__Protobuffer__AustraliaPayidPayload, decodeProto__Io__Haveno__Protobuffer__AutoConfirmSettings, decodeProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription, decodeProto__Io__Haveno__Protobuffer__BackupAccountReply, decodeProto__Io__Haveno__Protobuffer__BackupAccountRequest, decodeProto__Io__Haveno__Protobuffer__BalancesInfo, decodeProto__Io__Haveno__Protobuffer__BankAccountPayload, decodeProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message, decodeProto__Io__Haveno__Protobuffer__BizumAccountPayload, decodeProto__Io__Haveno__Protobuffer__BlockChainExplorer, decodeProto__Io__Haveno__Protobuffer__BtcBalanceInfo, decodeProto__Io__Haveno__Protobuffer__BundleOfEnvelopes, decodeProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade, decodeProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade, decodeProto__Io__Haveno__Protobuffer__ByteArray, decodeProto__Io__Haveno__Protobuffer__CancelOfferReply, decodeProto__Io__Haveno__Protobuffer__CancelOfferRequest, decodeProto__Io__Haveno__Protobuffer__CapitualAccountPayload, decodeProto__Io__Haveno__Protobuffer__CashAppAccountPayload, decodeProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload, decodeProto__Io__Haveno__Protobuffer__CashDepositAccountPayload, decodeProto__Io__Haveno__Protobuffer__CelPayAccountPayload, decodeProto__Io__Haveno__Protobuffer__ChangePasswordReply, decodeProto__Io__Haveno__Protobuffer__ChangePasswordRequest, decodeProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload, decodeProto__Io__Haveno__Protobuffer__ChatMessage, decodeProto__Io__Haveno__Protobuffer__CheckConnectionReply, decodeProto__Io__Haveno__Protobuffer__CheckConnectionRequest, decodeProto__Io__Haveno__Protobuffer__CheckConnectionsReply, decodeProto__Io__Haveno__Protobuffer__CheckConnectionsRequest, decodeProto__Io__Haveno__Protobuffer__CloseAccountReply, decodeProto__Io__Haveno__Protobuffer__CloseAccountRequest, decodeProto__Io__Haveno__Protobuffer__CloseConnectionMessage, decodeProto__Io__Haveno__Protobuffer__CompleteTradeReply, decodeProto__Io__Haveno__Protobuffer__CompleteTradeRequest, decodeProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply, decodeProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest, decodeProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply, decodeProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest, decodeProto__Io__Haveno__Protobuffer__Contract, decodeProto__Io__Haveno__Protobuffer__ContractInfo, decodeProto__Io__Haveno__Protobuffer__Country, decodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload, decodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message, decodeProto__Io__Haveno__Protobuffer__CreateAccountReply, decodeProto__Io__Haveno__Protobuffer__CreateAccountRequest, decodeProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply, decodeProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest, decodeProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply, decodeProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest, decodeProto__Io__Haveno__Protobuffer__CreateXmrTxReply, decodeProto__Io__Haveno__Protobuffer__CreateXmrTxRequest, decodeProto__Io__Haveno__Protobuffer__CryptoCurrency, decodeProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload, decodeProto__Io__Haveno__Protobuffer__Currency, decodeProto__Io__Haveno__Protobuffer__DataAndSeqNrPair, decodeProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey, decodeProto__Io__Haveno__Protobuffer__DeleteAccountReply, decodeProto__Io__Haveno__Protobuffer__DeleteAccountRequest, decodeProto__Io__Haveno__Protobuffer__DepositRequest, decodeProto__Io__Haveno__Protobuffer__DepositResponse, decodeProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage, decodeProto__Io__Haveno__Protobuffer__Dispute, decodeProto__Io__Haveno__Protobuffer__DisputeClosedMessage, decodeProto__Io__Haveno__Protobuffer__DisputeOpenedMessage, decodeProto__Io__Haveno__Protobuffer__DisputeResult, decodeProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload, decodeProto__Io__Haveno__Protobuffer__EncryptedConnection, decodeProto__Io__Haveno__Protobuffer__EncryptedConnectionList, decodeProto__Io__Haveno__Protobuffer__F2FAccountPayload, decodeProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload, decodeProto__Io__Haveno__Protobuffer__FileTransferPart, decodeProto__Io__Haveno__Protobuffer__Filter, decodeProto__Io__Haveno__Protobuffer__GetAddressBalanceReply, decodeProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest, decodeProto__Io__Haveno__Protobuffer__GetBalancesReply, decodeProto__Io__Haveno__Protobuffer__GetBalancesRequest, decodeProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply, decodeProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest, decodeProto__Io__Haveno__Protobuffer__GetChatMessagesReply, decodeProto__Io__Haveno__Protobuffer__GetChatMessagesRequest, decodeProto__Io__Haveno__Protobuffer__GetConnectionReply, decodeProto__Io__Haveno__Protobuffer__GetConnectionRequest, decodeProto__Io__Haveno__Protobuffer__GetConnectionsReply, decodeProto__Io__Haveno__Protobuffer__GetConnectionsRequest, decodeProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply, decodeProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest, decodeProto__Io__Haveno__Protobuffer__GetDataResponse, decodeProto__Io__Haveno__Protobuffer__GetDisputeReply, decodeProto__Io__Haveno__Protobuffer__GetDisputeRequest, decodeProto__Io__Haveno__Protobuffer__GetDisputesReply, decodeProto__Io__Haveno__Protobuffer__GetDisputesRequest, decodeProto__Io__Haveno__Protobuffer__GetFundingAddressesReply, decodeProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest, decodeProto__Io__Haveno__Protobuffer__GetInventoryRequest, decodeProto__Io__Haveno__Protobuffer__GetInventoryResponse, decodeProto__Io__Haveno__Protobuffer__GetMethodHelpReply, decodeProto__Io__Haveno__Protobuffer__GetMethodHelpRequest, decodeProto__Io__Haveno__Protobuffer__GetMyOfferReply, decodeProto__Io__Haveno__Protobuffer__GetMyOfferRequest, decodeProto__Io__Haveno__Protobuffer__GetMyOffersReply, decodeProto__Io__Haveno__Protobuffer__GetMyOffersRequest, decodeProto__Io__Haveno__Protobuffer__GetOfferReply, decodeProto__Io__Haveno__Protobuffer__GetOfferRequest, decodeProto__Io__Haveno__Protobuffer__GetOffersReply, decodeProto__Io__Haveno__Protobuffer__GetOffersRequest, decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply, decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest, decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply, decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest, decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply, decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest, decodeProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply, decodeProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest, decodeProto__Io__Haveno__Protobuffer__GetPeersRequest, decodeProto__Io__Haveno__Protobuffer__GetPeersResponse, decodeProto__Io__Haveno__Protobuffer__GetTradeReply, decodeProto__Io__Haveno__Protobuffer__GetTradeRequest, decodeProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply, decodeProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest, decodeProto__Io__Haveno__Protobuffer__GetTradesReply, decodeProto__Io__Haveno__Protobuffer__GetTradesRequest, decodeProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest, decodeProto__Io__Haveno__Protobuffer__GetVersionReply, decodeProto__Io__Haveno__Protobuffer__GetVersionRequest, decodeProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply, decodeProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest, decodeProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply, decodeProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest, decodeProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply, decodeProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest, decodeProto__Io__Haveno__Protobuffer__GetXmrSeedReply, decodeProto__Io__Haveno__Protobuffer__GetXmrSeedRequest, decodeProto__Io__Haveno__Protobuffer__GetXmrTxsReply, decodeProto__Io__Haveno__Protobuffer__GetXmrTxsRequest, decodeProto__Io__Haveno__Protobuffer__HalCashAccountPayload, decodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload, decodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message, decodeProto__Io__Haveno__Protobuffer__IgnoredMailboxMap, decodeProto__Io__Haveno__Protobuffer__ImpsAccountPayload, decodeProto__Io__Haveno__Protobuffer__InitMultisigRequest, decodeProto__Io__Haveno__Protobuffer__InitTradeRequest, decodeProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload, decodeProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload, decodeProto__Io__Haveno__Protobuffer__IsAccountOpenReply, decodeProto__Io__Haveno__Protobuffer__IsAccountOpenRequest, decodeProto__Io__Haveno__Protobuffer__IsAppInitializedReply, decodeProto__Io__Haveno__Protobuffer__IsAppInitializedRequest, decodeProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply, decodeProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest, decodeProto__Io__Haveno__Protobuffer__JapanBankAccountPayload, decodeProto__Io__Haveno__Protobuffer__LockWalletReply, decodeProto__Io__Haveno__Protobuffer__LockWalletRequest, decodeProto__Io__Haveno__Protobuffer__MailboxItem, decodeProto__Io__Haveno__Protobuffer__MailboxMessageList, decodeProto__Io__Haveno__Protobuffer__MailboxStoragePayload, decodeProto__Io__Haveno__Protobuffer__MapValue, decodeProto__Io__Haveno__Protobuffer__MarketAlertFilter, decodeProto__Io__Haveno__Protobuffer__MarketDepthInfo, decodeProto__Io__Haveno__Protobuffer__MarketDepthReply, decodeProto__Io__Haveno__Protobuffer__MarketDepthRequest, decodeProto__Io__Haveno__Protobuffer__MarketPriceInfo, decodeProto__Io__Haveno__Protobuffer__MarketPriceReply, decodeProto__Io__Haveno__Protobuffer__MarketPriceRequest, decodeProto__Io__Haveno__Protobuffer__MarketPricesReply, decodeProto__Io__Haveno__Protobuffer__MarketPricesRequest, decodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage, decodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage, decodeProto__Io__Haveno__Protobuffer__MediationDisputeList, decodeProto__Io__Haveno__Protobuffer__Mediator, decodeProto__Io__Haveno__Protobuffer__MockMailboxPayload, decodeProto__Io__Haveno__Protobuffer__MockPayload, decodeProto__Io__Haveno__Protobuffer__MoneseAccountPayload, decodeProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload, decodeProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload, decodeProto__Io__Haveno__Protobuffer__NationalBankAccountPayload, decodeProto__Io__Haveno__Protobuffer__NavigationPath, decodeProto__Io__Haveno__Protobuffer__NeftAccountPayload, decodeProto__Io__Haveno__Protobuffer__NequiAccountPayload, decodeProto__Io__Haveno__Protobuffer__NetworkEnvelope, decodeProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message, decodeProto__Io__Haveno__Protobuffer__NodeAddress, decodeProto__Io__Haveno__Protobuffer__NotificationMessage, decodeProto__Io__Haveno__Protobuffer__OKPayAccountPayload, decodeProto__Io__Haveno__Protobuffer__Offer, decodeProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest, decodeProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse, decodeProto__Io__Haveno__Protobuffer__OfferInfo, decodeProto__Io__Haveno__Protobuffer__OfferPayload, decodeProto__Io__Haveno__Protobuffer__OpenAccountReply, decodeProto__Io__Haveno__Protobuffer__OpenAccountRequest, decodeProto__Io__Haveno__Protobuffer__OpenDisputeReply, decodeProto__Io__Haveno__Protobuffer__OpenDisputeRequest, decodeProto__Io__Haveno__Protobuffer__OpenOffer, decodeProto__Io__Haveno__Protobuffer__PaxumAccountPayload, decodeProto__Io__Haveno__Protobuffer__PayByMailAccountPayload, decodeProto__Io__Haveno__Protobuffer__PayPalAccountPayload, decodeProto__Io__Haveno__Protobuffer__PaymentAccount, decodeProto__Io__Haveno__Protobuffer__PaymentAccountFilter, decodeProto__Io__Haveno__Protobuffer__PaymentAccountForm, decodeProto__Io__Haveno__Protobuffer__PaymentAccountFormField, decodeProto__Io__Haveno__Protobuffer__PaymentAccountList, decodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload, decodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message, decodeProto__Io__Haveno__Protobuffer__PaymentMethod, decodeProto__Io__Haveno__Protobuffer__PaymentReceivedMessage, decodeProto__Io__Haveno__Protobuffer__PaymentSentMessage, decodeProto__Io__Haveno__Protobuffer__PayseraAccountPayload, decodeProto__Io__Haveno__Protobuffer__PaytmAccountPayload, decodeProto__Io__Haveno__Protobuffer__Peer, decodeProto__Io__Haveno__Protobuffer__PeerList, decodeProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload, decodeProto__Io__Haveno__Protobuffer__PersistableEnvelope, decodeProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message, decodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload, decodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message, decodeProto__Io__Haveno__Protobuffer__Ping, decodeProto__Io__Haveno__Protobuffer__PixAccountPayload, decodeProto__Io__Haveno__Protobuffer__Pong, decodeProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload, decodeProto__Io__Haveno__Protobuffer__PostOfferReply, decodeProto__Io__Haveno__Protobuffer__PostOfferRequest, decodeProto__Io__Haveno__Protobuffer__PreferencesPayload, decodeProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage, decodeProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest, decodeProto__Io__Haveno__Protobuffer__PriceAlertFilter, decodeProto__Io__Haveno__Protobuffer__PrivateNotificationMessage, decodeProto__Io__Haveno__Protobuffer__PrivateNotificationPayload, decodeProto__Io__Haveno__Protobuffer__ProcessModel, decodeProto__Io__Haveno__Protobuffer__PromptPayAccountPayload, decodeProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry, decodeProto__Io__Haveno__Protobuffer__ProtectedStorageEntry, decodeProto__Io__Haveno__Protobuffer__PubKeyRing, decodeProto__Io__Haveno__Protobuffer__RawTransactionInput, decodeProto__Io__Haveno__Protobuffer__RefreshOfferMessage, decodeProto__Io__Haveno__Protobuffer__RefundAgent, decodeProto__Io__Haveno__Protobuffer__RefundDisputeList, decodeProto__Io__Haveno__Protobuffer__Region, decodeProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply, decodeProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest, decodeProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest, decodeProto__Io__Haveno__Protobuffer__RelayXmrTxReply, decodeProto__Io__Haveno__Protobuffer__RelayXmrTxRequest, decodeProto__Io__Haveno__Protobuffer__RemoveConnectionReply, decodeProto__Io__Haveno__Protobuffer__RemoveConnectionRequest, decodeProto__Io__Haveno__Protobuffer__RemoveDataMessage, decodeProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage, decodeProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply, decodeProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest, decodeProto__Io__Haveno__Protobuffer__RemovedPayloadsMap, decodeProto__Io__Haveno__Protobuffer__ResolveDisputeReply, decodeProto__Io__Haveno__Protobuffer__ResolveDisputeRequest, decodeProto__Io__Haveno__Protobuffer__RestoreAccountReply, decodeProto__Io__Haveno__Protobuffer__RestoreAccountRequest, decodeProto__Io__Haveno__Protobuffer__RevolutAccountPayload, decodeProto__Io__Haveno__Protobuffer__RtgsAccountPayload, decodeProto__Io__Haveno__Protobuffer__SameBankAccountPayload, decodeProto__Io__Haveno__Protobuffer__SatispayAccountPayload, decodeProto__Io__Haveno__Protobuffer__SealedAndSigned, decodeProto__Io__Haveno__Protobuffer__SellerAsMakerTrade, decodeProto__Io__Haveno__Protobuffer__SellerAsTakerTrade, decodeProto__Io__Haveno__Protobuffer__SendBtcRequest, decodeProto__Io__Haveno__Protobuffer__SendChatMessageReply, decodeProto__Io__Haveno__Protobuffer__SendChatMessageRequest, decodeProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply, decodeProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest, decodeProto__Io__Haveno__Protobuffer__SendNotificationReply, decodeProto__Io__Haveno__Protobuffer__SendNotificationRequest, decodeProto__Io__Haveno__Protobuffer__SepaAccountPayload, decodeProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload, decodeProto__Io__Haveno__Protobuffer__SequenceNumberEntry, decodeProto__Io__Haveno__Protobuffer__SequenceNumberMap, decodeProto__Io__Haveno__Protobuffer__SetAutoSwitchReply, decodeProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest, decodeProto__Io__Haveno__Protobuffer__SetConnectionReply, decodeProto__Io__Haveno__Protobuffer__SetConnectionRequest, decodeProto__Io__Haveno__Protobuffer__SetWalletPasswordReply, decodeProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest, decodeProto__Io__Haveno__Protobuffer__SignContractRequest, decodeProto__Io__Haveno__Protobuffer__SignContractResponse, decodeProto__Io__Haveno__Protobuffer__SignOfferRequest, decodeProto__Io__Haveno__Protobuffer__SignOfferResponse, decodeProto__Io__Haveno__Protobuffer__SignedOffer, decodeProto__Io__Haveno__Protobuffer__SignedOfferList, decodeProto__Io__Haveno__Protobuffer__SignedWitness, decodeProto__Io__Haveno__Protobuffer__SignedWitnessStore, decodeProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload, decodeProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply, decodeProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest, decodeProto__Io__Haveno__Protobuffer__StartXmrNodeReply, decodeProto__Io__Haveno__Protobuffer__StartXmrNodeRequest, decodeProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply, decodeProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest, decodeProto__Io__Haveno__Protobuffer__StopReply, decodeProto__Io__Haveno__Protobuffer__StopRequest, decodeProto__Io__Haveno__Protobuffer__StopXmrNodeReply, decodeProto__Io__Haveno__Protobuffer__StopXmrNodeRequest, decodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper, decodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message, decodeProto__Io__Haveno__Protobuffer__StoragePayload, decodeProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message, decodeProto__Io__Haveno__Protobuffer__StrikeAccountPayload, decodeProto__Io__Haveno__Protobuffer__SwiftAccountPayload, decodeProto__Io__Haveno__Protobuffer__SwishAccountPayload, decodeProto__Io__Haveno__Protobuffer__TakeOfferReply, decodeProto__Io__Haveno__Protobuffer__TakeOfferRequest, decodeProto__Io__Haveno__Protobuffer__TikkieAccountPayload, decodeProto__Io__Haveno__Protobuffer__Tradable, decodeProto__Io__Haveno__Protobuffer__TradableList, decodeProto__Io__Haveno__Protobuffer__Tradable__Message__Message, decodeProto__Io__Haveno__Protobuffer__Trade, decodeProto__Io__Haveno__Protobuffer__TradeCurrency, decodeProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message, decodeProto__Io__Haveno__Protobuffer__TradeInfo, decodeProto__Io__Haveno__Protobuffer__TradePeer, decodeProto__Io__Haveno__Protobuffer__TradeStatistics3, decodeProto__Io__Haveno__Protobuffer__TradeStatistics3Store, decodeProto__Io__Haveno__Protobuffer__TraditionalCurrency, decodeProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload, decodeProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload, decodeProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload, decodeProto__Io__Haveno__Protobuffer__UnlockWalletReply, decodeProto__Io__Haveno__Protobuffer__UnlockWalletRequest, decodeProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply, decodeProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest, decodeProto__Io__Haveno__Protobuffer__UpholdAccountPayload, decodeProto__Io__Haveno__Protobuffer__UpiAccountPayload, decodeProto__Io__Haveno__Protobuffer__UrlConnection, decodeProto__Io__Haveno__Protobuffer__UserPayload, decodeProto__Io__Haveno__Protobuffer__ValidateFormFieldReply, decodeProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest, decodeProto__Io__Haveno__Protobuffer__VenmoAccountPayload, decodeProto__Io__Haveno__Protobuffer__VerseAccountPayload, decodeProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload, decodeProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload, decodeProto__Io__Haveno__Protobuffer__WithdrawFundsReply, decodeProto__Io__Haveno__Protobuffer__WithdrawFundsRequest, decodeProto__Io__Haveno__Protobuffer__XmrAddressEntry, decodeProto__Io__Haveno__Protobuffer__XmrAddressEntryList, decodeProto__Io__Haveno__Protobuffer__XmrBalanceInfo, decodeProto__Io__Haveno__Protobuffer__XmrDestination, decodeProto__Io__Haveno__Protobuffer__XmrIncomingTransfer, decodeProto__Io__Haveno__Protobuffer__XmrNodeSettings, decodeProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer, decodeProto__Io__Haveno__Protobuffer__XmrTx, decodeProto__Io__Haveno__Protobuffer__ZelleAccountPayload, defaultProto__Io__Haveno__Protobuffer__AccountAgeWitness, defaultProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore, defaultProto__Io__Haveno__Protobuffer__AccountExistsReply, defaultProto__Io__Haveno__Protobuffer__AccountExistsRequest, defaultProto__Io__Haveno__Protobuffer__AchTransferAccountPayload, defaultProto__Io__Haveno__Protobuffer__AckMessage, defaultProto__Io__Haveno__Protobuffer__AddConnectionReply, defaultProto__Io__Haveno__Protobuffer__AddConnectionRequest, defaultProto__Io__Haveno__Protobuffer__AddDataMessage, defaultProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage, defaultProto__Io__Haveno__Protobuffer__AddressBalanceInfo, defaultProto__Io__Haveno__Protobuffer__AddressEntry, defaultProto__Io__Haveno__Protobuffer__AddressEntryList, defaultProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload, defaultProto__Io__Haveno__Protobuffer__Alert, defaultProto__Io__Haveno__Protobuffer__AliPayAccountPayload, defaultProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload, defaultProto__Io__Haveno__Protobuffer__ArbitrationDisputeList, defaultProto__Io__Haveno__Protobuffer__Arbitrator, defaultProto__Io__Haveno__Protobuffer__ArbitratorTrade, defaultProto__Io__Haveno__Protobuffer__Attachment, defaultProto__Io__Haveno__Protobuffer__AustraliaPayidPayload, defaultProto__Io__Haveno__Protobuffer__AutoConfirmSettings, defaultProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription, defaultProto__Io__Haveno__Protobuffer__BackupAccountReply, defaultProto__Io__Haveno__Protobuffer__BackupAccountRequest, defaultProto__Io__Haveno__Protobuffer__BalancesInfo, defaultProto__Io__Haveno__Protobuffer__BankAccountPayload, defaultProto__Io__Haveno__Protobuffer__BizumAccountPayload, defaultProto__Io__Haveno__Protobuffer__BlockChainExplorer, defaultProto__Io__Haveno__Protobuffer__BtcBalanceInfo, defaultProto__Io__Haveno__Protobuffer__BundleOfEnvelopes, defaultProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade, defaultProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade, defaultProto__Io__Haveno__Protobuffer__ByteArray, defaultProto__Io__Haveno__Protobuffer__CancelOfferReply, defaultProto__Io__Haveno__Protobuffer__CancelOfferRequest, defaultProto__Io__Haveno__Protobuffer__CapitualAccountPayload, defaultProto__Io__Haveno__Protobuffer__CashAppAccountPayload, defaultProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload, defaultProto__Io__Haveno__Protobuffer__CashDepositAccountPayload, defaultProto__Io__Haveno__Protobuffer__CelPayAccountPayload, defaultProto__Io__Haveno__Protobuffer__ChangePasswordReply, defaultProto__Io__Haveno__Protobuffer__ChangePasswordRequest, defaultProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload, defaultProto__Io__Haveno__Protobuffer__ChatMessage, defaultProto__Io__Haveno__Protobuffer__CheckConnectionReply, defaultProto__Io__Haveno__Protobuffer__CheckConnectionRequest, defaultProto__Io__Haveno__Protobuffer__CheckConnectionsReply, defaultProto__Io__Haveno__Protobuffer__CheckConnectionsRequest, defaultProto__Io__Haveno__Protobuffer__CloseAccountReply, defaultProto__Io__Haveno__Protobuffer__CloseAccountRequest, defaultProto__Io__Haveno__Protobuffer__CloseConnectionMessage, defaultProto__Io__Haveno__Protobuffer__CompleteTradeReply, defaultProto__Io__Haveno__Protobuffer__CompleteTradeRequest, defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply, defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest, defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply, defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest, defaultProto__Io__Haveno__Protobuffer__Contract, defaultProto__Io__Haveno__Protobuffer__ContractInfo, defaultProto__Io__Haveno__Protobuffer__Country, defaultProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload, defaultProto__Io__Haveno__Protobuffer__CreateAccountReply, defaultProto__Io__Haveno__Protobuffer__CreateAccountRequest, defaultProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply, defaultProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest, defaultProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply, defaultProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest, defaultProto__Io__Haveno__Protobuffer__CreateXmrTxReply, defaultProto__Io__Haveno__Protobuffer__CreateXmrTxRequest, defaultProto__Io__Haveno__Protobuffer__CryptoCurrency, defaultProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload, defaultProto__Io__Haveno__Protobuffer__Currency, defaultProto__Io__Haveno__Protobuffer__DataAndSeqNrPair, defaultProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey, defaultProto__Io__Haveno__Protobuffer__DeleteAccountReply, defaultProto__Io__Haveno__Protobuffer__DeleteAccountRequest, defaultProto__Io__Haveno__Protobuffer__DepositRequest, defaultProto__Io__Haveno__Protobuffer__DepositResponse, defaultProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage, defaultProto__Io__Haveno__Protobuffer__Dispute, defaultProto__Io__Haveno__Protobuffer__DisputeClosedMessage, defaultProto__Io__Haveno__Protobuffer__DisputeOpenedMessage, defaultProto__Io__Haveno__Protobuffer__DisputeResult, defaultProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload, defaultProto__Io__Haveno__Protobuffer__EncryptedConnection, defaultProto__Io__Haveno__Protobuffer__EncryptedConnectionList, defaultProto__Io__Haveno__Protobuffer__F2FAccountPayload, defaultProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload, defaultProto__Io__Haveno__Protobuffer__FileTransferPart, defaultProto__Io__Haveno__Protobuffer__Filter, defaultProto__Io__Haveno__Protobuffer__GetAddressBalanceReply, defaultProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest, defaultProto__Io__Haveno__Protobuffer__GetBalancesReply, defaultProto__Io__Haveno__Protobuffer__GetBalancesRequest, defaultProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply, defaultProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest, defaultProto__Io__Haveno__Protobuffer__GetChatMessagesReply, defaultProto__Io__Haveno__Protobuffer__GetChatMessagesRequest, defaultProto__Io__Haveno__Protobuffer__GetConnectionReply, defaultProto__Io__Haveno__Protobuffer__GetConnectionRequest, defaultProto__Io__Haveno__Protobuffer__GetConnectionsReply, defaultProto__Io__Haveno__Protobuffer__GetConnectionsRequest, defaultProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply, defaultProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest, defaultProto__Io__Haveno__Protobuffer__GetDataResponse, defaultProto__Io__Haveno__Protobuffer__GetDisputeReply, defaultProto__Io__Haveno__Protobuffer__GetDisputeRequest, defaultProto__Io__Haveno__Protobuffer__GetDisputesReply, defaultProto__Io__Haveno__Protobuffer__GetDisputesRequest, defaultProto__Io__Haveno__Protobuffer__GetFundingAddressesReply, defaultProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest, defaultProto__Io__Haveno__Protobuffer__GetInventoryRequest, defaultProto__Io__Haveno__Protobuffer__GetInventoryResponse, defaultProto__Io__Haveno__Protobuffer__GetMethodHelpReply, defaultProto__Io__Haveno__Protobuffer__GetMethodHelpRequest, defaultProto__Io__Haveno__Protobuffer__GetMyOfferReply, defaultProto__Io__Haveno__Protobuffer__GetMyOfferRequest, defaultProto__Io__Haveno__Protobuffer__GetMyOffersReply, defaultProto__Io__Haveno__Protobuffer__GetMyOffersRequest, defaultProto__Io__Haveno__Protobuffer__GetOfferReply, defaultProto__Io__Haveno__Protobuffer__GetOfferRequest, defaultProto__Io__Haveno__Protobuffer__GetOffersReply, defaultProto__Io__Haveno__Protobuffer__GetOffersRequest, defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply, defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest, defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply, defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest, defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply, defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest, defaultProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply, defaultProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest, defaultProto__Io__Haveno__Protobuffer__GetPeersRequest, defaultProto__Io__Haveno__Protobuffer__GetPeersResponse, defaultProto__Io__Haveno__Protobuffer__GetTradeReply, defaultProto__Io__Haveno__Protobuffer__GetTradeRequest, defaultProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply, defaultProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest, defaultProto__Io__Haveno__Protobuffer__GetTradesReply, defaultProto__Io__Haveno__Protobuffer__GetTradesRequest, defaultProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest, defaultProto__Io__Haveno__Protobuffer__GetVersionReply, defaultProto__Io__Haveno__Protobuffer__GetVersionRequest, defaultProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply, defaultProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest, defaultProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply, defaultProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest, defaultProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply, defaultProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest, defaultProto__Io__Haveno__Protobuffer__GetXmrSeedReply, defaultProto__Io__Haveno__Protobuffer__GetXmrSeedRequest, defaultProto__Io__Haveno__Protobuffer__GetXmrTxsReply, defaultProto__Io__Haveno__Protobuffer__GetXmrTxsRequest, defaultProto__Io__Haveno__Protobuffer__HalCashAccountPayload, defaultProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload, defaultProto__Io__Haveno__Protobuffer__IgnoredMailboxMap, defaultProto__Io__Haveno__Protobuffer__ImpsAccountPayload, defaultProto__Io__Haveno__Protobuffer__InitMultisigRequest, defaultProto__Io__Haveno__Protobuffer__InitTradeRequest, defaultProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload, defaultProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload, defaultProto__Io__Haveno__Protobuffer__IsAccountOpenReply, defaultProto__Io__Haveno__Protobuffer__IsAccountOpenRequest, defaultProto__Io__Haveno__Protobuffer__IsAppInitializedReply, defaultProto__Io__Haveno__Protobuffer__IsAppInitializedRequest, defaultProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply, defaultProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest, defaultProto__Io__Haveno__Protobuffer__JapanBankAccountPayload, defaultProto__Io__Haveno__Protobuffer__LockWalletReply, defaultProto__Io__Haveno__Protobuffer__LockWalletRequest, defaultProto__Io__Haveno__Protobuffer__MailboxItem, defaultProto__Io__Haveno__Protobuffer__MailboxMessageList, defaultProto__Io__Haveno__Protobuffer__MailboxStoragePayload, defaultProto__Io__Haveno__Protobuffer__MapValue, defaultProto__Io__Haveno__Protobuffer__MarketAlertFilter, defaultProto__Io__Haveno__Protobuffer__MarketDepthInfo, defaultProto__Io__Haveno__Protobuffer__MarketDepthReply, defaultProto__Io__Haveno__Protobuffer__MarketDepthRequest, defaultProto__Io__Haveno__Protobuffer__MarketPriceInfo, defaultProto__Io__Haveno__Protobuffer__MarketPriceReply, defaultProto__Io__Haveno__Protobuffer__MarketPriceRequest, defaultProto__Io__Haveno__Protobuffer__MarketPricesReply, defaultProto__Io__Haveno__Protobuffer__MarketPricesRequest, defaultProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage, defaultProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage, defaultProto__Io__Haveno__Protobuffer__MediationDisputeList, defaultProto__Io__Haveno__Protobuffer__Mediator, defaultProto__Io__Haveno__Protobuffer__MockMailboxPayload, defaultProto__Io__Haveno__Protobuffer__MockPayload, defaultProto__Io__Haveno__Protobuffer__MoneseAccountPayload, defaultProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload, defaultProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload, defaultProto__Io__Haveno__Protobuffer__NationalBankAccountPayload, defaultProto__Io__Haveno__Protobuffer__NavigationPath, defaultProto__Io__Haveno__Protobuffer__NeftAccountPayload, defaultProto__Io__Haveno__Protobuffer__NequiAccountPayload, defaultProto__Io__Haveno__Protobuffer__NetworkEnvelope, defaultProto__Io__Haveno__Protobuffer__NodeAddress, defaultProto__Io__Haveno__Protobuffer__NotificationMessage, defaultProto__Io__Haveno__Protobuffer__OKPayAccountPayload, defaultProto__Io__Haveno__Protobuffer__Offer, defaultProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest, defaultProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse, defaultProto__Io__Haveno__Protobuffer__OfferInfo, defaultProto__Io__Haveno__Protobuffer__OfferPayload, defaultProto__Io__Haveno__Protobuffer__OpenAccountReply, defaultProto__Io__Haveno__Protobuffer__OpenAccountRequest, defaultProto__Io__Haveno__Protobuffer__OpenDisputeReply, defaultProto__Io__Haveno__Protobuffer__OpenDisputeRequest, defaultProto__Io__Haveno__Protobuffer__OpenOffer, defaultProto__Io__Haveno__Protobuffer__PaxumAccountPayload, defaultProto__Io__Haveno__Protobuffer__PayByMailAccountPayload, defaultProto__Io__Haveno__Protobuffer__PayPalAccountPayload, defaultProto__Io__Haveno__Protobuffer__PaymentAccount, defaultProto__Io__Haveno__Protobuffer__PaymentAccountFilter, defaultProto__Io__Haveno__Protobuffer__PaymentAccountForm, defaultProto__Io__Haveno__Protobuffer__PaymentAccountFormField, defaultProto__Io__Haveno__Protobuffer__PaymentAccountList, defaultProto__Io__Haveno__Protobuffer__PaymentAccountPayload, defaultProto__Io__Haveno__Protobuffer__PaymentMethod, defaultProto__Io__Haveno__Protobuffer__PaymentReceivedMessage, defaultProto__Io__Haveno__Protobuffer__PaymentSentMessage, defaultProto__Io__Haveno__Protobuffer__PayseraAccountPayload, defaultProto__Io__Haveno__Protobuffer__PaytmAccountPayload, defaultProto__Io__Haveno__Protobuffer__Peer, defaultProto__Io__Haveno__Protobuffer__PeerList, defaultProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload, defaultProto__Io__Haveno__Protobuffer__PersistableEnvelope, defaultProto__Io__Haveno__Protobuffer__PersistableNetworkPayload, defaultProto__Io__Haveno__Protobuffer__Ping, defaultProto__Io__Haveno__Protobuffer__PixAccountPayload, defaultProto__Io__Haveno__Protobuffer__Pong, defaultProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload, defaultProto__Io__Haveno__Protobuffer__PostOfferReply, defaultProto__Io__Haveno__Protobuffer__PostOfferRequest, defaultProto__Io__Haveno__Protobuffer__PreferencesPayload, defaultProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage, defaultProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest, defaultProto__Io__Haveno__Protobuffer__PriceAlertFilter, defaultProto__Io__Haveno__Protobuffer__PrivateNotificationMessage, defaultProto__Io__Haveno__Protobuffer__PrivateNotificationPayload, defaultProto__Io__Haveno__Protobuffer__ProcessModel, defaultProto__Io__Haveno__Protobuffer__PromptPayAccountPayload, defaultProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry, defaultProto__Io__Haveno__Protobuffer__ProtectedStorageEntry, defaultProto__Io__Haveno__Protobuffer__PubKeyRing, defaultProto__Io__Haveno__Protobuffer__RawTransactionInput, defaultProto__Io__Haveno__Protobuffer__RefreshOfferMessage, defaultProto__Io__Haveno__Protobuffer__RefundAgent, defaultProto__Io__Haveno__Protobuffer__RefundDisputeList, defaultProto__Io__Haveno__Protobuffer__Region, defaultProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply, defaultProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest, defaultProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest, defaultProto__Io__Haveno__Protobuffer__RelayXmrTxReply, defaultProto__Io__Haveno__Protobuffer__RelayXmrTxRequest, defaultProto__Io__Haveno__Protobuffer__RemoveConnectionReply, defaultProto__Io__Haveno__Protobuffer__RemoveConnectionRequest, defaultProto__Io__Haveno__Protobuffer__RemoveDataMessage, defaultProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage, defaultProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply, defaultProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest, defaultProto__Io__Haveno__Protobuffer__RemovedPayloadsMap, defaultProto__Io__Haveno__Protobuffer__ResolveDisputeReply, defaultProto__Io__Haveno__Protobuffer__ResolveDisputeRequest, defaultProto__Io__Haveno__Protobuffer__RestoreAccountReply, defaultProto__Io__Haveno__Protobuffer__RestoreAccountRequest, defaultProto__Io__Haveno__Protobuffer__RevolutAccountPayload, defaultProto__Io__Haveno__Protobuffer__RtgsAccountPayload, defaultProto__Io__Haveno__Protobuffer__SameBankAccountPayload, defaultProto__Io__Haveno__Protobuffer__SatispayAccountPayload, defaultProto__Io__Haveno__Protobuffer__SealedAndSigned, defaultProto__Io__Haveno__Protobuffer__SellerAsMakerTrade, defaultProto__Io__Haveno__Protobuffer__SellerAsTakerTrade, defaultProto__Io__Haveno__Protobuffer__SendBtcRequest, defaultProto__Io__Haveno__Protobuffer__SendChatMessageReply, defaultProto__Io__Haveno__Protobuffer__SendChatMessageRequest, defaultProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply, defaultProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest, defaultProto__Io__Haveno__Protobuffer__SendNotificationReply, defaultProto__Io__Haveno__Protobuffer__SendNotificationRequest, defaultProto__Io__Haveno__Protobuffer__SepaAccountPayload, defaultProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload, defaultProto__Io__Haveno__Protobuffer__SequenceNumberEntry, defaultProto__Io__Haveno__Protobuffer__SequenceNumberMap, defaultProto__Io__Haveno__Protobuffer__SetAutoSwitchReply, defaultProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest, defaultProto__Io__Haveno__Protobuffer__SetConnectionReply, defaultProto__Io__Haveno__Protobuffer__SetConnectionRequest, defaultProto__Io__Haveno__Protobuffer__SetWalletPasswordReply, defaultProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest, defaultProto__Io__Haveno__Protobuffer__SignContractRequest, defaultProto__Io__Haveno__Protobuffer__SignContractResponse, defaultProto__Io__Haveno__Protobuffer__SignOfferRequest, defaultProto__Io__Haveno__Protobuffer__SignOfferResponse, defaultProto__Io__Haveno__Protobuffer__SignedOffer, defaultProto__Io__Haveno__Protobuffer__SignedOfferList, defaultProto__Io__Haveno__Protobuffer__SignedWitness, defaultProto__Io__Haveno__Protobuffer__SignedWitnessStore, defaultProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload, defaultProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply, defaultProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest, defaultProto__Io__Haveno__Protobuffer__StartXmrNodeReply, defaultProto__Io__Haveno__Protobuffer__StartXmrNodeRequest, defaultProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply, defaultProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest, defaultProto__Io__Haveno__Protobuffer__StopReply, defaultProto__Io__Haveno__Protobuffer__StopRequest, defaultProto__Io__Haveno__Protobuffer__StopXmrNodeReply, defaultProto__Io__Haveno__Protobuffer__StopXmrNodeRequest, defaultProto__Io__Haveno__Protobuffer__StorageEntryWrapper, defaultProto__Io__Haveno__Protobuffer__StoragePayload, defaultProto__Io__Haveno__Protobuffer__StrikeAccountPayload, defaultProto__Io__Haveno__Protobuffer__SwiftAccountPayload, defaultProto__Io__Haveno__Protobuffer__SwishAccountPayload, defaultProto__Io__Haveno__Protobuffer__TakeOfferReply, defaultProto__Io__Haveno__Protobuffer__TakeOfferRequest, defaultProto__Io__Haveno__Protobuffer__TikkieAccountPayload, defaultProto__Io__Haveno__Protobuffer__Tradable, defaultProto__Io__Haveno__Protobuffer__TradableList, defaultProto__Io__Haveno__Protobuffer__Trade, defaultProto__Io__Haveno__Protobuffer__TradeCurrency, defaultProto__Io__Haveno__Protobuffer__TradeInfo, defaultProto__Io__Haveno__Protobuffer__TradePeer, defaultProto__Io__Haveno__Protobuffer__TradeStatistics3, defaultProto__Io__Haveno__Protobuffer__TradeStatistics3Store, defaultProto__Io__Haveno__Protobuffer__TraditionalCurrency, defaultProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload, defaultProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload, defaultProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload, defaultProto__Io__Haveno__Protobuffer__UnlockWalletReply, defaultProto__Io__Haveno__Protobuffer__UnlockWalletRequest, defaultProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply, defaultProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest, defaultProto__Io__Haveno__Protobuffer__UpholdAccountPayload, defaultProto__Io__Haveno__Protobuffer__UpiAccountPayload, defaultProto__Io__Haveno__Protobuffer__UrlConnection, defaultProto__Io__Haveno__Protobuffer__UserPayload, defaultProto__Io__Haveno__Protobuffer__ValidateFormFieldReply, defaultProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest, defaultProto__Io__Haveno__Protobuffer__VenmoAccountPayload, defaultProto__Io__Haveno__Protobuffer__VerseAccountPayload, defaultProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload, defaultProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload, defaultProto__Io__Haveno__Protobuffer__WithdrawFundsReply, defaultProto__Io__Haveno__Protobuffer__WithdrawFundsRequest, defaultProto__Io__Haveno__Protobuffer__XmrAddressEntry, defaultProto__Io__Haveno__Protobuffer__XmrAddressEntryList, defaultProto__Io__Haveno__Protobuffer__XmrBalanceInfo, defaultProto__Io__Haveno__Protobuffer__XmrDestination, defaultProto__Io__Haveno__Protobuffer__XmrIncomingTransfer, defaultProto__Io__Haveno__Protobuffer__XmrNodeSettings, defaultProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer, defaultProto__Io__Haveno__Protobuffer__XmrTx, defaultProto__Io__Haveno__Protobuffer__ZelleAccountPayload, encodeProto__Io__Haveno__Protobuffer__AccountAgeWitness, encodeProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore, encodeProto__Io__Haveno__Protobuffer__AccountExistsReply, encodeProto__Io__Haveno__Protobuffer__AccountExistsRequest, encodeProto__Io__Haveno__Protobuffer__AchTransferAccountPayload, encodeProto__Io__Haveno__Protobuffer__AckMessage, encodeProto__Io__Haveno__Protobuffer__AddConnectionReply, encodeProto__Io__Haveno__Protobuffer__AddConnectionRequest, encodeProto__Io__Haveno__Protobuffer__AddDataMessage, encodeProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage, encodeProto__Io__Haveno__Protobuffer__AddressBalanceInfo, encodeProto__Io__Haveno__Protobuffer__AddressEntry, encodeProto__Io__Haveno__Protobuffer__AddressEntryList, encodeProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload, encodeProto__Io__Haveno__Protobuffer__Alert, encodeProto__Io__Haveno__Protobuffer__AliPayAccountPayload, encodeProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload, encodeProto__Io__Haveno__Protobuffer__ArbitrationDisputeList, encodeProto__Io__Haveno__Protobuffer__Arbitrator, encodeProto__Io__Haveno__Protobuffer__ArbitratorTrade, encodeProto__Io__Haveno__Protobuffer__Attachment, encodeProto__Io__Haveno__Protobuffer__AustraliaPayidPayload, encodeProto__Io__Haveno__Protobuffer__AutoConfirmSettings, encodeProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription, encodeProto__Io__Haveno__Protobuffer__BackupAccountReply, encodeProto__Io__Haveno__Protobuffer__BackupAccountRequest, encodeProto__Io__Haveno__Protobuffer__BalancesInfo, encodeProto__Io__Haveno__Protobuffer__BankAccountPayload, encodeProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message, encodeProto__Io__Haveno__Protobuffer__BizumAccountPayload, encodeProto__Io__Haveno__Protobuffer__BlockChainExplorer, encodeProto__Io__Haveno__Protobuffer__BtcBalanceInfo, encodeProto__Io__Haveno__Protobuffer__BundleOfEnvelopes, encodeProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade, encodeProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade, encodeProto__Io__Haveno__Protobuffer__ByteArray, encodeProto__Io__Haveno__Protobuffer__CancelOfferReply, encodeProto__Io__Haveno__Protobuffer__CancelOfferRequest, encodeProto__Io__Haveno__Protobuffer__CapitualAccountPayload, encodeProto__Io__Haveno__Protobuffer__CashAppAccountPayload, encodeProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload, encodeProto__Io__Haveno__Protobuffer__CashDepositAccountPayload, encodeProto__Io__Haveno__Protobuffer__CelPayAccountPayload, encodeProto__Io__Haveno__Protobuffer__ChangePasswordReply, encodeProto__Io__Haveno__Protobuffer__ChangePasswordRequest, encodeProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload, encodeProto__Io__Haveno__Protobuffer__ChatMessage, encodeProto__Io__Haveno__Protobuffer__CheckConnectionReply, encodeProto__Io__Haveno__Protobuffer__CheckConnectionRequest, encodeProto__Io__Haveno__Protobuffer__CheckConnectionsReply, encodeProto__Io__Haveno__Protobuffer__CheckConnectionsRequest, encodeProto__Io__Haveno__Protobuffer__CloseAccountReply, encodeProto__Io__Haveno__Protobuffer__CloseAccountRequest, encodeProto__Io__Haveno__Protobuffer__CloseConnectionMessage, encodeProto__Io__Haveno__Protobuffer__CompleteTradeReply, encodeProto__Io__Haveno__Protobuffer__CompleteTradeRequest, encodeProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply, encodeProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest, encodeProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply, encodeProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest, encodeProto__Io__Haveno__Protobuffer__Contract, encodeProto__Io__Haveno__Protobuffer__ContractInfo, encodeProto__Io__Haveno__Protobuffer__Country, encodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload, encodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message, encodeProto__Io__Haveno__Protobuffer__CreateAccountReply, encodeProto__Io__Haveno__Protobuffer__CreateAccountRequest, encodeProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply, encodeProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest, encodeProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply, encodeProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest, encodeProto__Io__Haveno__Protobuffer__CreateXmrTxReply, encodeProto__Io__Haveno__Protobuffer__CreateXmrTxRequest, encodeProto__Io__Haveno__Protobuffer__CryptoCurrency, encodeProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload, encodeProto__Io__Haveno__Protobuffer__Currency, encodeProto__Io__Haveno__Protobuffer__DataAndSeqNrPair, encodeProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey, encodeProto__Io__Haveno__Protobuffer__DeleteAccountReply, encodeProto__Io__Haveno__Protobuffer__DeleteAccountRequest, encodeProto__Io__Haveno__Protobuffer__DepositRequest, encodeProto__Io__Haveno__Protobuffer__DepositResponse, encodeProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage, encodeProto__Io__Haveno__Protobuffer__Dispute, encodeProto__Io__Haveno__Protobuffer__DisputeClosedMessage, encodeProto__Io__Haveno__Protobuffer__DisputeOpenedMessage, encodeProto__Io__Haveno__Protobuffer__DisputeResult, encodeProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload, encodeProto__Io__Haveno__Protobuffer__EncryptedConnection, encodeProto__Io__Haveno__Protobuffer__EncryptedConnectionList, encodeProto__Io__Haveno__Protobuffer__F2FAccountPayload, encodeProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload, encodeProto__Io__Haveno__Protobuffer__FileTransferPart, encodeProto__Io__Haveno__Protobuffer__Filter, encodeProto__Io__Haveno__Protobuffer__GetAddressBalanceReply, encodeProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest, encodeProto__Io__Haveno__Protobuffer__GetBalancesReply, encodeProto__Io__Haveno__Protobuffer__GetBalancesRequest, encodeProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply, encodeProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest, encodeProto__Io__Haveno__Protobuffer__GetChatMessagesReply, encodeProto__Io__Haveno__Protobuffer__GetChatMessagesRequest, encodeProto__Io__Haveno__Protobuffer__GetConnectionReply, encodeProto__Io__Haveno__Protobuffer__GetConnectionRequest, encodeProto__Io__Haveno__Protobuffer__GetConnectionsReply, encodeProto__Io__Haveno__Protobuffer__GetConnectionsRequest, encodeProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply, encodeProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest, encodeProto__Io__Haveno__Protobuffer__GetDataResponse, encodeProto__Io__Haveno__Protobuffer__GetDisputeReply, encodeProto__Io__Haveno__Protobuffer__GetDisputeRequest, encodeProto__Io__Haveno__Protobuffer__GetDisputesReply, encodeProto__Io__Haveno__Protobuffer__GetDisputesRequest, encodeProto__Io__Haveno__Protobuffer__GetFundingAddressesReply, encodeProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest, encodeProto__Io__Haveno__Protobuffer__GetInventoryRequest, encodeProto__Io__Haveno__Protobuffer__GetInventoryResponse, encodeProto__Io__Haveno__Protobuffer__GetMethodHelpReply, encodeProto__Io__Haveno__Protobuffer__GetMethodHelpRequest, encodeProto__Io__Haveno__Protobuffer__GetMyOfferReply, encodeProto__Io__Haveno__Protobuffer__GetMyOfferRequest, encodeProto__Io__Haveno__Protobuffer__GetMyOffersReply, encodeProto__Io__Haveno__Protobuffer__GetMyOffersRequest, encodeProto__Io__Haveno__Protobuffer__GetOfferReply, encodeProto__Io__Haveno__Protobuffer__GetOfferRequest, encodeProto__Io__Haveno__Protobuffer__GetOffersReply, encodeProto__Io__Haveno__Protobuffer__GetOffersRequest, encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply, encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest, encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply, encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest, encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply, encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest, encodeProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply, encodeProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest, encodeProto__Io__Haveno__Protobuffer__GetPeersRequest, encodeProto__Io__Haveno__Protobuffer__GetPeersResponse, encodeProto__Io__Haveno__Protobuffer__GetTradeReply, encodeProto__Io__Haveno__Protobuffer__GetTradeRequest, encodeProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply, encodeProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest, encodeProto__Io__Haveno__Protobuffer__GetTradesReply, encodeProto__Io__Haveno__Protobuffer__GetTradesRequest, encodeProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest, encodeProto__Io__Haveno__Protobuffer__GetVersionReply, encodeProto__Io__Haveno__Protobuffer__GetVersionRequest, encodeProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply, encodeProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest, encodeProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply, encodeProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest, encodeProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply, encodeProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest, encodeProto__Io__Haveno__Protobuffer__GetXmrSeedReply, encodeProto__Io__Haveno__Protobuffer__GetXmrSeedRequest, encodeProto__Io__Haveno__Protobuffer__GetXmrTxsReply, encodeProto__Io__Haveno__Protobuffer__GetXmrTxsRequest, encodeProto__Io__Haveno__Protobuffer__HalCashAccountPayload, encodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload, encodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message, encodeProto__Io__Haveno__Protobuffer__IgnoredMailboxMap, encodeProto__Io__Haveno__Protobuffer__ImpsAccountPayload, encodeProto__Io__Haveno__Protobuffer__InitMultisigRequest, encodeProto__Io__Haveno__Protobuffer__InitTradeRequest, encodeProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload, encodeProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload, encodeProto__Io__Haveno__Protobuffer__IsAccountOpenReply, encodeProto__Io__Haveno__Protobuffer__IsAccountOpenRequest, encodeProto__Io__Haveno__Protobuffer__IsAppInitializedReply, encodeProto__Io__Haveno__Protobuffer__IsAppInitializedRequest, encodeProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply, encodeProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest, encodeProto__Io__Haveno__Protobuffer__JapanBankAccountPayload, encodeProto__Io__Haveno__Protobuffer__LockWalletReply, encodeProto__Io__Haveno__Protobuffer__LockWalletRequest, encodeProto__Io__Haveno__Protobuffer__MailboxItem, encodeProto__Io__Haveno__Protobuffer__MailboxMessageList, encodeProto__Io__Haveno__Protobuffer__MailboxStoragePayload, encodeProto__Io__Haveno__Protobuffer__MapValue, encodeProto__Io__Haveno__Protobuffer__MarketAlertFilter, encodeProto__Io__Haveno__Protobuffer__MarketDepthInfo, encodeProto__Io__Haveno__Protobuffer__MarketDepthReply, encodeProto__Io__Haveno__Protobuffer__MarketDepthRequest, encodeProto__Io__Haveno__Protobuffer__MarketPriceInfo, encodeProto__Io__Haveno__Protobuffer__MarketPriceReply, encodeProto__Io__Haveno__Protobuffer__MarketPriceRequest, encodeProto__Io__Haveno__Protobuffer__MarketPricesReply, encodeProto__Io__Haveno__Protobuffer__MarketPricesRequest, encodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage, encodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage, encodeProto__Io__Haveno__Protobuffer__MediationDisputeList, encodeProto__Io__Haveno__Protobuffer__Mediator, encodeProto__Io__Haveno__Protobuffer__MockMailboxPayload, encodeProto__Io__Haveno__Protobuffer__MockPayload, encodeProto__Io__Haveno__Protobuffer__MoneseAccountPayload, encodeProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload, encodeProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload, encodeProto__Io__Haveno__Protobuffer__NationalBankAccountPayload, encodeProto__Io__Haveno__Protobuffer__NavigationPath, encodeProto__Io__Haveno__Protobuffer__NeftAccountPayload, encodeProto__Io__Haveno__Protobuffer__NequiAccountPayload, encodeProto__Io__Haveno__Protobuffer__NetworkEnvelope, encodeProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message, encodeProto__Io__Haveno__Protobuffer__NodeAddress, encodeProto__Io__Haveno__Protobuffer__NotificationMessage, encodeProto__Io__Haveno__Protobuffer__OKPayAccountPayload, encodeProto__Io__Haveno__Protobuffer__Offer, encodeProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest, encodeProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse, encodeProto__Io__Haveno__Protobuffer__OfferInfo, encodeProto__Io__Haveno__Protobuffer__OfferPayload, encodeProto__Io__Haveno__Protobuffer__OpenAccountReply, encodeProto__Io__Haveno__Protobuffer__OpenAccountRequest, encodeProto__Io__Haveno__Protobuffer__OpenDisputeReply, encodeProto__Io__Haveno__Protobuffer__OpenDisputeRequest, encodeProto__Io__Haveno__Protobuffer__OpenOffer, encodeProto__Io__Haveno__Protobuffer__PaxumAccountPayload, encodeProto__Io__Haveno__Protobuffer__PayByMailAccountPayload, encodeProto__Io__Haveno__Protobuffer__PayPalAccountPayload, encodeProto__Io__Haveno__Protobuffer__PaymentAccount, encodeProto__Io__Haveno__Protobuffer__PaymentAccountFilter, encodeProto__Io__Haveno__Protobuffer__PaymentAccountForm, encodeProto__Io__Haveno__Protobuffer__PaymentAccountFormField, encodeProto__Io__Haveno__Protobuffer__PaymentAccountList, encodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload, encodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message, encodeProto__Io__Haveno__Protobuffer__PaymentMethod, encodeProto__Io__Haveno__Protobuffer__PaymentReceivedMessage, encodeProto__Io__Haveno__Protobuffer__PaymentSentMessage, encodeProto__Io__Haveno__Protobuffer__PayseraAccountPayload, encodeProto__Io__Haveno__Protobuffer__PaytmAccountPayload, encodeProto__Io__Haveno__Protobuffer__Peer, encodeProto__Io__Haveno__Protobuffer__PeerList, encodeProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload, encodeProto__Io__Haveno__Protobuffer__PersistableEnvelope, encodeProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message, encodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload, encodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message, encodeProto__Io__Haveno__Protobuffer__Ping, encodeProto__Io__Haveno__Protobuffer__PixAccountPayload, encodeProto__Io__Haveno__Protobuffer__Pong, encodeProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload, encodeProto__Io__Haveno__Protobuffer__PostOfferReply, encodeProto__Io__Haveno__Protobuffer__PostOfferRequest, encodeProto__Io__Haveno__Protobuffer__PreferencesPayload, encodeProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage, encodeProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest, encodeProto__Io__Haveno__Protobuffer__PriceAlertFilter, encodeProto__Io__Haveno__Protobuffer__PrivateNotificationMessage, encodeProto__Io__Haveno__Protobuffer__PrivateNotificationPayload, encodeProto__Io__Haveno__Protobuffer__ProcessModel, encodeProto__Io__Haveno__Protobuffer__PromptPayAccountPayload, encodeProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry, encodeProto__Io__Haveno__Protobuffer__ProtectedStorageEntry, encodeProto__Io__Haveno__Protobuffer__PubKeyRing, encodeProto__Io__Haveno__Protobuffer__RawTransactionInput, encodeProto__Io__Haveno__Protobuffer__RefreshOfferMessage, encodeProto__Io__Haveno__Protobuffer__RefundAgent, encodeProto__Io__Haveno__Protobuffer__RefundDisputeList, encodeProto__Io__Haveno__Protobuffer__Region, encodeProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply, encodeProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest, encodeProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest, encodeProto__Io__Haveno__Protobuffer__RelayXmrTxReply, encodeProto__Io__Haveno__Protobuffer__RelayXmrTxRequest, encodeProto__Io__Haveno__Protobuffer__RemoveConnectionReply, encodeProto__Io__Haveno__Protobuffer__RemoveConnectionRequest, encodeProto__Io__Haveno__Protobuffer__RemoveDataMessage, encodeProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage, encodeProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply, encodeProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest, encodeProto__Io__Haveno__Protobuffer__RemovedPayloadsMap, encodeProto__Io__Haveno__Protobuffer__ResolveDisputeReply, encodeProto__Io__Haveno__Protobuffer__ResolveDisputeRequest, encodeProto__Io__Haveno__Protobuffer__RestoreAccountReply, encodeProto__Io__Haveno__Protobuffer__RestoreAccountRequest, encodeProto__Io__Haveno__Protobuffer__RevolutAccountPayload, encodeProto__Io__Haveno__Protobuffer__RtgsAccountPayload, encodeProto__Io__Haveno__Protobuffer__SameBankAccountPayload, encodeProto__Io__Haveno__Protobuffer__SatispayAccountPayload, encodeProto__Io__Haveno__Protobuffer__SealedAndSigned, encodeProto__Io__Haveno__Protobuffer__SellerAsMakerTrade, encodeProto__Io__Haveno__Protobuffer__SellerAsTakerTrade, encodeProto__Io__Haveno__Protobuffer__SendBtcRequest, encodeProto__Io__Haveno__Protobuffer__SendChatMessageReply, encodeProto__Io__Haveno__Protobuffer__SendChatMessageRequest, encodeProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply, encodeProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest, encodeProto__Io__Haveno__Protobuffer__SendNotificationReply, encodeProto__Io__Haveno__Protobuffer__SendNotificationRequest, encodeProto__Io__Haveno__Protobuffer__SepaAccountPayload, encodeProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload, encodeProto__Io__Haveno__Protobuffer__SequenceNumberEntry, encodeProto__Io__Haveno__Protobuffer__SequenceNumberMap, encodeProto__Io__Haveno__Protobuffer__SetAutoSwitchReply, encodeProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest, encodeProto__Io__Haveno__Protobuffer__SetConnectionReply, encodeProto__Io__Haveno__Protobuffer__SetConnectionRequest, encodeProto__Io__Haveno__Protobuffer__SetWalletPasswordReply, encodeProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest, encodeProto__Io__Haveno__Protobuffer__SignContractRequest, encodeProto__Io__Haveno__Protobuffer__SignContractResponse, encodeProto__Io__Haveno__Protobuffer__SignOfferRequest, encodeProto__Io__Haveno__Protobuffer__SignOfferResponse, encodeProto__Io__Haveno__Protobuffer__SignedOffer, encodeProto__Io__Haveno__Protobuffer__SignedOfferList, encodeProto__Io__Haveno__Protobuffer__SignedWitness, encodeProto__Io__Haveno__Protobuffer__SignedWitnessStore, encodeProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload, encodeProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply, encodeProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest, encodeProto__Io__Haveno__Protobuffer__StartXmrNodeReply, encodeProto__Io__Haveno__Protobuffer__StartXmrNodeRequest, encodeProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply, encodeProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest, encodeProto__Io__Haveno__Protobuffer__StopReply, encodeProto__Io__Haveno__Protobuffer__StopRequest, encodeProto__Io__Haveno__Protobuffer__StopXmrNodeReply, encodeProto__Io__Haveno__Protobuffer__StopXmrNodeRequest, encodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper, encodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message, encodeProto__Io__Haveno__Protobuffer__StoragePayload, encodeProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message, encodeProto__Io__Haveno__Protobuffer__StrikeAccountPayload, encodeProto__Io__Haveno__Protobuffer__SwiftAccountPayload, encodeProto__Io__Haveno__Protobuffer__SwishAccountPayload, encodeProto__Io__Haveno__Protobuffer__TakeOfferReply, encodeProto__Io__Haveno__Protobuffer__TakeOfferRequest, encodeProto__Io__Haveno__Protobuffer__TikkieAccountPayload, encodeProto__Io__Haveno__Protobuffer__Tradable, encodeProto__Io__Haveno__Protobuffer__TradableList, encodeProto__Io__Haveno__Protobuffer__Tradable__Message__Message, encodeProto__Io__Haveno__Protobuffer__Trade, encodeProto__Io__Haveno__Protobuffer__TradeCurrency, encodeProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message, encodeProto__Io__Haveno__Protobuffer__TradeInfo, encodeProto__Io__Haveno__Protobuffer__TradePeer, encodeProto__Io__Haveno__Protobuffer__TradeStatistics3, encodeProto__Io__Haveno__Protobuffer__TradeStatistics3Store, encodeProto__Io__Haveno__Protobuffer__TraditionalCurrency, encodeProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload, encodeProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload, encodeProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload, encodeProto__Io__Haveno__Protobuffer__UnlockWalletReply, encodeProto__Io__Haveno__Protobuffer__UnlockWalletRequest, encodeProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply, encodeProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest, encodeProto__Io__Haveno__Protobuffer__UpholdAccountPayload, encodeProto__Io__Haveno__Protobuffer__UpiAccountPayload, encodeProto__Io__Haveno__Protobuffer__UrlConnection, encodeProto__Io__Haveno__Protobuffer__UserPayload, encodeProto__Io__Haveno__Protobuffer__ValidateFormFieldReply, encodeProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest, encodeProto__Io__Haveno__Protobuffer__VenmoAccountPayload, encodeProto__Io__Haveno__Protobuffer__VerseAccountPayload, encodeProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload, encodeProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload, encodeProto__Io__Haveno__Protobuffer__WithdrawFundsReply, encodeProto__Io__Haveno__Protobuffer__WithdrawFundsRequest, encodeProto__Io__Haveno__Protobuffer__XmrAddressEntry, encodeProto__Io__Haveno__Protobuffer__XmrAddressEntryList, encodeProto__Io__Haveno__Protobuffer__XmrBalanceInfo, encodeProto__Io__Haveno__Protobuffer__XmrDestination, encodeProto__Io__Haveno__Protobuffer__XmrIncomingTransfer, encodeProto__Io__Haveno__Protobuffer__XmrNodeSettings, encodeProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer, encodeProto__Io__Haveno__Protobuffer__XmrTx, encodeProto__Io__Haveno__Protobuffer__ZelleAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__AccountAgeWitness, fieldNumbersProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore, fieldNumbersProto__Io__Haveno__Protobuffer__AccountExistsReply, fieldNumbersProto__Io__Haveno__Protobuffer__AccountExistsRequest, fieldNumbersProto__Io__Haveno__Protobuffer__AchTransferAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__AckMessage, fieldNumbersProto__Io__Haveno__Protobuffer__AddConnectionReply, fieldNumbersProto__Io__Haveno__Protobuffer__AddConnectionRequest, fieldNumbersProto__Io__Haveno__Protobuffer__AddDataMessage, fieldNumbersProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage, fieldNumbersProto__Io__Haveno__Protobuffer__AddressBalanceInfo, fieldNumbersProto__Io__Haveno__Protobuffer__AddressEntry, fieldNumbersProto__Io__Haveno__Protobuffer__AddressEntryList, fieldNumbersProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__Alert, fieldNumbersProto__Io__Haveno__Protobuffer__AliPayAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__ArbitrationDisputeList, fieldNumbersProto__Io__Haveno__Protobuffer__Arbitrator, fieldNumbersProto__Io__Haveno__Protobuffer__ArbitratorTrade, fieldNumbersProto__Io__Haveno__Protobuffer__Attachment, fieldNumbersProto__Io__Haveno__Protobuffer__AustraliaPayidPayload, fieldNumbersProto__Io__Haveno__Protobuffer__AutoConfirmSettings, fieldNumbersProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription, fieldNumbersProto__Io__Haveno__Protobuffer__BackupAccountReply, fieldNumbersProto__Io__Haveno__Protobuffer__BackupAccountRequest, fieldNumbersProto__Io__Haveno__Protobuffer__BalancesInfo, fieldNumbersProto__Io__Haveno__Protobuffer__BankAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message, fieldNumbersProto__Io__Haveno__Protobuffer__BizumAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__BlockChainExplorer, fieldNumbersProto__Io__Haveno__Protobuffer__BtcBalanceInfo, fieldNumbersProto__Io__Haveno__Protobuffer__BundleOfEnvelopes, fieldNumbersProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade, fieldNumbersProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade, fieldNumbersProto__Io__Haveno__Protobuffer__ByteArray, fieldNumbersProto__Io__Haveno__Protobuffer__CancelOfferReply, fieldNumbersProto__Io__Haveno__Protobuffer__CancelOfferRequest, fieldNumbersProto__Io__Haveno__Protobuffer__CapitualAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__CashAppAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__CashDepositAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__CelPayAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__ChangePasswordReply, fieldNumbersProto__Io__Haveno__Protobuffer__ChangePasswordRequest, fieldNumbersProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__ChatMessage, fieldNumbersProto__Io__Haveno__Protobuffer__CheckConnectionReply, fieldNumbersProto__Io__Haveno__Protobuffer__CheckConnectionRequest, fieldNumbersProto__Io__Haveno__Protobuffer__CheckConnectionsReply, fieldNumbersProto__Io__Haveno__Protobuffer__CheckConnectionsRequest, fieldNumbersProto__Io__Haveno__Protobuffer__CloseAccountReply, fieldNumbersProto__Io__Haveno__Protobuffer__CloseAccountRequest, fieldNumbersProto__Io__Haveno__Protobuffer__CloseConnectionMessage, fieldNumbersProto__Io__Haveno__Protobuffer__CompleteTradeReply, fieldNumbersProto__Io__Haveno__Protobuffer__CompleteTradeRequest, fieldNumbersProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply, fieldNumbersProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest, fieldNumbersProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply, fieldNumbersProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest, fieldNumbersProto__Io__Haveno__Protobuffer__Contract, fieldNumbersProto__Io__Haveno__Protobuffer__ContractInfo, fieldNumbersProto__Io__Haveno__Protobuffer__Country, fieldNumbersProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message, fieldNumbersProto__Io__Haveno__Protobuffer__CreateAccountReply, fieldNumbersProto__Io__Haveno__Protobuffer__CreateAccountRequest, fieldNumbersProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply, fieldNumbersProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest, fieldNumbersProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply, fieldNumbersProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest, fieldNumbersProto__Io__Haveno__Protobuffer__CreateXmrTxReply, fieldNumbersProto__Io__Haveno__Protobuffer__CreateXmrTxRequest, fieldNumbersProto__Io__Haveno__Protobuffer__CryptoCurrency, fieldNumbersProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__Currency, fieldNumbersProto__Io__Haveno__Protobuffer__DataAndSeqNrPair, fieldNumbersProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey, fieldNumbersProto__Io__Haveno__Protobuffer__DeleteAccountReply, fieldNumbersProto__Io__Haveno__Protobuffer__DeleteAccountRequest, fieldNumbersProto__Io__Haveno__Protobuffer__DepositRequest, fieldNumbersProto__Io__Haveno__Protobuffer__DepositResponse, fieldNumbersProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage, fieldNumbersProto__Io__Haveno__Protobuffer__Dispute, fieldNumbersProto__Io__Haveno__Protobuffer__DisputeClosedMessage, fieldNumbersProto__Io__Haveno__Protobuffer__DisputeOpenedMessage, fieldNumbersProto__Io__Haveno__Protobuffer__DisputeResult, fieldNumbersProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__EncryptedConnection, fieldNumbersProto__Io__Haveno__Protobuffer__EncryptedConnectionList, fieldNumbersProto__Io__Haveno__Protobuffer__F2FAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__FileTransferPart, fieldNumbersProto__Io__Haveno__Protobuffer__Filter, fieldNumbersProto__Io__Haveno__Protobuffer__GetAddressBalanceReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetBalancesReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetBalancesRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetChatMessagesReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetChatMessagesRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetConnectionReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetConnectionRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetConnectionsReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetConnectionsRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetDataResponse, fieldNumbersProto__Io__Haveno__Protobuffer__GetDisputeReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetDisputeRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetDisputesReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetDisputesRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetFundingAddressesReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetInventoryRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetInventoryResponse, fieldNumbersProto__Io__Haveno__Protobuffer__GetMethodHelpReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetMethodHelpRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetMyOfferReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetMyOfferRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetMyOffersReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetMyOffersRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetOfferReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetOfferRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetOffersReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetOffersRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetPeersRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetPeersResponse, fieldNumbersProto__Io__Haveno__Protobuffer__GetTradeReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetTradeRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetTradesReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetTradesRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetVersionReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetVersionRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrSeedReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrSeedRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrTxsReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrTxsRequest, fieldNumbersProto__Io__Haveno__Protobuffer__HalCashAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message, fieldNumbersProto__Io__Haveno__Protobuffer__IgnoredMailboxMap, fieldNumbersProto__Io__Haveno__Protobuffer__ImpsAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__InitMultisigRequest, fieldNumbersProto__Io__Haveno__Protobuffer__InitTradeRequest, fieldNumbersProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__IsAccountOpenReply, fieldNumbersProto__Io__Haveno__Protobuffer__IsAccountOpenRequest, fieldNumbersProto__Io__Haveno__Protobuffer__IsAppInitializedReply, fieldNumbersProto__Io__Haveno__Protobuffer__IsAppInitializedRequest, fieldNumbersProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply, fieldNumbersProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest, fieldNumbersProto__Io__Haveno__Protobuffer__JapanBankAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__LockWalletReply, fieldNumbersProto__Io__Haveno__Protobuffer__LockWalletRequest, fieldNumbersProto__Io__Haveno__Protobuffer__MailboxItem, fieldNumbersProto__Io__Haveno__Protobuffer__MailboxMessageList, fieldNumbersProto__Io__Haveno__Protobuffer__MailboxStoragePayload, fieldNumbersProto__Io__Haveno__Protobuffer__MapValue, fieldNumbersProto__Io__Haveno__Protobuffer__MarketAlertFilter, fieldNumbersProto__Io__Haveno__Protobuffer__MarketDepthInfo, fieldNumbersProto__Io__Haveno__Protobuffer__MarketDepthReply, fieldNumbersProto__Io__Haveno__Protobuffer__MarketDepthRequest, fieldNumbersProto__Io__Haveno__Protobuffer__MarketPriceInfo, fieldNumbersProto__Io__Haveno__Protobuffer__MarketPriceReply, fieldNumbersProto__Io__Haveno__Protobuffer__MarketPriceRequest, fieldNumbersProto__Io__Haveno__Protobuffer__MarketPricesReply, fieldNumbersProto__Io__Haveno__Protobuffer__MarketPricesRequest, fieldNumbersProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage, fieldNumbersProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage, fieldNumbersProto__Io__Haveno__Protobuffer__MediationDisputeList, fieldNumbersProto__Io__Haveno__Protobuffer__Mediator, fieldNumbersProto__Io__Haveno__Protobuffer__MockMailboxPayload, fieldNumbersProto__Io__Haveno__Protobuffer__MockPayload, fieldNumbersProto__Io__Haveno__Protobuffer__MoneseAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__NationalBankAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__NavigationPath, fieldNumbersProto__Io__Haveno__Protobuffer__NeftAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__NequiAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__NetworkEnvelope, fieldNumbersProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message, fieldNumbersProto__Io__Haveno__Protobuffer__NodeAddress, fieldNumbersProto__Io__Haveno__Protobuffer__NotificationMessage, fieldNumbersProto__Io__Haveno__Protobuffer__OKPayAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__Offer, fieldNumbersProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest, fieldNumbersProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse, fieldNumbersProto__Io__Haveno__Protobuffer__OfferInfo, fieldNumbersProto__Io__Haveno__Protobuffer__OfferPayload, fieldNumbersProto__Io__Haveno__Protobuffer__OpenAccountReply, fieldNumbersProto__Io__Haveno__Protobuffer__OpenAccountRequest, fieldNumbersProto__Io__Haveno__Protobuffer__OpenDisputeReply, fieldNumbersProto__Io__Haveno__Protobuffer__OpenDisputeRequest, fieldNumbersProto__Io__Haveno__Protobuffer__OpenOffer, fieldNumbersProto__Io__Haveno__Protobuffer__PaxumAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__PayByMailAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__PayPalAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccount, fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountFilter, fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountForm, fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountFormField, fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountList, fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message, fieldNumbersProto__Io__Haveno__Protobuffer__PaymentMethod, fieldNumbersProto__Io__Haveno__Protobuffer__PaymentReceivedMessage, fieldNumbersProto__Io__Haveno__Protobuffer__PaymentSentMessage, fieldNumbersProto__Io__Haveno__Protobuffer__PayseraAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__PaytmAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__Peer, fieldNumbersProto__Io__Haveno__Protobuffer__PeerList, fieldNumbersProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__PersistableEnvelope, fieldNumbersProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message, fieldNumbersProto__Io__Haveno__Protobuffer__PersistableNetworkPayload, fieldNumbersProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message, fieldNumbersProto__Io__Haveno__Protobuffer__Ping, fieldNumbersProto__Io__Haveno__Protobuffer__PixAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__Pong, fieldNumbersProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__PostOfferReply, fieldNumbersProto__Io__Haveno__Protobuffer__PostOfferRequest, fieldNumbersProto__Io__Haveno__Protobuffer__PreferencesPayload, fieldNumbersProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage, fieldNumbersProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest, fieldNumbersProto__Io__Haveno__Protobuffer__PriceAlertFilter, fieldNumbersProto__Io__Haveno__Protobuffer__PrivateNotificationMessage, fieldNumbersProto__Io__Haveno__Protobuffer__PrivateNotificationPayload, fieldNumbersProto__Io__Haveno__Protobuffer__ProcessModel, fieldNumbersProto__Io__Haveno__Protobuffer__PromptPayAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry, fieldNumbersProto__Io__Haveno__Protobuffer__ProtectedStorageEntry, fieldNumbersProto__Io__Haveno__Protobuffer__PubKeyRing, fieldNumbersProto__Io__Haveno__Protobuffer__RawTransactionInput, fieldNumbersProto__Io__Haveno__Protobuffer__RefreshOfferMessage, fieldNumbersProto__Io__Haveno__Protobuffer__RefundAgent, fieldNumbersProto__Io__Haveno__Protobuffer__RefundDisputeList, fieldNumbersProto__Io__Haveno__Protobuffer__Region, fieldNumbersProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply, fieldNumbersProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest, fieldNumbersProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest, fieldNumbersProto__Io__Haveno__Protobuffer__RelayXmrTxReply, fieldNumbersProto__Io__Haveno__Protobuffer__RelayXmrTxRequest, fieldNumbersProto__Io__Haveno__Protobuffer__RemoveConnectionReply, fieldNumbersProto__Io__Haveno__Protobuffer__RemoveConnectionRequest, fieldNumbersProto__Io__Haveno__Protobuffer__RemoveDataMessage, fieldNumbersProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage, fieldNumbersProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply, fieldNumbersProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest, fieldNumbersProto__Io__Haveno__Protobuffer__RemovedPayloadsMap, fieldNumbersProto__Io__Haveno__Protobuffer__ResolveDisputeReply, fieldNumbersProto__Io__Haveno__Protobuffer__ResolveDisputeRequest, fieldNumbersProto__Io__Haveno__Protobuffer__RestoreAccountReply, fieldNumbersProto__Io__Haveno__Protobuffer__RestoreAccountRequest, fieldNumbersProto__Io__Haveno__Protobuffer__RevolutAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__RtgsAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__SameBankAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__SatispayAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__SealedAndSigned, fieldNumbersProto__Io__Haveno__Protobuffer__SellerAsMakerTrade, fieldNumbersProto__Io__Haveno__Protobuffer__SellerAsTakerTrade, fieldNumbersProto__Io__Haveno__Protobuffer__SendBtcRequest, fieldNumbersProto__Io__Haveno__Protobuffer__SendChatMessageReply, fieldNumbersProto__Io__Haveno__Protobuffer__SendChatMessageRequest, fieldNumbersProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply, fieldNumbersProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest, fieldNumbersProto__Io__Haveno__Protobuffer__SendNotificationReply, fieldNumbersProto__Io__Haveno__Protobuffer__SendNotificationRequest, fieldNumbersProto__Io__Haveno__Protobuffer__SepaAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__SequenceNumberEntry, fieldNumbersProto__Io__Haveno__Protobuffer__SequenceNumberMap, fieldNumbersProto__Io__Haveno__Protobuffer__SetAutoSwitchReply, fieldNumbersProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest, fieldNumbersProto__Io__Haveno__Protobuffer__SetConnectionReply, fieldNumbersProto__Io__Haveno__Protobuffer__SetConnectionRequest, fieldNumbersProto__Io__Haveno__Protobuffer__SetWalletPasswordReply, fieldNumbersProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest, fieldNumbersProto__Io__Haveno__Protobuffer__SignContractRequest, fieldNumbersProto__Io__Haveno__Protobuffer__SignContractResponse, fieldNumbersProto__Io__Haveno__Protobuffer__SignOfferRequest, fieldNumbersProto__Io__Haveno__Protobuffer__SignOfferResponse, fieldNumbersProto__Io__Haveno__Protobuffer__SignedOffer, fieldNumbersProto__Io__Haveno__Protobuffer__SignedOfferList, fieldNumbersProto__Io__Haveno__Protobuffer__SignedWitness, fieldNumbersProto__Io__Haveno__Protobuffer__SignedWitnessStore, fieldNumbersProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply, fieldNumbersProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest, fieldNumbersProto__Io__Haveno__Protobuffer__StartXmrNodeReply, fieldNumbersProto__Io__Haveno__Protobuffer__StartXmrNodeRequest, fieldNumbersProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply, fieldNumbersProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest, fieldNumbersProto__Io__Haveno__Protobuffer__StopReply, fieldNumbersProto__Io__Haveno__Protobuffer__StopRequest, fieldNumbersProto__Io__Haveno__Protobuffer__StopXmrNodeReply, fieldNumbersProto__Io__Haveno__Protobuffer__StopXmrNodeRequest, fieldNumbersProto__Io__Haveno__Protobuffer__StorageEntryWrapper, fieldNumbersProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message, fieldNumbersProto__Io__Haveno__Protobuffer__StoragePayload, fieldNumbersProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message, fieldNumbersProto__Io__Haveno__Protobuffer__StrikeAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__SwiftAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__SwishAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__TakeOfferReply, fieldNumbersProto__Io__Haveno__Protobuffer__TakeOfferRequest, fieldNumbersProto__Io__Haveno__Protobuffer__TikkieAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__Tradable, fieldNumbersProto__Io__Haveno__Protobuffer__TradableList, fieldNumbersProto__Io__Haveno__Protobuffer__Tradable__Message__Message, fieldNumbersProto__Io__Haveno__Protobuffer__Trade, fieldNumbersProto__Io__Haveno__Protobuffer__TradeCurrency, fieldNumbersProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message, fieldNumbersProto__Io__Haveno__Protobuffer__TradeInfo, fieldNumbersProto__Io__Haveno__Protobuffer__TradePeer, fieldNumbersProto__Io__Haveno__Protobuffer__TradeStatistics3, fieldNumbersProto__Io__Haveno__Protobuffer__TradeStatistics3Store, fieldNumbersProto__Io__Haveno__Protobuffer__TraditionalCurrency, fieldNumbersProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__UnlockWalletReply, fieldNumbersProto__Io__Haveno__Protobuffer__UnlockWalletRequest, fieldNumbersProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply, fieldNumbersProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest, fieldNumbersProto__Io__Haveno__Protobuffer__UpholdAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__UpiAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__UrlConnection, fieldNumbersProto__Io__Haveno__Protobuffer__UserPayload, fieldNumbersProto__Io__Haveno__Protobuffer__ValidateFormFieldReply, fieldNumbersProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest, fieldNumbersProto__Io__Haveno__Protobuffer__VenmoAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__VerseAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__WithdrawFundsReply, fieldNumbersProto__Io__Haveno__Protobuffer__WithdrawFundsRequest, fieldNumbersProto__Io__Haveno__Protobuffer__XmrAddressEntry, fieldNumbersProto__Io__Haveno__Protobuffer__XmrAddressEntryList, fieldNumbersProto__Io__Haveno__Protobuffer__XmrBalanceInfo, fieldNumbersProto__Io__Haveno__Protobuffer__XmrDestination, fieldNumbersProto__Io__Haveno__Protobuffer__XmrIncomingTransfer, fieldNumbersProto__Io__Haveno__Protobuffer__XmrNodeSettings, fieldNumbersProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer, fieldNumbersProto__Io__Haveno__Protobuffer__XmrTx, fieldNumbersProto__Io__Haveno__Protobuffer__ZelleAccountPayload, unwrapProto__Io__Haveno__Protobuffer__BundleOfEnvelopes, unwrapProto__Io__Haveno__Protobuffer__NetworkEnvelope)

{-| 
This file was automatically generated by
- [`protoc-gen-elm`](https://www.npmjs.com/package/protoc-gen-elm) 4.0.3
- `protoc` 3.12.4
- the following specification files: `grpc.proto, pb.proto`

To run it, add a dependency via `elm install` on [`elm-protocol-buffers`](https://package.elm-lang.org/packages/eriktim/elm-protocol-buffers/1.2.0) version latest or higher.

@docs FieldNumbersProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message

@docs FieldNumbersProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message

@docs FieldNumbersProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message

@docs FieldNumbersProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message

@docs FieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message

@docs FieldNumbersProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message

@docs FieldNumbersProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message

@docs FieldNumbersProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message

@docs FieldNumbersProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message

@docs FieldNumbersProto__Io__Haveno__Protobuffer__Tradable__Message__Message

@docs FieldNumbersProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message

@docs Proto__Io__Haveno__Protobuffer__AccountAgeWitness, Proto__Io__Haveno__Protobuffer__AccountAgeWitnessStore

@docs Proto__Io__Haveno__Protobuffer__AccountExistsReply, Proto__Io__Haveno__Protobuffer__AccountExistsRequest

@docs Proto__Io__Haveno__Protobuffer__AchTransferAccountPayload, Proto__Io__Haveno__Protobuffer__AckMessage

@docs Proto__Io__Haveno__Protobuffer__AddConnectionReply, Proto__Io__Haveno__Protobuffer__AddConnectionRequest

@docs Proto__Io__Haveno__Protobuffer__AddDataMessage, Proto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage

@docs Proto__Io__Haveno__Protobuffer__AddressBalanceInfo, Proto__Io__Haveno__Protobuffer__AddressEntry

@docs Proto__Io__Haveno__Protobuffer__AddressEntryList, Proto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload

@docs Proto__Io__Haveno__Protobuffer__Alert, Proto__Io__Haveno__Protobuffer__AliPayAccountPayload

@docs Proto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload, Proto__Io__Haveno__Protobuffer__ArbitrationDisputeList

@docs Proto__Io__Haveno__Protobuffer__Arbitrator, Proto__Io__Haveno__Protobuffer__ArbitratorTrade

@docs Proto__Io__Haveno__Protobuffer__Attachment, Proto__Io__Haveno__Protobuffer__AustraliaPayidPayload

@docs Proto__Io__Haveno__Protobuffer__AutoConfirmSettings, Proto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription

@docs Proto__Io__Haveno__Protobuffer__BackupAccountReply, Proto__Io__Haveno__Protobuffer__BackupAccountRequest

@docs Proto__Io__Haveno__Protobuffer__BalancesInfo, Proto__Io__Haveno__Protobuffer__BankAccountPayload

@docs Proto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message, Proto__Io__Haveno__Protobuffer__BizumAccountPayload

@docs Proto__Io__Haveno__Protobuffer__BlockChainExplorer, Proto__Io__Haveno__Protobuffer__BtcBalanceInfo

@docs Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes, Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes_

@docs Proto__Io__Haveno__Protobuffer__BuyerAsMakerTrade, Proto__Io__Haveno__Protobuffer__BuyerAsTakerTrade

@docs Proto__Io__Haveno__Protobuffer__ByteArray, Proto__Io__Haveno__Protobuffer__CancelOfferReply

@docs Proto__Io__Haveno__Protobuffer__CancelOfferRequest, Proto__Io__Haveno__Protobuffer__CapitualAccountPayload

@docs Proto__Io__Haveno__Protobuffer__CashAppAccountPayload, Proto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload

@docs Proto__Io__Haveno__Protobuffer__CashDepositAccountPayload, Proto__Io__Haveno__Protobuffer__CelPayAccountPayload

@docs Proto__Io__Haveno__Protobuffer__ChangePasswordReply, Proto__Io__Haveno__Protobuffer__ChangePasswordRequest

@docs Proto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload, Proto__Io__Haveno__Protobuffer__ChatMessage

@docs Proto__Io__Haveno__Protobuffer__CheckConnectionReply, Proto__Io__Haveno__Protobuffer__CheckConnectionRequest

@docs Proto__Io__Haveno__Protobuffer__CheckConnectionsReply, Proto__Io__Haveno__Protobuffer__CheckConnectionsRequest

@docs Proto__Io__Haveno__Protobuffer__CloseAccountReply, Proto__Io__Haveno__Protobuffer__CloseAccountRequest

@docs Proto__Io__Haveno__Protobuffer__CloseConnectionMessage, Proto__Io__Haveno__Protobuffer__CompleteTradeReply

@docs Proto__Io__Haveno__Protobuffer__CompleteTradeRequest, Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply

@docs Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest, Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply

@docs Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest, Proto__Io__Haveno__Protobuffer__Contract

@docs Proto__Io__Haveno__Protobuffer__ContractInfo, Proto__Io__Haveno__Protobuffer__Country

@docs Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload

@docs Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message

@docs Proto__Io__Haveno__Protobuffer__CreateAccountReply, Proto__Io__Haveno__Protobuffer__CreateAccountRequest

@docs Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply

@docs Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest

@docs Proto__Io__Haveno__Protobuffer__CreatePaymentAccountReply, Proto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest

@docs Proto__Io__Haveno__Protobuffer__CreateXmrTxReply, Proto__Io__Haveno__Protobuffer__CreateXmrTxRequest

@docs Proto__Io__Haveno__Protobuffer__CryptoCurrency, Proto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload

@docs Proto__Io__Haveno__Protobuffer__Currency, Proto__Io__Haveno__Protobuffer__DataAndSeqNrPair

@docs Proto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey, Proto__Io__Haveno__Protobuffer__DeleteAccountReply

@docs Proto__Io__Haveno__Protobuffer__DeleteAccountRequest, Proto__Io__Haveno__Protobuffer__DepositRequest

@docs Proto__Io__Haveno__Protobuffer__DepositResponse, Proto__Io__Haveno__Protobuffer__DepositsConfirmedMessage

@docs Proto__Io__Haveno__Protobuffer__Dispute, Proto__Io__Haveno__Protobuffer__DisputeClosedMessage

@docs Proto__Io__Haveno__Protobuffer__DisputeOpenedMessage, Proto__Io__Haveno__Protobuffer__DisputeResult

@docs Proto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload, Proto__Io__Haveno__Protobuffer__EncryptedConnection

@docs Proto__Io__Haveno__Protobuffer__EncryptedConnectionList, Proto__Io__Haveno__Protobuffer__F2FAccountPayload

@docs Proto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload, Proto__Io__Haveno__Protobuffer__FileTransferPart

@docs Proto__Io__Haveno__Protobuffer__Filter, Proto__Io__Haveno__Protobuffer__GetAddressBalanceReply

@docs Proto__Io__Haveno__Protobuffer__GetAddressBalanceRequest, Proto__Io__Haveno__Protobuffer__GetBalancesReply

@docs Proto__Io__Haveno__Protobuffer__GetBalancesRequest, Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply

@docs Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest, Proto__Io__Haveno__Protobuffer__GetChatMessagesReply

@docs Proto__Io__Haveno__Protobuffer__GetChatMessagesRequest, Proto__Io__Haveno__Protobuffer__GetConnectionReply

@docs Proto__Io__Haveno__Protobuffer__GetConnectionRequest, Proto__Io__Haveno__Protobuffer__GetConnectionsReply

@docs Proto__Io__Haveno__Protobuffer__GetConnectionsRequest

@docs Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply

@docs Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest, Proto__Io__Haveno__Protobuffer__GetDataResponse

@docs Proto__Io__Haveno__Protobuffer__GetDisputeReply, Proto__Io__Haveno__Protobuffer__GetDisputeRequest

@docs Proto__Io__Haveno__Protobuffer__GetDisputesReply, Proto__Io__Haveno__Protobuffer__GetDisputesRequest

@docs Proto__Io__Haveno__Protobuffer__GetFundingAddressesReply, Proto__Io__Haveno__Protobuffer__GetFundingAddressesRequest

@docs Proto__Io__Haveno__Protobuffer__GetInventoryRequest, Proto__Io__Haveno__Protobuffer__GetInventoryResponse

@docs Proto__Io__Haveno__Protobuffer__GetMethodHelpReply, Proto__Io__Haveno__Protobuffer__GetMethodHelpRequest

@docs Proto__Io__Haveno__Protobuffer__GetMyOfferReply, Proto__Io__Haveno__Protobuffer__GetMyOfferRequest

@docs Proto__Io__Haveno__Protobuffer__GetMyOffersReply, Proto__Io__Haveno__Protobuffer__GetMyOffersRequest

@docs Proto__Io__Haveno__Protobuffer__GetOfferReply, Proto__Io__Haveno__Protobuffer__GetOfferRequest

@docs Proto__Io__Haveno__Protobuffer__GetOffersReply, Proto__Io__Haveno__Protobuffer__GetOffersRequest

@docs Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply

@docs Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest

@docs Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply, Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest

@docs Proto__Io__Haveno__Protobuffer__GetPaymentAccountsReply, Proto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest

@docs Proto__Io__Haveno__Protobuffer__GetPaymentMethodsReply, Proto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest

@docs Proto__Io__Haveno__Protobuffer__GetPeersRequest, Proto__Io__Haveno__Protobuffer__GetPeersResponse

@docs Proto__Io__Haveno__Protobuffer__GetTradeReply, Proto__Io__Haveno__Protobuffer__GetTradeRequest

@docs Proto__Io__Haveno__Protobuffer__GetTradeStatisticsReply, Proto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest

@docs Proto__Io__Haveno__Protobuffer__GetTradesReply, Proto__Io__Haveno__Protobuffer__GetTradesRequest

@docs Proto__Io__Haveno__Protobuffer__GetUpdatedDataRequest, Proto__Io__Haveno__Protobuffer__GetVersionReply

@docs Proto__Io__Haveno__Protobuffer__GetVersionRequest, Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply

@docs Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest, Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply

@docs Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest, Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply

@docs Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest, Proto__Io__Haveno__Protobuffer__GetXmrSeedReply

@docs Proto__Io__Haveno__Protobuffer__GetXmrSeedRequest, Proto__Io__Haveno__Protobuffer__GetXmrTxsReply

@docs Proto__Io__Haveno__Protobuffer__GetXmrTxsRequest, Proto__Io__Haveno__Protobuffer__HalCashAccountPayload

@docs Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload

@docs Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message

@docs Proto__Io__Haveno__Protobuffer__IgnoredMailboxMap, Proto__Io__Haveno__Protobuffer__ImpsAccountPayload

@docs Proto__Io__Haveno__Protobuffer__InitMultisigRequest, Proto__Io__Haveno__Protobuffer__InitTradeRequest

@docs Proto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload

@docs Proto__Io__Haveno__Protobuffer__InteracETransferAccountPayload, Proto__Io__Haveno__Protobuffer__IsAccountOpenReply

@docs Proto__Io__Haveno__Protobuffer__IsAccountOpenRequest, Proto__Io__Haveno__Protobuffer__IsAppInitializedReply

@docs Proto__Io__Haveno__Protobuffer__IsAppInitializedRequest, Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply

@docs Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest, Proto__Io__Haveno__Protobuffer__JapanBankAccountPayload

@docs Proto__Io__Haveno__Protobuffer__LockWalletReply, Proto__Io__Haveno__Protobuffer__LockWalletRequest

@docs Proto__Io__Haveno__Protobuffer__MailboxItem, Proto__Io__Haveno__Protobuffer__MailboxMessageList

@docs Proto__Io__Haveno__Protobuffer__MailboxStoragePayload, Proto__Io__Haveno__Protobuffer__MapValue

@docs Proto__Io__Haveno__Protobuffer__MarketAlertFilter, Proto__Io__Haveno__Protobuffer__MarketDepthInfo

@docs Proto__Io__Haveno__Protobuffer__MarketDepthReply, Proto__Io__Haveno__Protobuffer__MarketDepthRequest

@docs Proto__Io__Haveno__Protobuffer__MarketPriceInfo, Proto__Io__Haveno__Protobuffer__MarketPriceReply

@docs Proto__Io__Haveno__Protobuffer__MarketPriceRequest, Proto__Io__Haveno__Protobuffer__MarketPricesReply

@docs Proto__Io__Haveno__Protobuffer__MarketPricesRequest, Proto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage

@docs Proto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage, Proto__Io__Haveno__Protobuffer__MediationDisputeList

@docs Proto__Io__Haveno__Protobuffer__Mediator, Proto__Io__Haveno__Protobuffer__MockMailboxPayload

@docs Proto__Io__Haveno__Protobuffer__MockPayload, Proto__Io__Haveno__Protobuffer__MoneseAccountPayload

@docs Proto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload, Proto__Io__Haveno__Protobuffer__MoneyGramAccountPayload

@docs Proto__Io__Haveno__Protobuffer__NationalBankAccountPayload, Proto__Io__Haveno__Protobuffer__NavigationPath

@docs Proto__Io__Haveno__Protobuffer__NeftAccountPayload, Proto__Io__Haveno__Protobuffer__NequiAccountPayload

@docs Proto__Io__Haveno__Protobuffer__NetworkEnvelope, Proto__Io__Haveno__Protobuffer__NetworkEnvelope_

@docs Proto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message, Proto__Io__Haveno__Protobuffer__NodeAddress

@docs Proto__Io__Haveno__Protobuffer__NotificationMessage, Proto__Io__Haveno__Protobuffer__OKPayAccountPayload

@docs Proto__Io__Haveno__Protobuffer__Offer, Proto__Io__Haveno__Protobuffer__OfferAvailabilityRequest

@docs Proto__Io__Haveno__Protobuffer__OfferAvailabilityResponse, Proto__Io__Haveno__Protobuffer__OfferInfo

@docs Proto__Io__Haveno__Protobuffer__OfferPayload, Proto__Io__Haveno__Protobuffer__OpenAccountReply

@docs Proto__Io__Haveno__Protobuffer__OpenAccountRequest, Proto__Io__Haveno__Protobuffer__OpenDisputeReply

@docs Proto__Io__Haveno__Protobuffer__OpenDisputeRequest, Proto__Io__Haveno__Protobuffer__OpenOffer

@docs Proto__Io__Haveno__Protobuffer__PaxumAccountPayload, Proto__Io__Haveno__Protobuffer__PayByMailAccountPayload

@docs Proto__Io__Haveno__Protobuffer__PayPalAccountPayload, Proto__Io__Haveno__Protobuffer__PaymentAccount

@docs Proto__Io__Haveno__Protobuffer__PaymentAccountFilter, Proto__Io__Haveno__Protobuffer__PaymentAccountForm

@docs Proto__Io__Haveno__Protobuffer__PaymentAccountFormField, Proto__Io__Haveno__Protobuffer__PaymentAccountList

@docs Proto__Io__Haveno__Protobuffer__PaymentAccountPayload

@docs Proto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message, Proto__Io__Haveno__Protobuffer__PaymentMethod

@docs Proto__Io__Haveno__Protobuffer__PaymentReceivedMessage, Proto__Io__Haveno__Protobuffer__PaymentSentMessage

@docs Proto__Io__Haveno__Protobuffer__PayseraAccountPayload, Proto__Io__Haveno__Protobuffer__PaytmAccountPayload

@docs Proto__Io__Haveno__Protobuffer__Peer, Proto__Io__Haveno__Protobuffer__PeerList

@docs Proto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload, Proto__Io__Haveno__Protobuffer__PersistableEnvelope

@docs Proto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message

@docs Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload

@docs Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message, Proto__Io__Haveno__Protobuffer__Ping

@docs Proto__Io__Haveno__Protobuffer__PixAccountPayload, Proto__Io__Haveno__Protobuffer__Pong

@docs Proto__Io__Haveno__Protobuffer__PopmoneyAccountPayload, Proto__Io__Haveno__Protobuffer__PostOfferReply

@docs Proto__Io__Haveno__Protobuffer__PostOfferRequest, Proto__Io__Haveno__Protobuffer__PreferencesPayload

@docs Proto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage, Proto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest

@docs Proto__Io__Haveno__Protobuffer__PriceAlertFilter, Proto__Io__Haveno__Protobuffer__PrivateNotificationMessage

@docs Proto__Io__Haveno__Protobuffer__PrivateNotificationPayload, Proto__Io__Haveno__Protobuffer__ProcessModel

@docs Proto__Io__Haveno__Protobuffer__PromptPayAccountPayload, Proto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry

@docs Proto__Io__Haveno__Protobuffer__ProtectedStorageEntry, Proto__Io__Haveno__Protobuffer__PubKeyRing

@docs Proto__Io__Haveno__Protobuffer__RawTransactionInput, Proto__Io__Haveno__Protobuffer__RefreshOfferMessage

@docs Proto__Io__Haveno__Protobuffer__RefundAgent, Proto__Io__Haveno__Protobuffer__RefundDisputeList

@docs Proto__Io__Haveno__Protobuffer__Region, Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply

@docs Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest

@docs Proto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest, Proto__Io__Haveno__Protobuffer__RelayXmrTxReply

@docs Proto__Io__Haveno__Protobuffer__RelayXmrTxRequest, Proto__Io__Haveno__Protobuffer__RemoveConnectionReply

@docs Proto__Io__Haveno__Protobuffer__RemoveConnectionRequest, Proto__Io__Haveno__Protobuffer__RemoveDataMessage

@docs Proto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage, Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply

@docs Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest, Proto__Io__Haveno__Protobuffer__RemovedPayloadsMap

@docs Proto__Io__Haveno__Protobuffer__ResolveDisputeReply, Proto__Io__Haveno__Protobuffer__ResolveDisputeRequest

@docs Proto__Io__Haveno__Protobuffer__RestoreAccountReply, Proto__Io__Haveno__Protobuffer__RestoreAccountRequest

@docs Proto__Io__Haveno__Protobuffer__RevolutAccountPayload, Proto__Io__Haveno__Protobuffer__RtgsAccountPayload

@docs Proto__Io__Haveno__Protobuffer__SameBankAccountPayload, Proto__Io__Haveno__Protobuffer__SatispayAccountPayload

@docs Proto__Io__Haveno__Protobuffer__SealedAndSigned, Proto__Io__Haveno__Protobuffer__SellerAsMakerTrade

@docs Proto__Io__Haveno__Protobuffer__SellerAsTakerTrade, Proto__Io__Haveno__Protobuffer__SendBtcRequest

@docs Proto__Io__Haveno__Protobuffer__SendChatMessageReply, Proto__Io__Haveno__Protobuffer__SendChatMessageRequest

@docs Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply, Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest

@docs Proto__Io__Haveno__Protobuffer__SendNotificationReply, Proto__Io__Haveno__Protobuffer__SendNotificationRequest

@docs Proto__Io__Haveno__Protobuffer__SepaAccountPayload, Proto__Io__Haveno__Protobuffer__SepaInstantAccountPayload

@docs Proto__Io__Haveno__Protobuffer__SequenceNumberEntry, Proto__Io__Haveno__Protobuffer__SequenceNumberMap

@docs Proto__Io__Haveno__Protobuffer__SetAutoSwitchReply, Proto__Io__Haveno__Protobuffer__SetAutoSwitchRequest

@docs Proto__Io__Haveno__Protobuffer__SetConnectionReply, Proto__Io__Haveno__Protobuffer__SetConnectionRequest

@docs Proto__Io__Haveno__Protobuffer__SetWalletPasswordReply, Proto__Io__Haveno__Protobuffer__SetWalletPasswordRequest

@docs Proto__Io__Haveno__Protobuffer__SignContractRequest, Proto__Io__Haveno__Protobuffer__SignContractResponse

@docs Proto__Io__Haveno__Protobuffer__SignOfferRequest, Proto__Io__Haveno__Protobuffer__SignOfferResponse

@docs Proto__Io__Haveno__Protobuffer__SignedOffer, Proto__Io__Haveno__Protobuffer__SignedOfferList

@docs Proto__Io__Haveno__Protobuffer__SignedWitness, Proto__Io__Haveno__Protobuffer__SignedWitnessStore

@docs Proto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload, Proto__Io__Haveno__Protobuffer__StartCheckingConnectionReply

@docs Proto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest, Proto__Io__Haveno__Protobuffer__StartXmrNodeReply

@docs Proto__Io__Haveno__Protobuffer__StartXmrNodeRequest, Proto__Io__Haveno__Protobuffer__StopCheckingConnectionReply

@docs Proto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest, Proto__Io__Haveno__Protobuffer__StopReply

@docs Proto__Io__Haveno__Protobuffer__StopRequest, Proto__Io__Haveno__Protobuffer__StopXmrNodeReply

@docs Proto__Io__Haveno__Protobuffer__StopXmrNodeRequest, Proto__Io__Haveno__Protobuffer__StorageEntryWrapper

@docs Proto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message, Proto__Io__Haveno__Protobuffer__StoragePayload

@docs Proto__Io__Haveno__Protobuffer__StoragePayload__Message__Message, Proto__Io__Haveno__Protobuffer__StrikeAccountPayload

@docs Proto__Io__Haveno__Protobuffer__SwiftAccountPayload, Proto__Io__Haveno__Protobuffer__SwishAccountPayload

@docs Proto__Io__Haveno__Protobuffer__TakeOfferReply, Proto__Io__Haveno__Protobuffer__TakeOfferRequest

@docs Proto__Io__Haveno__Protobuffer__TikkieAccountPayload, Proto__Io__Haveno__Protobuffer__Tradable

@docs Proto__Io__Haveno__Protobuffer__TradableList, Proto__Io__Haveno__Protobuffer__Tradable__Message__Message

@docs Proto__Io__Haveno__Protobuffer__Trade, Proto__Io__Haveno__Protobuffer__TradeCurrency

@docs Proto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message, Proto__Io__Haveno__Protobuffer__TradeInfo

@docs Proto__Io__Haveno__Protobuffer__TradePeer, Proto__Io__Haveno__Protobuffer__TradeStatistics3

@docs Proto__Io__Haveno__Protobuffer__TradeStatistics3Store, Proto__Io__Haveno__Protobuffer__TraditionalCurrency

@docs Proto__Io__Haveno__Protobuffer__TransferwiseAccountPayload, Proto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload

@docs Proto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload, Proto__Io__Haveno__Protobuffer__UnlockWalletReply

@docs Proto__Io__Haveno__Protobuffer__UnlockWalletRequest, Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply

@docs Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest, Proto__Io__Haveno__Protobuffer__UpholdAccountPayload

@docs Proto__Io__Haveno__Protobuffer__UpiAccountPayload, Proto__Io__Haveno__Protobuffer__UrlConnection

@docs Proto__Io__Haveno__Protobuffer__UserPayload, Proto__Io__Haveno__Protobuffer__ValidateFormFieldReply

@docs Proto__Io__Haveno__Protobuffer__ValidateFormFieldRequest, Proto__Io__Haveno__Protobuffer__VenmoAccountPayload

@docs Proto__Io__Haveno__Protobuffer__VerseAccountPayload, Proto__Io__Haveno__Protobuffer__WeChatPayAccountPayload

@docs Proto__Io__Haveno__Protobuffer__WesternUnionAccountPayload, Proto__Io__Haveno__Protobuffer__WithdrawFundsReply

@docs Proto__Io__Haveno__Protobuffer__WithdrawFundsRequest, Proto__Io__Haveno__Protobuffer__XmrAddressEntry

@docs Proto__Io__Haveno__Protobuffer__XmrAddressEntryList, Proto__Io__Haveno__Protobuffer__XmrBalanceInfo

@docs Proto__Io__Haveno__Protobuffer__XmrDestination, Proto__Io__Haveno__Protobuffer__XmrIncomingTransfer

@docs Proto__Io__Haveno__Protobuffer__XmrNodeSettings, Proto__Io__Haveno__Protobuffer__XmrOutgoingTransfer

@docs Proto__Io__Haveno__Protobuffer__XmrTx, Proto__Io__Haveno__Protobuffer__ZelleAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__AccountAgeWitness, decodeProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore

@docs decodeProto__Io__Haveno__Protobuffer__AccountExistsReply, decodeProto__Io__Haveno__Protobuffer__AccountExistsRequest

@docs decodeProto__Io__Haveno__Protobuffer__AchTransferAccountPayload, decodeProto__Io__Haveno__Protobuffer__AckMessage

@docs decodeProto__Io__Haveno__Protobuffer__AddConnectionReply, decodeProto__Io__Haveno__Protobuffer__AddConnectionRequest

@docs decodeProto__Io__Haveno__Protobuffer__AddDataMessage

@docs decodeProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage

@docs decodeProto__Io__Haveno__Protobuffer__AddressBalanceInfo, decodeProto__Io__Haveno__Protobuffer__AddressEntry

@docs decodeProto__Io__Haveno__Protobuffer__AddressEntryList, decodeProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__Alert, decodeProto__Io__Haveno__Protobuffer__AliPayAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__ArbitrationDisputeList, decodeProto__Io__Haveno__Protobuffer__Arbitrator

@docs decodeProto__Io__Haveno__Protobuffer__ArbitratorTrade, decodeProto__Io__Haveno__Protobuffer__Attachment

@docs decodeProto__Io__Haveno__Protobuffer__AustraliaPayidPayload, decodeProto__Io__Haveno__Protobuffer__AutoConfirmSettings

@docs decodeProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription

@docs decodeProto__Io__Haveno__Protobuffer__BackupAccountReply, decodeProto__Io__Haveno__Protobuffer__BackupAccountRequest

@docs decodeProto__Io__Haveno__Protobuffer__BalancesInfo, decodeProto__Io__Haveno__Protobuffer__BankAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message

@docs decodeProto__Io__Haveno__Protobuffer__BizumAccountPayload, decodeProto__Io__Haveno__Protobuffer__BlockChainExplorer

@docs decodeProto__Io__Haveno__Protobuffer__BtcBalanceInfo, decodeProto__Io__Haveno__Protobuffer__BundleOfEnvelopes

@docs decodeProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade, decodeProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade

@docs decodeProto__Io__Haveno__Protobuffer__ByteArray, decodeProto__Io__Haveno__Protobuffer__CancelOfferReply

@docs decodeProto__Io__Haveno__Protobuffer__CancelOfferRequest, decodeProto__Io__Haveno__Protobuffer__CapitualAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__CashAppAccountPayload, decodeProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__CashDepositAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__CelPayAccountPayload, decodeProto__Io__Haveno__Protobuffer__ChangePasswordReply

@docs decodeProto__Io__Haveno__Protobuffer__ChangePasswordRequest

@docs decodeProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload, decodeProto__Io__Haveno__Protobuffer__ChatMessage

@docs decodeProto__Io__Haveno__Protobuffer__CheckConnectionReply, decodeProto__Io__Haveno__Protobuffer__CheckConnectionRequest

@docs decodeProto__Io__Haveno__Protobuffer__CheckConnectionsReply, decodeProto__Io__Haveno__Protobuffer__CheckConnectionsRequest

@docs decodeProto__Io__Haveno__Protobuffer__CloseAccountReply, decodeProto__Io__Haveno__Protobuffer__CloseAccountRequest

@docs decodeProto__Io__Haveno__Protobuffer__CloseConnectionMessage, decodeProto__Io__Haveno__Protobuffer__CompleteTradeReply

@docs decodeProto__Io__Haveno__Protobuffer__CompleteTradeRequest

@docs decodeProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply

@docs decodeProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest

@docs decodeProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply

@docs decodeProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest, decodeProto__Io__Haveno__Protobuffer__Contract

@docs decodeProto__Io__Haveno__Protobuffer__ContractInfo, decodeProto__Io__Haveno__Protobuffer__Country

@docs decodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message

@docs decodeProto__Io__Haveno__Protobuffer__CreateAccountReply, decodeProto__Io__Haveno__Protobuffer__CreateAccountRequest

@docs decodeProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply

@docs decodeProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest

@docs decodeProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply

@docs decodeProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest, decodeProto__Io__Haveno__Protobuffer__CreateXmrTxReply

@docs decodeProto__Io__Haveno__Protobuffer__CreateXmrTxRequest, decodeProto__Io__Haveno__Protobuffer__CryptoCurrency

@docs decodeProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload, decodeProto__Io__Haveno__Protobuffer__Currency

@docs decodeProto__Io__Haveno__Protobuffer__DataAndSeqNrPair, decodeProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey

@docs decodeProto__Io__Haveno__Protobuffer__DeleteAccountReply, decodeProto__Io__Haveno__Protobuffer__DeleteAccountRequest

@docs decodeProto__Io__Haveno__Protobuffer__DepositRequest, decodeProto__Io__Haveno__Protobuffer__DepositResponse

@docs decodeProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage, decodeProto__Io__Haveno__Protobuffer__Dispute

@docs decodeProto__Io__Haveno__Protobuffer__DisputeClosedMessage, decodeProto__Io__Haveno__Protobuffer__DisputeOpenedMessage

@docs decodeProto__Io__Haveno__Protobuffer__DisputeResult

@docs decodeProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__EncryptedConnection, decodeProto__Io__Haveno__Protobuffer__EncryptedConnectionList

@docs decodeProto__Io__Haveno__Protobuffer__F2FAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload, decodeProto__Io__Haveno__Protobuffer__FileTransferPart

@docs decodeProto__Io__Haveno__Protobuffer__Filter, decodeProto__Io__Haveno__Protobuffer__GetAddressBalanceReply

@docs decodeProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest, decodeProto__Io__Haveno__Protobuffer__GetBalancesReply

@docs decodeProto__Io__Haveno__Protobuffer__GetBalancesRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply

@docs decodeProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetChatMessagesReply, decodeProto__Io__Haveno__Protobuffer__GetChatMessagesRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetConnectionReply, decodeProto__Io__Haveno__Protobuffer__GetConnectionRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetConnectionsReply, decodeProto__Io__Haveno__Protobuffer__GetConnectionsRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply

@docs decodeProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetDataResponse, decodeProto__Io__Haveno__Protobuffer__GetDisputeReply

@docs decodeProto__Io__Haveno__Protobuffer__GetDisputeRequest, decodeProto__Io__Haveno__Protobuffer__GetDisputesReply

@docs decodeProto__Io__Haveno__Protobuffer__GetDisputesRequest, decodeProto__Io__Haveno__Protobuffer__GetFundingAddressesReply

@docs decodeProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetInventoryRequest, decodeProto__Io__Haveno__Protobuffer__GetInventoryResponse

@docs decodeProto__Io__Haveno__Protobuffer__GetMethodHelpReply, decodeProto__Io__Haveno__Protobuffer__GetMethodHelpRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetMyOfferReply, decodeProto__Io__Haveno__Protobuffer__GetMyOfferRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetMyOffersReply, decodeProto__Io__Haveno__Protobuffer__GetMyOffersRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetOfferReply, decodeProto__Io__Haveno__Protobuffer__GetOfferRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetOffersReply, decodeProto__Io__Haveno__Protobuffer__GetOffersRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply

@docs decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply

@docs decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply

@docs decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply

@docs decodeProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest, decodeProto__Io__Haveno__Protobuffer__GetPeersRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetPeersResponse, decodeProto__Io__Haveno__Protobuffer__GetTradeReply

@docs decodeProto__Io__Haveno__Protobuffer__GetTradeRequest, decodeProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply

@docs decodeProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest, decodeProto__Io__Haveno__Protobuffer__GetTradesReply

@docs decodeProto__Io__Haveno__Protobuffer__GetTradesRequest, decodeProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetVersionReply, decodeProto__Io__Haveno__Protobuffer__GetVersionRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply

@docs decodeProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply

@docs decodeProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest

@docs decodeProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply

@docs decodeProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest, decodeProto__Io__Haveno__Protobuffer__GetXmrSeedReply

@docs decodeProto__Io__Haveno__Protobuffer__GetXmrSeedRequest, decodeProto__Io__Haveno__Protobuffer__GetXmrTxsReply

@docs decodeProto__Io__Haveno__Protobuffer__GetXmrTxsRequest, decodeProto__Io__Haveno__Protobuffer__HalCashAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message

@docs decodeProto__Io__Haveno__Protobuffer__IgnoredMailboxMap, decodeProto__Io__Haveno__Protobuffer__ImpsAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__InitMultisigRequest, decodeProto__Io__Haveno__Protobuffer__InitTradeRequest

@docs decodeProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__IsAccountOpenReply, decodeProto__Io__Haveno__Protobuffer__IsAccountOpenRequest

@docs decodeProto__Io__Haveno__Protobuffer__IsAppInitializedReply, decodeProto__Io__Haveno__Protobuffer__IsAppInitializedRequest

@docs decodeProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply, decodeProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest

@docs decodeProto__Io__Haveno__Protobuffer__JapanBankAccountPayload, decodeProto__Io__Haveno__Protobuffer__LockWalletReply

@docs decodeProto__Io__Haveno__Protobuffer__LockWalletRequest, decodeProto__Io__Haveno__Protobuffer__MailboxItem

@docs decodeProto__Io__Haveno__Protobuffer__MailboxMessageList, decodeProto__Io__Haveno__Protobuffer__MailboxStoragePayload

@docs decodeProto__Io__Haveno__Protobuffer__MapValue, decodeProto__Io__Haveno__Protobuffer__MarketAlertFilter

@docs decodeProto__Io__Haveno__Protobuffer__MarketDepthInfo, decodeProto__Io__Haveno__Protobuffer__MarketDepthReply

@docs decodeProto__Io__Haveno__Protobuffer__MarketDepthRequest, decodeProto__Io__Haveno__Protobuffer__MarketPriceInfo

@docs decodeProto__Io__Haveno__Protobuffer__MarketPriceReply, decodeProto__Io__Haveno__Protobuffer__MarketPriceRequest

@docs decodeProto__Io__Haveno__Protobuffer__MarketPricesReply, decodeProto__Io__Haveno__Protobuffer__MarketPricesRequest

@docs decodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage

@docs decodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage

@docs decodeProto__Io__Haveno__Protobuffer__MediationDisputeList, decodeProto__Io__Haveno__Protobuffer__Mediator

@docs decodeProto__Io__Haveno__Protobuffer__MockMailboxPayload, decodeProto__Io__Haveno__Protobuffer__MockPayload

@docs decodeProto__Io__Haveno__Protobuffer__MoneseAccountPayload, decodeProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__NationalBankAccountPayload, decodeProto__Io__Haveno__Protobuffer__NavigationPath

@docs decodeProto__Io__Haveno__Protobuffer__NeftAccountPayload, decodeProto__Io__Haveno__Protobuffer__NequiAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__NetworkEnvelope

@docs decodeProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message, decodeProto__Io__Haveno__Protobuffer__NodeAddress

@docs decodeProto__Io__Haveno__Protobuffer__NotificationMessage, decodeProto__Io__Haveno__Protobuffer__OKPayAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__Offer, decodeProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest

@docs decodeProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse, decodeProto__Io__Haveno__Protobuffer__OfferInfo

@docs decodeProto__Io__Haveno__Protobuffer__OfferPayload, decodeProto__Io__Haveno__Protobuffer__OpenAccountReply

@docs decodeProto__Io__Haveno__Protobuffer__OpenAccountRequest, decodeProto__Io__Haveno__Protobuffer__OpenDisputeReply

@docs decodeProto__Io__Haveno__Protobuffer__OpenDisputeRequest, decodeProto__Io__Haveno__Protobuffer__OpenOffer

@docs decodeProto__Io__Haveno__Protobuffer__PaxumAccountPayload, decodeProto__Io__Haveno__Protobuffer__PayByMailAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__PayPalAccountPayload, decodeProto__Io__Haveno__Protobuffer__PaymentAccount

@docs decodeProto__Io__Haveno__Protobuffer__PaymentAccountFilter, decodeProto__Io__Haveno__Protobuffer__PaymentAccountForm

@docs decodeProto__Io__Haveno__Protobuffer__PaymentAccountFormField, decodeProto__Io__Haveno__Protobuffer__PaymentAccountList

@docs decodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message

@docs decodeProto__Io__Haveno__Protobuffer__PaymentMethod, decodeProto__Io__Haveno__Protobuffer__PaymentReceivedMessage

@docs decodeProto__Io__Haveno__Protobuffer__PaymentSentMessage, decodeProto__Io__Haveno__Protobuffer__PayseraAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__PaytmAccountPayload, decodeProto__Io__Haveno__Protobuffer__Peer

@docs decodeProto__Io__Haveno__Protobuffer__PeerList, decodeProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__PersistableEnvelope

@docs decodeProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message

@docs decodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload

@docs decodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message

@docs decodeProto__Io__Haveno__Protobuffer__Ping, decodeProto__Io__Haveno__Protobuffer__PixAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__Pong, decodeProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__PostOfferReply, decodeProto__Io__Haveno__Protobuffer__PostOfferRequest

@docs decodeProto__Io__Haveno__Protobuffer__PreferencesPayload

@docs decodeProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage

@docs decodeProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest, decodeProto__Io__Haveno__Protobuffer__PriceAlertFilter

@docs decodeProto__Io__Haveno__Protobuffer__PrivateNotificationMessage

@docs decodeProto__Io__Haveno__Protobuffer__PrivateNotificationPayload, decodeProto__Io__Haveno__Protobuffer__ProcessModel

@docs decodeProto__Io__Haveno__Protobuffer__PromptPayAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry

@docs decodeProto__Io__Haveno__Protobuffer__ProtectedStorageEntry, decodeProto__Io__Haveno__Protobuffer__PubKeyRing

@docs decodeProto__Io__Haveno__Protobuffer__RawTransactionInput, decodeProto__Io__Haveno__Protobuffer__RefreshOfferMessage

@docs decodeProto__Io__Haveno__Protobuffer__RefundAgent, decodeProto__Io__Haveno__Protobuffer__RefundDisputeList

@docs decodeProto__Io__Haveno__Protobuffer__Region, decodeProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply

@docs decodeProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest

@docs decodeProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest

@docs decodeProto__Io__Haveno__Protobuffer__RelayXmrTxReply, decodeProto__Io__Haveno__Protobuffer__RelayXmrTxRequest

@docs decodeProto__Io__Haveno__Protobuffer__RemoveConnectionReply, decodeProto__Io__Haveno__Protobuffer__RemoveConnectionRequest

@docs decodeProto__Io__Haveno__Protobuffer__RemoveDataMessage, decodeProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage

@docs decodeProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply

@docs decodeProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest

@docs decodeProto__Io__Haveno__Protobuffer__RemovedPayloadsMap, decodeProto__Io__Haveno__Protobuffer__ResolveDisputeReply

@docs decodeProto__Io__Haveno__Protobuffer__ResolveDisputeRequest, decodeProto__Io__Haveno__Protobuffer__RestoreAccountReply

@docs decodeProto__Io__Haveno__Protobuffer__RestoreAccountRequest, decodeProto__Io__Haveno__Protobuffer__RevolutAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__RtgsAccountPayload, decodeProto__Io__Haveno__Protobuffer__SameBankAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__SatispayAccountPayload, decodeProto__Io__Haveno__Protobuffer__SealedAndSigned

@docs decodeProto__Io__Haveno__Protobuffer__SellerAsMakerTrade, decodeProto__Io__Haveno__Protobuffer__SellerAsTakerTrade

@docs decodeProto__Io__Haveno__Protobuffer__SendBtcRequest, decodeProto__Io__Haveno__Protobuffer__SendChatMessageReply

@docs decodeProto__Io__Haveno__Protobuffer__SendChatMessageRequest

@docs decodeProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply

@docs decodeProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest

@docs decodeProto__Io__Haveno__Protobuffer__SendNotificationReply, decodeProto__Io__Haveno__Protobuffer__SendNotificationRequest

@docs decodeProto__Io__Haveno__Protobuffer__SepaAccountPayload, decodeProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__SequenceNumberEntry, decodeProto__Io__Haveno__Protobuffer__SequenceNumberMap

@docs decodeProto__Io__Haveno__Protobuffer__SetAutoSwitchReply, decodeProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest

@docs decodeProto__Io__Haveno__Protobuffer__SetConnectionReply, decodeProto__Io__Haveno__Protobuffer__SetConnectionRequest

@docs decodeProto__Io__Haveno__Protobuffer__SetWalletPasswordReply

@docs decodeProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest, decodeProto__Io__Haveno__Protobuffer__SignContractRequest

@docs decodeProto__Io__Haveno__Protobuffer__SignContractResponse, decodeProto__Io__Haveno__Protobuffer__SignOfferRequest

@docs decodeProto__Io__Haveno__Protobuffer__SignOfferResponse, decodeProto__Io__Haveno__Protobuffer__SignedOffer

@docs decodeProto__Io__Haveno__Protobuffer__SignedOfferList, decodeProto__Io__Haveno__Protobuffer__SignedWitness

@docs decodeProto__Io__Haveno__Protobuffer__SignedWitnessStore

@docs decodeProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply

@docs decodeProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest

@docs decodeProto__Io__Haveno__Protobuffer__StartXmrNodeReply, decodeProto__Io__Haveno__Protobuffer__StartXmrNodeRequest

@docs decodeProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply

@docs decodeProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest, decodeProto__Io__Haveno__Protobuffer__StopReply

@docs decodeProto__Io__Haveno__Protobuffer__StopRequest, decodeProto__Io__Haveno__Protobuffer__StopXmrNodeReply

@docs decodeProto__Io__Haveno__Protobuffer__StopXmrNodeRequest, decodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper

@docs decodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message

@docs decodeProto__Io__Haveno__Protobuffer__StoragePayload

@docs decodeProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message

@docs decodeProto__Io__Haveno__Protobuffer__StrikeAccountPayload, decodeProto__Io__Haveno__Protobuffer__SwiftAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__SwishAccountPayload, decodeProto__Io__Haveno__Protobuffer__TakeOfferReply

@docs decodeProto__Io__Haveno__Protobuffer__TakeOfferRequest, decodeProto__Io__Haveno__Protobuffer__TikkieAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__Tradable, decodeProto__Io__Haveno__Protobuffer__TradableList

@docs decodeProto__Io__Haveno__Protobuffer__Tradable__Message__Message, decodeProto__Io__Haveno__Protobuffer__Trade

@docs decodeProto__Io__Haveno__Protobuffer__TradeCurrency, decodeProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message

@docs decodeProto__Io__Haveno__Protobuffer__TradeInfo, decodeProto__Io__Haveno__Protobuffer__TradePeer

@docs decodeProto__Io__Haveno__Protobuffer__TradeStatistics3, decodeProto__Io__Haveno__Protobuffer__TradeStatistics3Store

@docs decodeProto__Io__Haveno__Protobuffer__TraditionalCurrency

@docs decodeProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__UnlockWalletReply, decodeProto__Io__Haveno__Protobuffer__UnlockWalletRequest

@docs decodeProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply

@docs decodeProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest

@docs decodeProto__Io__Haveno__Protobuffer__UpholdAccountPayload, decodeProto__Io__Haveno__Protobuffer__UpiAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__UrlConnection, decodeProto__Io__Haveno__Protobuffer__UserPayload

@docs decodeProto__Io__Haveno__Protobuffer__ValidateFormFieldReply

@docs decodeProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest, decodeProto__Io__Haveno__Protobuffer__VenmoAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__VerseAccountPayload, decodeProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload

@docs decodeProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload, decodeProto__Io__Haveno__Protobuffer__WithdrawFundsReply

@docs decodeProto__Io__Haveno__Protobuffer__WithdrawFundsRequest, decodeProto__Io__Haveno__Protobuffer__XmrAddressEntry

@docs decodeProto__Io__Haveno__Protobuffer__XmrAddressEntryList, decodeProto__Io__Haveno__Protobuffer__XmrBalanceInfo

@docs decodeProto__Io__Haveno__Protobuffer__XmrDestination, decodeProto__Io__Haveno__Protobuffer__XmrIncomingTransfer

@docs decodeProto__Io__Haveno__Protobuffer__XmrNodeSettings, decodeProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer

@docs decodeProto__Io__Haveno__Protobuffer__XmrTx, decodeProto__Io__Haveno__Protobuffer__ZelleAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__AccountAgeWitness, defaultProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore

@docs defaultProto__Io__Haveno__Protobuffer__AccountExistsReply, defaultProto__Io__Haveno__Protobuffer__AccountExistsRequest

@docs defaultProto__Io__Haveno__Protobuffer__AchTransferAccountPayload, defaultProto__Io__Haveno__Protobuffer__AckMessage

@docs defaultProto__Io__Haveno__Protobuffer__AddConnectionReply, defaultProto__Io__Haveno__Protobuffer__AddConnectionRequest

@docs defaultProto__Io__Haveno__Protobuffer__AddDataMessage

@docs defaultProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage

@docs defaultProto__Io__Haveno__Protobuffer__AddressBalanceInfo, defaultProto__Io__Haveno__Protobuffer__AddressEntry

@docs defaultProto__Io__Haveno__Protobuffer__AddressEntryList, defaultProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__Alert, defaultProto__Io__Haveno__Protobuffer__AliPayAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__ArbitrationDisputeList, defaultProto__Io__Haveno__Protobuffer__Arbitrator

@docs defaultProto__Io__Haveno__Protobuffer__ArbitratorTrade, defaultProto__Io__Haveno__Protobuffer__Attachment

@docs defaultProto__Io__Haveno__Protobuffer__AustraliaPayidPayload, defaultProto__Io__Haveno__Protobuffer__AutoConfirmSettings

@docs defaultProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription

@docs defaultProto__Io__Haveno__Protobuffer__BackupAccountReply, defaultProto__Io__Haveno__Protobuffer__BackupAccountRequest

@docs defaultProto__Io__Haveno__Protobuffer__BalancesInfo, defaultProto__Io__Haveno__Protobuffer__BankAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__BizumAccountPayload, defaultProto__Io__Haveno__Protobuffer__BlockChainExplorer

@docs defaultProto__Io__Haveno__Protobuffer__BtcBalanceInfo, defaultProto__Io__Haveno__Protobuffer__BundleOfEnvelopes

@docs defaultProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade, defaultProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade

@docs defaultProto__Io__Haveno__Protobuffer__ByteArray, defaultProto__Io__Haveno__Protobuffer__CancelOfferReply

@docs defaultProto__Io__Haveno__Protobuffer__CancelOfferRequest, defaultProto__Io__Haveno__Protobuffer__CapitualAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__CashAppAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__CashDepositAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__CelPayAccountPayload, defaultProto__Io__Haveno__Protobuffer__ChangePasswordReply

@docs defaultProto__Io__Haveno__Protobuffer__ChangePasswordRequest

@docs defaultProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload, defaultProto__Io__Haveno__Protobuffer__ChatMessage

@docs defaultProto__Io__Haveno__Protobuffer__CheckConnectionReply, defaultProto__Io__Haveno__Protobuffer__CheckConnectionRequest

@docs defaultProto__Io__Haveno__Protobuffer__CheckConnectionsReply

@docs defaultProto__Io__Haveno__Protobuffer__CheckConnectionsRequest, defaultProto__Io__Haveno__Protobuffer__CloseAccountReply

@docs defaultProto__Io__Haveno__Protobuffer__CloseAccountRequest, defaultProto__Io__Haveno__Protobuffer__CloseConnectionMessage

@docs defaultProto__Io__Haveno__Protobuffer__CompleteTradeReply, defaultProto__Io__Haveno__Protobuffer__CompleteTradeRequest

@docs defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply

@docs defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest

@docs defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply

@docs defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest, defaultProto__Io__Haveno__Protobuffer__Contract

@docs defaultProto__Io__Haveno__Protobuffer__ContractInfo, defaultProto__Io__Haveno__Protobuffer__Country

@docs defaultProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__CreateAccountReply, defaultProto__Io__Haveno__Protobuffer__CreateAccountRequest

@docs defaultProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply

@docs defaultProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest

@docs defaultProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply

@docs defaultProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest

@docs defaultProto__Io__Haveno__Protobuffer__CreateXmrTxReply, defaultProto__Io__Haveno__Protobuffer__CreateXmrTxRequest

@docs defaultProto__Io__Haveno__Protobuffer__CryptoCurrency, defaultProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__Currency, defaultProto__Io__Haveno__Protobuffer__DataAndSeqNrPair

@docs defaultProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey

@docs defaultProto__Io__Haveno__Protobuffer__DeleteAccountReply, defaultProto__Io__Haveno__Protobuffer__DeleteAccountRequest

@docs defaultProto__Io__Haveno__Protobuffer__DepositRequest, defaultProto__Io__Haveno__Protobuffer__DepositResponse

@docs defaultProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage, defaultProto__Io__Haveno__Protobuffer__Dispute

@docs defaultProto__Io__Haveno__Protobuffer__DisputeClosedMessage, defaultProto__Io__Haveno__Protobuffer__DisputeOpenedMessage

@docs defaultProto__Io__Haveno__Protobuffer__DisputeResult

@docs defaultProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__EncryptedConnection, defaultProto__Io__Haveno__Protobuffer__EncryptedConnectionList

@docs defaultProto__Io__Haveno__Protobuffer__F2FAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__FileTransferPart, defaultProto__Io__Haveno__Protobuffer__Filter

@docs defaultProto__Io__Haveno__Protobuffer__GetAddressBalanceReply

@docs defaultProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest, defaultProto__Io__Haveno__Protobuffer__GetBalancesReply

@docs defaultProto__Io__Haveno__Protobuffer__GetBalancesRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply

@docs defaultProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetChatMessagesReply, defaultProto__Io__Haveno__Protobuffer__GetChatMessagesRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetConnectionReply, defaultProto__Io__Haveno__Protobuffer__GetConnectionRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetConnectionsReply, defaultProto__Io__Haveno__Protobuffer__GetConnectionsRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply

@docs defaultProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetDataResponse, defaultProto__Io__Haveno__Protobuffer__GetDisputeReply

@docs defaultProto__Io__Haveno__Protobuffer__GetDisputeRequest, defaultProto__Io__Haveno__Protobuffer__GetDisputesReply

@docs defaultProto__Io__Haveno__Protobuffer__GetDisputesRequest, defaultProto__Io__Haveno__Protobuffer__GetFundingAddressesReply

@docs defaultProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetInventoryRequest, defaultProto__Io__Haveno__Protobuffer__GetInventoryResponse

@docs defaultProto__Io__Haveno__Protobuffer__GetMethodHelpReply, defaultProto__Io__Haveno__Protobuffer__GetMethodHelpRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetMyOfferReply, defaultProto__Io__Haveno__Protobuffer__GetMyOfferRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetMyOffersReply, defaultProto__Io__Haveno__Protobuffer__GetMyOffersRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetOfferReply, defaultProto__Io__Haveno__Protobuffer__GetOfferRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetOffersReply, defaultProto__Io__Haveno__Protobuffer__GetOffersRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply

@docs defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply

@docs defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply

@docs defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply

@docs defaultProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest, defaultProto__Io__Haveno__Protobuffer__GetPeersRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetPeersResponse, defaultProto__Io__Haveno__Protobuffer__GetTradeReply

@docs defaultProto__Io__Haveno__Protobuffer__GetTradeRequest, defaultProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply

@docs defaultProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest, defaultProto__Io__Haveno__Protobuffer__GetTradesReply

@docs defaultProto__Io__Haveno__Protobuffer__GetTradesRequest, defaultProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetVersionReply, defaultProto__Io__Haveno__Protobuffer__GetVersionRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply

@docs defaultProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply

@docs defaultProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest

@docs defaultProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply

@docs defaultProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest, defaultProto__Io__Haveno__Protobuffer__GetXmrSeedReply

@docs defaultProto__Io__Haveno__Protobuffer__GetXmrSeedRequest, defaultProto__Io__Haveno__Protobuffer__GetXmrTxsReply

@docs defaultProto__Io__Haveno__Protobuffer__GetXmrTxsRequest, defaultProto__Io__Haveno__Protobuffer__HalCashAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload, defaultProto__Io__Haveno__Protobuffer__IgnoredMailboxMap

@docs defaultProto__Io__Haveno__Protobuffer__ImpsAccountPayload, defaultProto__Io__Haveno__Protobuffer__InitMultisigRequest

@docs defaultProto__Io__Haveno__Protobuffer__InitTradeRequest

@docs defaultProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__IsAccountOpenReply, defaultProto__Io__Haveno__Protobuffer__IsAccountOpenRequest

@docs defaultProto__Io__Haveno__Protobuffer__IsAppInitializedReply

@docs defaultProto__Io__Haveno__Protobuffer__IsAppInitializedRequest

@docs defaultProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply, defaultProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest

@docs defaultProto__Io__Haveno__Protobuffer__JapanBankAccountPayload, defaultProto__Io__Haveno__Protobuffer__LockWalletReply

@docs defaultProto__Io__Haveno__Protobuffer__LockWalletRequest, defaultProto__Io__Haveno__Protobuffer__MailboxItem

@docs defaultProto__Io__Haveno__Protobuffer__MailboxMessageList, defaultProto__Io__Haveno__Protobuffer__MailboxStoragePayload

@docs defaultProto__Io__Haveno__Protobuffer__MapValue, defaultProto__Io__Haveno__Protobuffer__MarketAlertFilter

@docs defaultProto__Io__Haveno__Protobuffer__MarketDepthInfo, defaultProto__Io__Haveno__Protobuffer__MarketDepthReply

@docs defaultProto__Io__Haveno__Protobuffer__MarketDepthRequest, defaultProto__Io__Haveno__Protobuffer__MarketPriceInfo

@docs defaultProto__Io__Haveno__Protobuffer__MarketPriceReply, defaultProto__Io__Haveno__Protobuffer__MarketPriceRequest

@docs defaultProto__Io__Haveno__Protobuffer__MarketPricesReply, defaultProto__Io__Haveno__Protobuffer__MarketPricesRequest

@docs defaultProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage

@docs defaultProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage

@docs defaultProto__Io__Haveno__Protobuffer__MediationDisputeList, defaultProto__Io__Haveno__Protobuffer__Mediator

@docs defaultProto__Io__Haveno__Protobuffer__MockMailboxPayload, defaultProto__Io__Haveno__Protobuffer__MockPayload

@docs defaultProto__Io__Haveno__Protobuffer__MoneseAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__NationalBankAccountPayload, defaultProto__Io__Haveno__Protobuffer__NavigationPath

@docs defaultProto__Io__Haveno__Protobuffer__NeftAccountPayload, defaultProto__Io__Haveno__Protobuffer__NequiAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__NetworkEnvelope, defaultProto__Io__Haveno__Protobuffer__NodeAddress

@docs defaultProto__Io__Haveno__Protobuffer__NotificationMessage, defaultProto__Io__Haveno__Protobuffer__OKPayAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__Offer, defaultProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest

@docs defaultProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse, defaultProto__Io__Haveno__Protobuffer__OfferInfo

@docs defaultProto__Io__Haveno__Protobuffer__OfferPayload, defaultProto__Io__Haveno__Protobuffer__OpenAccountReply

@docs defaultProto__Io__Haveno__Protobuffer__OpenAccountRequest, defaultProto__Io__Haveno__Protobuffer__OpenDisputeReply

@docs defaultProto__Io__Haveno__Protobuffer__OpenDisputeRequest, defaultProto__Io__Haveno__Protobuffer__OpenOffer

@docs defaultProto__Io__Haveno__Protobuffer__PaxumAccountPayload, defaultProto__Io__Haveno__Protobuffer__PayByMailAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__PayPalAccountPayload, defaultProto__Io__Haveno__Protobuffer__PaymentAccount

@docs defaultProto__Io__Haveno__Protobuffer__PaymentAccountFilter, defaultProto__Io__Haveno__Protobuffer__PaymentAccountForm

@docs defaultProto__Io__Haveno__Protobuffer__PaymentAccountFormField, defaultProto__Io__Haveno__Protobuffer__PaymentAccountList

@docs defaultProto__Io__Haveno__Protobuffer__PaymentAccountPayload, defaultProto__Io__Haveno__Protobuffer__PaymentMethod

@docs defaultProto__Io__Haveno__Protobuffer__PaymentReceivedMessage, defaultProto__Io__Haveno__Protobuffer__PaymentSentMessage

@docs defaultProto__Io__Haveno__Protobuffer__PayseraAccountPayload, defaultProto__Io__Haveno__Protobuffer__PaytmAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__Peer, defaultProto__Io__Haveno__Protobuffer__PeerList

@docs defaultProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__PersistableEnvelope

@docs defaultProto__Io__Haveno__Protobuffer__PersistableNetworkPayload, defaultProto__Io__Haveno__Protobuffer__Ping

@docs defaultProto__Io__Haveno__Protobuffer__PixAccountPayload, defaultProto__Io__Haveno__Protobuffer__Pong

@docs defaultProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload, defaultProto__Io__Haveno__Protobuffer__PostOfferReply

@docs defaultProto__Io__Haveno__Protobuffer__PostOfferRequest, defaultProto__Io__Haveno__Protobuffer__PreferencesPayload

@docs defaultProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage

@docs defaultProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest, defaultProto__Io__Haveno__Protobuffer__PriceAlertFilter

@docs defaultProto__Io__Haveno__Protobuffer__PrivateNotificationMessage

@docs defaultProto__Io__Haveno__Protobuffer__PrivateNotificationPayload, defaultProto__Io__Haveno__Protobuffer__ProcessModel

@docs defaultProto__Io__Haveno__Protobuffer__PromptPayAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry

@docs defaultProto__Io__Haveno__Protobuffer__ProtectedStorageEntry, defaultProto__Io__Haveno__Protobuffer__PubKeyRing

@docs defaultProto__Io__Haveno__Protobuffer__RawTransactionInput, defaultProto__Io__Haveno__Protobuffer__RefreshOfferMessage

@docs defaultProto__Io__Haveno__Protobuffer__RefundAgent, defaultProto__Io__Haveno__Protobuffer__RefundDisputeList

@docs defaultProto__Io__Haveno__Protobuffer__Region, defaultProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply

@docs defaultProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest

@docs defaultProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest

@docs defaultProto__Io__Haveno__Protobuffer__RelayXmrTxReply, defaultProto__Io__Haveno__Protobuffer__RelayXmrTxRequest

@docs defaultProto__Io__Haveno__Protobuffer__RemoveConnectionReply

@docs defaultProto__Io__Haveno__Protobuffer__RemoveConnectionRequest, defaultProto__Io__Haveno__Protobuffer__RemoveDataMessage

@docs defaultProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage

@docs defaultProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply

@docs defaultProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest

@docs defaultProto__Io__Haveno__Protobuffer__RemovedPayloadsMap, defaultProto__Io__Haveno__Protobuffer__ResolveDisputeReply

@docs defaultProto__Io__Haveno__Protobuffer__ResolveDisputeRequest, defaultProto__Io__Haveno__Protobuffer__RestoreAccountReply

@docs defaultProto__Io__Haveno__Protobuffer__RestoreAccountRequest, defaultProto__Io__Haveno__Protobuffer__RevolutAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__RtgsAccountPayload, defaultProto__Io__Haveno__Protobuffer__SameBankAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__SatispayAccountPayload, defaultProto__Io__Haveno__Protobuffer__SealedAndSigned

@docs defaultProto__Io__Haveno__Protobuffer__SellerAsMakerTrade, defaultProto__Io__Haveno__Protobuffer__SellerAsTakerTrade

@docs defaultProto__Io__Haveno__Protobuffer__SendBtcRequest, defaultProto__Io__Haveno__Protobuffer__SendChatMessageReply

@docs defaultProto__Io__Haveno__Protobuffer__SendChatMessageRequest

@docs defaultProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply

@docs defaultProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest

@docs defaultProto__Io__Haveno__Protobuffer__SendNotificationReply

@docs defaultProto__Io__Haveno__Protobuffer__SendNotificationRequest, defaultProto__Io__Haveno__Protobuffer__SepaAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__SequenceNumberEntry, defaultProto__Io__Haveno__Protobuffer__SequenceNumberMap

@docs defaultProto__Io__Haveno__Protobuffer__SetAutoSwitchReply, defaultProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest

@docs defaultProto__Io__Haveno__Protobuffer__SetConnectionReply, defaultProto__Io__Haveno__Protobuffer__SetConnectionRequest

@docs defaultProto__Io__Haveno__Protobuffer__SetWalletPasswordReply

@docs defaultProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest

@docs defaultProto__Io__Haveno__Protobuffer__SignContractRequest, defaultProto__Io__Haveno__Protobuffer__SignContractResponse

@docs defaultProto__Io__Haveno__Protobuffer__SignOfferRequest, defaultProto__Io__Haveno__Protobuffer__SignOfferResponse

@docs defaultProto__Io__Haveno__Protobuffer__SignedOffer, defaultProto__Io__Haveno__Protobuffer__SignedOfferList

@docs defaultProto__Io__Haveno__Protobuffer__SignedWitness, defaultProto__Io__Haveno__Protobuffer__SignedWitnessStore

@docs defaultProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply

@docs defaultProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest

@docs defaultProto__Io__Haveno__Protobuffer__StartXmrNodeReply, defaultProto__Io__Haveno__Protobuffer__StartXmrNodeRequest

@docs defaultProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply

@docs defaultProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest, defaultProto__Io__Haveno__Protobuffer__StopReply

@docs defaultProto__Io__Haveno__Protobuffer__StopRequest, defaultProto__Io__Haveno__Protobuffer__StopXmrNodeReply

@docs defaultProto__Io__Haveno__Protobuffer__StopXmrNodeRequest, defaultProto__Io__Haveno__Protobuffer__StorageEntryWrapper

@docs defaultProto__Io__Haveno__Protobuffer__StoragePayload, defaultProto__Io__Haveno__Protobuffer__StrikeAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__SwiftAccountPayload, defaultProto__Io__Haveno__Protobuffer__SwishAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__TakeOfferReply, defaultProto__Io__Haveno__Protobuffer__TakeOfferRequest

@docs defaultProto__Io__Haveno__Protobuffer__TikkieAccountPayload, defaultProto__Io__Haveno__Protobuffer__Tradable

@docs defaultProto__Io__Haveno__Protobuffer__TradableList, defaultProto__Io__Haveno__Protobuffer__Trade

@docs defaultProto__Io__Haveno__Protobuffer__TradeCurrency, defaultProto__Io__Haveno__Protobuffer__TradeInfo

@docs defaultProto__Io__Haveno__Protobuffer__TradePeer, defaultProto__Io__Haveno__Protobuffer__TradeStatistics3

@docs defaultProto__Io__Haveno__Protobuffer__TradeStatistics3Store, defaultProto__Io__Haveno__Protobuffer__TraditionalCurrency

@docs defaultProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__UnlockWalletReply, defaultProto__Io__Haveno__Protobuffer__UnlockWalletRequest

@docs defaultProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply

@docs defaultProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest

@docs defaultProto__Io__Haveno__Protobuffer__UpholdAccountPayload, defaultProto__Io__Haveno__Protobuffer__UpiAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__UrlConnection, defaultProto__Io__Haveno__Protobuffer__UserPayload

@docs defaultProto__Io__Haveno__Protobuffer__ValidateFormFieldReply

@docs defaultProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest

@docs defaultProto__Io__Haveno__Protobuffer__VenmoAccountPayload, defaultProto__Io__Haveno__Protobuffer__VerseAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload

@docs defaultProto__Io__Haveno__Protobuffer__WithdrawFundsReply, defaultProto__Io__Haveno__Protobuffer__WithdrawFundsRequest

@docs defaultProto__Io__Haveno__Protobuffer__XmrAddressEntry, defaultProto__Io__Haveno__Protobuffer__XmrAddressEntryList

@docs defaultProto__Io__Haveno__Protobuffer__XmrBalanceInfo, defaultProto__Io__Haveno__Protobuffer__XmrDestination

@docs defaultProto__Io__Haveno__Protobuffer__XmrIncomingTransfer, defaultProto__Io__Haveno__Protobuffer__XmrNodeSettings

@docs defaultProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer, defaultProto__Io__Haveno__Protobuffer__XmrTx

@docs defaultProto__Io__Haveno__Protobuffer__ZelleAccountPayload, encodeProto__Io__Haveno__Protobuffer__AccountAgeWitness

@docs encodeProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore, encodeProto__Io__Haveno__Protobuffer__AccountExistsReply

@docs encodeProto__Io__Haveno__Protobuffer__AccountExistsRequest

@docs encodeProto__Io__Haveno__Protobuffer__AchTransferAccountPayload, encodeProto__Io__Haveno__Protobuffer__AckMessage

@docs encodeProto__Io__Haveno__Protobuffer__AddConnectionReply, encodeProto__Io__Haveno__Protobuffer__AddConnectionRequest

@docs encodeProto__Io__Haveno__Protobuffer__AddDataMessage

@docs encodeProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage

@docs encodeProto__Io__Haveno__Protobuffer__AddressBalanceInfo, encodeProto__Io__Haveno__Protobuffer__AddressEntry

@docs encodeProto__Io__Haveno__Protobuffer__AddressEntryList, encodeProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__Alert, encodeProto__Io__Haveno__Protobuffer__AliPayAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__ArbitrationDisputeList, encodeProto__Io__Haveno__Protobuffer__Arbitrator

@docs encodeProto__Io__Haveno__Protobuffer__ArbitratorTrade, encodeProto__Io__Haveno__Protobuffer__Attachment

@docs encodeProto__Io__Haveno__Protobuffer__AustraliaPayidPayload, encodeProto__Io__Haveno__Protobuffer__AutoConfirmSettings

@docs encodeProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription

@docs encodeProto__Io__Haveno__Protobuffer__BackupAccountReply, encodeProto__Io__Haveno__Protobuffer__BackupAccountRequest

@docs encodeProto__Io__Haveno__Protobuffer__BalancesInfo, encodeProto__Io__Haveno__Protobuffer__BankAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message

@docs encodeProto__Io__Haveno__Protobuffer__BizumAccountPayload, encodeProto__Io__Haveno__Protobuffer__BlockChainExplorer

@docs encodeProto__Io__Haveno__Protobuffer__BtcBalanceInfo, encodeProto__Io__Haveno__Protobuffer__BundleOfEnvelopes

@docs encodeProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade, encodeProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade

@docs encodeProto__Io__Haveno__Protobuffer__ByteArray, encodeProto__Io__Haveno__Protobuffer__CancelOfferReply

@docs encodeProto__Io__Haveno__Protobuffer__CancelOfferRequest, encodeProto__Io__Haveno__Protobuffer__CapitualAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__CashAppAccountPayload, encodeProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__CashDepositAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__CelPayAccountPayload, encodeProto__Io__Haveno__Protobuffer__ChangePasswordReply

@docs encodeProto__Io__Haveno__Protobuffer__ChangePasswordRequest

@docs encodeProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload, encodeProto__Io__Haveno__Protobuffer__ChatMessage

@docs encodeProto__Io__Haveno__Protobuffer__CheckConnectionReply, encodeProto__Io__Haveno__Protobuffer__CheckConnectionRequest

@docs encodeProto__Io__Haveno__Protobuffer__CheckConnectionsReply, encodeProto__Io__Haveno__Protobuffer__CheckConnectionsRequest

@docs encodeProto__Io__Haveno__Protobuffer__CloseAccountReply, encodeProto__Io__Haveno__Protobuffer__CloseAccountRequest

@docs encodeProto__Io__Haveno__Protobuffer__CloseConnectionMessage, encodeProto__Io__Haveno__Protobuffer__CompleteTradeReply

@docs encodeProto__Io__Haveno__Protobuffer__CompleteTradeRequest

@docs encodeProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply

@docs encodeProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest

@docs encodeProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply

@docs encodeProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest, encodeProto__Io__Haveno__Protobuffer__Contract

@docs encodeProto__Io__Haveno__Protobuffer__ContractInfo, encodeProto__Io__Haveno__Protobuffer__Country

@docs encodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message

@docs encodeProto__Io__Haveno__Protobuffer__CreateAccountReply, encodeProto__Io__Haveno__Protobuffer__CreateAccountRequest

@docs encodeProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply

@docs encodeProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest

@docs encodeProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply

@docs encodeProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest, encodeProto__Io__Haveno__Protobuffer__CreateXmrTxReply

@docs encodeProto__Io__Haveno__Protobuffer__CreateXmrTxRequest, encodeProto__Io__Haveno__Protobuffer__CryptoCurrency

@docs encodeProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload, encodeProto__Io__Haveno__Protobuffer__Currency

@docs encodeProto__Io__Haveno__Protobuffer__DataAndSeqNrPair, encodeProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey

@docs encodeProto__Io__Haveno__Protobuffer__DeleteAccountReply, encodeProto__Io__Haveno__Protobuffer__DeleteAccountRequest

@docs encodeProto__Io__Haveno__Protobuffer__DepositRequest, encodeProto__Io__Haveno__Protobuffer__DepositResponse

@docs encodeProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage, encodeProto__Io__Haveno__Protobuffer__Dispute

@docs encodeProto__Io__Haveno__Protobuffer__DisputeClosedMessage, encodeProto__Io__Haveno__Protobuffer__DisputeOpenedMessage

@docs encodeProto__Io__Haveno__Protobuffer__DisputeResult

@docs encodeProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__EncryptedConnection, encodeProto__Io__Haveno__Protobuffer__EncryptedConnectionList

@docs encodeProto__Io__Haveno__Protobuffer__F2FAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload, encodeProto__Io__Haveno__Protobuffer__FileTransferPart

@docs encodeProto__Io__Haveno__Protobuffer__Filter, encodeProto__Io__Haveno__Protobuffer__GetAddressBalanceReply

@docs encodeProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest, encodeProto__Io__Haveno__Protobuffer__GetBalancesReply

@docs encodeProto__Io__Haveno__Protobuffer__GetBalancesRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply

@docs encodeProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetChatMessagesReply, encodeProto__Io__Haveno__Protobuffer__GetChatMessagesRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetConnectionReply, encodeProto__Io__Haveno__Protobuffer__GetConnectionRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetConnectionsReply, encodeProto__Io__Haveno__Protobuffer__GetConnectionsRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply

@docs encodeProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetDataResponse, encodeProto__Io__Haveno__Protobuffer__GetDisputeReply

@docs encodeProto__Io__Haveno__Protobuffer__GetDisputeRequest, encodeProto__Io__Haveno__Protobuffer__GetDisputesReply

@docs encodeProto__Io__Haveno__Protobuffer__GetDisputesRequest, encodeProto__Io__Haveno__Protobuffer__GetFundingAddressesReply

@docs encodeProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetInventoryRequest, encodeProto__Io__Haveno__Protobuffer__GetInventoryResponse

@docs encodeProto__Io__Haveno__Protobuffer__GetMethodHelpReply, encodeProto__Io__Haveno__Protobuffer__GetMethodHelpRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetMyOfferReply, encodeProto__Io__Haveno__Protobuffer__GetMyOfferRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetMyOffersReply, encodeProto__Io__Haveno__Protobuffer__GetMyOffersRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetOfferReply, encodeProto__Io__Haveno__Protobuffer__GetOfferRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetOffersReply, encodeProto__Io__Haveno__Protobuffer__GetOffersRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply

@docs encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply

@docs encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply

@docs encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply

@docs encodeProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest, encodeProto__Io__Haveno__Protobuffer__GetPeersRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetPeersResponse, encodeProto__Io__Haveno__Protobuffer__GetTradeReply

@docs encodeProto__Io__Haveno__Protobuffer__GetTradeRequest, encodeProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply

@docs encodeProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest, encodeProto__Io__Haveno__Protobuffer__GetTradesReply

@docs encodeProto__Io__Haveno__Protobuffer__GetTradesRequest, encodeProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetVersionReply, encodeProto__Io__Haveno__Protobuffer__GetVersionRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply

@docs encodeProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply

@docs encodeProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest

@docs encodeProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply

@docs encodeProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest, encodeProto__Io__Haveno__Protobuffer__GetXmrSeedReply

@docs encodeProto__Io__Haveno__Protobuffer__GetXmrSeedRequest, encodeProto__Io__Haveno__Protobuffer__GetXmrTxsReply

@docs encodeProto__Io__Haveno__Protobuffer__GetXmrTxsRequest, encodeProto__Io__Haveno__Protobuffer__HalCashAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message

@docs encodeProto__Io__Haveno__Protobuffer__IgnoredMailboxMap, encodeProto__Io__Haveno__Protobuffer__ImpsAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__InitMultisigRequest, encodeProto__Io__Haveno__Protobuffer__InitTradeRequest

@docs encodeProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__IsAccountOpenReply, encodeProto__Io__Haveno__Protobuffer__IsAccountOpenRequest

@docs encodeProto__Io__Haveno__Protobuffer__IsAppInitializedReply, encodeProto__Io__Haveno__Protobuffer__IsAppInitializedRequest

@docs encodeProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply, encodeProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest

@docs encodeProto__Io__Haveno__Protobuffer__JapanBankAccountPayload, encodeProto__Io__Haveno__Protobuffer__LockWalletReply

@docs encodeProto__Io__Haveno__Protobuffer__LockWalletRequest, encodeProto__Io__Haveno__Protobuffer__MailboxItem

@docs encodeProto__Io__Haveno__Protobuffer__MailboxMessageList, encodeProto__Io__Haveno__Protobuffer__MailboxStoragePayload

@docs encodeProto__Io__Haveno__Protobuffer__MapValue, encodeProto__Io__Haveno__Protobuffer__MarketAlertFilter

@docs encodeProto__Io__Haveno__Protobuffer__MarketDepthInfo, encodeProto__Io__Haveno__Protobuffer__MarketDepthReply

@docs encodeProto__Io__Haveno__Protobuffer__MarketDepthRequest, encodeProto__Io__Haveno__Protobuffer__MarketPriceInfo

@docs encodeProto__Io__Haveno__Protobuffer__MarketPriceReply, encodeProto__Io__Haveno__Protobuffer__MarketPriceRequest

@docs encodeProto__Io__Haveno__Protobuffer__MarketPricesReply, encodeProto__Io__Haveno__Protobuffer__MarketPricesRequest

@docs encodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage

@docs encodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage

@docs encodeProto__Io__Haveno__Protobuffer__MediationDisputeList, encodeProto__Io__Haveno__Protobuffer__Mediator

@docs encodeProto__Io__Haveno__Protobuffer__MockMailboxPayload, encodeProto__Io__Haveno__Protobuffer__MockPayload

@docs encodeProto__Io__Haveno__Protobuffer__MoneseAccountPayload, encodeProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__NationalBankAccountPayload, encodeProto__Io__Haveno__Protobuffer__NavigationPath

@docs encodeProto__Io__Haveno__Protobuffer__NeftAccountPayload, encodeProto__Io__Haveno__Protobuffer__NequiAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__NetworkEnvelope

@docs encodeProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message, encodeProto__Io__Haveno__Protobuffer__NodeAddress

@docs encodeProto__Io__Haveno__Protobuffer__NotificationMessage, encodeProto__Io__Haveno__Protobuffer__OKPayAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__Offer, encodeProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest

@docs encodeProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse, encodeProto__Io__Haveno__Protobuffer__OfferInfo

@docs encodeProto__Io__Haveno__Protobuffer__OfferPayload, encodeProto__Io__Haveno__Protobuffer__OpenAccountReply

@docs encodeProto__Io__Haveno__Protobuffer__OpenAccountRequest, encodeProto__Io__Haveno__Protobuffer__OpenDisputeReply

@docs encodeProto__Io__Haveno__Protobuffer__OpenDisputeRequest, encodeProto__Io__Haveno__Protobuffer__OpenOffer

@docs encodeProto__Io__Haveno__Protobuffer__PaxumAccountPayload, encodeProto__Io__Haveno__Protobuffer__PayByMailAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__PayPalAccountPayload, encodeProto__Io__Haveno__Protobuffer__PaymentAccount

@docs encodeProto__Io__Haveno__Protobuffer__PaymentAccountFilter, encodeProto__Io__Haveno__Protobuffer__PaymentAccountForm

@docs encodeProto__Io__Haveno__Protobuffer__PaymentAccountFormField, encodeProto__Io__Haveno__Protobuffer__PaymentAccountList

@docs encodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message

@docs encodeProto__Io__Haveno__Protobuffer__PaymentMethod, encodeProto__Io__Haveno__Protobuffer__PaymentReceivedMessage

@docs encodeProto__Io__Haveno__Protobuffer__PaymentSentMessage, encodeProto__Io__Haveno__Protobuffer__PayseraAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__PaytmAccountPayload, encodeProto__Io__Haveno__Protobuffer__Peer

@docs encodeProto__Io__Haveno__Protobuffer__PeerList, encodeProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__PersistableEnvelope

@docs encodeProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message

@docs encodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload

@docs encodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message

@docs encodeProto__Io__Haveno__Protobuffer__Ping, encodeProto__Io__Haveno__Protobuffer__PixAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__Pong, encodeProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__PostOfferReply, encodeProto__Io__Haveno__Protobuffer__PostOfferRequest

@docs encodeProto__Io__Haveno__Protobuffer__PreferencesPayload

@docs encodeProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage

@docs encodeProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest, encodeProto__Io__Haveno__Protobuffer__PriceAlertFilter

@docs encodeProto__Io__Haveno__Protobuffer__PrivateNotificationMessage

@docs encodeProto__Io__Haveno__Protobuffer__PrivateNotificationPayload, encodeProto__Io__Haveno__Protobuffer__ProcessModel

@docs encodeProto__Io__Haveno__Protobuffer__PromptPayAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry

@docs encodeProto__Io__Haveno__Protobuffer__ProtectedStorageEntry, encodeProto__Io__Haveno__Protobuffer__PubKeyRing

@docs encodeProto__Io__Haveno__Protobuffer__RawTransactionInput, encodeProto__Io__Haveno__Protobuffer__RefreshOfferMessage

@docs encodeProto__Io__Haveno__Protobuffer__RefundAgent, encodeProto__Io__Haveno__Protobuffer__RefundDisputeList

@docs encodeProto__Io__Haveno__Protobuffer__Region, encodeProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply

@docs encodeProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest

@docs encodeProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest

@docs encodeProto__Io__Haveno__Protobuffer__RelayXmrTxReply, encodeProto__Io__Haveno__Protobuffer__RelayXmrTxRequest

@docs encodeProto__Io__Haveno__Protobuffer__RemoveConnectionReply, encodeProto__Io__Haveno__Protobuffer__RemoveConnectionRequest

@docs encodeProto__Io__Haveno__Protobuffer__RemoveDataMessage, encodeProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage

@docs encodeProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply

@docs encodeProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest

@docs encodeProto__Io__Haveno__Protobuffer__RemovedPayloadsMap, encodeProto__Io__Haveno__Protobuffer__ResolveDisputeReply

@docs encodeProto__Io__Haveno__Protobuffer__ResolveDisputeRequest, encodeProto__Io__Haveno__Protobuffer__RestoreAccountReply

@docs encodeProto__Io__Haveno__Protobuffer__RestoreAccountRequest, encodeProto__Io__Haveno__Protobuffer__RevolutAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__RtgsAccountPayload, encodeProto__Io__Haveno__Protobuffer__SameBankAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__SatispayAccountPayload, encodeProto__Io__Haveno__Protobuffer__SealedAndSigned

@docs encodeProto__Io__Haveno__Protobuffer__SellerAsMakerTrade, encodeProto__Io__Haveno__Protobuffer__SellerAsTakerTrade

@docs encodeProto__Io__Haveno__Protobuffer__SendBtcRequest, encodeProto__Io__Haveno__Protobuffer__SendChatMessageReply

@docs encodeProto__Io__Haveno__Protobuffer__SendChatMessageRequest

@docs encodeProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply

@docs encodeProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest

@docs encodeProto__Io__Haveno__Protobuffer__SendNotificationReply, encodeProto__Io__Haveno__Protobuffer__SendNotificationRequest

@docs encodeProto__Io__Haveno__Protobuffer__SepaAccountPayload, encodeProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__SequenceNumberEntry, encodeProto__Io__Haveno__Protobuffer__SequenceNumberMap

@docs encodeProto__Io__Haveno__Protobuffer__SetAutoSwitchReply, encodeProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest

@docs encodeProto__Io__Haveno__Protobuffer__SetConnectionReply, encodeProto__Io__Haveno__Protobuffer__SetConnectionRequest

@docs encodeProto__Io__Haveno__Protobuffer__SetWalletPasswordReply

@docs encodeProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest, encodeProto__Io__Haveno__Protobuffer__SignContractRequest

@docs encodeProto__Io__Haveno__Protobuffer__SignContractResponse, encodeProto__Io__Haveno__Protobuffer__SignOfferRequest

@docs encodeProto__Io__Haveno__Protobuffer__SignOfferResponse, encodeProto__Io__Haveno__Protobuffer__SignedOffer

@docs encodeProto__Io__Haveno__Protobuffer__SignedOfferList, encodeProto__Io__Haveno__Protobuffer__SignedWitness

@docs encodeProto__Io__Haveno__Protobuffer__SignedWitnessStore

@docs encodeProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply

@docs encodeProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest

@docs encodeProto__Io__Haveno__Protobuffer__StartXmrNodeReply, encodeProto__Io__Haveno__Protobuffer__StartXmrNodeRequest

@docs encodeProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply

@docs encodeProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest, encodeProto__Io__Haveno__Protobuffer__StopReply

@docs encodeProto__Io__Haveno__Protobuffer__StopRequest, encodeProto__Io__Haveno__Protobuffer__StopXmrNodeReply

@docs encodeProto__Io__Haveno__Protobuffer__StopXmrNodeRequest, encodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper

@docs encodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message

@docs encodeProto__Io__Haveno__Protobuffer__StoragePayload

@docs encodeProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message

@docs encodeProto__Io__Haveno__Protobuffer__StrikeAccountPayload, encodeProto__Io__Haveno__Protobuffer__SwiftAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__SwishAccountPayload, encodeProto__Io__Haveno__Protobuffer__TakeOfferReply

@docs encodeProto__Io__Haveno__Protobuffer__TakeOfferRequest, encodeProto__Io__Haveno__Protobuffer__TikkieAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__Tradable, encodeProto__Io__Haveno__Protobuffer__TradableList

@docs encodeProto__Io__Haveno__Protobuffer__Tradable__Message__Message, encodeProto__Io__Haveno__Protobuffer__Trade

@docs encodeProto__Io__Haveno__Protobuffer__TradeCurrency, encodeProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message

@docs encodeProto__Io__Haveno__Protobuffer__TradeInfo, encodeProto__Io__Haveno__Protobuffer__TradePeer

@docs encodeProto__Io__Haveno__Protobuffer__TradeStatistics3, encodeProto__Io__Haveno__Protobuffer__TradeStatistics3Store

@docs encodeProto__Io__Haveno__Protobuffer__TraditionalCurrency

@docs encodeProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__UnlockWalletReply, encodeProto__Io__Haveno__Protobuffer__UnlockWalletRequest

@docs encodeProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply

@docs encodeProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest

@docs encodeProto__Io__Haveno__Protobuffer__UpholdAccountPayload, encodeProto__Io__Haveno__Protobuffer__UpiAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__UrlConnection, encodeProto__Io__Haveno__Protobuffer__UserPayload

@docs encodeProto__Io__Haveno__Protobuffer__ValidateFormFieldReply

@docs encodeProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest, encodeProto__Io__Haveno__Protobuffer__VenmoAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__VerseAccountPayload, encodeProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload

@docs encodeProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload, encodeProto__Io__Haveno__Protobuffer__WithdrawFundsReply

@docs encodeProto__Io__Haveno__Protobuffer__WithdrawFundsRequest, encodeProto__Io__Haveno__Protobuffer__XmrAddressEntry

@docs encodeProto__Io__Haveno__Protobuffer__XmrAddressEntryList, encodeProto__Io__Haveno__Protobuffer__XmrBalanceInfo

@docs encodeProto__Io__Haveno__Protobuffer__XmrDestination, encodeProto__Io__Haveno__Protobuffer__XmrIncomingTransfer

@docs encodeProto__Io__Haveno__Protobuffer__XmrNodeSettings, encodeProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer

@docs encodeProto__Io__Haveno__Protobuffer__XmrTx, encodeProto__Io__Haveno__Protobuffer__ZelleAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AccountAgeWitness

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AccountExistsReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AccountExistsRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AchTransferAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AckMessage, fieldNumbersProto__Io__Haveno__Protobuffer__AddConnectionReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AddConnectionRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AddDataMessage

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AddressBalanceInfo, fieldNumbersProto__Io__Haveno__Protobuffer__AddressEntry

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AddressEntryList

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__Alert

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AliPayAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ArbitrationDisputeList, fieldNumbersProto__Io__Haveno__Protobuffer__Arbitrator

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ArbitratorTrade, fieldNumbersProto__Io__Haveno__Protobuffer__Attachment

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AustraliaPayidPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AutoConfirmSettings

@docs fieldNumbersProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription

@docs fieldNumbersProto__Io__Haveno__Protobuffer__BackupAccountReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__BackupAccountRequest, fieldNumbersProto__Io__Haveno__Protobuffer__BalancesInfo

@docs fieldNumbersProto__Io__Haveno__Protobuffer__BankAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message

@docs fieldNumbersProto__Io__Haveno__Protobuffer__BizumAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__BlockChainExplorer, fieldNumbersProto__Io__Haveno__Protobuffer__BtcBalanceInfo

@docs fieldNumbersProto__Io__Haveno__Protobuffer__BundleOfEnvelopes

@docs fieldNumbersProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade

@docs fieldNumbersProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade, fieldNumbersProto__Io__Haveno__Protobuffer__ByteArray

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CancelOfferReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CancelOfferRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CapitualAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CashAppAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CashDepositAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CelPayAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ChangePasswordReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ChangePasswordRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ChatMessage, fieldNumbersProto__Io__Haveno__Protobuffer__CheckConnectionReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CheckConnectionRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CheckConnectionsReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CheckConnectionsRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CloseAccountReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CloseAccountRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CloseConnectionMessage

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CompleteTradeReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CompleteTradeRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__Contract, fieldNumbersProto__Io__Haveno__Protobuffer__ContractInfo

@docs fieldNumbersProto__Io__Haveno__Protobuffer__Country

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CreateAccountReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CreateAccountRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CreateXmrTxReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CreateXmrTxRequest, fieldNumbersProto__Io__Haveno__Protobuffer__CryptoCurrency

@docs fieldNumbersProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__Currency, fieldNumbersProto__Io__Haveno__Protobuffer__DataAndSeqNrPair

@docs fieldNumbersProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey

@docs fieldNumbersProto__Io__Haveno__Protobuffer__DeleteAccountReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__DeleteAccountRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__DepositRequest, fieldNumbersProto__Io__Haveno__Protobuffer__DepositResponse

@docs fieldNumbersProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage, fieldNumbersProto__Io__Haveno__Protobuffer__Dispute

@docs fieldNumbersProto__Io__Haveno__Protobuffer__DisputeClosedMessage

@docs fieldNumbersProto__Io__Haveno__Protobuffer__DisputeOpenedMessage

@docs fieldNumbersProto__Io__Haveno__Protobuffer__DisputeResult

@docs fieldNumbersProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__EncryptedConnection

@docs fieldNumbersProto__Io__Haveno__Protobuffer__EncryptedConnectionList

@docs fieldNumbersProto__Io__Haveno__Protobuffer__F2FAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__FileTransferPart, fieldNumbersProto__Io__Haveno__Protobuffer__Filter

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetAddressBalanceReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetBalancesReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetBalancesRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetChatMessagesReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetChatMessagesRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetConnectionReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetConnectionRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetConnectionsReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetConnectionsRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetDataResponse, fieldNumbersProto__Io__Haveno__Protobuffer__GetDisputeReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetDisputeRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetDisputesReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetDisputesRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetFundingAddressesReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetInventoryRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetInventoryResponse

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetMethodHelpReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetMethodHelpRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetMyOfferReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetMyOfferRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetMyOffersReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetMyOffersRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetOfferReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetOfferRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetOffersReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetOffersRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetPeersRequest, fieldNumbersProto__Io__Haveno__Protobuffer__GetPeersResponse

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetTradeReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetTradeRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetTradesReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetTradesRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetVersionReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetVersionRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrSeedReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrSeedRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrTxsReply, fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrTxsRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__HalCashAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message

@docs fieldNumbersProto__Io__Haveno__Protobuffer__IgnoredMailboxMap

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ImpsAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__InitMultisigRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__InitTradeRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__IsAccountOpenReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__IsAccountOpenRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__IsAppInitializedReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__IsAppInitializedRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__JapanBankAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__LockWalletReply, fieldNumbersProto__Io__Haveno__Protobuffer__LockWalletRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__MailboxItem, fieldNumbersProto__Io__Haveno__Protobuffer__MailboxMessageList

@docs fieldNumbersProto__Io__Haveno__Protobuffer__MailboxStoragePayload, fieldNumbersProto__Io__Haveno__Protobuffer__MapValue

@docs fieldNumbersProto__Io__Haveno__Protobuffer__MarketAlertFilter, fieldNumbersProto__Io__Haveno__Protobuffer__MarketDepthInfo

@docs fieldNumbersProto__Io__Haveno__Protobuffer__MarketDepthReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__MarketDepthRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__MarketPriceInfo, fieldNumbersProto__Io__Haveno__Protobuffer__MarketPriceReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__MarketPriceRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__MarketPricesReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__MarketPricesRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage

@docs fieldNumbersProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage

@docs fieldNumbersProto__Io__Haveno__Protobuffer__MediationDisputeList, fieldNumbersProto__Io__Haveno__Protobuffer__Mediator

@docs fieldNumbersProto__Io__Haveno__Protobuffer__MockMailboxPayload, fieldNumbersProto__Io__Haveno__Protobuffer__MockPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__MoneseAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__NationalBankAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__NavigationPath, fieldNumbersProto__Io__Haveno__Protobuffer__NeftAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__NequiAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__NetworkEnvelope

@docs fieldNumbersProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message

@docs fieldNumbersProto__Io__Haveno__Protobuffer__NodeAddress, fieldNumbersProto__Io__Haveno__Protobuffer__NotificationMessage

@docs fieldNumbersProto__Io__Haveno__Protobuffer__OKPayAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__Offer

@docs fieldNumbersProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse

@docs fieldNumbersProto__Io__Haveno__Protobuffer__OfferInfo, fieldNumbersProto__Io__Haveno__Protobuffer__OfferPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__OpenAccountReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__OpenAccountRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__OpenDisputeReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__OpenDisputeRequest, fieldNumbersProto__Io__Haveno__Protobuffer__OpenOffer

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PaxumAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PayByMailAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PayPalAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccount

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountFilter

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountForm

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountFormField

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountList

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PaymentMethod

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PaymentReceivedMessage

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PaymentSentMessage

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PayseraAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PaytmAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__Peer

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PeerList

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PersistableEnvelope

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PersistableNetworkPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message

@docs fieldNumbersProto__Io__Haveno__Protobuffer__Ping, fieldNumbersProto__Io__Haveno__Protobuffer__PixAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__Pong, fieldNumbersProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PostOfferReply, fieldNumbersProto__Io__Haveno__Protobuffer__PostOfferRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PreferencesPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PriceAlertFilter

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PrivateNotificationMessage

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PrivateNotificationPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ProcessModel

@docs fieldNumbersProto__Io__Haveno__Protobuffer__PromptPayAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ProtectedStorageEntry, fieldNumbersProto__Io__Haveno__Protobuffer__PubKeyRing

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RawTransactionInput

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RefreshOfferMessage, fieldNumbersProto__Io__Haveno__Protobuffer__RefundAgent

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RefundDisputeList, fieldNumbersProto__Io__Haveno__Protobuffer__Region

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RelayXmrTxReply, fieldNumbersProto__Io__Haveno__Protobuffer__RelayXmrTxRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RemoveConnectionReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RemoveConnectionRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RemoveDataMessage

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RemovedPayloadsMap

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ResolveDisputeReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ResolveDisputeRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RestoreAccountReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RestoreAccountRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RevolutAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__RtgsAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SameBankAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SatispayAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SealedAndSigned

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SellerAsMakerTrade

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SellerAsTakerTrade, fieldNumbersProto__Io__Haveno__Protobuffer__SendBtcRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SendChatMessageReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SendChatMessageRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SendNotificationReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SendNotificationRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SepaAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SequenceNumberEntry

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SequenceNumberMap

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SetAutoSwitchReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SetConnectionReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SetConnectionRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SetWalletPasswordReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SignContractRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SignContractResponse

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SignOfferRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SignOfferResponse, fieldNumbersProto__Io__Haveno__Protobuffer__SignedOffer

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SignedOfferList, fieldNumbersProto__Io__Haveno__Protobuffer__SignedWitness

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SignedWitnessStore

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__StartXmrNodeReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__StartXmrNodeRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__StopReply, fieldNumbersProto__Io__Haveno__Protobuffer__StopRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__StopXmrNodeReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__StopXmrNodeRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__StorageEntryWrapper

@docs fieldNumbersProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message

@docs fieldNumbersProto__Io__Haveno__Protobuffer__StoragePayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message

@docs fieldNumbersProto__Io__Haveno__Protobuffer__StrikeAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SwiftAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__SwishAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__TakeOfferReply, fieldNumbersProto__Io__Haveno__Protobuffer__TakeOfferRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__TikkieAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__Tradable

@docs fieldNumbersProto__Io__Haveno__Protobuffer__TradableList

@docs fieldNumbersProto__Io__Haveno__Protobuffer__Tradable__Message__Message, fieldNumbersProto__Io__Haveno__Protobuffer__Trade

@docs fieldNumbersProto__Io__Haveno__Protobuffer__TradeCurrency

@docs fieldNumbersProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message

@docs fieldNumbersProto__Io__Haveno__Protobuffer__TradeInfo, fieldNumbersProto__Io__Haveno__Protobuffer__TradePeer

@docs fieldNumbersProto__Io__Haveno__Protobuffer__TradeStatistics3

@docs fieldNumbersProto__Io__Haveno__Protobuffer__TradeStatistics3Store

@docs fieldNumbersProto__Io__Haveno__Protobuffer__TraditionalCurrency

@docs fieldNumbersProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__UnlockWalletReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__UnlockWalletRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__UpholdAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__UpiAccountPayload, fieldNumbersProto__Io__Haveno__Protobuffer__UrlConnection

@docs fieldNumbersProto__Io__Haveno__Protobuffer__UserPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ValidateFormFieldReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__VenmoAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__VerseAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload

@docs fieldNumbersProto__Io__Haveno__Protobuffer__WithdrawFundsReply

@docs fieldNumbersProto__Io__Haveno__Protobuffer__WithdrawFundsRequest

@docs fieldNumbersProto__Io__Haveno__Protobuffer__XmrAddressEntry

@docs fieldNumbersProto__Io__Haveno__Protobuffer__XmrAddressEntryList

@docs fieldNumbersProto__Io__Haveno__Protobuffer__XmrBalanceInfo, fieldNumbersProto__Io__Haveno__Protobuffer__XmrDestination

@docs fieldNumbersProto__Io__Haveno__Protobuffer__XmrIncomingTransfer

@docs fieldNumbersProto__Io__Haveno__Protobuffer__XmrNodeSettings

@docs fieldNumbersProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer, fieldNumbersProto__Io__Haveno__Protobuffer__XmrTx

@docs fieldNumbersProto__Io__Haveno__Protobuffer__ZelleAccountPayload, unwrapProto__Io__Haveno__Protobuffer__BundleOfEnvelopes

@docs unwrapProto__Io__Haveno__Protobuffer__NetworkEnvelope

-}

import Bytes
import Dict
import Maybe
import Proto.Io.Haveno.Protobuffer.AddressEntry.Context
import Proto.Io.Haveno.Protobuffer.AvailabilityResult
import Proto.Io.Haveno.Protobuffer.BankAccountPayload.Message
import Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message
import Proto.Io.Haveno.Protobuffer.Dispute.State
import Proto.Io.Haveno.Protobuffer.DisputeResult.Reason
import Proto.Io.Haveno.Protobuffer.DisputeResult.SubtractFeeFrom
import Proto.Io.Haveno.Protobuffer.DisputeResult.Winner
import Proto.Io.Haveno.Protobuffer.GetTradesRequest.Category
import Proto.Io.Haveno.Protobuffer.IfscBasedAccountPayload.Message
import Proto.Io.Haveno.Protobuffer.MediationResultState
import Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message
import Proto.Io.Haveno.Protobuffer.NotificationMessage.NotificationType
import Proto.Io.Haveno.Protobuffer.OfferDirection
import Proto.Io.Haveno.Protobuffer.OpenOffer.State
import Proto.Io.Haveno.Protobuffer.PaymentAccountForm.FormId
import Proto.Io.Haveno.Protobuffer.PaymentAccountFormField.Component
import Proto.Io.Haveno.Protobuffer.PaymentAccountFormField.FieldId
import Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message
import Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message
import Proto.Io.Haveno.Protobuffer.PersistableNetworkPayload.Message
import Proto.Io.Haveno.Protobuffer.RefundResultState
import Proto.Io.Haveno.Protobuffer.SignedWitness.VerificationMethod
import Proto.Io.Haveno.Protobuffer.StorageEntryWrapper.Message
import Proto.Io.Haveno.Protobuffer.StoragePayload.Message
import Proto.Io.Haveno.Protobuffer.SupportType
import Proto.Io.Haveno.Protobuffer.Tradable.Message
import Proto.Io.Haveno.Protobuffer.Trade.DisputeState
import Proto.Io.Haveno.Protobuffer.Trade.PayoutState
import Proto.Io.Haveno.Protobuffer.Trade.State
import Proto.Io.Haveno.Protobuffer.Trade.TradePeriodState
import Proto.Io.Haveno.Protobuffer.TradeCurrency.Message
import Proto.Io.Haveno.Protobuffer.TradeProtocolVersion
import Proto.Io.Haveno.Protobuffer.UrlConnection.AuthenticationStatus
import Proto.Io.Haveno.Protobuffer.UrlConnection.OnlineStatus
import Proto.Io.Haveno.Protobuffer.XmrAddressEntry.Context
import Protobuf.Decode
import Protobuf.Encode
import Protobuf.Types.Int64


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message :
    FieldNumbersProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message
fieldNumbersProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message =
    { cryptoCurrency = 3, traditionalCurrency = 4 }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
type alias FieldNumbersProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message =
    { cryptoCurrency : Int, traditionalCurrency : Int }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message :
    (Maybe Proto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message -> a -> a) -> Protobuf.Decode.FieldDecoder a
decodeProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message =
    Protobuf.Decode.oneOf
        [ ( 3
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.TradeCurrency.Message.CryptoCurrency
                      decodeProto__Io__Haveno__Protobuffer__CryptoCurrency
          )
        , ( 4
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.TradeCurrency.Message.TraditionalCurrency
                      decodeProto__Io__Haveno__Protobuffer__TraditionalCurrency
          )
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message :
    Maybe Proto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message -> ( Int, Protobuf.Encode.Encoder )
encodeProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message value =
    case value of
        Nothing ->
            ( 0, Protobuf.Encode.none )

        Just (Proto.Io.Haveno.Protobuffer.TradeCurrency.Message.CryptoCurrency innerValue) ->
            ( 3, encodeProto__Io__Haveno__Protobuffer__CryptoCurrency innerValue )

        Just (Proto.Io.Haveno.Protobuffer.TradeCurrency.Message.TraditionalCurrency innerValue) ->
            ( 4, encodeProto__Io__Haveno__Protobuffer__TraditionalCurrency innerValue )


{-| `Proto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message` options

-}
type alias Proto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message =
    Proto.Io.Haveno.Protobuffer.TradeCurrency.Message.Message Proto__Io__Haveno__Protobuffer__CryptoCurrency Proto__Io__Haveno__Protobuffer__TraditionalCurrency


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Tradable__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Tradable__Message__Message :
    FieldNumbersProto__Io__Haveno__Protobuffer__Tradable__Message__Message
fieldNumbersProto__Io__Haveno__Protobuffer__Tradable__Message__Message =
    { openOffer = 1
    , signedOffer = 2
    , buyerAsMakerTrade = 3
    , buyerAsTakerTrade = 4
    , sellerAsMakerTrade = 5
    , sellerAsTakerTrade = 6
    , arbitratorTrade = 7
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Tradable__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
type alias FieldNumbersProto__Io__Haveno__Protobuffer__Tradable__Message__Message =
    { openOffer : Int
    , signedOffer : Int
    , buyerAsMakerTrade : Int
    , buyerAsTakerTrade : Int
    , sellerAsMakerTrade : Int
    , sellerAsTakerTrade : Int
    , arbitratorTrade : Int
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Tradable__Message__Message` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Tradable__Message__Message :
    (Maybe Proto__Io__Haveno__Protobuffer__Tradable__Message__Message -> a -> a) -> Protobuf.Decode.FieldDecoder a
decodeProto__Io__Haveno__Protobuffer__Tradable__Message__Message =
    Protobuf.Decode.oneOf
        [ ( 1
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.Tradable.Message.OpenOffer
                      decodeProto__Io__Haveno__Protobuffer__OpenOffer
          )
        , ( 2
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.Tradable.Message.SignedOffer
                      decodeProto__Io__Haveno__Protobuffer__SignedOffer
          )
        , ( 3
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.Tradable.Message.BuyerAsMakerTrade
                      decodeProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade
          )
        , ( 4
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.Tradable.Message.BuyerAsTakerTrade
                      decodeProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade
          )
        , ( 5
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.Tradable.Message.SellerAsMakerTrade
                      decodeProto__Io__Haveno__Protobuffer__SellerAsMakerTrade
          )
        , ( 6
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.Tradable.Message.SellerAsTakerTrade
                      decodeProto__Io__Haveno__Protobuffer__SellerAsTakerTrade
          )
        , ( 7
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.Tradable.Message.ArbitratorTrade
                      decodeProto__Io__Haveno__Protobuffer__ArbitratorTrade
          )
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Tradable__Message__Message` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Tradable__Message__Message :
    Maybe Proto__Io__Haveno__Protobuffer__Tradable__Message__Message -> ( Int, Protobuf.Encode.Encoder )
encodeProto__Io__Haveno__Protobuffer__Tradable__Message__Message value =
    case value of
        Nothing ->
            ( 0, Protobuf.Encode.none )

        Just (Proto.Io.Haveno.Protobuffer.Tradable.Message.OpenOffer innerValue) ->
            ( 1, encodeProto__Io__Haveno__Protobuffer__OpenOffer innerValue )

        Just (Proto.Io.Haveno.Protobuffer.Tradable.Message.SignedOffer innerValue) ->
            ( 2, encodeProto__Io__Haveno__Protobuffer__SignedOffer innerValue )

        Just (Proto.Io.Haveno.Protobuffer.Tradable.Message.BuyerAsMakerTrade innerValue) ->
            ( 3, encodeProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade innerValue )

        Just (Proto.Io.Haveno.Protobuffer.Tradable.Message.BuyerAsTakerTrade innerValue) ->
            ( 4, encodeProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade innerValue )

        Just (Proto.Io.Haveno.Protobuffer.Tradable.Message.SellerAsMakerTrade innerValue) ->
            ( 5, encodeProto__Io__Haveno__Protobuffer__SellerAsMakerTrade innerValue )

        Just (Proto.Io.Haveno.Protobuffer.Tradable.Message.SellerAsTakerTrade innerValue) ->
            ( 6, encodeProto__Io__Haveno__Protobuffer__SellerAsTakerTrade innerValue )

        Just (Proto.Io.Haveno.Protobuffer.Tradable.Message.ArbitratorTrade innerValue) ->
            ( 7, encodeProto__Io__Haveno__Protobuffer__ArbitratorTrade innerValue )


{-| `Proto__Io__Haveno__Protobuffer__Tradable__Message__Message` options

-}
type alias Proto__Io__Haveno__Protobuffer__Tradable__Message__Message =
    Proto.Io.Haveno.Protobuffer.Tradable.Message.Message Proto__Io__Haveno__Protobuffer__OpenOffer Proto__Io__Haveno__Protobuffer__SignedOffer Proto__Io__Haveno__Protobuffer__BuyerAsMakerTrade Proto__Io__Haveno__Protobuffer__BuyerAsTakerTrade Proto__Io__Haveno__Protobuffer__SellerAsMakerTrade Proto__Io__Haveno__Protobuffer__SellerAsTakerTrade Proto__Io__Haveno__Protobuffer__ArbitratorTrade


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StoragePayload__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message :
    FieldNumbersProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message
fieldNumbersProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message =
    { alert = 1
    , arbitrator = 2
    , mediator = 3
    , filter = 4
    , mailboxStoragePayload = 5
    , offerPayload = 6
    , refundAgent = 7
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StoragePayload__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
type alias FieldNumbersProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message =
    { alert : Int
    , arbitrator : Int
    , mediator : Int
    , filter : Int
    , mailboxStoragePayload : Int
    , offerPayload : Int
    , refundAgent : Int
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__StoragePayload__Message__Message` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message :
    (Maybe Proto__Io__Haveno__Protobuffer__StoragePayload__Message__Message -> a -> a) -> Protobuf.Decode.FieldDecoder a
decodeProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message =
    Protobuf.Decode.oneOf
        [ ( 1
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.StoragePayload.Message.Alert
                      decodeProto__Io__Haveno__Protobuffer__Alert
          )
        , ( 2
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.StoragePayload.Message.Arbitrator
                      decodeProto__Io__Haveno__Protobuffer__Arbitrator
          )
        , ( 3
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.StoragePayload.Message.Mediator
                      decodeProto__Io__Haveno__Protobuffer__Mediator
          )
        , ( 4
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.StoragePayload.Message.Filter
                      decodeProto__Io__Haveno__Protobuffer__Filter
          )
        , ( 5
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.StoragePayload.Message.MailboxStoragePayload
                      decodeProto__Io__Haveno__Protobuffer__MailboxStoragePayload
          )
        , ( 6
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.StoragePayload.Message.OfferPayload
                      decodeProto__Io__Haveno__Protobuffer__OfferPayload
          )
        , ( 7
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.StoragePayload.Message.RefundAgent
                      decodeProto__Io__Haveno__Protobuffer__RefundAgent
          )
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__StoragePayload__Message__Message` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message :
    Maybe Proto__Io__Haveno__Protobuffer__StoragePayload__Message__Message -> ( Int, Protobuf.Encode.Encoder )
encodeProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message value =
    case value of
        Nothing ->
            ( 0, Protobuf.Encode.none )

        Just (Proto.Io.Haveno.Protobuffer.StoragePayload.Message.Alert innerValue) ->
            ( 1, encodeProto__Io__Haveno__Protobuffer__Alert innerValue )

        Just (Proto.Io.Haveno.Protobuffer.StoragePayload.Message.Arbitrator innerValue) ->
            ( 2, encodeProto__Io__Haveno__Protobuffer__Arbitrator innerValue )

        Just (Proto.Io.Haveno.Protobuffer.StoragePayload.Message.Mediator innerValue) ->
            ( 3, encodeProto__Io__Haveno__Protobuffer__Mediator innerValue )

        Just (Proto.Io.Haveno.Protobuffer.StoragePayload.Message.Filter innerValue) ->
            ( 4, encodeProto__Io__Haveno__Protobuffer__Filter innerValue )

        Just (Proto.Io.Haveno.Protobuffer.StoragePayload.Message.MailboxStoragePayload innerValue) ->
            ( 5, encodeProto__Io__Haveno__Protobuffer__MailboxStoragePayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.StoragePayload.Message.OfferPayload innerValue) ->
            ( 6, encodeProto__Io__Haveno__Protobuffer__OfferPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.StoragePayload.Message.RefundAgent innerValue) ->
            ( 7, encodeProto__Io__Haveno__Protobuffer__RefundAgent innerValue )


{-| `Proto__Io__Haveno__Protobuffer__StoragePayload__Message__Message` options

-}
type alias Proto__Io__Haveno__Protobuffer__StoragePayload__Message__Message =
    Proto.Io.Haveno.Protobuffer.StoragePayload.Message.Message Proto__Io__Haveno__Protobuffer__Alert Proto__Io__Haveno__Protobuffer__Arbitrator Proto__Io__Haveno__Protobuffer__Mediator Proto__Io__Haveno__Protobuffer__Filter Proto__Io__Haveno__Protobuffer__MailboxStoragePayload Proto__Io__Haveno__Protobuffer__OfferPayload Proto__Io__Haveno__Protobuffer__RefundAgent


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message :
    FieldNumbersProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message
fieldNumbersProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message =
    { protectedStorageEntry = 1, protectedMailboxStorageEntry = 2 }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
type alias FieldNumbersProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message =
    { protectedStorageEntry : Int, protectedMailboxStorageEntry : Int }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message :
    (Maybe Proto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message -> a -> a)
    -> Protobuf.Decode.FieldDecoder a
decodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message =
    Protobuf.Decode.oneOf
        [ ( 1
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.StorageEntryWrapper.Message.ProtectedStorageEntry
                      decodeProto__Io__Haveno__Protobuffer__ProtectedStorageEntry
          )
        , ( 2
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.StorageEntryWrapper.Message.ProtectedMailboxStorageEntry
                      decodeProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry
          )
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message :
    Maybe Proto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message -> ( Int, Protobuf.Encode.Encoder )
encodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message value =
    case value of
        Nothing ->
            ( 0, Protobuf.Encode.none )

        Just (Proto.Io.Haveno.Protobuffer.StorageEntryWrapper.Message.ProtectedStorageEntry innerValue) ->
            ( 1, encodeProto__Io__Haveno__Protobuffer__ProtectedStorageEntry innerValue )

        Just (Proto.Io.Haveno.Protobuffer.StorageEntryWrapper.Message.ProtectedMailboxStorageEntry innerValue) ->
            ( 2, encodeProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry innerValue )


{-| `Proto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message` options

-}
type alias Proto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message =
    Proto.Io.Haveno.Protobuffer.StorageEntryWrapper.Message.Message Proto__Io__Haveno__Protobuffer__ProtectedStorageEntry Proto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message :
    FieldNumbersProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message
fieldNumbersProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message =
    { accountAgeWitness = 1, signedWitness = 2, tradeStatistics3 = 3 }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
type alias FieldNumbersProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message =
    { accountAgeWitness : Int, signedWitness : Int, tradeStatistics3 : Int }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message :
    (Maybe Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message -> a -> a)
    -> Protobuf.Decode.FieldDecoder a
decodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message =
    Protobuf.Decode.oneOf
        [ ( 1
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableNetworkPayload.Message.AccountAgeWitness
                      decodeProto__Io__Haveno__Protobuffer__AccountAgeWitness
          )
        , ( 2
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableNetworkPayload.Message.SignedWitness
                      decodeProto__Io__Haveno__Protobuffer__SignedWitness
          )
        , ( 3
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableNetworkPayload.Message.TradeStatistics3
                      decodeProto__Io__Haveno__Protobuffer__TradeStatistics3
          )
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message :
    Maybe Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message
    -> ( Int, Protobuf.Encode.Encoder )
encodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message value =
    case value of
        Nothing ->
            ( 0, Protobuf.Encode.none )

        Just (Proto.Io.Haveno.Protobuffer.PersistableNetworkPayload.Message.AccountAgeWitness innerValue) ->
            ( 1, encodeProto__Io__Haveno__Protobuffer__AccountAgeWitness innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableNetworkPayload.Message.SignedWitness innerValue) ->
            ( 2, encodeProto__Io__Haveno__Protobuffer__SignedWitness innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableNetworkPayload.Message.TradeStatistics3 innerValue) ->
            ( 3, encodeProto__Io__Haveno__Protobuffer__TradeStatistics3 innerValue )


{-| `Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message` options

-}
type alias Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message =
    Proto.Io.Haveno.Protobuffer.PersistableNetworkPayload.Message.Message Proto__Io__Haveno__Protobuffer__AccountAgeWitness Proto__Io__Haveno__Protobuffer__SignedWitness Proto__Io__Haveno__Protobuffer__TradeStatistics3


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message :
    FieldNumbersProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message
fieldNumbersProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message =
    { sequenceNumberMap = 1
    , peerList = 2
    , addressEntryList = 3
    , navigationPath = 4
    , tradableList = 5
    , arbitrationDisputeList = 6
    , preferencesPayload = 7
    , userPayload = 8
    , paymentAccountList = 9
    , accountAgeWitnessStore = 10
    , signedWitnessStore = 11
    , mediationDisputeList = 12
    , refundDisputeList = 13
    , tradeStatistics3Store = 14
    , mailboxMessageList = 15
    , ignoredMailboxMap = 16
    , removedPayloadsMap = 17
    , xmrAddressEntryList = 18
    , signedOfferList = 19
    , encryptedConnectionList = 20
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
type alias FieldNumbersProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message =
    { sequenceNumberMap : Int
    , peerList : Int
    , addressEntryList : Int
    , navigationPath : Int
    , tradableList : Int
    , arbitrationDisputeList : Int
    , preferencesPayload : Int
    , userPayload : Int
    , paymentAccountList : Int
    , accountAgeWitnessStore : Int
    , signedWitnessStore : Int
    , mediationDisputeList : Int
    , refundDisputeList : Int
    , tradeStatistics3Store : Int
    , mailboxMessageList : Int
    , ignoredMailboxMap : Int
    , removedPayloadsMap : Int
    , xmrAddressEntryList : Int
    , signedOfferList : Int
    , encryptedConnectionList : Int
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message :
    (Maybe Proto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message -> a -> a)
    -> Protobuf.Decode.FieldDecoder a
decodeProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message =
    Protobuf.Decode.oneOf
        [ ( 1
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.SequenceNumberMap
                      decodeProto__Io__Haveno__Protobuffer__SequenceNumberMap
          )
        , ( 2
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.PeerList
                      decodeProto__Io__Haveno__Protobuffer__PeerList
          )
        , ( 3
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.AddressEntryList
                      decodeProto__Io__Haveno__Protobuffer__AddressEntryList
          )
        , ( 4
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.NavigationPath
                      decodeProto__Io__Haveno__Protobuffer__NavigationPath
          )
        , ( 5
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.TradableList
                      decodeProto__Io__Haveno__Protobuffer__TradableList
          )
        , ( 6
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.ArbitrationDisputeList
                      decodeProto__Io__Haveno__Protobuffer__ArbitrationDisputeList
          )
        , ( 7
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.PreferencesPayload
                      decodeProto__Io__Haveno__Protobuffer__PreferencesPayload
          )
        , ( 8
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.UserPayload
                      decodeProto__Io__Haveno__Protobuffer__UserPayload
          )
        , ( 9
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.PaymentAccountList
                      decodeProto__Io__Haveno__Protobuffer__PaymentAccountList
          )
        , ( 10
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.AccountAgeWitnessStore
                      decodeProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore
          )
        , ( 11
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.SignedWitnessStore
                      decodeProto__Io__Haveno__Protobuffer__SignedWitnessStore
          )
        , ( 12
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.MediationDisputeList
                      decodeProto__Io__Haveno__Protobuffer__MediationDisputeList
          )
        , ( 13
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.RefundDisputeList
                      decodeProto__Io__Haveno__Protobuffer__RefundDisputeList
          )
        , ( 14
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.TradeStatistics3Store
                      decodeProto__Io__Haveno__Protobuffer__TradeStatistics3Store
          )
        , ( 15
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.MailboxMessageList
                      decodeProto__Io__Haveno__Protobuffer__MailboxMessageList
          )
        , ( 16
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.IgnoredMailboxMap
                      decodeProto__Io__Haveno__Protobuffer__IgnoredMailboxMap
          )
        , ( 17
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.RemovedPayloadsMap
                      decodeProto__Io__Haveno__Protobuffer__RemovedPayloadsMap
          )
        , ( 18
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.XmrAddressEntryList
                      decodeProto__Io__Haveno__Protobuffer__XmrAddressEntryList
          )
        , ( 19
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.SignedOfferList
                      decodeProto__Io__Haveno__Protobuffer__SignedOfferList
          )
        , ( 20
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.EncryptedConnectionList
                      decodeProto__Io__Haveno__Protobuffer__EncryptedConnectionList
          )
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message :
    Maybe Proto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message -> ( Int, Protobuf.Encode.Encoder )
encodeProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message value =
    case value of
        Nothing ->
            ( 0, Protobuf.Encode.none )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.SequenceNumberMap innerValue) ->
            ( 1, encodeProto__Io__Haveno__Protobuffer__SequenceNumberMap innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.PeerList innerValue) ->
            ( 2, encodeProto__Io__Haveno__Protobuffer__PeerList innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.AddressEntryList innerValue) ->
            ( 3, encodeProto__Io__Haveno__Protobuffer__AddressEntryList innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.NavigationPath innerValue) ->
            ( 4, encodeProto__Io__Haveno__Protobuffer__NavigationPath innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.TradableList innerValue) ->
            ( 5, encodeProto__Io__Haveno__Protobuffer__TradableList innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.ArbitrationDisputeList innerValue) ->
            ( 6, encodeProto__Io__Haveno__Protobuffer__ArbitrationDisputeList innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.PreferencesPayload innerValue) ->
            ( 7, encodeProto__Io__Haveno__Protobuffer__PreferencesPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.UserPayload innerValue) ->
            ( 8, encodeProto__Io__Haveno__Protobuffer__UserPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.PaymentAccountList innerValue) ->
            ( 9, encodeProto__Io__Haveno__Protobuffer__PaymentAccountList innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.AccountAgeWitnessStore innerValue) ->
            ( 10, encodeProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.SignedWitnessStore innerValue) ->
            ( 11, encodeProto__Io__Haveno__Protobuffer__SignedWitnessStore innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.MediationDisputeList innerValue) ->
            ( 12, encodeProto__Io__Haveno__Protobuffer__MediationDisputeList innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.RefundDisputeList innerValue) ->
            ( 13, encodeProto__Io__Haveno__Protobuffer__RefundDisputeList innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.TradeStatistics3Store innerValue) ->
            ( 14, encodeProto__Io__Haveno__Protobuffer__TradeStatistics3Store innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.MailboxMessageList innerValue) ->
            ( 15, encodeProto__Io__Haveno__Protobuffer__MailboxMessageList innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.IgnoredMailboxMap innerValue) ->
            ( 16, encodeProto__Io__Haveno__Protobuffer__IgnoredMailboxMap innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.RemovedPayloadsMap innerValue) ->
            ( 17, encodeProto__Io__Haveno__Protobuffer__RemovedPayloadsMap innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.XmrAddressEntryList innerValue) ->
            ( 18, encodeProto__Io__Haveno__Protobuffer__XmrAddressEntryList innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.SignedOfferList innerValue) ->
            ( 19, encodeProto__Io__Haveno__Protobuffer__SignedOfferList innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.EncryptedConnectionList innerValue) ->
            ( 20, encodeProto__Io__Haveno__Protobuffer__EncryptedConnectionList innerValue )


{-| `Proto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message` options

-}
type alias Proto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message =
    Proto.Io.Haveno.Protobuffer.PersistableEnvelope.Message.Message Proto__Io__Haveno__Protobuffer__SequenceNumberMap Proto__Io__Haveno__Protobuffer__PeerList Proto__Io__Haveno__Protobuffer__AddressEntryList Proto__Io__Haveno__Protobuffer__NavigationPath Proto__Io__Haveno__Protobuffer__TradableList Proto__Io__Haveno__Protobuffer__ArbitrationDisputeList Proto__Io__Haveno__Protobuffer__PreferencesPayload Proto__Io__Haveno__Protobuffer__UserPayload Proto__Io__Haveno__Protobuffer__PaymentAccountList Proto__Io__Haveno__Protobuffer__AccountAgeWitnessStore Proto__Io__Haveno__Protobuffer__SignedWitnessStore Proto__Io__Haveno__Protobuffer__MediationDisputeList Proto__Io__Haveno__Protobuffer__RefundDisputeList Proto__Io__Haveno__Protobuffer__TradeStatistics3Store Proto__Io__Haveno__Protobuffer__MailboxMessageList Proto__Io__Haveno__Protobuffer__IgnoredMailboxMap Proto__Io__Haveno__Protobuffer__RemovedPayloadsMap Proto__Io__Haveno__Protobuffer__XmrAddressEntryList Proto__Io__Haveno__Protobuffer__SignedOfferList Proto__Io__Haveno__Protobuffer__EncryptedConnectionList


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message :
    FieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message =
    { aliPayAccountPayload = 5
    , chaseQuickPayAccountPayload = 6
    , zelleAccountPayload = 7
    , countryBasedPaymentAccountPayload = 8
    , cryptoCurrencyAccountPayload = 9
    , fasterPaymentsAccountPayload = 10
    , interacETransferAccountPayload = 11
    , oKPayAccountPayload = 12
    , perfectMoneyAccountPayload = 13
    , swishAccountPayload = 14
    , uSPostalMoneyOrderAccountPayload = 15
    , upholdAccountPayload = 16
    , cashAppAccountPayload = 17
    , moneyBeamAccountPayload = 18
    , venmoAccountPayload = 19
    , popmoneyAccountPayload = 20
    , revolutAccountPayload = 21
    , weChatPayAccountPayload = 22
    , moneyGramAccountPayload = 23
    , halCashAccountPayload = 24
    , promptPayAccountPayload = 25
    , advancedCashAccountPayload = 26
    , instantCryptoCurrencyAccountPayload = 27
    , japanBankAccountPayload = 28
    , transferwiseAccountPayload = 29
    , australiaPayidPayload = 30
    , amazonGiftCardAccountPayload = 31
    , payByMailAccountPayload = 32
    , capitualAccountPayload = 33
    , payseraAccountPayload = 34
    , paxumAccountPayload = 35
    , swiftAccountPayload = 36
    , celPayAccountPayload = 37
    , moneseAccountPayload = 38
    , verseAccountPayload = 39
    , cashAtAtmAccountPayload = 40
    , paypalAccountPayload = 41
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
type alias FieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message =
    { aliPayAccountPayload : Int
    , chaseQuickPayAccountPayload : Int
    , zelleAccountPayload : Int
    , countryBasedPaymentAccountPayload : Int
    , cryptoCurrencyAccountPayload : Int
    , fasterPaymentsAccountPayload : Int
    , interacETransferAccountPayload : Int
    , oKPayAccountPayload : Int
    , perfectMoneyAccountPayload : Int
    , swishAccountPayload : Int
    , uSPostalMoneyOrderAccountPayload : Int
    , upholdAccountPayload : Int
    , cashAppAccountPayload : Int
    , moneyBeamAccountPayload : Int
    , venmoAccountPayload : Int
    , popmoneyAccountPayload : Int
    , revolutAccountPayload : Int
    , weChatPayAccountPayload : Int
    , moneyGramAccountPayload : Int
    , halCashAccountPayload : Int
    , promptPayAccountPayload : Int
    , advancedCashAccountPayload : Int
    , instantCryptoCurrencyAccountPayload : Int
    , japanBankAccountPayload : Int
    , transferwiseAccountPayload : Int
    , australiaPayidPayload : Int
    , amazonGiftCardAccountPayload : Int
    , payByMailAccountPayload : Int
    , capitualAccountPayload : Int
    , payseraAccountPayload : Int
    , paxumAccountPayload : Int
    , swiftAccountPayload : Int
    , celPayAccountPayload : Int
    , moneseAccountPayload : Int
    , verseAccountPayload : Int
    , cashAtAtmAccountPayload : Int
    , paypalAccountPayload : Int
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message :
    (Maybe Proto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message -> a -> a)
    -> Protobuf.Decode.FieldDecoder a
decodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message =
    Protobuf.Decode.oneOf
        [ ( 5
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.AliPayAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__AliPayAccountPayload
          )
        , ( 6
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.ChaseQuickPayAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload
          )
        , ( 7
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.ZelleAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__ZelleAccountPayload
          )
        , ( 8
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.CountryBasedPaymentAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload
          )
        , ( 9
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.CryptoCurrencyAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload
          )
        , ( 10
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.FasterPaymentsAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload
          )
        , ( 11
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.InteracETransferAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload
          )
        , ( 12
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.OKPayAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__OKPayAccountPayload
          )
        , ( 13
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.PerfectMoneyAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload
          )
        , ( 14
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.SwishAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__SwishAccountPayload
          )
        , ( 15
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.USPostalMoneyOrderAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload
          )
        , ( 16
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.UpholdAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__UpholdAccountPayload
          )
        , ( 17
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.CashAppAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__CashAppAccountPayload
          )
        , ( 18
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.MoneyBeamAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload
          )
        , ( 19
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.VenmoAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__VenmoAccountPayload
          )
        , ( 20
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.PopmoneyAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload
          )
        , ( 21
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.RevolutAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__RevolutAccountPayload
          )
        , ( 22
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.WeChatPayAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload
          )
        , ( 23
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.MoneyGramAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload
          )
        , ( 24
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.HalCashAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__HalCashAccountPayload
          )
        , ( 25
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.PromptPayAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__PromptPayAccountPayload
          )
        , ( 26
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.AdvancedCashAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload
          )
        , ( 27
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.InstantCryptoCurrencyAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload
          )
        , ( 28
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.JapanBankAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__JapanBankAccountPayload
          )
        , ( 29
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.TransferwiseAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload
          )
        , ( 30
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.AustraliaPayidPayload
                      decodeProto__Io__Haveno__Protobuffer__AustraliaPayidPayload
          )
        , ( 31
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.AmazonGiftCardAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload
          )
        , ( 32
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.PayByMailAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__PayByMailAccountPayload
          )
        , ( 33
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.CapitualAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__CapitualAccountPayload
          )
        , ( 34
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.PayseraAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__PayseraAccountPayload
          )
        , ( 35
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.PaxumAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__PaxumAccountPayload
          )
        , ( 36
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.SwiftAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__SwiftAccountPayload
          )
        , ( 37
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.CelPayAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__CelPayAccountPayload
          )
        , ( 38
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.MoneseAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__MoneseAccountPayload
          )
        , ( 39
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.VerseAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__VerseAccountPayload
          )
        , ( 40
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.CashAtAtmAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload
          )
        , ( 41
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.PaypalAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__PayPalAccountPayload
          )
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message :
    Maybe Proto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message -> ( Int, Protobuf.Encode.Encoder )
encodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message value =
    case value of
        Nothing ->
            ( 0, Protobuf.Encode.none )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.AliPayAccountPayload innerValue) ->
            ( 5, encodeProto__Io__Haveno__Protobuffer__AliPayAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.ChaseQuickPayAccountPayload innerValue) ->
            ( 6, encodeProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.ZelleAccountPayload innerValue) ->
            ( 7, encodeProto__Io__Haveno__Protobuffer__ZelleAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.CountryBasedPaymentAccountPayload innerValue) ->
            ( 8, encodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.CryptoCurrencyAccountPayload innerValue) ->
            ( 9, encodeProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.FasterPaymentsAccountPayload innerValue) ->
            ( 10, encodeProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.InteracETransferAccountPayload innerValue) ->
            ( 11, encodeProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.OKPayAccountPayload innerValue) ->
            ( 12, encodeProto__Io__Haveno__Protobuffer__OKPayAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.PerfectMoneyAccountPayload innerValue) ->
            ( 13, encodeProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.SwishAccountPayload innerValue) ->
            ( 14, encodeProto__Io__Haveno__Protobuffer__SwishAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.USPostalMoneyOrderAccountPayload innerValue) ->
            ( 15, encodeProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.UpholdAccountPayload innerValue) ->
            ( 16, encodeProto__Io__Haveno__Protobuffer__UpholdAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.CashAppAccountPayload innerValue) ->
            ( 17, encodeProto__Io__Haveno__Protobuffer__CashAppAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.MoneyBeamAccountPayload innerValue) ->
            ( 18, encodeProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.VenmoAccountPayload innerValue) ->
            ( 19, encodeProto__Io__Haveno__Protobuffer__VenmoAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.PopmoneyAccountPayload innerValue) ->
            ( 20, encodeProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.RevolutAccountPayload innerValue) ->
            ( 21, encodeProto__Io__Haveno__Protobuffer__RevolutAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.WeChatPayAccountPayload innerValue) ->
            ( 22, encodeProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.MoneyGramAccountPayload innerValue) ->
            ( 23, encodeProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.HalCashAccountPayload innerValue) ->
            ( 24, encodeProto__Io__Haveno__Protobuffer__HalCashAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.PromptPayAccountPayload innerValue) ->
            ( 25, encodeProto__Io__Haveno__Protobuffer__PromptPayAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.AdvancedCashAccountPayload innerValue) ->
            ( 26, encodeProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.InstantCryptoCurrencyAccountPayload innerValue) ->
            ( 27, encodeProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.JapanBankAccountPayload innerValue) ->
            ( 28, encodeProto__Io__Haveno__Protobuffer__JapanBankAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.TransferwiseAccountPayload innerValue) ->
            ( 29, encodeProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.AustraliaPayidPayload innerValue) ->
            ( 30, encodeProto__Io__Haveno__Protobuffer__AustraliaPayidPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.AmazonGiftCardAccountPayload innerValue) ->
            ( 31, encodeProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.PayByMailAccountPayload innerValue) ->
            ( 32, encodeProto__Io__Haveno__Protobuffer__PayByMailAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.CapitualAccountPayload innerValue) ->
            ( 33, encodeProto__Io__Haveno__Protobuffer__CapitualAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.PayseraAccountPayload innerValue) ->
            ( 34, encodeProto__Io__Haveno__Protobuffer__PayseraAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.PaxumAccountPayload innerValue) ->
            ( 35, encodeProto__Io__Haveno__Protobuffer__PaxumAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.SwiftAccountPayload innerValue) ->
            ( 36, encodeProto__Io__Haveno__Protobuffer__SwiftAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.CelPayAccountPayload innerValue) ->
            ( 37, encodeProto__Io__Haveno__Protobuffer__CelPayAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.MoneseAccountPayload innerValue) ->
            ( 38, encodeProto__Io__Haveno__Protobuffer__MoneseAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.VerseAccountPayload innerValue) ->
            ( 39, encodeProto__Io__Haveno__Protobuffer__VerseAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.CashAtAtmAccountPayload innerValue) ->
            ( 40, encodeProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.PaypalAccountPayload innerValue) ->
            ( 41, encodeProto__Io__Haveno__Protobuffer__PayPalAccountPayload innerValue )


{-| `Proto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message` options

-}
type alias Proto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message =
    Proto.Io.Haveno.Protobuffer.PaymentAccountPayload.Message.Message Proto__Io__Haveno__Protobuffer__AliPayAccountPayload Proto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload Proto__Io__Haveno__Protobuffer__ZelleAccountPayload Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload Proto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload Proto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload Proto__Io__Haveno__Protobuffer__InteracETransferAccountPayload Proto__Io__Haveno__Protobuffer__OKPayAccountPayload Proto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload Proto__Io__Haveno__Protobuffer__SwishAccountPayload Proto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload Proto__Io__Haveno__Protobuffer__UpholdAccountPayload Proto__Io__Haveno__Protobuffer__CashAppAccountPayload Proto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload Proto__Io__Haveno__Protobuffer__VenmoAccountPayload Proto__Io__Haveno__Protobuffer__PopmoneyAccountPayload Proto__Io__Haveno__Protobuffer__RevolutAccountPayload Proto__Io__Haveno__Protobuffer__WeChatPayAccountPayload Proto__Io__Haveno__Protobuffer__MoneyGramAccountPayload Proto__Io__Haveno__Protobuffer__HalCashAccountPayload Proto__Io__Haveno__Protobuffer__PromptPayAccountPayload Proto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload Proto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload Proto__Io__Haveno__Protobuffer__JapanBankAccountPayload Proto__Io__Haveno__Protobuffer__TransferwiseAccountPayload Proto__Io__Haveno__Protobuffer__AustraliaPayidPayload Proto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload Proto__Io__Haveno__Protobuffer__PayByMailAccountPayload Proto__Io__Haveno__Protobuffer__CapitualAccountPayload Proto__Io__Haveno__Protobuffer__PayseraAccountPayload Proto__Io__Haveno__Protobuffer__PaxumAccountPayload Proto__Io__Haveno__Protobuffer__SwiftAccountPayload Proto__Io__Haveno__Protobuffer__CelPayAccountPayload Proto__Io__Haveno__Protobuffer__MoneseAccountPayload Proto__Io__Haveno__Protobuffer__VerseAccountPayload Proto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload Proto__Io__Haveno__Protobuffer__PayPalAccountPayload


{-| Unwrap a `BundleOfEnvelopes` from its wrapper `BundleOfEnvelopes_.`

-}
unwrapProto__Io__Haveno__Protobuffer__BundleOfEnvelopes :
    Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes_ -> Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes
unwrapProto__Io__Haveno__Protobuffer__BundleOfEnvelopes (Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes_ wrapped) =
    wrapped


{-| Type wrapper for alias type `BundleOfEnvelopes` to avoid unlimited recursion.

For a more in-depth explanation why we need this, read this: https://github.com/elm/compiler/blob/master/hints/recursive-alias.md.

-}
type Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes_
    = Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes_ Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message :
    FieldNumbersProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message
fieldNumbersProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message =
    { preliminaryGetDataRequest = 2
    , getDataResponse = 3
    , getUpdatedDataRequest = 4
    , getPeersRequest = 5
    , getPeersResponse = 6
    , ping = 7
    , pong = 8
    , offerAvailabilityRequest = 9
    , offerAvailabilityResponse = 10
    , refreshOfferMessage = 11
    , addDataMessage = 12
    , removeDataMessage = 13
    , removeMailboxDataMessage = 14
    , closeConnectionMessage = 15
    , prefixedSealedAndSignedMessage = 16
    , privateNotificationMessage = 17
    , addPersistableNetworkPayloadMessage = 18
    , ackMessage = 19
    , bundleOfEnvelopes = 20
    , getInventoryRequest = 21
    , getInventoryResponse = 22
    , signOfferRequest = 23
    , signOfferResponse = 24
    , initTradeRequest = 25
    , initMultisigRequest = 26
    , signContractRequest = 27
    , signContractResponse = 28
    , depositRequest = 29
    , depositResponse = 30
    , depositsConfirmedMessage = 31
    , paymentSentMessage = 32
    , paymentReceivedMessage = 33
    , disputeOpenedMessage = 34
    , disputeClosedMessage = 35
    , chatMessage = 36
    , mediatedPayoutTxSignatureMessage = 37
    , mediatedPayoutTxPublishedMessage = 38
    , fileTransferPart = 39
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
type alias FieldNumbersProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message =
    { preliminaryGetDataRequest : Int
    , getDataResponse : Int
    , getUpdatedDataRequest : Int
    , getPeersRequest : Int
    , getPeersResponse : Int
    , ping : Int
    , pong : Int
    , offerAvailabilityRequest : Int
    , offerAvailabilityResponse : Int
    , refreshOfferMessage : Int
    , addDataMessage : Int
    , removeDataMessage : Int
    , removeMailboxDataMessage : Int
    , closeConnectionMessage : Int
    , prefixedSealedAndSignedMessage : Int
    , privateNotificationMessage : Int
    , addPersistableNetworkPayloadMessage : Int
    , ackMessage : Int
    , bundleOfEnvelopes : Int
    , getInventoryRequest : Int
    , getInventoryResponse : Int
    , signOfferRequest : Int
    , signOfferResponse : Int
    , initTradeRequest : Int
    , initMultisigRequest : Int
    , signContractRequest : Int
    , signContractResponse : Int
    , depositRequest : Int
    , depositResponse : Int
    , depositsConfirmedMessage : Int
    , paymentSentMessage : Int
    , paymentReceivedMessage : Int
    , disputeOpenedMessage : Int
    , disputeClosedMessage : Int
    , chatMessage : Int
    , mediatedPayoutTxSignatureMessage : Int
    , mediatedPayoutTxPublishedMessage : Int
    , fileTransferPart : Int
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message :
    (Maybe Proto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message -> a -> a)
    -> Protobuf.Decode.FieldDecoder a
decodeProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message =
    Protobuf.Decode.oneOf
        [ ( 2
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.PreliminaryGetDataRequest
                      decodeProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest
          )
        , ( 3
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.GetDataResponse
                      decodeProto__Io__Haveno__Protobuffer__GetDataResponse
          )
        , ( 4
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.GetUpdatedDataRequest
                      decodeProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest
          )
        , ( 5
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.GetPeersRequest
                      decodeProto__Io__Haveno__Protobuffer__GetPeersRequest
          )
        , ( 6
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.GetPeersResponse
                      decodeProto__Io__Haveno__Protobuffer__GetPeersResponse
          )
        , ( 7
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.Ping
                      decodeProto__Io__Haveno__Protobuffer__Ping
          )
        , ( 8
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.Pong
                      decodeProto__Io__Haveno__Protobuffer__Pong
          )
        , ( 9
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.OfferAvailabilityRequest
                      decodeProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest
          )
        , ( 10
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.OfferAvailabilityResponse
                      decodeProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse
          )
        , ( 11
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.RefreshOfferMessage
                      decodeProto__Io__Haveno__Protobuffer__RefreshOfferMessage
          )
        , ( 12
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.AddDataMessage
                      decodeProto__Io__Haveno__Protobuffer__AddDataMessage
          )
        , ( 13
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.RemoveDataMessage
                      decodeProto__Io__Haveno__Protobuffer__RemoveDataMessage
          )
        , ( 14
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.RemoveMailboxDataMessage
                      decodeProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage
          )
        , ( 15
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.CloseConnectionMessage
                      decodeProto__Io__Haveno__Protobuffer__CloseConnectionMessage
          )
        , ( 16
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.PrefixedSealedAndSignedMessage
                      decodeProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage
          )
        , ( 17
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.PrivateNotificationMessage
                      decodeProto__Io__Haveno__Protobuffer__PrivateNotificationMessage
          )
        , ( 18
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.AddPersistableNetworkPayloadMessage
                      decodeProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage
          )
        , ( 19
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.AckMessage
                      decodeProto__Io__Haveno__Protobuffer__AckMessage
          )
        , ( 20
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.BundleOfEnvelopes
                      (Protobuf.Decode.map Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes_ <|
                           Protobuf.Decode.lazy <| \_ -> decodeProto__Io__Haveno__Protobuffer__BundleOfEnvelopes
                      )
          )
        , ( 21
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.GetInventoryRequest
                      decodeProto__Io__Haveno__Protobuffer__GetInventoryRequest
          )
        , ( 22
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.GetInventoryResponse
                      decodeProto__Io__Haveno__Protobuffer__GetInventoryResponse
          )
        , ( 23
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.SignOfferRequest
                      decodeProto__Io__Haveno__Protobuffer__SignOfferRequest
          )
        , ( 24
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.SignOfferResponse
                      decodeProto__Io__Haveno__Protobuffer__SignOfferResponse
          )
        , ( 25
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.InitTradeRequest
                      decodeProto__Io__Haveno__Protobuffer__InitTradeRequest
          )
        , ( 26
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.InitMultisigRequest
                      decodeProto__Io__Haveno__Protobuffer__InitMultisigRequest
          )
        , ( 27
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.SignContractRequest
                      decodeProto__Io__Haveno__Protobuffer__SignContractRequest
          )
        , ( 28
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.SignContractResponse
                      decodeProto__Io__Haveno__Protobuffer__SignContractResponse
          )
        , ( 29
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.DepositRequest
                      decodeProto__Io__Haveno__Protobuffer__DepositRequest
          )
        , ( 30
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.DepositResponse
                      decodeProto__Io__Haveno__Protobuffer__DepositResponse
          )
        , ( 31
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.DepositsConfirmedMessage
                      decodeProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage
          )
        , ( 32
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.PaymentSentMessage
                      decodeProto__Io__Haveno__Protobuffer__PaymentSentMessage
          )
        , ( 33
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.PaymentReceivedMessage
                      decodeProto__Io__Haveno__Protobuffer__PaymentReceivedMessage
          )
        , ( 34
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.DisputeOpenedMessage
                      decodeProto__Io__Haveno__Protobuffer__DisputeOpenedMessage
          )
        , ( 35
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.DisputeClosedMessage
                      decodeProto__Io__Haveno__Protobuffer__DisputeClosedMessage
          )
        , ( 36
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.ChatMessage
                      decodeProto__Io__Haveno__Protobuffer__ChatMessage
          )
        , ( 37
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.MediatedPayoutTxSignatureMessage
                      decodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage
          )
        , ( 38
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.MediatedPayoutTxPublishedMessage
                      decodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage
          )
        , ( 39
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.FileTransferPart
                      decodeProto__Io__Haveno__Protobuffer__FileTransferPart
          )
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message :
    Maybe Proto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message -> ( Int, Protobuf.Encode.Encoder )
encodeProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message value =
    case value of
        Nothing ->
            ( 0, Protobuf.Encode.none )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.PreliminaryGetDataRequest innerValue) ->
            ( 2, encodeProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.GetDataResponse innerValue) ->
            ( 3, encodeProto__Io__Haveno__Protobuffer__GetDataResponse innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.GetUpdatedDataRequest innerValue) ->
            ( 4, encodeProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.GetPeersRequest innerValue) ->
            ( 5, encodeProto__Io__Haveno__Protobuffer__GetPeersRequest innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.GetPeersResponse innerValue) ->
            ( 6, encodeProto__Io__Haveno__Protobuffer__GetPeersResponse innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.Ping innerValue) ->
            ( 7, encodeProto__Io__Haveno__Protobuffer__Ping innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.Pong innerValue) ->
            ( 8, encodeProto__Io__Haveno__Protobuffer__Pong innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.OfferAvailabilityRequest innerValue) ->
            ( 9, encodeProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.OfferAvailabilityResponse innerValue) ->
            ( 10, encodeProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.RefreshOfferMessage innerValue) ->
            ( 11, encodeProto__Io__Haveno__Protobuffer__RefreshOfferMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.AddDataMessage innerValue) ->
            ( 12, encodeProto__Io__Haveno__Protobuffer__AddDataMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.RemoveDataMessage innerValue) ->
            ( 13, encodeProto__Io__Haveno__Protobuffer__RemoveDataMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.RemoveMailboxDataMessage innerValue) ->
            ( 14, encodeProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.CloseConnectionMessage innerValue) ->
            ( 15, encodeProto__Io__Haveno__Protobuffer__CloseConnectionMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.PrefixedSealedAndSignedMessage innerValue) ->
            ( 16, encodeProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.PrivateNotificationMessage innerValue) ->
            ( 17, encodeProto__Io__Haveno__Protobuffer__PrivateNotificationMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.AddPersistableNetworkPayloadMessage innerValue) ->
            ( 18, encodeProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.AckMessage innerValue) ->
            ( 19, encodeProto__Io__Haveno__Protobuffer__AckMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.BundleOfEnvelopes innerValue) ->
            ( 20
            , (unwrapProto__Io__Haveno__Protobuffer__BundleOfEnvelopes
                  >> encodeProto__Io__Haveno__Protobuffer__BundleOfEnvelopes
              )
                innerValue
            )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.GetInventoryRequest innerValue) ->
            ( 21, encodeProto__Io__Haveno__Protobuffer__GetInventoryRequest innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.GetInventoryResponse innerValue) ->
            ( 22, encodeProto__Io__Haveno__Protobuffer__GetInventoryResponse innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.SignOfferRequest innerValue) ->
            ( 23, encodeProto__Io__Haveno__Protobuffer__SignOfferRequest innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.SignOfferResponse innerValue) ->
            ( 24, encodeProto__Io__Haveno__Protobuffer__SignOfferResponse innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.InitTradeRequest innerValue) ->
            ( 25, encodeProto__Io__Haveno__Protobuffer__InitTradeRequest innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.InitMultisigRequest innerValue) ->
            ( 26, encodeProto__Io__Haveno__Protobuffer__InitMultisigRequest innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.SignContractRequest innerValue) ->
            ( 27, encodeProto__Io__Haveno__Protobuffer__SignContractRequest innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.SignContractResponse innerValue) ->
            ( 28, encodeProto__Io__Haveno__Protobuffer__SignContractResponse innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.DepositRequest innerValue) ->
            ( 29, encodeProto__Io__Haveno__Protobuffer__DepositRequest innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.DepositResponse innerValue) ->
            ( 30, encodeProto__Io__Haveno__Protobuffer__DepositResponse innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.DepositsConfirmedMessage innerValue) ->
            ( 31, encodeProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.PaymentSentMessage innerValue) ->
            ( 32, encodeProto__Io__Haveno__Protobuffer__PaymentSentMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.PaymentReceivedMessage innerValue) ->
            ( 33, encodeProto__Io__Haveno__Protobuffer__PaymentReceivedMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.DisputeOpenedMessage innerValue) ->
            ( 34, encodeProto__Io__Haveno__Protobuffer__DisputeOpenedMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.DisputeClosedMessage innerValue) ->
            ( 35, encodeProto__Io__Haveno__Protobuffer__DisputeClosedMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.ChatMessage innerValue) ->
            ( 36, encodeProto__Io__Haveno__Protobuffer__ChatMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.MediatedPayoutTxSignatureMessage innerValue) ->
            ( 37, encodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.MediatedPayoutTxPublishedMessage innerValue) ->
            ( 38, encodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage innerValue )

        Just (Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.FileTransferPart innerValue) ->
            ( 39, encodeProto__Io__Haveno__Protobuffer__FileTransferPart innerValue )


{-| `Proto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message` options

-}
type alias Proto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message =
    Proto.Io.Haveno.Protobuffer.NetworkEnvelope.Message.Message Proto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest Proto__Io__Haveno__Protobuffer__GetDataResponse Proto__Io__Haveno__Protobuffer__GetUpdatedDataRequest Proto__Io__Haveno__Protobuffer__GetPeersRequest Proto__Io__Haveno__Protobuffer__GetPeersResponse Proto__Io__Haveno__Protobuffer__Ping Proto__Io__Haveno__Protobuffer__Pong Proto__Io__Haveno__Protobuffer__OfferAvailabilityRequest Proto__Io__Haveno__Protobuffer__OfferAvailabilityResponse Proto__Io__Haveno__Protobuffer__RefreshOfferMessage Proto__Io__Haveno__Protobuffer__AddDataMessage Proto__Io__Haveno__Protobuffer__RemoveDataMessage Proto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage Proto__Io__Haveno__Protobuffer__CloseConnectionMessage Proto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage Proto__Io__Haveno__Protobuffer__PrivateNotificationMessage Proto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage Proto__Io__Haveno__Protobuffer__AckMessage Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes_ Proto__Io__Haveno__Protobuffer__GetInventoryRequest Proto__Io__Haveno__Protobuffer__GetInventoryResponse Proto__Io__Haveno__Protobuffer__SignOfferRequest Proto__Io__Haveno__Protobuffer__SignOfferResponse Proto__Io__Haveno__Protobuffer__InitTradeRequest Proto__Io__Haveno__Protobuffer__InitMultisigRequest Proto__Io__Haveno__Protobuffer__SignContractRequest Proto__Io__Haveno__Protobuffer__SignContractResponse Proto__Io__Haveno__Protobuffer__DepositRequest Proto__Io__Haveno__Protobuffer__DepositResponse Proto__Io__Haveno__Protobuffer__DepositsConfirmedMessage Proto__Io__Haveno__Protobuffer__PaymentSentMessage Proto__Io__Haveno__Protobuffer__PaymentReceivedMessage Proto__Io__Haveno__Protobuffer__DisputeOpenedMessage Proto__Io__Haveno__Protobuffer__DisputeClosedMessage Proto__Io__Haveno__Protobuffer__ChatMessage Proto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage Proto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage Proto__Io__Haveno__Protobuffer__FileTransferPart


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message :
    FieldNumbersProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message
fieldNumbersProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message =
    { neftAccountPayload = 4, rtgsAccountPayload = 5, impsAccountPayload = 6 }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
type alias FieldNumbersProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message =
    { neftAccountPayload : Int, rtgsAccountPayload : Int, impsAccountPayload : Int }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message :
    (Maybe Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message -> a -> a)
    -> Protobuf.Decode.FieldDecoder a
decodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message =
    Protobuf.Decode.oneOf
        [ ( 4
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.IfscBasedAccountPayload.Message.NeftAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__NeftAccountPayload
          )
        , ( 5
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.IfscBasedAccountPayload.Message.RtgsAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__RtgsAccountPayload
          )
        , ( 6
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.IfscBasedAccountPayload.Message.ImpsAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__ImpsAccountPayload
          )
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message :
    Maybe Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message -> ( Int, Protobuf.Encode.Encoder )
encodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message value =
    case value of
        Nothing ->
            ( 0, Protobuf.Encode.none )

        Just (Proto.Io.Haveno.Protobuffer.IfscBasedAccountPayload.Message.NeftAccountPayload innerValue) ->
            ( 4, encodeProto__Io__Haveno__Protobuffer__NeftAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.IfscBasedAccountPayload.Message.RtgsAccountPayload innerValue) ->
            ( 5, encodeProto__Io__Haveno__Protobuffer__RtgsAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.IfscBasedAccountPayload.Message.ImpsAccountPayload innerValue) ->
            ( 6, encodeProto__Io__Haveno__Protobuffer__ImpsAccountPayload innerValue )


{-| `Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message` options

-}
type alias Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message =
    Proto.Io.Haveno.Protobuffer.IfscBasedAccountPayload.Message.Message Proto__Io__Haveno__Protobuffer__NeftAccountPayload Proto__Io__Haveno__Protobuffer__RtgsAccountPayload Proto__Io__Haveno__Protobuffer__ImpsAccountPayload


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message :
    FieldNumbersProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message
fieldNumbersProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message =
    { bankAccountPayload = 3
    , cashDepositAccountPayload = 4
    , sepaAccountPayload = 5
    , westernUnionAccountPayload = 6
    , sepaInstantAccountPayload = 7
    , f2fAccountPayload = 8
    , upiAccountPayload = 9
    , paytmAccountPayload = 10
    , ifscBasedAccountPayload = 11
    , nequiAccountPayload = 12
    , bizumAccountPayload = 13
    , pixAccountPayload = 14
    , satispayAccountPayload = 15
    , strikeAccountPayload = 16
    , tikkieAccountPayload = 17
    , transferwiseUsdAccountPayload = 18
    , swiftAccountPayload = 19
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
type alias FieldNumbersProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message =
    { bankAccountPayload : Int
    , cashDepositAccountPayload : Int
    , sepaAccountPayload : Int
    , westernUnionAccountPayload : Int
    , sepaInstantAccountPayload : Int
    , f2fAccountPayload : Int
    , upiAccountPayload : Int
    , paytmAccountPayload : Int
    , ifscBasedAccountPayload : Int
    , nequiAccountPayload : Int
    , bizumAccountPayload : Int
    , pixAccountPayload : Int
    , satispayAccountPayload : Int
    , strikeAccountPayload : Int
    , tikkieAccountPayload : Int
    , transferwiseUsdAccountPayload : Int
    , swiftAccountPayload : Int
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message :
    (Maybe Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message -> a -> a)
    -> Protobuf.Decode.FieldDecoder a
decodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message =
    Protobuf.Decode.oneOf
        [ ( 3
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.BankAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__BankAccountPayload
          )
        , ( 4
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.CashDepositAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__CashDepositAccountPayload
          )
        , ( 5
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.SepaAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__SepaAccountPayload
          )
        , ( 6
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.WesternUnionAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload
          )
        , ( 7
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.SepaInstantAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload
          )
        , ( 8
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.F2fAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__F2FAccountPayload
          )
        , ( 9
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.UpiAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__UpiAccountPayload
          )
        , ( 10
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.PaytmAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__PaytmAccountPayload
          )
        , ( 11
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.IfscBasedAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload
          )
        , ( 12
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.NequiAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__NequiAccountPayload
          )
        , ( 13
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.BizumAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__BizumAccountPayload
          )
        , ( 14
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.PixAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__PixAccountPayload
          )
        , ( 15
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.SatispayAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__SatispayAccountPayload
          )
        , ( 16
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.StrikeAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__StrikeAccountPayload
          )
        , ( 17
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.TikkieAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__TikkieAccountPayload
          )
        , ( 18
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.TransferwiseUsdAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload
          )
        , ( 19
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.SwiftAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__SwiftAccountPayload
          )
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message :
    Maybe Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message
    -> ( Int, Protobuf.Encode.Encoder )
encodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message value =
    case value of
        Nothing ->
            ( 0, Protobuf.Encode.none )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.BankAccountPayload innerValue) ->
            ( 3, encodeProto__Io__Haveno__Protobuffer__BankAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.CashDepositAccountPayload innerValue) ->
            ( 4, encodeProto__Io__Haveno__Protobuffer__CashDepositAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.SepaAccountPayload innerValue) ->
            ( 5, encodeProto__Io__Haveno__Protobuffer__SepaAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.WesternUnionAccountPayload innerValue) ->
            ( 6, encodeProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.SepaInstantAccountPayload innerValue) ->
            ( 7, encodeProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.F2fAccountPayload innerValue) ->
            ( 8, encodeProto__Io__Haveno__Protobuffer__F2FAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.UpiAccountPayload innerValue) ->
            ( 9, encodeProto__Io__Haveno__Protobuffer__UpiAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.PaytmAccountPayload innerValue) ->
            ( 10, encodeProto__Io__Haveno__Protobuffer__PaytmAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.IfscBasedAccountPayload innerValue) ->
            ( 11, encodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.NequiAccountPayload innerValue) ->
            ( 12, encodeProto__Io__Haveno__Protobuffer__NequiAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.BizumAccountPayload innerValue) ->
            ( 13, encodeProto__Io__Haveno__Protobuffer__BizumAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.PixAccountPayload innerValue) ->
            ( 14, encodeProto__Io__Haveno__Protobuffer__PixAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.SatispayAccountPayload innerValue) ->
            ( 15, encodeProto__Io__Haveno__Protobuffer__SatispayAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.StrikeAccountPayload innerValue) ->
            ( 16, encodeProto__Io__Haveno__Protobuffer__StrikeAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.TikkieAccountPayload innerValue) ->
            ( 17, encodeProto__Io__Haveno__Protobuffer__TikkieAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.TransferwiseUsdAccountPayload innerValue) ->
            ( 18, encodeProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.SwiftAccountPayload innerValue) ->
            ( 19, encodeProto__Io__Haveno__Protobuffer__SwiftAccountPayload innerValue )


{-| `Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message` options

-}
type alias Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message =
    Proto.Io.Haveno.Protobuffer.CountryBasedPaymentAccountPayload.Message.Message Proto__Io__Haveno__Protobuffer__BankAccountPayload Proto__Io__Haveno__Protobuffer__CashDepositAccountPayload Proto__Io__Haveno__Protobuffer__SepaAccountPayload Proto__Io__Haveno__Protobuffer__WesternUnionAccountPayload Proto__Io__Haveno__Protobuffer__SepaInstantAccountPayload Proto__Io__Haveno__Protobuffer__F2FAccountPayload Proto__Io__Haveno__Protobuffer__UpiAccountPayload Proto__Io__Haveno__Protobuffer__PaytmAccountPayload Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload Proto__Io__Haveno__Protobuffer__NequiAccountPayload Proto__Io__Haveno__Protobuffer__BizumAccountPayload Proto__Io__Haveno__Protobuffer__PixAccountPayload Proto__Io__Haveno__Protobuffer__SatispayAccountPayload Proto__Io__Haveno__Protobuffer__StrikeAccountPayload Proto__Io__Haveno__Protobuffer__TikkieAccountPayload Proto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload Proto__Io__Haveno__Protobuffer__SwiftAccountPayload


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message :
    FieldNumbersProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message
fieldNumbersProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message =
    { nationalBankAccountPayload = 9
    , sameBankAccontPayload = 10
    , specificBanksAccountPayload = 11
    , achTransferAccountPayload = 13
    , domesticWireTransferAccountPayload = 14
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message`. This is mostly useful for internals, like documentation generation.

-}
type alias FieldNumbersProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message =
    { nationalBankAccountPayload : Int
    , sameBankAccontPayload : Int
    , specificBanksAccountPayload : Int
    , achTransferAccountPayload : Int
    , domesticWireTransferAccountPayload : Int
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message :
    (Maybe Proto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message -> a -> a)
    -> Protobuf.Decode.FieldDecoder a
decodeProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message =
    Protobuf.Decode.oneOf
        [ ( 9
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.BankAccountPayload.Message.NationalBankAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__NationalBankAccountPayload
          )
        , ( 10
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.BankAccountPayload.Message.SameBankAccontPayload
                      decodeProto__Io__Haveno__Protobuffer__SameBankAccountPayload
          )
        , ( 11
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.BankAccountPayload.Message.SpecificBanksAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload
          )
        , ( 13
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.BankAccountPayload.Message.AchTransferAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__AchTransferAccountPayload
          )
        , ( 14
          , Protobuf.Decode.lazy <|
              \_ ->
                  Protobuf.Decode.map
                      Proto.Io.Haveno.Protobuffer.BankAccountPayload.Message.DomesticWireTransferAccountPayload
                      decodeProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload
          )
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message :
    Maybe Proto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message -> ( Int, Protobuf.Encode.Encoder )
encodeProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message value =
    case value of
        Nothing ->
            ( 0, Protobuf.Encode.none )

        Just (Proto.Io.Haveno.Protobuffer.BankAccountPayload.Message.NationalBankAccountPayload innerValue) ->
            ( 9, encodeProto__Io__Haveno__Protobuffer__NationalBankAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.BankAccountPayload.Message.SameBankAccontPayload innerValue) ->
            ( 10, encodeProto__Io__Haveno__Protobuffer__SameBankAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.BankAccountPayload.Message.SpecificBanksAccountPayload innerValue) ->
            ( 11, encodeProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.BankAccountPayload.Message.AchTransferAccountPayload innerValue) ->
            ( 13, encodeProto__Io__Haveno__Protobuffer__AchTransferAccountPayload innerValue )

        Just (Proto.Io.Haveno.Protobuffer.BankAccountPayload.Message.DomesticWireTransferAccountPayload innerValue) ->
            ( 14, encodeProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload innerValue )


{-| `Proto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message` options

-}
type alias Proto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message =
    Proto.Io.Haveno.Protobuffer.BankAccountPayload.Message.Message Proto__Io__Haveno__Protobuffer__NationalBankAccountPayload Proto__Io__Haveno__Protobuffer__SameBankAccountPayload Proto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload Proto__Io__Haveno__Protobuffer__AchTransferAccountPayload Proto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AddressBalanceInfo`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AddressBalanceInfo :
    { address : Int, balance : Int, numConfirmations : Int, isAddressUnused : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__AddressBalanceInfo =
    { address = 1, balance = 2, numConfirmations = 3, isAddressUnused = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__AddressBalanceInfo. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AddressBalanceInfo : Proto__Io__Haveno__Protobuffer__AddressBalanceInfo
defaultProto__Io__Haveno__Protobuffer__AddressBalanceInfo =
    { address = ""
    , balance = Protobuf.Types.Int64.fromInts 0 0
    , numConfirmations = Protobuf.Types.Int64.fromInts 0 0
    , isAddressUnused = False
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AddressBalanceInfo` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AddressBalanceInfo :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AddressBalanceInfo
decodeProto__Io__Haveno__Protobuffer__AddressBalanceInfo =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AddressBalanceInfo
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | address = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int64 (\a r -> { r | balance = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | numConfirmations = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.bool (\a r -> { r | isAddressUnused = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AddressBalanceInfo` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AddressBalanceInfo :
    Proto__Io__Haveno__Protobuffer__AddressBalanceInfo -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AddressBalanceInfo value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.address )
        , ( 2, Protobuf.Encode.int64 value.balance )
        , ( 3, Protobuf.Encode.int64 value.numConfirmations )
        , ( 4, Protobuf.Encode.bool value.isAddressUnused )
        ]


{-| `Proto__Io__Haveno__Protobuffer__AddressBalanceInfo` message

-}
type alias Proto__Io__Haveno__Protobuffer__AddressBalanceInfo =
    { address : String
    , balance : Protobuf.Types.Int64.Int64
    , numConfirmations : Protobuf.Types.Int64.Int64
    , isAddressUnused : Bool
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__XmrBalanceInfo`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__XmrBalanceInfo :
    { balance : Int
    , availableBalance : Int
    , pendingBalance : Int
    , reservedOfferBalance : Int
    , reservedTradeBalance : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__XmrBalanceInfo =
    { balance = 1, availableBalance = 2, pendingBalance = 3, reservedOfferBalance = 4, reservedTradeBalance = 5 }


{-| Default for Proto__Io__Haveno__Protobuffer__XmrBalanceInfo. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__XmrBalanceInfo : Proto__Io__Haveno__Protobuffer__XmrBalanceInfo
defaultProto__Io__Haveno__Protobuffer__XmrBalanceInfo =
    { balance = Protobuf.Types.Int64.fromInts 0 0
    , availableBalance = Protobuf.Types.Int64.fromInts 0 0
    , pendingBalance = Protobuf.Types.Int64.fromInts 0 0
    , reservedOfferBalance = Protobuf.Types.Int64.fromInts 0 0
    , reservedTradeBalance = Protobuf.Types.Int64.fromInts 0 0
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__XmrBalanceInfo` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__XmrBalanceInfo :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__XmrBalanceInfo
decodeProto__Io__Haveno__Protobuffer__XmrBalanceInfo =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__XmrBalanceInfo
        [ Protobuf.Decode.optional 1 Protobuf.Decode.uint64 (\a r -> { r | balance = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.uint64 (\a r -> { r | availableBalance = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.uint64 (\a r -> { r | pendingBalance = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.uint64 (\a r -> { r | reservedOfferBalance = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.uint64 (\a r -> { r | reservedTradeBalance = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__XmrBalanceInfo` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__XmrBalanceInfo :
    Proto__Io__Haveno__Protobuffer__XmrBalanceInfo -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__XmrBalanceInfo value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.uint64 value.balance )
        , ( 2, Protobuf.Encode.uint64 value.availableBalance )
        , ( 3, Protobuf.Encode.uint64 value.pendingBalance )
        , ( 4, Protobuf.Encode.uint64 value.reservedOfferBalance )
        , ( 5, Protobuf.Encode.uint64 value.reservedTradeBalance )
        ]


{-| `Proto__Io__Haveno__Protobuffer__XmrBalanceInfo` message

-}
type alias Proto__Io__Haveno__Protobuffer__XmrBalanceInfo =
    { balance : Protobuf.Types.Int64.Int64
    , availableBalance : Protobuf.Types.Int64.Int64
    , pendingBalance : Protobuf.Types.Int64.Int64
    , reservedOfferBalance : Protobuf.Types.Int64.Int64
    , reservedTradeBalance : Protobuf.Types.Int64.Int64
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__BtcBalanceInfo`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__BtcBalanceInfo :
    { availableBalance : Int, reservedBalance : Int, totalAvailableBalance : Int, lockedBalance : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__BtcBalanceInfo =
    { availableBalance = 1, reservedBalance = 2, totalAvailableBalance = 3, lockedBalance = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__BtcBalanceInfo. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__BtcBalanceInfo : Proto__Io__Haveno__Protobuffer__BtcBalanceInfo
defaultProto__Io__Haveno__Protobuffer__BtcBalanceInfo =
    { availableBalance = Protobuf.Types.Int64.fromInts 0 0
    , reservedBalance = Protobuf.Types.Int64.fromInts 0 0
    , totalAvailableBalance = Protobuf.Types.Int64.fromInts 0 0
    , lockedBalance = Protobuf.Types.Int64.fromInts 0 0
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__BtcBalanceInfo` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__BtcBalanceInfo :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__BtcBalanceInfo
decodeProto__Io__Haveno__Protobuffer__BtcBalanceInfo =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__BtcBalanceInfo
        [ Protobuf.Decode.optional 1 Protobuf.Decode.uint64 (\a r -> { r | availableBalance = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.uint64 (\a r -> { r | reservedBalance = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.uint64 (\a r -> { r | totalAvailableBalance = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.uint64 (\a r -> { r | lockedBalance = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__BtcBalanceInfo` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__BtcBalanceInfo :
    Proto__Io__Haveno__Protobuffer__BtcBalanceInfo -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__BtcBalanceInfo value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.uint64 value.availableBalance )
        , ( 2, Protobuf.Encode.uint64 value.reservedBalance )
        , ( 3, Protobuf.Encode.uint64 value.totalAvailableBalance )
        , ( 4, Protobuf.Encode.uint64 value.lockedBalance )
        ]


{-| `Proto__Io__Haveno__Protobuffer__BtcBalanceInfo` message

-}
type alias Proto__Io__Haveno__Protobuffer__BtcBalanceInfo =
    { availableBalance : Protobuf.Types.Int64.Int64
    , reservedBalance : Protobuf.Types.Int64.Int64
    , totalAvailableBalance : Protobuf.Types.Int64.Int64
    , lockedBalance : Protobuf.Types.Int64.Int64
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__BalancesInfo`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__BalancesInfo : { btc : Int, xmr : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__BalancesInfo =
    { btc = 1, xmr = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__BalancesInfo. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__BalancesInfo : Proto__Io__Haveno__Protobuffer__BalancesInfo
defaultProto__Io__Haveno__Protobuffer__BalancesInfo =
    { btc = Nothing, xmr = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__BalancesInfo` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__BalancesInfo :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__BalancesInfo
decodeProto__Io__Haveno__Protobuffer__BalancesInfo =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__BalancesInfo
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__BtcBalanceInfo)
            (\a r -> { r | btc = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__XmrBalanceInfo)
            (\a r -> { r | xmr = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__BalancesInfo` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__BalancesInfo :
    Proto__Io__Haveno__Protobuffer__BalancesInfo -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__BalancesInfo value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__BtcBalanceInfo >> Maybe.withDefault Protobuf.Encode.none)
                value.btc
          )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__XmrBalanceInfo >> Maybe.withDefault Protobuf.Encode.none)
                value.xmr
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__BalancesInfo` message

-}
type alias Proto__Io__Haveno__Protobuffer__BalancesInfo =
    { btc : Maybe Proto__Io__Haveno__Protobuffer__BtcBalanceInfo
    , xmr : Maybe Proto__Io__Haveno__Protobuffer__XmrBalanceInfo
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__UnlockWalletReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__UnlockWalletReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__UnlockWalletReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__UnlockWalletReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__UnlockWalletReply : Proto__Io__Haveno__Protobuffer__UnlockWalletReply
defaultProto__Io__Haveno__Protobuffer__UnlockWalletReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__UnlockWalletReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__UnlockWalletReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__UnlockWalletReply
decodeProto__Io__Haveno__Protobuffer__UnlockWalletReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__UnlockWalletReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__UnlockWalletReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__UnlockWalletReply :
    Proto__Io__Haveno__Protobuffer__UnlockWalletReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__UnlockWalletReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__UnlockWalletReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__UnlockWalletReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__UnlockWalletRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__UnlockWalletRequest : { password : Int, timeout : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__UnlockWalletRequest =
    { password = 1, timeout = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__UnlockWalletRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__UnlockWalletRequest : Proto__Io__Haveno__Protobuffer__UnlockWalletRequest
defaultProto__Io__Haveno__Protobuffer__UnlockWalletRequest =
    { password = "", timeout = Protobuf.Types.Int64.fromInts 0 0 }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__UnlockWalletRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__UnlockWalletRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__UnlockWalletRequest
decodeProto__Io__Haveno__Protobuffer__UnlockWalletRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__UnlockWalletRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | password = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.uint64 (\a r -> { r | timeout = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__UnlockWalletRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__UnlockWalletRequest :
    Proto__Io__Haveno__Protobuffer__UnlockWalletRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__UnlockWalletRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.password ), ( 2, Protobuf.Encode.uint64 value.timeout ) ]


{-| `Proto__Io__Haveno__Protobuffer__UnlockWalletRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__UnlockWalletRequest =
    { password : String, timeout : Protobuf.Types.Int64.Int64 }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__LockWalletReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__LockWalletReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__LockWalletReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__LockWalletReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__LockWalletReply : Proto__Io__Haveno__Protobuffer__LockWalletReply
defaultProto__Io__Haveno__Protobuffer__LockWalletReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__LockWalletReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__LockWalletReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__LockWalletReply
decodeProto__Io__Haveno__Protobuffer__LockWalletReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__LockWalletReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__LockWalletReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__LockWalletReply :
    Proto__Io__Haveno__Protobuffer__LockWalletReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__LockWalletReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__LockWalletReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__LockWalletReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__LockWalletRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__LockWalletRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__LockWalletRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__LockWalletRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__LockWalletRequest : Proto__Io__Haveno__Protobuffer__LockWalletRequest
defaultProto__Io__Haveno__Protobuffer__LockWalletRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__LockWalletRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__LockWalletRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__LockWalletRequest
decodeProto__Io__Haveno__Protobuffer__LockWalletRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__LockWalletRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__LockWalletRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__LockWalletRequest :
    Proto__Io__Haveno__Protobuffer__LockWalletRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__LockWalletRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__LockWalletRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__LockWalletRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply :
    Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply
defaultProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply
decodeProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply :
    Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest : { password : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest =
    { password = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest :
    Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest
defaultProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest =
    { password = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest
decodeProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | password = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest :
    Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.password ) ]


{-| `Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__RemoveWalletPasswordRequest =
    { password : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SetWalletPasswordReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SetWalletPasswordReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__SetWalletPasswordReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__SetWalletPasswordReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SetWalletPasswordReply : Proto__Io__Haveno__Protobuffer__SetWalletPasswordReply
defaultProto__Io__Haveno__Protobuffer__SetWalletPasswordReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SetWalletPasswordReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SetWalletPasswordReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SetWalletPasswordReply
decodeProto__Io__Haveno__Protobuffer__SetWalletPasswordReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__SetWalletPasswordReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SetWalletPasswordReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SetWalletPasswordReply :
    Proto__Io__Haveno__Protobuffer__SetWalletPasswordReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SetWalletPasswordReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__SetWalletPasswordReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__SetWalletPasswordReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SetWalletPasswordRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest : { password : Int, newPassword : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest =
    { password = 1, newPassword = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__SetWalletPasswordRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest :
    Proto__Io__Haveno__Protobuffer__SetWalletPasswordRequest
defaultProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest =
    { password = "", newPassword = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SetWalletPasswordRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SetWalletPasswordRequest
decodeProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | password = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | newPassword = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SetWalletPasswordRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest :
    Proto__Io__Haveno__Protobuffer__SetWalletPasswordRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SetWalletPasswordRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.password ), ( 2, Protobuf.Encode.string value.newPassword ) ]


{-| `Proto__Io__Haveno__Protobuffer__SetWalletPasswordRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__SetWalletPasswordRequest =
    { password : String, newPassword : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetFundingAddressesReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetFundingAddressesReply : { addressBalanceInfo : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetFundingAddressesReply =
    { addressBalanceInfo = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetFundingAddressesReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetFundingAddressesReply :
    Proto__Io__Haveno__Protobuffer__GetFundingAddressesReply
defaultProto__Io__Haveno__Protobuffer__GetFundingAddressesReply =
    { addressBalanceInfo = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetFundingAddressesReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetFundingAddressesReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetFundingAddressesReply
decodeProto__Io__Haveno__Protobuffer__GetFundingAddressesReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetFundingAddressesReply
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__AddressBalanceInfo
            .addressBalanceInfo
            (\a r -> { r | addressBalanceInfo = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetFundingAddressesReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetFundingAddressesReply :
    Proto__Io__Haveno__Protobuffer__GetFundingAddressesReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetFundingAddressesReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__AddressBalanceInfo) value.addressBalanceInfo
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__GetFundingAddressesReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetFundingAddressesReply =
    { addressBalanceInfo : List Proto__Io__Haveno__Protobuffer__AddressBalanceInfo }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetFundingAddressesRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__GetFundingAddressesRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest :
    Proto__Io__Haveno__Protobuffer__GetFundingAddressesRequest
defaultProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetFundingAddressesRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetFundingAddressesRequest
decodeProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetFundingAddressesRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest :
    Proto__Io__Haveno__Protobuffer__GetFundingAddressesRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetFundingAddressesRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__GetFundingAddressesRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetFundingAddressesRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SendBtcRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SendBtcRequest :
    { address : Int, amount : Int, txFeeRate : Int, memo : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SendBtcRequest =
    { address = 1, amount = 2, txFeeRate = 3, memo = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__SendBtcRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SendBtcRequest : Proto__Io__Haveno__Protobuffer__SendBtcRequest
defaultProto__Io__Haveno__Protobuffer__SendBtcRequest =
    { address = "", amount = "", txFeeRate = "", memo = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SendBtcRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SendBtcRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SendBtcRequest
decodeProto__Io__Haveno__Protobuffer__SendBtcRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SendBtcRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | address = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | amount = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | txFeeRate = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | memo = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SendBtcRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SendBtcRequest :
    Proto__Io__Haveno__Protobuffer__SendBtcRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SendBtcRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.address )
        , ( 2, Protobuf.Encode.string value.amount )
        , ( 3, Protobuf.Encode.string value.txFeeRate )
        , ( 4, Protobuf.Encode.string value.memo )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SendBtcRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__SendBtcRequest =
    { address : String, amount : String, txFeeRate : String, memo : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetAddressBalanceReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetAddressBalanceReply : { addressBalanceInfo : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetAddressBalanceReply =
    { addressBalanceInfo = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetAddressBalanceReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetAddressBalanceReply : Proto__Io__Haveno__Protobuffer__GetAddressBalanceReply
defaultProto__Io__Haveno__Protobuffer__GetAddressBalanceReply =
    { addressBalanceInfo = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetAddressBalanceReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetAddressBalanceReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetAddressBalanceReply
decodeProto__Io__Haveno__Protobuffer__GetAddressBalanceReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetAddressBalanceReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__AddressBalanceInfo)
            (\a r -> { r | addressBalanceInfo = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetAddressBalanceReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetAddressBalanceReply :
    Proto__Io__Haveno__Protobuffer__GetAddressBalanceReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetAddressBalanceReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__AddressBalanceInfo
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.addressBalanceInfo
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__GetAddressBalanceReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetAddressBalanceReply =
    { addressBalanceInfo : Maybe Proto__Io__Haveno__Protobuffer__AddressBalanceInfo }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetAddressBalanceRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest : { address : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest =
    { address = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetAddressBalanceRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest :
    Proto__Io__Haveno__Protobuffer__GetAddressBalanceRequest
defaultProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest =
    { address = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetAddressBalanceRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetAddressBalanceRequest
decodeProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | address = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetAddressBalanceRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest :
    Proto__Io__Haveno__Protobuffer__GetAddressBalanceRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetAddressBalanceRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.address ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetAddressBalanceRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetAddressBalanceRequest =
    { address : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RelayXmrTxReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RelayXmrTxReply : { hash : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__RelayXmrTxReply =
    { hash = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__RelayXmrTxReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RelayXmrTxReply : Proto__Io__Haveno__Protobuffer__RelayXmrTxReply
defaultProto__Io__Haveno__Protobuffer__RelayXmrTxReply =
    { hash = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RelayXmrTxReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RelayXmrTxReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RelayXmrTxReply
decodeProto__Io__Haveno__Protobuffer__RelayXmrTxReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__RelayXmrTxReply
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | hash = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RelayXmrTxReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RelayXmrTxReply :
    Proto__Io__Haveno__Protobuffer__RelayXmrTxReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RelayXmrTxReply value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.hash ) ]


{-| `Proto__Io__Haveno__Protobuffer__RelayXmrTxReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__RelayXmrTxReply =
    { hash : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RelayXmrTxRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RelayXmrTxRequest : { metadata : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__RelayXmrTxRequest =
    { metadata = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__RelayXmrTxRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RelayXmrTxRequest : Proto__Io__Haveno__Protobuffer__RelayXmrTxRequest
defaultProto__Io__Haveno__Protobuffer__RelayXmrTxRequest =
    { metadata = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RelayXmrTxRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RelayXmrTxRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RelayXmrTxRequest
decodeProto__Io__Haveno__Protobuffer__RelayXmrTxRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__RelayXmrTxRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | metadata = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RelayXmrTxRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RelayXmrTxRequest :
    Proto__Io__Haveno__Protobuffer__RelayXmrTxRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RelayXmrTxRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.metadata ) ]


{-| `Proto__Io__Haveno__Protobuffer__RelayXmrTxRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__RelayXmrTxRequest =
    { metadata : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CreateXmrTxReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CreateXmrTxReply : { tx : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CreateXmrTxReply =
    { tx = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__CreateXmrTxReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CreateXmrTxReply : Proto__Io__Haveno__Protobuffer__CreateXmrTxReply
defaultProto__Io__Haveno__Protobuffer__CreateXmrTxReply =
    { tx = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CreateXmrTxReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CreateXmrTxReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CreateXmrTxReply
decodeProto__Io__Haveno__Protobuffer__CreateXmrTxReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CreateXmrTxReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__XmrTx)
            (\a r -> { r | tx = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CreateXmrTxReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CreateXmrTxReply :
    Proto__Io__Haveno__Protobuffer__CreateXmrTxReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CreateXmrTxReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__XmrTx >> Maybe.withDefault Protobuf.Encode.none) value.tx
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__CreateXmrTxReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__CreateXmrTxReply =
    { tx : Maybe Proto__Io__Haveno__Protobuffer__XmrTx }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CreateXmrTxRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CreateXmrTxRequest : { destinations : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CreateXmrTxRequest =
    { destinations = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__CreateXmrTxRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CreateXmrTxRequest : Proto__Io__Haveno__Protobuffer__CreateXmrTxRequest
defaultProto__Io__Haveno__Protobuffer__CreateXmrTxRequest =
    { destinations = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CreateXmrTxRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CreateXmrTxRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CreateXmrTxRequest
decodeProto__Io__Haveno__Protobuffer__CreateXmrTxRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CreateXmrTxRequest
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__XmrDestination
            .destinations
            (\a r -> { r | destinations = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CreateXmrTxRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CreateXmrTxRequest :
    Proto__Io__Haveno__Protobuffer__CreateXmrTxRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CreateXmrTxRequest value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__XmrDestination) value.destinations ) ]


{-| `Proto__Io__Haveno__Protobuffer__CreateXmrTxRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__CreateXmrTxRequest =
    { destinations : List Proto__Io__Haveno__Protobuffer__XmrDestination }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__XmrOutgoingTransfer`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer :
    { amount : Int, accountIndex : Int, subaddressIndices : Int, destinations : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer =
    { amount = 1, accountIndex = 2, subaddressIndices = 3, destinations = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__XmrOutgoingTransfer. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer : Proto__Io__Haveno__Protobuffer__XmrOutgoingTransfer
defaultProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer =
    { amount = "", accountIndex = 0, subaddressIndices = [], destinations = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__XmrOutgoingTransfer` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__XmrOutgoingTransfer
decodeProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | amount = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int32 (\a r -> { r | accountIndex = a })
        , Protobuf.Decode.repeated 3 Protobuf.Decode.int32 .subaddressIndices (\a r -> { r | subaddressIndices = a })
        , Protobuf.Decode.repeated
            4
            decodeProto__Io__Haveno__Protobuffer__XmrDestination
            .destinations
            (\a r -> { r | destinations = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__XmrOutgoingTransfer` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer :
    Proto__Io__Haveno__Protobuffer__XmrOutgoingTransfer -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.amount )
        , ( 2, Protobuf.Encode.int32 value.accountIndex )
        , ( 3, (Protobuf.Encode.list Protobuf.Encode.int32) value.subaddressIndices )
        , ( 4, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__XmrDestination) value.destinations )
        ]


{-| `Proto__Io__Haveno__Protobuffer__XmrOutgoingTransfer` message

-}
type alias Proto__Io__Haveno__Protobuffer__XmrOutgoingTransfer =
    { amount : String
    , accountIndex : Int
    , subaddressIndices : List Int
    , destinations : List Proto__Io__Haveno__Protobuffer__XmrDestination
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__XmrIncomingTransfer`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__XmrIncomingTransfer :
    { amount : Int, accountIndex : Int, subaddressIndex : Int, address : Int, numSuggestedConfirmations : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__XmrIncomingTransfer =
    { amount = 1, accountIndex = 2, subaddressIndex = 3, address = 4, numSuggestedConfirmations = 5 }


{-| Default for Proto__Io__Haveno__Protobuffer__XmrIncomingTransfer. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__XmrIncomingTransfer : Proto__Io__Haveno__Protobuffer__XmrIncomingTransfer
defaultProto__Io__Haveno__Protobuffer__XmrIncomingTransfer =
    { amount = ""
    , accountIndex = 0
    , subaddressIndex = 0
    , address = ""
    , numSuggestedConfirmations = Protobuf.Types.Int64.fromInts 0 0
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__XmrIncomingTransfer` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__XmrIncomingTransfer :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__XmrIncomingTransfer
decodeProto__Io__Haveno__Protobuffer__XmrIncomingTransfer =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__XmrIncomingTransfer
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | amount = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int32 (\a r -> { r | accountIndex = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int32 (\a r -> { r | subaddressIndex = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | address = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.uint64 (\a r -> { r | numSuggestedConfirmations = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__XmrIncomingTransfer` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__XmrIncomingTransfer :
    Proto__Io__Haveno__Protobuffer__XmrIncomingTransfer -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__XmrIncomingTransfer value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.amount )
        , ( 2, Protobuf.Encode.int32 value.accountIndex )
        , ( 3, Protobuf.Encode.int32 value.subaddressIndex )
        , ( 4, Protobuf.Encode.string value.address )
        , ( 5, Protobuf.Encode.uint64 value.numSuggestedConfirmations )
        ]


{-| `Proto__Io__Haveno__Protobuffer__XmrIncomingTransfer` message

-}
type alias Proto__Io__Haveno__Protobuffer__XmrIncomingTransfer =
    { amount : String
    , accountIndex : Int
    , subaddressIndex : Int
    , address : String
    , numSuggestedConfirmations : Protobuf.Types.Int64.Int64
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__XmrDestination`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__XmrDestination : { address : Int, amount : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__XmrDestination =
    { address = 1, amount = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__XmrDestination. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__XmrDestination : Proto__Io__Haveno__Protobuffer__XmrDestination
defaultProto__Io__Haveno__Protobuffer__XmrDestination =
    { address = "", amount = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__XmrDestination` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__XmrDestination :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__XmrDestination
decodeProto__Io__Haveno__Protobuffer__XmrDestination =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__XmrDestination
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | address = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | amount = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__XmrDestination` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__XmrDestination :
    Proto__Io__Haveno__Protobuffer__XmrDestination -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__XmrDestination value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.address ), ( 2, Protobuf.Encode.string value.amount ) ]


{-| `Proto__Io__Haveno__Protobuffer__XmrDestination` message

-}
type alias Proto__Io__Haveno__Protobuffer__XmrDestination =
    { address : String, amount : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__XmrTx`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__XmrTx :
    { hash : Int
    , fee : Int
    , isConfirmed : Int
    , isLocked : Int
    , height : Int
    , timestamp : Int
    , incomingTransfers : Int
    , outgoingTransfer : Int
    , metadata : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__XmrTx =
    { hash = 1
    , fee = 2
    , isConfirmed = 3
    , isLocked = 4
    , height = 5
    , timestamp = 6
    , incomingTransfers = 7
    , outgoingTransfer = 8
    , metadata = 9
    }


{-| Default for Proto__Io__Haveno__Protobuffer__XmrTx. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__XmrTx : Proto__Io__Haveno__Protobuffer__XmrTx
defaultProto__Io__Haveno__Protobuffer__XmrTx =
    { hash = ""
    , fee = ""
    , isConfirmed = False
    , isLocked = False
    , height = Protobuf.Types.Int64.fromInts 0 0
    , timestamp = Protobuf.Types.Int64.fromInts 0 0
    , incomingTransfers = []
    , outgoingTransfer = Nothing
    , metadata = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__XmrTx` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__XmrTx : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__XmrTx
decodeProto__Io__Haveno__Protobuffer__XmrTx =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__XmrTx
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | hash = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | fee = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.bool (\a r -> { r | isConfirmed = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.bool (\a r -> { r | isLocked = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.uint64 (\a r -> { r | height = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.uint64 (\a r -> { r | timestamp = a })
        , Protobuf.Decode.repeated
            7
            decodeProto__Io__Haveno__Protobuffer__XmrIncomingTransfer
            .incomingTransfers
            (\a r -> { r | incomingTransfers = a })
        , Protobuf.Decode.optional
            8
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer)
            (\a r -> { r | outgoingTransfer = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.string (\a r -> { r | metadata = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__XmrTx` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__XmrTx : Proto__Io__Haveno__Protobuffer__XmrTx -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__XmrTx value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.hash )
        , ( 2, Protobuf.Encode.string value.fee )
        , ( 3, Protobuf.Encode.bool value.isConfirmed )
        , ( 4, Protobuf.Encode.bool value.isLocked )
        , ( 5, Protobuf.Encode.uint64 value.height )
        , ( 6, Protobuf.Encode.uint64 value.timestamp )
        , ( 7
          , (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__XmrIncomingTransfer) value.incomingTransfers
          )
        , ( 8
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__XmrOutgoingTransfer
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.outgoingTransfer
          )
        , ( 9, Protobuf.Encode.string value.metadata )
        ]


{-| `Proto__Io__Haveno__Protobuffer__XmrTx` message

-}
type alias Proto__Io__Haveno__Protobuffer__XmrTx =
    { hash : String
    , fee : String
    , isConfirmed : Bool
    , isLocked : Bool
    , height : Protobuf.Types.Int64.Int64
    , timestamp : Protobuf.Types.Int64.Int64
    , incomingTransfers : List Proto__Io__Haveno__Protobuffer__XmrIncomingTransfer
    , outgoingTransfer : Maybe Proto__Io__Haveno__Protobuffer__XmrOutgoingTransfer
    , metadata : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetXmrTxsReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrTxsReply : { txs : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrTxsReply =
    { txs = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetXmrTxsReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetXmrTxsReply : Proto__Io__Haveno__Protobuffer__GetXmrTxsReply
defaultProto__Io__Haveno__Protobuffer__GetXmrTxsReply =
    { txs = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetXmrTxsReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetXmrTxsReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetXmrTxsReply
decodeProto__Io__Haveno__Protobuffer__GetXmrTxsReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetXmrTxsReply
        [ Protobuf.Decode.repeated 1 decodeProto__Io__Haveno__Protobuffer__XmrTx .txs (\a r -> { r | txs = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetXmrTxsReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetXmrTxsReply :
    Proto__Io__Haveno__Protobuffer__GetXmrTxsReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetXmrTxsReply value =
    Protobuf.Encode.message [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__XmrTx) value.txs ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetXmrTxsReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetXmrTxsReply =
    { txs : List Proto__Io__Haveno__Protobuffer__XmrTx }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetXmrTxsRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrTxsRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrTxsRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__GetXmrTxsRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetXmrTxsRequest : Proto__Io__Haveno__Protobuffer__GetXmrTxsRequest
defaultProto__Io__Haveno__Protobuffer__GetXmrTxsRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetXmrTxsRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetXmrTxsRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetXmrTxsRequest
decodeProto__Io__Haveno__Protobuffer__GetXmrTxsRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__GetXmrTxsRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetXmrTxsRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetXmrTxsRequest :
    Proto__Io__Haveno__Protobuffer__GetXmrTxsRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetXmrTxsRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__GetXmrTxsRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetXmrTxsRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply : { subaddress : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply =
    { subaddress = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply :
    Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply
defaultProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply =
    { subaddress = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply
decodeProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | subaddress = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply :
    Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.subaddress ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressReply =
    { subaddress : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest :
    Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest
defaultProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest
decodeProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest :
    Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetXmrNewSubaddressRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply : { primaryAddress : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply =
    { primaryAddress = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply :
    Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply
defaultProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply =
    { primaryAddress = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply
decodeProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | primaryAddress = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply :
    Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.primaryAddress ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressReply =
    { primaryAddress : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest :
    Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest
defaultProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest
decodeProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest :
    Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetXmrPrimaryAddressRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetXmrSeedReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrSeedReply : { seed : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrSeedReply =
    { seed = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetXmrSeedReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetXmrSeedReply : Proto__Io__Haveno__Protobuffer__GetXmrSeedReply
defaultProto__Io__Haveno__Protobuffer__GetXmrSeedReply =
    { seed = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetXmrSeedReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetXmrSeedReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetXmrSeedReply
decodeProto__Io__Haveno__Protobuffer__GetXmrSeedReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetXmrSeedReply
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | seed = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetXmrSeedReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetXmrSeedReply :
    Proto__Io__Haveno__Protobuffer__GetXmrSeedReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetXmrSeedReply value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.seed ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetXmrSeedReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetXmrSeedReply =
    { seed : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetXmrSeedRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrSeedRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrSeedRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__GetXmrSeedRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetXmrSeedRequest : Proto__Io__Haveno__Protobuffer__GetXmrSeedRequest
defaultProto__Io__Haveno__Protobuffer__GetXmrSeedRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetXmrSeedRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetXmrSeedRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetXmrSeedRequest
decodeProto__Io__Haveno__Protobuffer__GetXmrSeedRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__GetXmrSeedRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetXmrSeedRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetXmrSeedRequest :
    Proto__Io__Haveno__Protobuffer__GetXmrSeedRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetXmrSeedRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__GetXmrSeedRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetXmrSeedRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetBalancesReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetBalancesReply : { balances : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetBalancesReply =
    { balances = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetBalancesReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetBalancesReply : Proto__Io__Haveno__Protobuffer__GetBalancesReply
defaultProto__Io__Haveno__Protobuffer__GetBalancesReply =
    { balances = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetBalancesReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetBalancesReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetBalancesReply
decodeProto__Io__Haveno__Protobuffer__GetBalancesReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetBalancesReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__BalancesInfo)
            (\a r -> { r | balances = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetBalancesReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetBalancesReply :
    Proto__Io__Haveno__Protobuffer__GetBalancesReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetBalancesReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__BalancesInfo >> Maybe.withDefault Protobuf.Encode.none)
                value.balances
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__GetBalancesReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetBalancesReply =
    { balances : Maybe Proto__Io__Haveno__Protobuffer__BalancesInfo }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetBalancesRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetBalancesRequest : { currencyCode : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetBalancesRequest =
    { currencyCode = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetBalancesRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetBalancesRequest : Proto__Io__Haveno__Protobuffer__GetBalancesRequest
defaultProto__Io__Haveno__Protobuffer__GetBalancesRequest =
    { currencyCode = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetBalancesRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetBalancesRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetBalancesRequest
decodeProto__Io__Haveno__Protobuffer__GetBalancesRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetBalancesRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | currencyCode = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetBalancesRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetBalancesRequest :
    Proto__Io__Haveno__Protobuffer__GetBalancesRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetBalancesRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.currencyCode ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetBalancesRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetBalancesRequest =
    { currencyCode : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ContractInfo`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ContractInfo :
    { buyerNodeAddress : Int
    , sellerNodeAddress : Int
    , arbitratorNodeAddress : Int
    , isBuyerMakerAndSellerTaker : Int
    , makerAccountId : Int
    , takerAccountId : Int
    , makerPaymentAccountPayload : Int
    , takerPaymentAccountPayload : Int
    , makerPayoutAddressString : Int
    , takerPayoutAddressString : Int
    , lockTime : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__ContractInfo =
    { buyerNodeAddress = 1
    , sellerNodeAddress = 2
    , arbitratorNodeAddress = 3
    , isBuyerMakerAndSellerTaker = 6
    , makerAccountId = 7
    , takerAccountId = 8
    , makerPaymentAccountPayload = 9
    , takerPaymentAccountPayload = 10
    , makerPayoutAddressString = 11
    , takerPayoutAddressString = 12
    , lockTime = 13
    }


{-| Default for Proto__Io__Haveno__Protobuffer__ContractInfo. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ContractInfo : Proto__Io__Haveno__Protobuffer__ContractInfo
defaultProto__Io__Haveno__Protobuffer__ContractInfo =
    { buyerNodeAddress = ""
    , sellerNodeAddress = ""
    , arbitratorNodeAddress = ""
    , isBuyerMakerAndSellerTaker = False
    , makerAccountId = ""
    , takerAccountId = ""
    , makerPaymentAccountPayload = Nothing
    , takerPaymentAccountPayload = Nothing
    , makerPayoutAddressString = ""
    , takerPayoutAddressString = ""
    , lockTime = Protobuf.Types.Int64.fromInts 0 0
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ContractInfo` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ContractInfo :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ContractInfo
decodeProto__Io__Haveno__Protobuffer__ContractInfo =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__ContractInfo
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | buyerNodeAddress = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | sellerNodeAddress = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | arbitratorNodeAddress = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.bool (\a r -> { r | isBuyerMakerAndSellerTaker = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | makerAccountId = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.string (\a r -> { r | takerAccountId = a })
        , Protobuf.Decode.optional
            9
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload)
            (\a r -> { r | makerPaymentAccountPayload = a })
        , Protobuf.Decode.optional
            10
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload)
            (\a r -> { r | takerPaymentAccountPayload = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.string (\a r -> { r | makerPayoutAddressString = a })
        , Protobuf.Decode.optional 12 Protobuf.Decode.string (\a r -> { r | takerPayoutAddressString = a })
        , Protobuf.Decode.optional 13 Protobuf.Decode.uint64 (\a r -> { r | lockTime = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ContractInfo` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ContractInfo :
    Proto__Io__Haveno__Protobuffer__ContractInfo -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ContractInfo value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.buyerNodeAddress )
        , ( 2, Protobuf.Encode.string value.sellerNodeAddress )
        , ( 3, Protobuf.Encode.string value.arbitratorNodeAddress )
        , ( 6, Protobuf.Encode.bool value.isBuyerMakerAndSellerTaker )
        , ( 7, Protobuf.Encode.string value.makerAccountId )
        , ( 8, Protobuf.Encode.string value.takerAccountId )
        , ( 9
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.makerPaymentAccountPayload
          )
        , ( 10
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.takerPaymentAccountPayload
          )
        , ( 11, Protobuf.Encode.string value.makerPayoutAddressString )
        , ( 12, Protobuf.Encode.string value.takerPayoutAddressString )
        , ( 13, Protobuf.Encode.uint64 value.lockTime )
        ]


{-| `Proto__Io__Haveno__Protobuffer__ContractInfo` message

-}
type alias Proto__Io__Haveno__Protobuffer__ContractInfo =
    { buyerNodeAddress : String
    , sellerNodeAddress : String
    , arbitratorNodeAddress : String
    , isBuyerMakerAndSellerTaker : Bool
    , makerAccountId : String
    , takerAccountId : String
    , makerPaymentAccountPayload : Maybe Proto__Io__Haveno__Protobuffer__PaymentAccountPayload
    , takerPaymentAccountPayload : Maybe Proto__Io__Haveno__Protobuffer__PaymentAccountPayload
    , makerPayoutAddressString : String
    , takerPayoutAddressString : String
    , lockTime : Protobuf.Types.Int64.Int64
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__TradeInfo`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__TradeInfo :
    { offer : Int
    , tradeId : Int
    , shortId : Int
    , date : Int
    , role : Int
    , amount : Int
    , makerFee : Int
    , takerFee : Int
    , buyerSecurityDeposit : Int
    , sellerSecurityDeposit : Int
    , buyerDepositTxFee : Int
    , sellerDepositTxFee : Int
    , buyerPayoutTxFee : Int
    , sellerPayoutTxFee : Int
    , buyerPayoutAmount : Int
    , sellerPayoutAmount : Int
    , price : Int
    , arbitratorNodeAddress : Int
    , tradePeerNodeAddress : Int
    , state : Int
    , phase : Int
    , periodState : Int
    , payoutState : Int
    , disputeState : Int
    , isDepositsPublished : Int
    , isDepositsConfirmed : Int
    , isDepositsUnlocked : Int
    , isPaymentSent : Int
    , isPaymentReceived : Int
    , isPayoutPublished : Int
    , isPayoutConfirmed : Int
    , isPayoutUnlocked : Int
    , isCompleted : Int
    , contractAsJson : Int
    , contract : Int
    , tradeVolume : Int
    , makerDepositTxId : Int
    , takerDepositTxId : Int
    , payoutTxId : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__TradeInfo =
    { offer = 1
    , tradeId = 2
    , shortId = 3
    , date = 4
    , role = 5
    , amount = 6
    , makerFee = 7
    , takerFee = 8
    , buyerSecurityDeposit = 9
    , sellerSecurityDeposit = 10
    , buyerDepositTxFee = 11
    , sellerDepositTxFee = 12
    , buyerPayoutTxFee = 13
    , sellerPayoutTxFee = 14
    , buyerPayoutAmount = 15
    , sellerPayoutAmount = 16
    , price = 17
    , arbitratorNodeAddress = 18
    , tradePeerNodeAddress = 19
    , state = 20
    , phase = 21
    , periodState = 22
    , payoutState = 23
    , disputeState = 24
    , isDepositsPublished = 25
    , isDepositsConfirmed = 26
    , isDepositsUnlocked = 27
    , isPaymentSent = 28
    , isPaymentReceived = 29
    , isPayoutPublished = 30
    , isPayoutConfirmed = 31
    , isPayoutUnlocked = 32
    , isCompleted = 33
    , contractAsJson = 34
    , contract = 35
    , tradeVolume = 36
    , makerDepositTxId = 37
    , takerDepositTxId = 38
    , payoutTxId = 39
    }


{-| Default for Proto__Io__Haveno__Protobuffer__TradeInfo. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__TradeInfo : Proto__Io__Haveno__Protobuffer__TradeInfo
defaultProto__Io__Haveno__Protobuffer__TradeInfo =
    { offer = Nothing
    , tradeId = ""
    , shortId = ""
    , date = Protobuf.Types.Int64.fromInts 0 0
    , role = ""
    , amount = Protobuf.Types.Int64.fromInts 0 0
    , makerFee = Protobuf.Types.Int64.fromInts 0 0
    , takerFee = Protobuf.Types.Int64.fromInts 0 0
    , buyerSecurityDeposit = Protobuf.Types.Int64.fromInts 0 0
    , sellerSecurityDeposit = Protobuf.Types.Int64.fromInts 0 0
    , buyerDepositTxFee = Protobuf.Types.Int64.fromInts 0 0
    , sellerDepositTxFee = Protobuf.Types.Int64.fromInts 0 0
    , buyerPayoutTxFee = Protobuf.Types.Int64.fromInts 0 0
    , sellerPayoutTxFee = Protobuf.Types.Int64.fromInts 0 0
    , buyerPayoutAmount = Protobuf.Types.Int64.fromInts 0 0
    , sellerPayoutAmount = Protobuf.Types.Int64.fromInts 0 0
    , price = ""
    , arbitratorNodeAddress = ""
    , tradePeerNodeAddress = ""
    , state = ""
    , phase = ""
    , periodState = ""
    , payoutState = ""
    , disputeState = ""
    , isDepositsPublished = False
    , isDepositsConfirmed = False
    , isDepositsUnlocked = False
    , isPaymentSent = False
    , isPaymentReceived = False
    , isPayoutPublished = False
    , isPayoutConfirmed = False
    , isPayoutUnlocked = False
    , isCompleted = False
    , contractAsJson = ""
    , contract = Nothing
    , tradeVolume = ""
    , makerDepositTxId = ""
    , takerDepositTxId = ""
    , payoutTxId = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__TradeInfo` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__TradeInfo : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__TradeInfo
decodeProto__Io__Haveno__Protobuffer__TradeInfo =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__TradeInfo
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__OfferInfo)
            (\a r -> { r | offer = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | shortId = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.uint64 (\a r -> { r | date = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | role = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.uint64 (\a r -> { r | amount = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.uint64 (\a r -> { r | makerFee = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.uint64 (\a r -> { r | takerFee = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.uint64 (\a r -> { r | buyerSecurityDeposit = a })
        , Protobuf.Decode.optional 10 Protobuf.Decode.uint64 (\a r -> { r | sellerSecurityDeposit = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.uint64 (\a r -> { r | buyerDepositTxFee = a })
        , Protobuf.Decode.optional 12 Protobuf.Decode.uint64 (\a r -> { r | sellerDepositTxFee = a })
        , Protobuf.Decode.optional 13 Protobuf.Decode.uint64 (\a r -> { r | buyerPayoutTxFee = a })
        , Protobuf.Decode.optional 14 Protobuf.Decode.uint64 (\a r -> { r | sellerPayoutTxFee = a })
        , Protobuf.Decode.optional 15 Protobuf.Decode.uint64 (\a r -> { r | buyerPayoutAmount = a })
        , Protobuf.Decode.optional 16 Protobuf.Decode.uint64 (\a r -> { r | sellerPayoutAmount = a })
        , Protobuf.Decode.optional 17 Protobuf.Decode.string (\a r -> { r | price = a })
        , Protobuf.Decode.optional 18 Protobuf.Decode.string (\a r -> { r | arbitratorNodeAddress = a })
        , Protobuf.Decode.optional 19 Protobuf.Decode.string (\a r -> { r | tradePeerNodeAddress = a })
        , Protobuf.Decode.optional 20 Protobuf.Decode.string (\a r -> { r | state = a })
        , Protobuf.Decode.optional 21 Protobuf.Decode.string (\a r -> { r | phase = a })
        , Protobuf.Decode.optional 22 Protobuf.Decode.string (\a r -> { r | periodState = a })
        , Protobuf.Decode.optional 23 Protobuf.Decode.string (\a r -> { r | payoutState = a })
        , Protobuf.Decode.optional 24 Protobuf.Decode.string (\a r -> { r | disputeState = a })
        , Protobuf.Decode.optional 25 Protobuf.Decode.bool (\a r -> { r | isDepositsPublished = a })
        , Protobuf.Decode.optional 26 Protobuf.Decode.bool (\a r -> { r | isDepositsConfirmed = a })
        , Protobuf.Decode.optional 27 Protobuf.Decode.bool (\a r -> { r | isDepositsUnlocked = a })
        , Protobuf.Decode.optional 28 Protobuf.Decode.bool (\a r -> { r | isPaymentSent = a })
        , Protobuf.Decode.optional 29 Protobuf.Decode.bool (\a r -> { r | isPaymentReceived = a })
        , Protobuf.Decode.optional 30 Protobuf.Decode.bool (\a r -> { r | isPayoutPublished = a })
        , Protobuf.Decode.optional 31 Protobuf.Decode.bool (\a r -> { r | isPayoutConfirmed = a })
        , Protobuf.Decode.optional 32 Protobuf.Decode.bool (\a r -> { r | isPayoutUnlocked = a })
        , Protobuf.Decode.optional 33 Protobuf.Decode.bool (\a r -> { r | isCompleted = a })
        , Protobuf.Decode.optional 34 Protobuf.Decode.string (\a r -> { r | contractAsJson = a })
        , Protobuf.Decode.optional
            35
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__ContractInfo)
            (\a r -> { r | contract = a })
        , Protobuf.Decode.optional 36 Protobuf.Decode.string (\a r -> { r | tradeVolume = a })
        , Protobuf.Decode.optional 37 Protobuf.Decode.string (\a r -> { r | makerDepositTxId = a })
        , Protobuf.Decode.optional 38 Protobuf.Decode.string (\a r -> { r | takerDepositTxId = a })
        , Protobuf.Decode.optional 39 Protobuf.Decode.string (\a r -> { r | payoutTxId = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__TradeInfo` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__TradeInfo : Proto__Io__Haveno__Protobuffer__TradeInfo -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__TradeInfo value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__OfferInfo >> Maybe.withDefault Protobuf.Encode.none)
                value.offer
          )
        , ( 2, Protobuf.Encode.string value.tradeId )
        , ( 3, Protobuf.Encode.string value.shortId )
        , ( 4, Protobuf.Encode.uint64 value.date )
        , ( 5, Protobuf.Encode.string value.role )
        , ( 6, Protobuf.Encode.uint64 value.amount )
        , ( 7, Protobuf.Encode.uint64 value.makerFee )
        , ( 8, Protobuf.Encode.uint64 value.takerFee )
        , ( 9, Protobuf.Encode.uint64 value.buyerSecurityDeposit )
        , ( 10, Protobuf.Encode.uint64 value.sellerSecurityDeposit )
        , ( 11, Protobuf.Encode.uint64 value.buyerDepositTxFee )
        , ( 12, Protobuf.Encode.uint64 value.sellerDepositTxFee )
        , ( 13, Protobuf.Encode.uint64 value.buyerPayoutTxFee )
        , ( 14, Protobuf.Encode.uint64 value.sellerPayoutTxFee )
        , ( 15, Protobuf.Encode.uint64 value.buyerPayoutAmount )
        , ( 16, Protobuf.Encode.uint64 value.sellerPayoutAmount )
        , ( 17, Protobuf.Encode.string value.price )
        , ( 18, Protobuf.Encode.string value.arbitratorNodeAddress )
        , ( 19, Protobuf.Encode.string value.tradePeerNodeAddress )
        , ( 20, Protobuf.Encode.string value.state )
        , ( 21, Protobuf.Encode.string value.phase )
        , ( 22, Protobuf.Encode.string value.periodState )
        , ( 23, Protobuf.Encode.string value.payoutState )
        , ( 24, Protobuf.Encode.string value.disputeState )
        , ( 25, Protobuf.Encode.bool value.isDepositsPublished )
        , ( 26, Protobuf.Encode.bool value.isDepositsConfirmed )
        , ( 27, Protobuf.Encode.bool value.isDepositsUnlocked )
        , ( 28, Protobuf.Encode.bool value.isPaymentSent )
        , ( 29, Protobuf.Encode.bool value.isPaymentReceived )
        , ( 30, Protobuf.Encode.bool value.isPayoutPublished )
        , ( 31, Protobuf.Encode.bool value.isPayoutConfirmed )
        , ( 32, Protobuf.Encode.bool value.isPayoutUnlocked )
        , ( 33, Protobuf.Encode.bool value.isCompleted )
        , ( 34, Protobuf.Encode.string value.contractAsJson )
        , ( 35
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__ContractInfo >> Maybe.withDefault Protobuf.Encode.none)
                value.contract
          )
        , ( 36, Protobuf.Encode.string value.tradeVolume )
        , ( 37, Protobuf.Encode.string value.makerDepositTxId )
        , ( 38, Protobuf.Encode.string value.takerDepositTxId )
        , ( 39, Protobuf.Encode.string value.payoutTxId )
        ]


{-| `Proto__Io__Haveno__Protobuffer__TradeInfo` message

-}
type alias Proto__Io__Haveno__Protobuffer__TradeInfo =
    { offer : Maybe Proto__Io__Haveno__Protobuffer__OfferInfo
    , tradeId : String
    , shortId : String
    , date : Protobuf.Types.Int64.Int64
    , role : String
    , amount : Protobuf.Types.Int64.Int64
    , makerFee : Protobuf.Types.Int64.Int64
    , takerFee : Protobuf.Types.Int64.Int64
    , buyerSecurityDeposit : Protobuf.Types.Int64.Int64
    , sellerSecurityDeposit : Protobuf.Types.Int64.Int64
    , buyerDepositTxFee : Protobuf.Types.Int64.Int64
    , sellerDepositTxFee : Protobuf.Types.Int64.Int64
    , buyerPayoutTxFee : Protobuf.Types.Int64.Int64
    , sellerPayoutTxFee : Protobuf.Types.Int64.Int64
    , buyerPayoutAmount : Protobuf.Types.Int64.Int64
    , sellerPayoutAmount : Protobuf.Types.Int64.Int64
    , price : String
    , arbitratorNodeAddress : String
    , tradePeerNodeAddress : String
    , state : String
    , phase : String
    , periodState : String
    , payoutState : String
    , disputeState : String
    , isDepositsPublished : Bool
    , isDepositsConfirmed : Bool
    , isDepositsUnlocked : Bool
    , isPaymentSent : Bool
    , isPaymentReceived : Bool
    , isPayoutPublished : Bool
    , isPayoutConfirmed : Bool
    , isPayoutUnlocked : Bool
    , isCompleted : Bool
    , contractAsJson : String
    , contract : Maybe Proto__Io__Haveno__Protobuffer__ContractInfo
    , tradeVolume : String
    , makerDepositTxId : String
    , takerDepositTxId : String
    , payoutTxId : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SendChatMessageReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SendChatMessageReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__SendChatMessageReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__SendChatMessageReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SendChatMessageReply : Proto__Io__Haveno__Protobuffer__SendChatMessageReply
defaultProto__Io__Haveno__Protobuffer__SendChatMessageReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SendChatMessageReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SendChatMessageReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SendChatMessageReply
decodeProto__Io__Haveno__Protobuffer__SendChatMessageReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__SendChatMessageReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SendChatMessageReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SendChatMessageReply :
    Proto__Io__Haveno__Protobuffer__SendChatMessageReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SendChatMessageReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__SendChatMessageReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__SendChatMessageReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SendChatMessageRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SendChatMessageRequest : { tradeId : Int, message : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SendChatMessageRequest =
    { tradeId = 1, message = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__SendChatMessageRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SendChatMessageRequest : Proto__Io__Haveno__Protobuffer__SendChatMessageRequest
defaultProto__Io__Haveno__Protobuffer__SendChatMessageRequest =
    { tradeId = "", message = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SendChatMessageRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SendChatMessageRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SendChatMessageRequest
decodeProto__Io__Haveno__Protobuffer__SendChatMessageRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SendChatMessageRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | message = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SendChatMessageRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SendChatMessageRequest :
    Proto__Io__Haveno__Protobuffer__SendChatMessageRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SendChatMessageRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.tradeId ), ( 2, Protobuf.Encode.string value.message ) ]


{-| `Proto__Io__Haveno__Protobuffer__SendChatMessageRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__SendChatMessageRequest =
    { tradeId : String, message : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetChatMessagesReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetChatMessagesReply : { message : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetChatMessagesReply =
    { message = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetChatMessagesReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetChatMessagesReply : Proto__Io__Haveno__Protobuffer__GetChatMessagesReply
defaultProto__Io__Haveno__Protobuffer__GetChatMessagesReply =
    { message = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetChatMessagesReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetChatMessagesReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetChatMessagesReply
decodeProto__Io__Haveno__Protobuffer__GetChatMessagesReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetChatMessagesReply
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__ChatMessage
            .message
            (\a r -> { r | message = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetChatMessagesReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetChatMessagesReply :
    Proto__Io__Haveno__Protobuffer__GetChatMessagesReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetChatMessagesReply value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__ChatMessage) value.message ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetChatMessagesReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetChatMessagesReply =
    { message : List Proto__Io__Haveno__Protobuffer__ChatMessage }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetChatMessagesRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetChatMessagesRequest : { tradeId : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetChatMessagesRequest =
    { tradeId = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetChatMessagesRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetChatMessagesRequest : Proto__Io__Haveno__Protobuffer__GetChatMessagesRequest
defaultProto__Io__Haveno__Protobuffer__GetChatMessagesRequest =
    { tradeId = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetChatMessagesRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetChatMessagesRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetChatMessagesRequest
decodeProto__Io__Haveno__Protobuffer__GetChatMessagesRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetChatMessagesRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetChatMessagesRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetChatMessagesRequest :
    Proto__Io__Haveno__Protobuffer__GetChatMessagesRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetChatMessagesRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.tradeId ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetChatMessagesRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetChatMessagesRequest =
    { tradeId : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__WithdrawFundsReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__WithdrawFundsReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__WithdrawFundsReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__WithdrawFundsReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__WithdrawFundsReply : Proto__Io__Haveno__Protobuffer__WithdrawFundsReply
defaultProto__Io__Haveno__Protobuffer__WithdrawFundsReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__WithdrawFundsReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__WithdrawFundsReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__WithdrawFundsReply
decodeProto__Io__Haveno__Protobuffer__WithdrawFundsReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__WithdrawFundsReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__WithdrawFundsReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__WithdrawFundsReply :
    Proto__Io__Haveno__Protobuffer__WithdrawFundsReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__WithdrawFundsReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__WithdrawFundsReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__WithdrawFundsReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__WithdrawFundsRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__WithdrawFundsRequest : { tradeId : Int, address : Int, memo : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__WithdrawFundsRequest =
    { tradeId = 1, address = 2, memo = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__WithdrawFundsRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__WithdrawFundsRequest : Proto__Io__Haveno__Protobuffer__WithdrawFundsRequest
defaultProto__Io__Haveno__Protobuffer__WithdrawFundsRequest =
    { tradeId = "", address = "", memo = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__WithdrawFundsRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__WithdrawFundsRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__WithdrawFundsRequest
decodeProto__Io__Haveno__Protobuffer__WithdrawFundsRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__WithdrawFundsRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | address = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | memo = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__WithdrawFundsRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__WithdrawFundsRequest :
    Proto__Io__Haveno__Protobuffer__WithdrawFundsRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__WithdrawFundsRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.tradeId )
        , ( 2, Protobuf.Encode.string value.address )
        , ( 3, Protobuf.Encode.string value.memo )
        ]


{-| `Proto__Io__Haveno__Protobuffer__WithdrawFundsRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__WithdrawFundsRequest =
    { tradeId : String, address : String, memo : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CompleteTradeReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CompleteTradeReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__CompleteTradeReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__CompleteTradeReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CompleteTradeReply : Proto__Io__Haveno__Protobuffer__CompleteTradeReply
defaultProto__Io__Haveno__Protobuffer__CompleteTradeReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CompleteTradeReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CompleteTradeReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CompleteTradeReply
decodeProto__Io__Haveno__Protobuffer__CompleteTradeReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__CompleteTradeReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CompleteTradeReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CompleteTradeReply :
    Proto__Io__Haveno__Protobuffer__CompleteTradeReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CompleteTradeReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__CompleteTradeReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__CompleteTradeReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CompleteTradeRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CompleteTradeRequest : { tradeId : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CompleteTradeRequest =
    { tradeId = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__CompleteTradeRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CompleteTradeRequest : Proto__Io__Haveno__Protobuffer__CompleteTradeRequest
defaultProto__Io__Haveno__Protobuffer__CompleteTradeRequest =
    { tradeId = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CompleteTradeRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CompleteTradeRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CompleteTradeRequest
decodeProto__Io__Haveno__Protobuffer__CompleteTradeRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CompleteTradeRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CompleteTradeRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CompleteTradeRequest :
    Proto__Io__Haveno__Protobuffer__CompleteTradeRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CompleteTradeRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.tradeId ) ]


{-| `Proto__Io__Haveno__Protobuffer__CompleteTradeRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__CompleteTradeRequest =
    { tradeId : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetTradesReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetTradesReply : { trades : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetTradesReply =
    { trades = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetTradesReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetTradesReply : Proto__Io__Haveno__Protobuffer__GetTradesReply
defaultProto__Io__Haveno__Protobuffer__GetTradesReply =
    { trades = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetTradesReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetTradesReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetTradesReply
decodeProto__Io__Haveno__Protobuffer__GetTradesReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetTradesReply
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__TradeInfo
            .trades
            (\a r -> { r | trades = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetTradesReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetTradesReply :
    Proto__Io__Haveno__Protobuffer__GetTradesReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetTradesReply value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__TradeInfo) value.trades ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetTradesReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetTradesReply =
    { trades : List Proto__Io__Haveno__Protobuffer__TradeInfo }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetTradesRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetTradesRequest : { category : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetTradesRequest =
    { category = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetTradesRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetTradesRequest : Proto__Io__Haveno__Protobuffer__GetTradesRequest
defaultProto__Io__Haveno__Protobuffer__GetTradesRequest =
    { category = Proto.Io.Haveno.Protobuffer.GetTradesRequest.Category.defaultCategory }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetTradesRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetTradesRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetTradesRequest
decodeProto__Io__Haveno__Protobuffer__GetTradesRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetTradesRequest
        [ Protobuf.Decode.optional
            1
            Proto.Io.Haveno.Protobuffer.GetTradesRequest.Category.decodeCategory
            (\a r -> { r | category = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetTradesRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetTradesRequest :
    Proto__Io__Haveno__Protobuffer__GetTradesRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetTradesRequest value =
    Protobuf.Encode.message
        [ ( 1, Proto.Io.Haveno.Protobuffer.GetTradesRequest.Category.encodeCategory value.category ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetTradesRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetTradesRequest =
    { category : Proto.Io.Haveno.Protobuffer.GetTradesRequest.Category.Category }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetTradeReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetTradeReply : { trade : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetTradeReply =
    { trade = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetTradeReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetTradeReply : Proto__Io__Haveno__Protobuffer__GetTradeReply
defaultProto__Io__Haveno__Protobuffer__GetTradeReply =
    { trade = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetTradeReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetTradeReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetTradeReply
decodeProto__Io__Haveno__Protobuffer__GetTradeReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetTradeReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__TradeInfo)
            (\a r -> { r | trade = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetTradeReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetTradeReply :
    Proto__Io__Haveno__Protobuffer__GetTradeReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetTradeReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__TradeInfo >> Maybe.withDefault Protobuf.Encode.none)
                value.trade
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__GetTradeReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetTradeReply =
    { trade : Maybe Proto__Io__Haveno__Protobuffer__TradeInfo }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetTradeRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetTradeRequest : { tradeId : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetTradeRequest =
    { tradeId = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetTradeRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetTradeRequest : Proto__Io__Haveno__Protobuffer__GetTradeRequest
defaultProto__Io__Haveno__Protobuffer__GetTradeRequest =
    { tradeId = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetTradeRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetTradeRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetTradeRequest
decodeProto__Io__Haveno__Protobuffer__GetTradeRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetTradeRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetTradeRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetTradeRequest :
    Proto__Io__Haveno__Protobuffer__GetTradeRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetTradeRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.tradeId ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetTradeRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetTradeRequest =
    { tradeId : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply :
    Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply
defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply
decodeProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply :
    Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest : { tradeId : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest =
    { tradeId = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest :
    Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest
defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest =
    { tradeId = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest
decodeProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest :
    Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.tradeId ) ]


{-| `Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__ConfirmPaymentReceivedRequest =
    { tradeId : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply : Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply
defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply
decodeProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply :
    Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest : { tradeId : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest =
    { tradeId = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest :
    Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest
defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest =
    { tradeId = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest
decodeProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest :
    Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.tradeId ) ]


{-| `Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__ConfirmPaymentSentRequest =
    { tradeId : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__TakeOfferReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__TakeOfferReply : { trade : Int, failureReason : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__TakeOfferReply =
    { trade = 1, failureReason = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__TakeOfferReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__TakeOfferReply : Proto__Io__Haveno__Protobuffer__TakeOfferReply
defaultProto__Io__Haveno__Protobuffer__TakeOfferReply =
    { trade = Nothing, failureReason = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__TakeOfferReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__TakeOfferReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__TakeOfferReply
decodeProto__Io__Haveno__Protobuffer__TakeOfferReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__TakeOfferReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__TradeInfo)
            (\a r -> { r | trade = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription)
            (\a r -> { r | failureReason = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__TakeOfferReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__TakeOfferReply :
    Proto__Io__Haveno__Protobuffer__TakeOfferReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__TakeOfferReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__TradeInfo >> Maybe.withDefault Protobuf.Encode.none)
                value.trade
          )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.failureReason
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__TakeOfferReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__TakeOfferReply =
    { trade : Maybe Proto__Io__Haveno__Protobuffer__TradeInfo
    , failureReason : Maybe Proto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__TakeOfferRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__TakeOfferRequest : { offerId : Int, paymentAccountId : Int, amount : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__TakeOfferRequest =
    { offerId = 1, paymentAccountId = 2, amount = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__TakeOfferRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__TakeOfferRequest : Proto__Io__Haveno__Protobuffer__TakeOfferRequest
defaultProto__Io__Haveno__Protobuffer__TakeOfferRequest =
    { offerId = "", paymentAccountId = "", amount = Protobuf.Types.Int64.fromInts 0 0 }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__TakeOfferRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__TakeOfferRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__TakeOfferRequest
decodeProto__Io__Haveno__Protobuffer__TakeOfferRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__TakeOfferRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | offerId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | paymentAccountId = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.uint64 (\a r -> { r | amount = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__TakeOfferRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__TakeOfferRequest :
    Proto__Io__Haveno__Protobuffer__TakeOfferRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__TakeOfferRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.offerId )
        , ( 2, Protobuf.Encode.string value.paymentAccountId )
        , ( 3, Protobuf.Encode.uint64 value.amount )
        ]


{-| `Proto__Io__Haveno__Protobuffer__TakeOfferRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__TakeOfferRequest =
    { offerId : String, paymentAccountId : String, amount : Protobuf.Types.Int64.Int64 }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StopReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__StopReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__StopReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__StopReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__StopReply : Proto__Io__Haveno__Protobuffer__StopReply
defaultProto__Io__Haveno__Protobuffer__StopReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__StopReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__StopReply : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__StopReply
decodeProto__Io__Haveno__Protobuffer__StopReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__StopReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__StopReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__StopReply : Proto__Io__Haveno__Protobuffer__StopReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__StopReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__StopReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__StopReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StopRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__StopRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__StopRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__StopRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__StopRequest : Proto__Io__Haveno__Protobuffer__StopRequest
defaultProto__Io__Haveno__Protobuffer__StopRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__StopRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__StopRequest : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__StopRequest
decodeProto__Io__Haveno__Protobuffer__StopRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__StopRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__StopRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__StopRequest :
    Proto__Io__Haveno__Protobuffer__StopRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__StopRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__StopRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__StopRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetTradeStatisticsReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply : { tradeStatistics : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply =
    { tradeStatistics = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetTradeStatisticsReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply : Proto__Io__Haveno__Protobuffer__GetTradeStatisticsReply
defaultProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply =
    { tradeStatistics = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetTradeStatisticsReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetTradeStatisticsReply
decodeProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__TradeStatistics3
            .tradeStatistics
            (\a r -> { r | tradeStatistics = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetTradeStatisticsReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply :
    Proto__Io__Haveno__Protobuffer__GetTradeStatisticsReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetTradeStatisticsReply value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__TradeStatistics3) value.tradeStatistics ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetTradeStatisticsReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetTradeStatisticsReply =
    { tradeStatistics : List Proto__Io__Haveno__Protobuffer__TradeStatistics3 }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest :
    Proto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest
defaultProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest
decodeProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest :
    Proto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetTradeStatisticsRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MarketDepthInfo`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MarketDepthInfo :
    { currencyCode : Int, buyPrices : Int, buyDepth : Int, sellPrices : Int, sellDepth : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MarketDepthInfo =
    { currencyCode = 1, buyPrices = 2, buyDepth = 3, sellPrices = 4, sellDepth = 5 }


{-| Default for Proto__Io__Haveno__Protobuffer__MarketDepthInfo. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MarketDepthInfo : Proto__Io__Haveno__Protobuffer__MarketDepthInfo
defaultProto__Io__Haveno__Protobuffer__MarketDepthInfo =
    { currencyCode = "", buyPrices = [], buyDepth = [], sellPrices = [], sellDepth = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MarketDepthInfo` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MarketDepthInfo :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MarketDepthInfo
decodeProto__Io__Haveno__Protobuffer__MarketDepthInfo =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MarketDepthInfo
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | currencyCode = a })
        , Protobuf.Decode.repeated 2 Protobuf.Decode.double .buyPrices (\a r -> { r | buyPrices = a })
        , Protobuf.Decode.repeated 3 Protobuf.Decode.double .buyDepth (\a r -> { r | buyDepth = a })
        , Protobuf.Decode.repeated 4 Protobuf.Decode.double .sellPrices (\a r -> { r | sellPrices = a })
        , Protobuf.Decode.repeated 5 Protobuf.Decode.double .sellDepth (\a r -> { r | sellDepth = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MarketDepthInfo` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MarketDepthInfo :
    Proto__Io__Haveno__Protobuffer__MarketDepthInfo -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MarketDepthInfo value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.currencyCode )
        , ( 2, (Protobuf.Encode.list Protobuf.Encode.double) value.buyPrices )
        , ( 3, (Protobuf.Encode.list Protobuf.Encode.double) value.buyDepth )
        , ( 4, (Protobuf.Encode.list Protobuf.Encode.double) value.sellPrices )
        , ( 5, (Protobuf.Encode.list Protobuf.Encode.double) value.sellDepth )
        ]


{-| `Proto__Io__Haveno__Protobuffer__MarketDepthInfo` message

-}
type alias Proto__Io__Haveno__Protobuffer__MarketDepthInfo =
    { currencyCode : String
    , buyPrices : List Float
    , buyDepth : List Float
    , sellPrices : List Float
    , sellDepth : List Float
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MarketDepthReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MarketDepthReply : { marketDepth : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MarketDepthReply =
    { marketDepth = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__MarketDepthReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MarketDepthReply : Proto__Io__Haveno__Protobuffer__MarketDepthReply
defaultProto__Io__Haveno__Protobuffer__MarketDepthReply =
    { marketDepth = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MarketDepthReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MarketDepthReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MarketDepthReply
decodeProto__Io__Haveno__Protobuffer__MarketDepthReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MarketDepthReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__MarketDepthInfo)
            (\a r -> { r | marketDepth = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MarketDepthReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MarketDepthReply :
    Proto__Io__Haveno__Protobuffer__MarketDepthReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MarketDepthReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__MarketDepthInfo >> Maybe.withDefault Protobuf.Encode.none)
                value.marketDepth
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__MarketDepthReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__MarketDepthReply =
    { marketDepth : Maybe Proto__Io__Haveno__Protobuffer__MarketDepthInfo }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MarketDepthRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MarketDepthRequest : { currencyCode : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MarketDepthRequest =
    { currencyCode = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__MarketDepthRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MarketDepthRequest : Proto__Io__Haveno__Protobuffer__MarketDepthRequest
defaultProto__Io__Haveno__Protobuffer__MarketDepthRequest =
    { currencyCode = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MarketDepthRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MarketDepthRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MarketDepthRequest
decodeProto__Io__Haveno__Protobuffer__MarketDepthRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MarketDepthRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | currencyCode = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MarketDepthRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MarketDepthRequest :
    Proto__Io__Haveno__Protobuffer__MarketDepthRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MarketDepthRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.currencyCode ) ]


{-| `Proto__Io__Haveno__Protobuffer__MarketDepthRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__MarketDepthRequest =
    { currencyCode : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MarketPriceInfo`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MarketPriceInfo : { currencyCode : Int, price : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MarketPriceInfo =
    { currencyCode = 1, price = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__MarketPriceInfo. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MarketPriceInfo : Proto__Io__Haveno__Protobuffer__MarketPriceInfo
defaultProto__Io__Haveno__Protobuffer__MarketPriceInfo =
    { currencyCode = "", price = 0 }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MarketPriceInfo` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MarketPriceInfo :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MarketPriceInfo
decodeProto__Io__Haveno__Protobuffer__MarketPriceInfo =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MarketPriceInfo
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | currencyCode = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.double (\a r -> { r | price = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MarketPriceInfo` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MarketPriceInfo :
    Proto__Io__Haveno__Protobuffer__MarketPriceInfo -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MarketPriceInfo value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.currencyCode ), ( 2, Protobuf.Encode.double value.price ) ]


{-| `Proto__Io__Haveno__Protobuffer__MarketPriceInfo` message

-}
type alias Proto__Io__Haveno__Protobuffer__MarketPriceInfo =
    { currencyCode : String, price : Float }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MarketPricesReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MarketPricesReply : { marketPrice : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MarketPricesReply =
    { marketPrice = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__MarketPricesReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MarketPricesReply : Proto__Io__Haveno__Protobuffer__MarketPricesReply
defaultProto__Io__Haveno__Protobuffer__MarketPricesReply =
    { marketPrice = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MarketPricesReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MarketPricesReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MarketPricesReply
decodeProto__Io__Haveno__Protobuffer__MarketPricesReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MarketPricesReply
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__MarketPriceInfo
            .marketPrice
            (\a r -> { r | marketPrice = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MarketPricesReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MarketPricesReply :
    Proto__Io__Haveno__Protobuffer__MarketPricesReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MarketPricesReply value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__MarketPriceInfo) value.marketPrice ) ]


{-| `Proto__Io__Haveno__Protobuffer__MarketPricesReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__MarketPricesReply =
    { marketPrice : List Proto__Io__Haveno__Protobuffer__MarketPriceInfo }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MarketPricesRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MarketPricesRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__MarketPricesRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__MarketPricesRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MarketPricesRequest : Proto__Io__Haveno__Protobuffer__MarketPricesRequest
defaultProto__Io__Haveno__Protobuffer__MarketPricesRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MarketPricesRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MarketPricesRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MarketPricesRequest
decodeProto__Io__Haveno__Protobuffer__MarketPricesRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__MarketPricesRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MarketPricesRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MarketPricesRequest :
    Proto__Io__Haveno__Protobuffer__MarketPricesRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MarketPricesRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__MarketPricesRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__MarketPricesRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MarketPriceReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MarketPriceReply : { price : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MarketPriceReply =
    { price = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__MarketPriceReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MarketPriceReply : Proto__Io__Haveno__Protobuffer__MarketPriceReply
defaultProto__Io__Haveno__Protobuffer__MarketPriceReply =
    { price = 0 }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MarketPriceReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MarketPriceReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MarketPriceReply
decodeProto__Io__Haveno__Protobuffer__MarketPriceReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MarketPriceReply
        [ Protobuf.Decode.optional 1 Protobuf.Decode.double (\a r -> { r | price = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MarketPriceReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MarketPriceReply :
    Proto__Io__Haveno__Protobuffer__MarketPriceReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MarketPriceReply value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.double value.price ) ]


{-| `Proto__Io__Haveno__Protobuffer__MarketPriceReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__MarketPriceReply =
    { price : Float }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MarketPriceRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MarketPriceRequest : { currencyCode : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MarketPriceRequest =
    { currencyCode = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__MarketPriceRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MarketPriceRequest : Proto__Io__Haveno__Protobuffer__MarketPriceRequest
defaultProto__Io__Haveno__Protobuffer__MarketPriceRequest =
    { currencyCode = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MarketPriceRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MarketPriceRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MarketPriceRequest
decodeProto__Io__Haveno__Protobuffer__MarketPriceRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MarketPriceRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | currencyCode = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MarketPriceRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MarketPriceRequest :
    Proto__Io__Haveno__Protobuffer__MarketPriceRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MarketPriceRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.currencyCode ) ]


{-| `Proto__Io__Haveno__Protobuffer__MarketPriceRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__MarketPriceRequest =
    { currencyCode : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ValidateFormFieldReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ValidateFormFieldReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__ValidateFormFieldReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__ValidateFormFieldReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ValidateFormFieldReply : Proto__Io__Haveno__Protobuffer__ValidateFormFieldReply
defaultProto__Io__Haveno__Protobuffer__ValidateFormFieldReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ValidateFormFieldReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ValidateFormFieldReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ValidateFormFieldReply
decodeProto__Io__Haveno__Protobuffer__ValidateFormFieldReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__ValidateFormFieldReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ValidateFormFieldReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ValidateFormFieldReply :
    Proto__Io__Haveno__Protobuffer__ValidateFormFieldReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ValidateFormFieldReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__ValidateFormFieldReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__ValidateFormFieldReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ValidateFormFieldRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest : { form : Int, fieldId : Int, value : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest =
    { form = 1, fieldId = 2, value = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__ValidateFormFieldRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest :
    Proto__Io__Haveno__Protobuffer__ValidateFormFieldRequest
defaultProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest =
    { form = Nothing, fieldId = Proto.Io.Haveno.Protobuffer.PaymentAccountFormField.FieldId.defaultFieldId, value = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ValidateFormFieldRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ValidateFormFieldRequest
decodeProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentAccountForm)
            (\a r -> { r | form = a })
        , Protobuf.Decode.optional
            2
            Proto.Io.Haveno.Protobuffer.PaymentAccountFormField.FieldId.decodeFieldId
            (\a r -> { r | fieldId = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | value = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ValidateFormFieldRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest :
    Proto__Io__Haveno__Protobuffer__ValidateFormFieldRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ValidateFormFieldRequest value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentAccountForm
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.form
          )
        , ( 2, Proto.Io.Haveno.Protobuffer.PaymentAccountFormField.FieldId.encodeFieldId value.fieldId )
        , ( 3, Protobuf.Encode.string value.value )
        ]


{-| `Proto__Io__Haveno__Protobuffer__ValidateFormFieldRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__ValidateFormFieldRequest =
    { form : Maybe Proto__Io__Haveno__Protobuffer__PaymentAccountForm
    , fieldId : Proto.Io.Haveno.Protobuffer.PaymentAccountFormField.FieldId.FieldId
    , value : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply : { paymentMethods : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply =
    { paymentMethods = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply :
    Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply
defaultProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply =
    { paymentMethods = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply
decodeProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__PaymentMethod
            .paymentMethods
            (\a r -> { r | paymentMethods = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply :
    Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__PaymentMethod) value.paymentMethods ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsReply =
    { paymentMethods : List Proto__Io__Haveno__Protobuffer__PaymentMethod }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest :
    Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest
defaultProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest
decodeProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest :
    Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetCryptoCurrencyPaymentMethodsRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply : { paymentAccount : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply =
    { paymentAccount = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply :
    Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply
defaultProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply =
    { paymentAccount = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply
decodeProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentAccount)
            (\a r -> { r | paymentAccount = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply :
    Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentAccount >> Maybe.withDefault Protobuf.Encode.none)
                value.paymentAccount
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountReply =
    { paymentAccount : Maybe Proto__Io__Haveno__Protobuffer__PaymentAccount }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest :
    { accountName : Int, currencyCode : Int, address : Int, tradeInstant : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest =
    { accountName = 1, currencyCode = 2, address = 3, tradeInstant = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest :
    Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest
defaultProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest =
    { accountName = "", currencyCode = "", address = "", tradeInstant = False }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest
decodeProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | accountName = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | currencyCode = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | address = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.bool (\a r -> { r | tradeInstant = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest :
    Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.accountName )
        , ( 2, Protobuf.Encode.string value.currencyCode )
        , ( 3, Protobuf.Encode.string value.address )
        , ( 4, Protobuf.Encode.bool value.tradeInstant )
        ]


{-| `Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__CreateCryptoCurrencyPaymentAccountRequest =
    { accountName : String, currencyCode : String, address : String, tradeInstant : Bool }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply : { paymentAccountFormAsJson : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply =
    { paymentAccountFormAsJson = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply :
    Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply
defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply =
    { paymentAccountFormAsJson = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply
decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | paymentAccountFormAsJson = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply :
    Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.paymentAccountFormAsJson ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonReply =
    { paymentAccountFormAsJson : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest : { paymentMethodId : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest =
    { paymentMethodId = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest :
    Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest
defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest =
    { paymentMethodId = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest
decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | paymentMethodId = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest :
    Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.paymentMethodId ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormAsJsonRequest =
    { paymentMethodId : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply : { paymentAccountForm : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply =
    { paymentAccountForm = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply :
    Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply
defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply =
    { paymentAccountForm = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply
decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentAccountForm)
            (\a r -> { r | paymentAccountForm = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply :
    Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentAccountForm
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.paymentAccountForm
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormReply =
    { paymentAccountForm : Maybe Proto__Io__Haveno__Protobuffer__PaymentAccountForm }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest :
    { paymentMethodId : Int, paymentAccountPayload : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest =
    { paymentMethodId = 1, paymentAccountPayload = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest :
    Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest
defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest =
    { paymentMethodId = "", paymentAccountPayload = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest
decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | paymentMethodId = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload)
            (\a r -> { r | paymentAccountPayload = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest :
    Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.paymentMethodId )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.paymentAccountPayload
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetPaymentAccountFormRequest =
    { paymentMethodId : String, paymentAccountPayload : Maybe Proto__Io__Haveno__Protobuffer__PaymentAccountPayload }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetPaymentMethodsReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply : { paymentMethods : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply =
    { paymentMethods = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetPaymentMethodsReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply : Proto__Io__Haveno__Protobuffer__GetPaymentMethodsReply
defaultProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply =
    { paymentMethods = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetPaymentMethodsReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetPaymentMethodsReply
decodeProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__PaymentMethod
            .paymentMethods
            (\a r -> { r | paymentMethods = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetPaymentMethodsReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply :
    Proto__Io__Haveno__Protobuffer__GetPaymentMethodsReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetPaymentMethodsReply value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__PaymentMethod) value.paymentMethods ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetPaymentMethodsReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetPaymentMethodsReply =
    { paymentMethods : List Proto__Io__Haveno__Protobuffer__PaymentMethod }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest :
    Proto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest
defaultProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest
decodeProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest :
    Proto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetPaymentMethodsRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetPaymentAccountsReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply : { paymentAccounts : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply =
    { paymentAccounts = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetPaymentAccountsReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply : Proto__Io__Haveno__Protobuffer__GetPaymentAccountsReply
defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply =
    { paymentAccounts = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetPaymentAccountsReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetPaymentAccountsReply
decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__PaymentAccount
            .paymentAccounts
            (\a r -> { r | paymentAccounts = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetPaymentAccountsReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply :
    Proto__Io__Haveno__Protobuffer__GetPaymentAccountsReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountsReply value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__PaymentAccount) value.paymentAccounts ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetPaymentAccountsReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetPaymentAccountsReply =
    { paymentAccounts : List Proto__Io__Haveno__Protobuffer__PaymentAccount }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest :
    Proto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest
defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest
decodeProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest :
    Proto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetPaymentAccountsRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CreatePaymentAccountReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply : { paymentAccount : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply =
    { paymentAccount = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__CreatePaymentAccountReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply :
    Proto__Io__Haveno__Protobuffer__CreatePaymentAccountReply
defaultProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply =
    { paymentAccount = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CreatePaymentAccountReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CreatePaymentAccountReply
decodeProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentAccount)
            (\a r -> { r | paymentAccount = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CreatePaymentAccountReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply :
    Proto__Io__Haveno__Protobuffer__CreatePaymentAccountReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CreatePaymentAccountReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentAccount >> Maybe.withDefault Protobuf.Encode.none)
                value.paymentAccount
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__CreatePaymentAccountReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__CreatePaymentAccountReply =
    { paymentAccount : Maybe Proto__Io__Haveno__Protobuffer__PaymentAccount }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest :
    { paymentAccountForm : Int, paymentAccountFormAsJson : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest =
    { paymentAccountForm = 1, paymentAccountFormAsJson = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest :
    Proto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest
defaultProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest =
    { paymentAccountForm = Nothing, paymentAccountFormAsJson = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest
decodeProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentAccountForm)
            (\a r -> { r | paymentAccountForm = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | paymentAccountFormAsJson = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest :
    Proto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentAccountForm
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.paymentAccountForm
          )
        , ( 2, Protobuf.Encode.string value.paymentAccountFormAsJson )
        ]


{-| `Proto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__CreatePaymentAccountRequest =
    { paymentAccountForm : Maybe Proto__Io__Haveno__Protobuffer__PaymentAccountForm, paymentAccountFormAsJson : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription :
    { availabilityResult : Int, description : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription =
    { availabilityResult = 1, description = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription :
    Proto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription
defaultProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription =
    { availabilityResult = Proto.Io.Haveno.Protobuffer.AvailabilityResult.defaultAvailabilityResult, description = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription
decodeProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription
        [ Protobuf.Decode.optional
            1
            Proto.Io.Haveno.Protobuffer.AvailabilityResult.decodeAvailabilityResult
            (\a r -> { r | availabilityResult = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | description = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription :
    Proto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription value =
    Protobuf.Encode.message
        [ ( 1, Proto.Io.Haveno.Protobuffer.AvailabilityResult.encodeAvailabilityResult value.availabilityResult )
        , ( 2, Protobuf.Encode.string value.description )
        ]


{-| `Proto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription` message

-}
type alias Proto__Io__Haveno__Protobuffer__AvailabilityResultWithDescription =
    { availabilityResult : Proto.Io.Haveno.Protobuffer.AvailabilityResult.AvailabilityResult, description : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__OfferInfo`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__OfferInfo :
    { id : Int
    , direction : Int
    , price : Int
    , useMarketBasedPrice : Int
    , marketPriceMarginPct : Int
    , amount : Int
    , minAmount : Int
    , makerFeePct : Int
    , takerFeePct : Int
    , penaltyFeePct : Int
    , buyerSecurityDepositPct : Int
    , sellerSecurityDepositPct : Int
    , volume : Int
    , minVolume : Int
    , triggerPrice : Int
    , paymentAccountId : Int
    , paymentMethodId : Int
    , paymentMethodShortName : Int
    , baseCurrencyCode : Int
    , counterCurrencyCode : Int
    , date : Int
    , state : Int
    , isActivated : Int
    , isMyOffer : Int
    , ownerNodeAddress : Int
    , pubKeyRing : Int
    , versionNr : Int
    , protocolVersion : Int
    , arbitratorSigner : Int
    , splitOutputTxHash : Int
    , splitOutputTxFee : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__OfferInfo =
    { id = 1
    , direction = 2
    , price = 3
    , useMarketBasedPrice = 4
    , marketPriceMarginPct = 5
    , amount = 6
    , minAmount = 7
    , makerFeePct = 8
    , takerFeePct = 9
    , penaltyFeePct = 10
    , buyerSecurityDepositPct = 11
    , sellerSecurityDepositPct = 12
    , volume = 13
    , minVolume = 14
    , triggerPrice = 15
    , paymentAccountId = 16
    , paymentMethodId = 17
    , paymentMethodShortName = 18
    , baseCurrencyCode = 19
    , counterCurrencyCode = 20
    , date = 21
    , state = 22
    , isActivated = 23
    , isMyOffer = 24
    , ownerNodeAddress = 25
    , pubKeyRing = 26
    , versionNr = 27
    , protocolVersion = 28
    , arbitratorSigner = 29
    , splitOutputTxHash = 30
    , splitOutputTxFee = 31
    }


{-| Default for Proto__Io__Haveno__Protobuffer__OfferInfo. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__OfferInfo : Proto__Io__Haveno__Protobuffer__OfferInfo
defaultProto__Io__Haveno__Protobuffer__OfferInfo =
    { id = ""
    , direction = ""
    , price = ""
    , useMarketBasedPrice = False
    , marketPriceMarginPct = 0
    , amount = Protobuf.Types.Int64.fromInts 0 0
    , minAmount = Protobuf.Types.Int64.fromInts 0 0
    , makerFeePct = 0
    , takerFeePct = 0
    , penaltyFeePct = 0
    , buyerSecurityDepositPct = 0
    , sellerSecurityDepositPct = 0
    , volume = ""
    , minVolume = ""
    , triggerPrice = ""
    , paymentAccountId = ""
    , paymentMethodId = ""
    , paymentMethodShortName = ""
    , baseCurrencyCode = ""
    , counterCurrencyCode = ""
    , date = Protobuf.Types.Int64.fromInts 0 0
    , state = ""
    , isActivated = False
    , isMyOffer = False
    , ownerNodeAddress = ""
    , pubKeyRing = ""
    , versionNr = ""
    , protocolVersion = 0
    , arbitratorSigner = ""
    , splitOutputTxHash = ""
    , splitOutputTxFee = Protobuf.Types.Int64.fromInts 0 0
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__OfferInfo` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__OfferInfo : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__OfferInfo
decodeProto__Io__Haveno__Protobuffer__OfferInfo =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__OfferInfo
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | id = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | direction = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | price = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.bool (\a r -> { r | useMarketBasedPrice = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.double (\a r -> { r | marketPriceMarginPct = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.uint64 (\a r -> { r | amount = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.uint64 (\a r -> { r | minAmount = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.double (\a r -> { r | makerFeePct = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.double (\a r -> { r | takerFeePct = a })
        , Protobuf.Decode.optional 10 Protobuf.Decode.double (\a r -> { r | penaltyFeePct = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.double (\a r -> { r | buyerSecurityDepositPct = a })
        , Protobuf.Decode.optional 12 Protobuf.Decode.double (\a r -> { r | sellerSecurityDepositPct = a })
        , Protobuf.Decode.optional 13 Protobuf.Decode.string (\a r -> { r | volume = a })
        , Protobuf.Decode.optional 14 Protobuf.Decode.string (\a r -> { r | minVolume = a })
        , Protobuf.Decode.optional 15 Protobuf.Decode.string (\a r -> { r | triggerPrice = a })
        , Protobuf.Decode.optional 16 Protobuf.Decode.string (\a r -> { r | paymentAccountId = a })
        , Protobuf.Decode.optional 17 Protobuf.Decode.string (\a r -> { r | paymentMethodId = a })
        , Protobuf.Decode.optional 18 Protobuf.Decode.string (\a r -> { r | paymentMethodShortName = a })
        , Protobuf.Decode.optional 19 Protobuf.Decode.string (\a r -> { r | baseCurrencyCode = a })
        , Protobuf.Decode.optional 20 Protobuf.Decode.string (\a r -> { r | counterCurrencyCode = a })
        , Protobuf.Decode.optional 21 Protobuf.Decode.uint64 (\a r -> { r | date = a })
        , Protobuf.Decode.optional 22 Protobuf.Decode.string (\a r -> { r | state = a })
        , Protobuf.Decode.optional 23 Protobuf.Decode.bool (\a r -> { r | isActivated = a })
        , Protobuf.Decode.optional 24 Protobuf.Decode.bool (\a r -> { r | isMyOffer = a })
        , Protobuf.Decode.optional 25 Protobuf.Decode.string (\a r -> { r | ownerNodeAddress = a })
        , Protobuf.Decode.optional 26 Protobuf.Decode.string (\a r -> { r | pubKeyRing = a })
        , Protobuf.Decode.optional 27 Protobuf.Decode.string (\a r -> { r | versionNr = a })
        , Protobuf.Decode.optional 28 Protobuf.Decode.int32 (\a r -> { r | protocolVersion = a })
        , Protobuf.Decode.optional 29 Protobuf.Decode.string (\a r -> { r | arbitratorSigner = a })
        , Protobuf.Decode.optional 30 Protobuf.Decode.string (\a r -> { r | splitOutputTxHash = a })
        , Protobuf.Decode.optional 31 Protobuf.Decode.uint64 (\a r -> { r | splitOutputTxFee = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__OfferInfo` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__OfferInfo : Proto__Io__Haveno__Protobuffer__OfferInfo -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__OfferInfo value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.id )
        , ( 2, Protobuf.Encode.string value.direction )
        , ( 3, Protobuf.Encode.string value.price )
        , ( 4, Protobuf.Encode.bool value.useMarketBasedPrice )
        , ( 5, Protobuf.Encode.double value.marketPriceMarginPct )
        , ( 6, Protobuf.Encode.uint64 value.amount )
        , ( 7, Protobuf.Encode.uint64 value.minAmount )
        , ( 8, Protobuf.Encode.double value.makerFeePct )
        , ( 9, Protobuf.Encode.double value.takerFeePct )
        , ( 10, Protobuf.Encode.double value.penaltyFeePct )
        , ( 11, Protobuf.Encode.double value.buyerSecurityDepositPct )
        , ( 12, Protobuf.Encode.double value.sellerSecurityDepositPct )
        , ( 13, Protobuf.Encode.string value.volume )
        , ( 14, Protobuf.Encode.string value.minVolume )
        , ( 15, Protobuf.Encode.string value.triggerPrice )
        , ( 16, Protobuf.Encode.string value.paymentAccountId )
        , ( 17, Protobuf.Encode.string value.paymentMethodId )
        , ( 18, Protobuf.Encode.string value.paymentMethodShortName )
        , ( 19, Protobuf.Encode.string value.baseCurrencyCode )
        , ( 20, Protobuf.Encode.string value.counterCurrencyCode )
        , ( 21, Protobuf.Encode.uint64 value.date )
        , ( 22, Protobuf.Encode.string value.state )
        , ( 23, Protobuf.Encode.bool value.isActivated )
        , ( 24, Protobuf.Encode.bool value.isMyOffer )
        , ( 25, Protobuf.Encode.string value.ownerNodeAddress )
        , ( 26, Protobuf.Encode.string value.pubKeyRing )
        , ( 27, Protobuf.Encode.string value.versionNr )
        , ( 28, Protobuf.Encode.int32 value.protocolVersion )
        , ( 29, Protobuf.Encode.string value.arbitratorSigner )
        , ( 30, Protobuf.Encode.string value.splitOutputTxHash )
        , ( 31, Protobuf.Encode.uint64 value.splitOutputTxFee )
        ]


{-| `Proto__Io__Haveno__Protobuffer__OfferInfo` message

-}
type alias Proto__Io__Haveno__Protobuffer__OfferInfo =
    { id : String
    , direction : String
    , price : String
    , useMarketBasedPrice : Bool
    , marketPriceMarginPct : Float
    , amount : Protobuf.Types.Int64.Int64
    , minAmount : Protobuf.Types.Int64.Int64
    , makerFeePct : Float
    , takerFeePct : Float
    , penaltyFeePct : Float
    , buyerSecurityDepositPct : Float
    , sellerSecurityDepositPct : Float
    , volume : String
    , minVolume : String
    , triggerPrice : String
    , paymentAccountId : String
    , paymentMethodId : String
    , paymentMethodShortName : String
    , baseCurrencyCode : String
    , counterCurrencyCode : String
    , date : Protobuf.Types.Int64.Int64
    , state : String
    , isActivated : Bool
    , isMyOffer : Bool
    , ownerNodeAddress : String
    , pubKeyRing : String
    , versionNr : String
    , protocolVersion : Int
    , arbitratorSigner : String
    , splitOutputTxHash : String
    , splitOutputTxFee : Protobuf.Types.Int64.Int64
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CancelOfferReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CancelOfferReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__CancelOfferReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__CancelOfferReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CancelOfferReply : Proto__Io__Haveno__Protobuffer__CancelOfferReply
defaultProto__Io__Haveno__Protobuffer__CancelOfferReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CancelOfferReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CancelOfferReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CancelOfferReply
decodeProto__Io__Haveno__Protobuffer__CancelOfferReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__CancelOfferReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CancelOfferReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CancelOfferReply :
    Proto__Io__Haveno__Protobuffer__CancelOfferReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CancelOfferReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__CancelOfferReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__CancelOfferReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CancelOfferRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CancelOfferRequest : { id : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CancelOfferRequest =
    { id = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__CancelOfferRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CancelOfferRequest : Proto__Io__Haveno__Protobuffer__CancelOfferRequest
defaultProto__Io__Haveno__Protobuffer__CancelOfferRequest =
    { id = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CancelOfferRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CancelOfferRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CancelOfferRequest
decodeProto__Io__Haveno__Protobuffer__CancelOfferRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CancelOfferRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | id = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CancelOfferRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CancelOfferRequest :
    Proto__Io__Haveno__Protobuffer__CancelOfferRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CancelOfferRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.id ) ]


{-| `Proto__Io__Haveno__Protobuffer__CancelOfferRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__CancelOfferRequest =
    { id : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PostOfferReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PostOfferReply : { offer : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PostOfferReply =
    { offer = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__PostOfferReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PostOfferReply : Proto__Io__Haveno__Protobuffer__PostOfferReply
defaultProto__Io__Haveno__Protobuffer__PostOfferReply =
    { offer = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PostOfferReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PostOfferReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PostOfferReply
decodeProto__Io__Haveno__Protobuffer__PostOfferReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PostOfferReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__OfferInfo)
            (\a r -> { r | offer = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PostOfferReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PostOfferReply :
    Proto__Io__Haveno__Protobuffer__PostOfferReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PostOfferReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__OfferInfo >> Maybe.withDefault Protobuf.Encode.none)
                value.offer
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PostOfferReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__PostOfferReply =
    { offer : Maybe Proto__Io__Haveno__Protobuffer__OfferInfo }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PostOfferRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PostOfferRequest :
    { currencyCode : Int
    , direction : Int
    , price : Int
    , useMarketBasedPrice : Int
    , marketPriceMarginPct : Int
    , amount : Int
    , minAmount : Int
    , buyerSecurityDepositPct : Int
    , triggerPrice : Int
    , reserveExactAmount : Int
    , paymentAccountId : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__PostOfferRequest =
    { currencyCode = 1
    , direction = 2
    , price = 3
    , useMarketBasedPrice = 4
    , marketPriceMarginPct = 5
    , amount = 6
    , minAmount = 7
    , buyerSecurityDepositPct = 8
    , triggerPrice = 9
    , reserveExactAmount = 10
    , paymentAccountId = 11
    }


{-| Default for Proto__Io__Haveno__Protobuffer__PostOfferRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PostOfferRequest : Proto__Io__Haveno__Protobuffer__PostOfferRequest
defaultProto__Io__Haveno__Protobuffer__PostOfferRequest =
    { currencyCode = ""
    , direction = ""
    , price = ""
    , useMarketBasedPrice = False
    , marketPriceMarginPct = 0
    , amount = Protobuf.Types.Int64.fromInts 0 0
    , minAmount = Protobuf.Types.Int64.fromInts 0 0
    , buyerSecurityDepositPct = 0
    , triggerPrice = ""
    , reserveExactAmount = False
    , paymentAccountId = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PostOfferRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PostOfferRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PostOfferRequest
decodeProto__Io__Haveno__Protobuffer__PostOfferRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PostOfferRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | currencyCode = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | direction = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | price = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.bool (\a r -> { r | useMarketBasedPrice = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.double (\a r -> { r | marketPriceMarginPct = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.uint64 (\a r -> { r | amount = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.uint64 (\a r -> { r | minAmount = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.double (\a r -> { r | buyerSecurityDepositPct = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.string (\a r -> { r | triggerPrice = a })
        , Protobuf.Decode.optional 10 Protobuf.Decode.bool (\a r -> { r | reserveExactAmount = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.string (\a r -> { r | paymentAccountId = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PostOfferRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PostOfferRequest :
    Proto__Io__Haveno__Protobuffer__PostOfferRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PostOfferRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.currencyCode )
        , ( 2, Protobuf.Encode.string value.direction )
        , ( 3, Protobuf.Encode.string value.price )
        , ( 4, Protobuf.Encode.bool value.useMarketBasedPrice )
        , ( 5, Protobuf.Encode.double value.marketPriceMarginPct )
        , ( 6, Protobuf.Encode.uint64 value.amount )
        , ( 7, Protobuf.Encode.uint64 value.minAmount )
        , ( 8, Protobuf.Encode.double value.buyerSecurityDepositPct )
        , ( 9, Protobuf.Encode.string value.triggerPrice )
        , ( 10, Protobuf.Encode.bool value.reserveExactAmount )
        , ( 11, Protobuf.Encode.string value.paymentAccountId )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PostOfferRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__PostOfferRequest =
    { currencyCode : String
    , direction : String
    , price : String
    , useMarketBasedPrice : Bool
    , marketPriceMarginPct : Float
    , amount : Protobuf.Types.Int64.Int64
    , minAmount : Protobuf.Types.Int64.Int64
    , buyerSecurityDepositPct : Float
    , triggerPrice : String
    , reserveExactAmount : Bool
    , paymentAccountId : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetMyOffersReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetMyOffersReply : { offers : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetMyOffersReply =
    { offers = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetMyOffersReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetMyOffersReply : Proto__Io__Haveno__Protobuffer__GetMyOffersReply
defaultProto__Io__Haveno__Protobuffer__GetMyOffersReply =
    { offers = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetMyOffersReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetMyOffersReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetMyOffersReply
decodeProto__Io__Haveno__Protobuffer__GetMyOffersReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetMyOffersReply
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__OfferInfo
            .offers
            (\a r -> { r | offers = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetMyOffersReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetMyOffersReply :
    Proto__Io__Haveno__Protobuffer__GetMyOffersReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetMyOffersReply value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__OfferInfo) value.offers ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetMyOffersReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetMyOffersReply =
    { offers : List Proto__Io__Haveno__Protobuffer__OfferInfo }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetMyOffersRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetMyOffersRequest : { direction : Int, currencyCode : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetMyOffersRequest =
    { direction = 1, currencyCode = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetMyOffersRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetMyOffersRequest : Proto__Io__Haveno__Protobuffer__GetMyOffersRequest
defaultProto__Io__Haveno__Protobuffer__GetMyOffersRequest =
    { direction = "", currencyCode = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetMyOffersRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetMyOffersRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetMyOffersRequest
decodeProto__Io__Haveno__Protobuffer__GetMyOffersRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetMyOffersRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | direction = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | currencyCode = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetMyOffersRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetMyOffersRequest :
    Proto__Io__Haveno__Protobuffer__GetMyOffersRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetMyOffersRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.direction ), ( 2, Protobuf.Encode.string value.currencyCode ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetMyOffersRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetMyOffersRequest =
    { direction : String, currencyCode : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetOffersReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetOffersReply : { offers : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetOffersReply =
    { offers = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetOffersReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetOffersReply : Proto__Io__Haveno__Protobuffer__GetOffersReply
defaultProto__Io__Haveno__Protobuffer__GetOffersReply =
    { offers = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetOffersReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetOffersReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetOffersReply
decodeProto__Io__Haveno__Protobuffer__GetOffersReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetOffersReply
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__OfferInfo
            .offers
            (\a r -> { r | offers = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetOffersReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetOffersReply :
    Proto__Io__Haveno__Protobuffer__GetOffersReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetOffersReply value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__OfferInfo) value.offers ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetOffersReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetOffersReply =
    { offers : List Proto__Io__Haveno__Protobuffer__OfferInfo }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetOffersRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetOffersRequest : { direction : Int, currencyCode : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetOffersRequest =
    { direction = 1, currencyCode = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetOffersRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetOffersRequest : Proto__Io__Haveno__Protobuffer__GetOffersRequest
defaultProto__Io__Haveno__Protobuffer__GetOffersRequest =
    { direction = "", currencyCode = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetOffersRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetOffersRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetOffersRequest
decodeProto__Io__Haveno__Protobuffer__GetOffersRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetOffersRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | direction = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | currencyCode = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetOffersRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetOffersRequest :
    Proto__Io__Haveno__Protobuffer__GetOffersRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetOffersRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.direction ), ( 2, Protobuf.Encode.string value.currencyCode ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetOffersRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetOffersRequest =
    { direction : String, currencyCode : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetMyOfferReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetMyOfferReply : { offer : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetMyOfferReply =
    { offer = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetMyOfferReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetMyOfferReply : Proto__Io__Haveno__Protobuffer__GetMyOfferReply
defaultProto__Io__Haveno__Protobuffer__GetMyOfferReply =
    { offer = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetMyOfferReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetMyOfferReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetMyOfferReply
decodeProto__Io__Haveno__Protobuffer__GetMyOfferReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetMyOfferReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__OfferInfo)
            (\a r -> { r | offer = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetMyOfferReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetMyOfferReply :
    Proto__Io__Haveno__Protobuffer__GetMyOfferReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetMyOfferReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__OfferInfo >> Maybe.withDefault Protobuf.Encode.none)
                value.offer
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__GetMyOfferReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetMyOfferReply =
    { offer : Maybe Proto__Io__Haveno__Protobuffer__OfferInfo }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetMyOfferRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetMyOfferRequest : { id : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetMyOfferRequest =
    { id = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetMyOfferRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetMyOfferRequest : Proto__Io__Haveno__Protobuffer__GetMyOfferRequest
defaultProto__Io__Haveno__Protobuffer__GetMyOfferRequest =
    { id = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetMyOfferRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetMyOfferRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetMyOfferRequest
decodeProto__Io__Haveno__Protobuffer__GetMyOfferRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetMyOfferRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | id = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetMyOfferRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetMyOfferRequest :
    Proto__Io__Haveno__Protobuffer__GetMyOfferRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetMyOfferRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.id ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetMyOfferRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetMyOfferRequest =
    { id : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetOfferReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetOfferReply : { offer : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetOfferReply =
    { offer = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetOfferReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetOfferReply : Proto__Io__Haveno__Protobuffer__GetOfferReply
defaultProto__Io__Haveno__Protobuffer__GetOfferReply =
    { offer = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetOfferReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetOfferReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetOfferReply
decodeProto__Io__Haveno__Protobuffer__GetOfferReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetOfferReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__OfferInfo)
            (\a r -> { r | offer = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetOfferReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetOfferReply :
    Proto__Io__Haveno__Protobuffer__GetOfferReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetOfferReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__OfferInfo >> Maybe.withDefault Protobuf.Encode.none)
                value.offer
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__GetOfferReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetOfferReply =
    { offer : Maybe Proto__Io__Haveno__Protobuffer__OfferInfo }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetOfferRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetOfferRequest : { id : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetOfferRequest =
    { id = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetOfferRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetOfferRequest : Proto__Io__Haveno__Protobuffer__GetOfferRequest
defaultProto__Io__Haveno__Protobuffer__GetOfferRequest =
    { id = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetOfferRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetOfferRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetOfferRequest
decodeProto__Io__Haveno__Protobuffer__GetOfferRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetOfferRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | id = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetOfferRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetOfferRequest :
    Proto__Io__Haveno__Protobuffer__GetOfferRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetOfferRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.id ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetOfferRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetOfferRequest =
    { id : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StopXmrNodeReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__StopXmrNodeReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__StopXmrNodeReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__StopXmrNodeReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__StopXmrNodeReply : Proto__Io__Haveno__Protobuffer__StopXmrNodeReply
defaultProto__Io__Haveno__Protobuffer__StopXmrNodeReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__StopXmrNodeReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__StopXmrNodeReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__StopXmrNodeReply
decodeProto__Io__Haveno__Protobuffer__StopXmrNodeReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__StopXmrNodeReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__StopXmrNodeReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__StopXmrNodeReply :
    Proto__Io__Haveno__Protobuffer__StopXmrNodeReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__StopXmrNodeReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__StopXmrNodeReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__StopXmrNodeReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StopXmrNodeRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__StopXmrNodeRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__StopXmrNodeRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__StopXmrNodeRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__StopXmrNodeRequest : Proto__Io__Haveno__Protobuffer__StopXmrNodeRequest
defaultProto__Io__Haveno__Protobuffer__StopXmrNodeRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__StopXmrNodeRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__StopXmrNodeRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__StopXmrNodeRequest
decodeProto__Io__Haveno__Protobuffer__StopXmrNodeRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__StopXmrNodeRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__StopXmrNodeRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__StopXmrNodeRequest :
    Proto__Io__Haveno__Protobuffer__StopXmrNodeRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__StopXmrNodeRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__StopXmrNodeRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__StopXmrNodeRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StartXmrNodeReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__StartXmrNodeReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__StartXmrNodeReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__StartXmrNodeReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__StartXmrNodeReply : Proto__Io__Haveno__Protobuffer__StartXmrNodeReply
defaultProto__Io__Haveno__Protobuffer__StartXmrNodeReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__StartXmrNodeReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__StartXmrNodeReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__StartXmrNodeReply
decodeProto__Io__Haveno__Protobuffer__StartXmrNodeReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__StartXmrNodeReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__StartXmrNodeReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__StartXmrNodeReply :
    Proto__Io__Haveno__Protobuffer__StartXmrNodeReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__StartXmrNodeReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__StartXmrNodeReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__StartXmrNodeReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StartXmrNodeRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__StartXmrNodeRequest : { settings : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__StartXmrNodeRequest =
    { settings = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__StartXmrNodeRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__StartXmrNodeRequest : Proto__Io__Haveno__Protobuffer__StartXmrNodeRequest
defaultProto__Io__Haveno__Protobuffer__StartXmrNodeRequest =
    { settings = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__StartXmrNodeRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__StartXmrNodeRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__StartXmrNodeRequest
decodeProto__Io__Haveno__Protobuffer__StartXmrNodeRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__StartXmrNodeRequest
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__XmrNodeSettings)
            (\a r -> { r | settings = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__StartXmrNodeRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__StartXmrNodeRequest :
    Proto__Io__Haveno__Protobuffer__StartXmrNodeRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__StartXmrNodeRequest value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__XmrNodeSettings >> Maybe.withDefault Protobuf.Encode.none)
                value.settings
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__StartXmrNodeRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__StartXmrNodeRequest =
    { settings : Maybe Proto__Io__Haveno__Protobuffer__XmrNodeSettings }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply : { settings : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply =
    { settings = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply : Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply
defaultProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply =
    { settings = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply
decodeProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__XmrNodeSettings)
            (\a r -> { r | settings = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply :
    Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__XmrNodeSettings >> Maybe.withDefault Protobuf.Encode.none)
                value.settings
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsReply =
    { settings : Maybe Proto__Io__Haveno__Protobuffer__XmrNodeSettings }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest :
    Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest
defaultProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest
decodeProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest :
    Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetXmrNodeSettingsRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply : { isRunning : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply =
    { isRunning = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply : Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply
defaultProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply =
    { isRunning = False }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply
decodeProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply
        [ Protobuf.Decode.optional 1 Protobuf.Decode.bool (\a r -> { r | isRunning = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply :
    Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.bool value.isRunning ) ]


{-| `Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineReply =
    { isRunning : Bool }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest : Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest
defaultProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest
decodeProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest :
    Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__IsXmrNodeOnlineRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SetAutoSwitchReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SetAutoSwitchReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__SetAutoSwitchReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__SetAutoSwitchReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SetAutoSwitchReply : Proto__Io__Haveno__Protobuffer__SetAutoSwitchReply
defaultProto__Io__Haveno__Protobuffer__SetAutoSwitchReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SetAutoSwitchReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SetAutoSwitchReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SetAutoSwitchReply
decodeProto__Io__Haveno__Protobuffer__SetAutoSwitchReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__SetAutoSwitchReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SetAutoSwitchReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SetAutoSwitchReply :
    Proto__Io__Haveno__Protobuffer__SetAutoSwitchReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SetAutoSwitchReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__SetAutoSwitchReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__SetAutoSwitchReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SetAutoSwitchRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest : { autoSwitch : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest =
    { autoSwitch = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__SetAutoSwitchRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest : Proto__Io__Haveno__Protobuffer__SetAutoSwitchRequest
defaultProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest =
    { autoSwitch = False }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SetAutoSwitchRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SetAutoSwitchRequest
decodeProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.bool (\a r -> { r | autoSwitch = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SetAutoSwitchRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest :
    Proto__Io__Haveno__Protobuffer__SetAutoSwitchRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SetAutoSwitchRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.bool value.autoSwitch ) ]


{-| `Proto__Io__Haveno__Protobuffer__SetAutoSwitchRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__SetAutoSwitchRequest =
    { autoSwitch : Bool }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply : { connection : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply =
    { connection = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply :
    Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply
defaultProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply =
    { connection = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply
decodeProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__UrlConnection)
            (\a r -> { r | connection = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply :
    Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__UrlConnection >> Maybe.withDefault Protobuf.Encode.none)
                value.connection
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionReply =
    { connection : Maybe Proto__Io__Haveno__Protobuffer__UrlConnection }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest :
    Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest
defaultProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest
decodeProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest :
    Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetBestAvailableConnectionRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StopCheckingConnectionReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__StopCheckingConnectionReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply :
    Proto__Io__Haveno__Protobuffer__StopCheckingConnectionReply
defaultProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__StopCheckingConnectionReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__StopCheckingConnectionReply
decodeProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__StopCheckingConnectionReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply :
    Proto__Io__Haveno__Protobuffer__StopCheckingConnectionReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__StopCheckingConnectionReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__StopCheckingConnectionReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__StopCheckingConnectionReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest :
    Proto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest
defaultProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest
decodeProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest :
    Proto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__StopCheckingConnectionRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StartCheckingConnectionReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__StartCheckingConnectionReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply :
    Proto__Io__Haveno__Protobuffer__StartCheckingConnectionReply
defaultProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__StartCheckingConnectionReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__StartCheckingConnectionReply
decodeProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__StartCheckingConnectionReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply :
    Proto__Io__Haveno__Protobuffer__StartCheckingConnectionReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__StartCheckingConnectionReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__StartCheckingConnectionReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__StartCheckingConnectionReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest : { refreshPeriod : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest =
    { refreshPeriod = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest :
    Proto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest
defaultProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest =
    { refreshPeriod = 0 }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest
decodeProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.int32 (\a r -> { r | refreshPeriod = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest :
    Proto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.int32 value.refreshPeriod ) ]


{-| `Proto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__StartCheckingConnectionRequest =
    { refreshPeriod : Int }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CheckConnectionsReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CheckConnectionsReply : { connections : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CheckConnectionsReply =
    { connections = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__CheckConnectionsReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CheckConnectionsReply : Proto__Io__Haveno__Protobuffer__CheckConnectionsReply
defaultProto__Io__Haveno__Protobuffer__CheckConnectionsReply =
    { connections = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CheckConnectionsReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CheckConnectionsReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CheckConnectionsReply
decodeProto__Io__Haveno__Protobuffer__CheckConnectionsReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CheckConnectionsReply
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__UrlConnection
            .connections
            (\a r -> { r | connections = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CheckConnectionsReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CheckConnectionsReply :
    Proto__Io__Haveno__Protobuffer__CheckConnectionsReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CheckConnectionsReply value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__UrlConnection) value.connections ) ]


{-| `Proto__Io__Haveno__Protobuffer__CheckConnectionsReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__CheckConnectionsReply =
    { connections : List Proto__Io__Haveno__Protobuffer__UrlConnection }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CheckConnectionsRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CheckConnectionsRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__CheckConnectionsRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__CheckConnectionsRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CheckConnectionsRequest : Proto__Io__Haveno__Protobuffer__CheckConnectionsRequest
defaultProto__Io__Haveno__Protobuffer__CheckConnectionsRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CheckConnectionsRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CheckConnectionsRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CheckConnectionsRequest
decodeProto__Io__Haveno__Protobuffer__CheckConnectionsRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__CheckConnectionsRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CheckConnectionsRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CheckConnectionsRequest :
    Proto__Io__Haveno__Protobuffer__CheckConnectionsRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CheckConnectionsRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__CheckConnectionsRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__CheckConnectionsRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CheckConnectionReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CheckConnectionReply : { connection : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CheckConnectionReply =
    { connection = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__CheckConnectionReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CheckConnectionReply : Proto__Io__Haveno__Protobuffer__CheckConnectionReply
defaultProto__Io__Haveno__Protobuffer__CheckConnectionReply =
    { connection = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CheckConnectionReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CheckConnectionReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CheckConnectionReply
decodeProto__Io__Haveno__Protobuffer__CheckConnectionReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CheckConnectionReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__UrlConnection)
            (\a r -> { r | connection = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CheckConnectionReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CheckConnectionReply :
    Proto__Io__Haveno__Protobuffer__CheckConnectionReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CheckConnectionReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__UrlConnection >> Maybe.withDefault Protobuf.Encode.none)
                value.connection
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__CheckConnectionReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__CheckConnectionReply =
    { connection : Maybe Proto__Io__Haveno__Protobuffer__UrlConnection }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CheckConnectionRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CheckConnectionRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__CheckConnectionRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__CheckConnectionRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CheckConnectionRequest : Proto__Io__Haveno__Protobuffer__CheckConnectionRequest
defaultProto__Io__Haveno__Protobuffer__CheckConnectionRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CheckConnectionRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CheckConnectionRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CheckConnectionRequest
decodeProto__Io__Haveno__Protobuffer__CheckConnectionRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__CheckConnectionRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CheckConnectionRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CheckConnectionRequest :
    Proto__Io__Haveno__Protobuffer__CheckConnectionRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CheckConnectionRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__CheckConnectionRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__CheckConnectionRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SetConnectionReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SetConnectionReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__SetConnectionReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__SetConnectionReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SetConnectionReply : Proto__Io__Haveno__Protobuffer__SetConnectionReply
defaultProto__Io__Haveno__Protobuffer__SetConnectionReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SetConnectionReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SetConnectionReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SetConnectionReply
decodeProto__Io__Haveno__Protobuffer__SetConnectionReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__SetConnectionReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SetConnectionReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SetConnectionReply :
    Proto__Io__Haveno__Protobuffer__SetConnectionReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SetConnectionReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__SetConnectionReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__SetConnectionReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SetConnectionRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SetConnectionRequest : { url : Int, connection : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SetConnectionRequest =
    { url = 1, connection = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__SetConnectionRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SetConnectionRequest : Proto__Io__Haveno__Protobuffer__SetConnectionRequest
defaultProto__Io__Haveno__Protobuffer__SetConnectionRequest =
    { url = "", connection = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SetConnectionRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SetConnectionRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SetConnectionRequest
decodeProto__Io__Haveno__Protobuffer__SetConnectionRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SetConnectionRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | url = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__UrlConnection)
            (\a r -> { r | connection = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SetConnectionRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SetConnectionRequest :
    Proto__Io__Haveno__Protobuffer__SetConnectionRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SetConnectionRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.url )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__UrlConnection >> Maybe.withDefault Protobuf.Encode.none)
                value.connection
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SetConnectionRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__SetConnectionRequest =
    { url : String, connection : Maybe Proto__Io__Haveno__Protobuffer__UrlConnection }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetConnectionsReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetConnectionsReply : { connections : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetConnectionsReply =
    { connections = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetConnectionsReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetConnectionsReply : Proto__Io__Haveno__Protobuffer__GetConnectionsReply
defaultProto__Io__Haveno__Protobuffer__GetConnectionsReply =
    { connections = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetConnectionsReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetConnectionsReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetConnectionsReply
decodeProto__Io__Haveno__Protobuffer__GetConnectionsReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetConnectionsReply
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__UrlConnection
            .connections
            (\a r -> { r | connections = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetConnectionsReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetConnectionsReply :
    Proto__Io__Haveno__Protobuffer__GetConnectionsReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetConnectionsReply value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__UrlConnection) value.connections ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetConnectionsReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetConnectionsReply =
    { connections : List Proto__Io__Haveno__Protobuffer__UrlConnection }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetConnectionsRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetConnectionsRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__GetConnectionsRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__GetConnectionsRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetConnectionsRequest : Proto__Io__Haveno__Protobuffer__GetConnectionsRequest
defaultProto__Io__Haveno__Protobuffer__GetConnectionsRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetConnectionsRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetConnectionsRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetConnectionsRequest
decodeProto__Io__Haveno__Protobuffer__GetConnectionsRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__GetConnectionsRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetConnectionsRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetConnectionsRequest :
    Proto__Io__Haveno__Protobuffer__GetConnectionsRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetConnectionsRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__GetConnectionsRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetConnectionsRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetConnectionReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetConnectionReply : { connection : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetConnectionReply =
    { connection = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetConnectionReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetConnectionReply : Proto__Io__Haveno__Protobuffer__GetConnectionReply
defaultProto__Io__Haveno__Protobuffer__GetConnectionReply =
    { connection = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetConnectionReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetConnectionReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetConnectionReply
decodeProto__Io__Haveno__Protobuffer__GetConnectionReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetConnectionReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__UrlConnection)
            (\a r -> { r | connection = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetConnectionReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetConnectionReply :
    Proto__Io__Haveno__Protobuffer__GetConnectionReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetConnectionReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__UrlConnection >> Maybe.withDefault Protobuf.Encode.none)
                value.connection
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__GetConnectionReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetConnectionReply =
    { connection : Maybe Proto__Io__Haveno__Protobuffer__UrlConnection }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetConnectionRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetConnectionRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__GetConnectionRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__GetConnectionRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetConnectionRequest : Proto__Io__Haveno__Protobuffer__GetConnectionRequest
defaultProto__Io__Haveno__Protobuffer__GetConnectionRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetConnectionRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetConnectionRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetConnectionRequest
decodeProto__Io__Haveno__Protobuffer__GetConnectionRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__GetConnectionRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetConnectionRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetConnectionRequest :
    Proto__Io__Haveno__Protobuffer__GetConnectionRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetConnectionRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__GetConnectionRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetConnectionRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RemoveConnectionReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RemoveConnectionReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__RemoveConnectionReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__RemoveConnectionReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RemoveConnectionReply : Proto__Io__Haveno__Protobuffer__RemoveConnectionReply
defaultProto__Io__Haveno__Protobuffer__RemoveConnectionReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RemoveConnectionReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RemoveConnectionReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RemoveConnectionReply
decodeProto__Io__Haveno__Protobuffer__RemoveConnectionReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__RemoveConnectionReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RemoveConnectionReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RemoveConnectionReply :
    Proto__Io__Haveno__Protobuffer__RemoveConnectionReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RemoveConnectionReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__RemoveConnectionReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__RemoveConnectionReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RemoveConnectionRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RemoveConnectionRequest : { url : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__RemoveConnectionRequest =
    { url = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__RemoveConnectionRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RemoveConnectionRequest : Proto__Io__Haveno__Protobuffer__RemoveConnectionRequest
defaultProto__Io__Haveno__Protobuffer__RemoveConnectionRequest =
    { url = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RemoveConnectionRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RemoveConnectionRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RemoveConnectionRequest
decodeProto__Io__Haveno__Protobuffer__RemoveConnectionRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__RemoveConnectionRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | url = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RemoveConnectionRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RemoveConnectionRequest :
    Proto__Io__Haveno__Protobuffer__RemoveConnectionRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RemoveConnectionRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.url ) ]


{-| `Proto__Io__Haveno__Protobuffer__RemoveConnectionRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__RemoveConnectionRequest =
    { url : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AddConnectionReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AddConnectionReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__AddConnectionReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__AddConnectionReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AddConnectionReply : Proto__Io__Haveno__Protobuffer__AddConnectionReply
defaultProto__Io__Haveno__Protobuffer__AddConnectionReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AddConnectionReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AddConnectionReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AddConnectionReply
decodeProto__Io__Haveno__Protobuffer__AddConnectionReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__AddConnectionReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AddConnectionReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AddConnectionReply :
    Proto__Io__Haveno__Protobuffer__AddConnectionReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AddConnectionReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__AddConnectionReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__AddConnectionReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AddConnectionRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AddConnectionRequest : { connection : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__AddConnectionRequest =
    { connection = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__AddConnectionRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AddConnectionRequest : Proto__Io__Haveno__Protobuffer__AddConnectionRequest
defaultProto__Io__Haveno__Protobuffer__AddConnectionRequest =
    { connection = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AddConnectionRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AddConnectionRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AddConnectionRequest
decodeProto__Io__Haveno__Protobuffer__AddConnectionRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AddConnectionRequest
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__UrlConnection)
            (\a r -> { r | connection = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AddConnectionRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AddConnectionRequest :
    Proto__Io__Haveno__Protobuffer__AddConnectionRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AddConnectionRequest value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__UrlConnection >> Maybe.withDefault Protobuf.Encode.none)
                value.connection
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__AddConnectionRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__AddConnectionRequest =
    { connection : Maybe Proto__Io__Haveno__Protobuffer__UrlConnection }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__UrlConnection`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__UrlConnection :
    { url : Int, username : Int, password : Int, priority : Int, onlineStatus : Int, authenticationStatus : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__UrlConnection =
    { url = 1, username = 2, password = 3, priority = 4, onlineStatus = 5, authenticationStatus = 6 }


{-| Default for Proto__Io__Haveno__Protobuffer__UrlConnection. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__UrlConnection : Proto__Io__Haveno__Protobuffer__UrlConnection
defaultProto__Io__Haveno__Protobuffer__UrlConnection =
    { url = ""
    , username = ""
    , password = ""
    , priority = 0
    , onlineStatus = Proto.Io.Haveno.Protobuffer.UrlConnection.OnlineStatus.defaultOnlineStatus
    , authenticationStatus = Proto.Io.Haveno.Protobuffer.UrlConnection.AuthenticationStatus.defaultAuthenticationStatus
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__UrlConnection` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__UrlConnection :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__UrlConnection
decodeProto__Io__Haveno__Protobuffer__UrlConnection =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__UrlConnection
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | url = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | username = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | password = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.int32 (\a r -> { r | priority = a })
        , Protobuf.Decode.optional
            5
            Proto.Io.Haveno.Protobuffer.UrlConnection.OnlineStatus.decodeOnlineStatus
            (\a r -> { r | onlineStatus = a })
        , Protobuf.Decode.optional
            6
            Proto.Io.Haveno.Protobuffer.UrlConnection.AuthenticationStatus.decodeAuthenticationStatus
            (\a r -> { r | authenticationStatus = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__UrlConnection` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__UrlConnection :
    Proto__Io__Haveno__Protobuffer__UrlConnection -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__UrlConnection value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.url )
        , ( 2, Protobuf.Encode.string value.username )
        , ( 3, Protobuf.Encode.string value.password )
        , ( 4, Protobuf.Encode.int32 value.priority )
        , ( 5, Proto.Io.Haveno.Protobuffer.UrlConnection.OnlineStatus.encodeOnlineStatus value.onlineStatus )
        , ( 6
          , Proto.Io.Haveno.Protobuffer.UrlConnection.AuthenticationStatus.encodeAuthenticationStatus
                value.authenticationStatus
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__UrlConnection` message

-}
type alias Proto__Io__Haveno__Protobuffer__UrlConnection =
    { url : String
    , username : String
    , password : String
    , priority : Int
    , onlineStatus : Proto.Io.Haveno.Protobuffer.UrlConnection.OnlineStatus.OnlineStatus
    , authenticationStatus : Proto.Io.Haveno.Protobuffer.UrlConnection.AuthenticationStatus.AuthenticationStatus
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SendNotificationReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SendNotificationReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__SendNotificationReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__SendNotificationReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SendNotificationReply : Proto__Io__Haveno__Protobuffer__SendNotificationReply
defaultProto__Io__Haveno__Protobuffer__SendNotificationReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SendNotificationReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SendNotificationReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SendNotificationReply
decodeProto__Io__Haveno__Protobuffer__SendNotificationReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__SendNotificationReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SendNotificationReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SendNotificationReply :
    Proto__Io__Haveno__Protobuffer__SendNotificationReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SendNotificationReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__SendNotificationReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__SendNotificationReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SendNotificationRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SendNotificationRequest : { notification : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SendNotificationRequest =
    { notification = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__SendNotificationRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SendNotificationRequest : Proto__Io__Haveno__Protobuffer__SendNotificationRequest
defaultProto__Io__Haveno__Protobuffer__SendNotificationRequest =
    { notification = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SendNotificationRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SendNotificationRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SendNotificationRequest
decodeProto__Io__Haveno__Protobuffer__SendNotificationRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SendNotificationRequest
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NotificationMessage)
            (\a r -> { r | notification = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SendNotificationRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SendNotificationRequest :
    Proto__Io__Haveno__Protobuffer__SendNotificationRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SendNotificationRequest value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NotificationMessage
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.notification
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SendNotificationRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__SendNotificationRequest =
    { notification : Maybe Proto__Io__Haveno__Protobuffer__NotificationMessage }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__NotificationMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__NotificationMessage :
    { id : Int, type_ : Int, timestamp : Int, title : Int, message : Int, trade : Int, chatMessage : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__NotificationMessage =
    { id = 1, type_ = 2, timestamp = 3, title = 4, message = 5, trade = 6, chatMessage = 7 }


{-| Default for Proto__Io__Haveno__Protobuffer__NotificationMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__NotificationMessage : Proto__Io__Haveno__Protobuffer__NotificationMessage
defaultProto__Io__Haveno__Protobuffer__NotificationMessage =
    { id = ""
    , type_ = Proto.Io.Haveno.Protobuffer.NotificationMessage.NotificationType.defaultNotificationType
    , timestamp = Protobuf.Types.Int64.fromInts 0 0
    , title = ""
    , message = ""
    , trade = Nothing
    , chatMessage = Nothing
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__NotificationMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__NotificationMessage :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__NotificationMessage
decodeProto__Io__Haveno__Protobuffer__NotificationMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__NotificationMessage
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | id = a })
        , Protobuf.Decode.optional
            2
            Proto.Io.Haveno.Protobuffer.NotificationMessage.NotificationType.decodeNotificationType
            (\a r -> { r | type_ = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | timestamp = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | title = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | message = a })
        , Protobuf.Decode.optional
            6
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__TradeInfo)
            (\a r -> { r | trade = a })
        , Protobuf.Decode.optional
            7
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__ChatMessage)
            (\a r -> { r | chatMessage = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__NotificationMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__NotificationMessage :
    Proto__Io__Haveno__Protobuffer__NotificationMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__NotificationMessage value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.id )
        , ( 2, Proto.Io.Haveno.Protobuffer.NotificationMessage.NotificationType.encodeNotificationType value.type_ )
        , ( 3, Protobuf.Encode.int64 value.timestamp )
        , ( 4, Protobuf.Encode.string value.title )
        , ( 5, Protobuf.Encode.string value.message )
        , ( 6
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__TradeInfo >> Maybe.withDefault Protobuf.Encode.none)
                value.trade
          )
        , ( 7
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__ChatMessage >> Maybe.withDefault Protobuf.Encode.none)
                value.chatMessage
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__NotificationMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__NotificationMessage =
    { id : String
    , type_ : Proto.Io.Haveno.Protobuffer.NotificationMessage.NotificationType.NotificationType
    , timestamp : Protobuf.Types.Int64.Int64
    , title : String
    , message : String
    , trade : Maybe Proto__Io__Haveno__Protobuffer__TradeInfo
    , chatMessage : Maybe Proto__Io__Haveno__Protobuffer__ChatMessage
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest :
    Proto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest
defaultProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest
decodeProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest :
    Proto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__RegisterNotificationListenerRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply :
    Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply
defaultProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply
decodeProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply :
    Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest : { disputeAgentType : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest =
    { disputeAgentType = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest :
    Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest
defaultProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest =
    { disputeAgentType = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest
decodeProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | disputeAgentType = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest :
    Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.disputeAgentType ) ]


{-| `Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__UnregisterDisputeAgentRequest =
    { disputeAgentType : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply :
    Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply
defaultProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply
decodeProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply :
    Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest :
    { disputeAgentType : Int, registrationKey : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest =
    { disputeAgentType = 1, registrationKey = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest :
    Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest
defaultProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest =
    { disputeAgentType = "", registrationKey = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest
decodeProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | disputeAgentType = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | registrationKey = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest :
    Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.disputeAgentType ), ( 2, Protobuf.Encode.string value.registrationKey ) ]


{-| `Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__RegisterDisputeAgentRequest =
    { disputeAgentType : String, registrationKey : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply :
    Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply
defaultProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply
decodeProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply :
    Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest :
    { disputeId : Int, message : Int, attachments : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest =
    { disputeId = 1, message = 2, attachments = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest :
    Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest
defaultProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest =
    { disputeId = "", message = "", attachments = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest
decodeProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | disputeId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | message = a })
        , Protobuf.Decode.repeated
            3
            decodeProto__Io__Haveno__Protobuffer__Attachment
            .attachments
            (\a r -> { r | attachments = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest :
    Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.disputeId )
        , ( 2, Protobuf.Encode.string value.message )
        , ( 3, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__Attachment) value.attachments )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__SendDisputeChatMessageRequest =
    { disputeId : String, message : String, attachments : List Proto__Io__Haveno__Protobuffer__Attachment }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ResolveDisputeRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ResolveDisputeRequest :
    { tradeId : Int, winner : Int, reason : Int, summaryNotes : Int, customPayoutAmount : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__ResolveDisputeRequest =
    { tradeId = 1, winner = 2, reason = 3, summaryNotes = 4, customPayoutAmount = 5 }


{-| Default for Proto__Io__Haveno__Protobuffer__ResolveDisputeRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ResolveDisputeRequest : Proto__Io__Haveno__Protobuffer__ResolveDisputeRequest
defaultProto__Io__Haveno__Protobuffer__ResolveDisputeRequest =
    { tradeId = ""
    , winner = Proto.Io.Haveno.Protobuffer.DisputeResult.Winner.defaultWinner
    , reason = Proto.Io.Haveno.Protobuffer.DisputeResult.Reason.defaultReason
    , summaryNotes = ""
    , customPayoutAmount = Protobuf.Types.Int64.fromInts 0 0
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ResolveDisputeRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ResolveDisputeRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ResolveDisputeRequest
decodeProto__Io__Haveno__Protobuffer__ResolveDisputeRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__ResolveDisputeRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional
            2
            Proto.Io.Haveno.Protobuffer.DisputeResult.Winner.decodeWinner
            (\a r -> { r | winner = a })
        , Protobuf.Decode.optional
            3
            Proto.Io.Haveno.Protobuffer.DisputeResult.Reason.decodeReason
            (\a r -> { r | reason = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | summaryNotes = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.uint64 (\a r -> { r | customPayoutAmount = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ResolveDisputeRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ResolveDisputeRequest :
    Proto__Io__Haveno__Protobuffer__ResolveDisputeRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ResolveDisputeRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.tradeId )
        , ( 2, Proto.Io.Haveno.Protobuffer.DisputeResult.Winner.encodeWinner value.winner )
        , ( 3, Proto.Io.Haveno.Protobuffer.DisputeResult.Reason.encodeReason value.reason )
        , ( 4, Protobuf.Encode.string value.summaryNotes )
        , ( 5, Protobuf.Encode.uint64 value.customPayoutAmount )
        ]


{-| `Proto__Io__Haveno__Protobuffer__ResolveDisputeRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__ResolveDisputeRequest =
    { tradeId : String
    , winner : Proto.Io.Haveno.Protobuffer.DisputeResult.Winner.Winner
    , reason : Proto.Io.Haveno.Protobuffer.DisputeResult.Reason.Reason
    , summaryNotes : String
    , customPayoutAmount : Protobuf.Types.Int64.Int64
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ResolveDisputeReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ResolveDisputeReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__ResolveDisputeReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__ResolveDisputeReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ResolveDisputeReply : Proto__Io__Haveno__Protobuffer__ResolveDisputeReply
defaultProto__Io__Haveno__Protobuffer__ResolveDisputeReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ResolveDisputeReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ResolveDisputeReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ResolveDisputeReply
decodeProto__Io__Haveno__Protobuffer__ResolveDisputeReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__ResolveDisputeReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ResolveDisputeReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ResolveDisputeReply :
    Proto__Io__Haveno__Protobuffer__ResolveDisputeReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ResolveDisputeReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__ResolveDisputeReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__ResolveDisputeReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__OpenDisputeReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__OpenDisputeReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__OpenDisputeReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__OpenDisputeReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__OpenDisputeReply : Proto__Io__Haveno__Protobuffer__OpenDisputeReply
defaultProto__Io__Haveno__Protobuffer__OpenDisputeReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__OpenDisputeReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__OpenDisputeReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__OpenDisputeReply
decodeProto__Io__Haveno__Protobuffer__OpenDisputeReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__OpenDisputeReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__OpenDisputeReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__OpenDisputeReply :
    Proto__Io__Haveno__Protobuffer__OpenDisputeReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__OpenDisputeReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__OpenDisputeReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__OpenDisputeReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__OpenDisputeRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__OpenDisputeRequest : { tradeId : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__OpenDisputeRequest =
    { tradeId = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__OpenDisputeRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__OpenDisputeRequest : Proto__Io__Haveno__Protobuffer__OpenDisputeRequest
defaultProto__Io__Haveno__Protobuffer__OpenDisputeRequest =
    { tradeId = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__OpenDisputeRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__OpenDisputeRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__OpenDisputeRequest
decodeProto__Io__Haveno__Protobuffer__OpenDisputeRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__OpenDisputeRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__OpenDisputeRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__OpenDisputeRequest :
    Proto__Io__Haveno__Protobuffer__OpenDisputeRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__OpenDisputeRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.tradeId ) ]


{-| `Proto__Io__Haveno__Protobuffer__OpenDisputeRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__OpenDisputeRequest =
    { tradeId : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetDisputeReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetDisputeReply : { dispute : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetDisputeReply =
    { dispute = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetDisputeReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetDisputeReply : Proto__Io__Haveno__Protobuffer__GetDisputeReply
defaultProto__Io__Haveno__Protobuffer__GetDisputeReply =
    { dispute = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetDisputeReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetDisputeReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetDisputeReply
decodeProto__Io__Haveno__Protobuffer__GetDisputeReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetDisputeReply
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Dispute)
            (\a r -> { r | dispute = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetDisputeReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetDisputeReply :
    Proto__Io__Haveno__Protobuffer__GetDisputeReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetDisputeReply value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Dispute >> Maybe.withDefault Protobuf.Encode.none)
                value.dispute
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__GetDisputeReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetDisputeReply =
    { dispute : Maybe Proto__Io__Haveno__Protobuffer__Dispute }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetDisputeRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetDisputeRequest : { tradeId : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetDisputeRequest =
    { tradeId = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetDisputeRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetDisputeRequest : Proto__Io__Haveno__Protobuffer__GetDisputeRequest
defaultProto__Io__Haveno__Protobuffer__GetDisputeRequest =
    { tradeId = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetDisputeRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetDisputeRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetDisputeRequest
decodeProto__Io__Haveno__Protobuffer__GetDisputeRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetDisputeRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetDisputeRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetDisputeRequest :
    Proto__Io__Haveno__Protobuffer__GetDisputeRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetDisputeRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.tradeId ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetDisputeRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetDisputeRequest =
    { tradeId : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetDisputesReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetDisputesReply : { disputes : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetDisputesReply =
    { disputes = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetDisputesReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetDisputesReply : Proto__Io__Haveno__Protobuffer__GetDisputesReply
defaultProto__Io__Haveno__Protobuffer__GetDisputesReply =
    { disputes = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetDisputesReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetDisputesReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetDisputesReply
decodeProto__Io__Haveno__Protobuffer__GetDisputesReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetDisputesReply
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__Dispute
            .disputes
            (\a r -> { r | disputes = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetDisputesReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetDisputesReply :
    Proto__Io__Haveno__Protobuffer__GetDisputesReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetDisputesReply value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__Dispute) value.disputes ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetDisputesReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetDisputesReply =
    { disputes : List Proto__Io__Haveno__Protobuffer__Dispute }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetDisputesRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetDisputesRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__GetDisputesRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__GetDisputesRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetDisputesRequest : Proto__Io__Haveno__Protobuffer__GetDisputesRequest
defaultProto__Io__Haveno__Protobuffer__GetDisputesRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetDisputesRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetDisputesRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetDisputesRequest
decodeProto__Io__Haveno__Protobuffer__GetDisputesRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__GetDisputesRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetDisputesRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetDisputesRequest :
    Proto__Io__Haveno__Protobuffer__GetDisputesRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetDisputesRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__GetDisputesRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetDisputesRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RestoreAccountReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RestoreAccountReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__RestoreAccountReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__RestoreAccountReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RestoreAccountReply : Proto__Io__Haveno__Protobuffer__RestoreAccountReply
defaultProto__Io__Haveno__Protobuffer__RestoreAccountReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RestoreAccountReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RestoreAccountReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RestoreAccountReply
decodeProto__Io__Haveno__Protobuffer__RestoreAccountReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__RestoreAccountReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RestoreAccountReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RestoreAccountReply :
    Proto__Io__Haveno__Protobuffer__RestoreAccountReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RestoreAccountReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__RestoreAccountReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__RestoreAccountReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RestoreAccountRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RestoreAccountRequest :
    { zipBytes : Int, offset : Int, totalLength : Int, hasMore : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__RestoreAccountRequest =
    { zipBytes = 1, offset = 2, totalLength = 3, hasMore = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__RestoreAccountRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RestoreAccountRequest : Proto__Io__Haveno__Protobuffer__RestoreAccountRequest
defaultProto__Io__Haveno__Protobuffer__RestoreAccountRequest =
    { zipBytes = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , offset = Protobuf.Types.Int64.fromInts 0 0
    , totalLength = Protobuf.Types.Int64.fromInts 0 0
    , hasMore = False
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RestoreAccountRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RestoreAccountRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RestoreAccountRequest
decodeProto__Io__Haveno__Protobuffer__RestoreAccountRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__RestoreAccountRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.bytes (\a r -> { r | zipBytes = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.uint64 (\a r -> { r | offset = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.uint64 (\a r -> { r | totalLength = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.bool (\a r -> { r | hasMore = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RestoreAccountRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RestoreAccountRequest :
    Proto__Io__Haveno__Protobuffer__RestoreAccountRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RestoreAccountRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.bytes value.zipBytes )
        , ( 2, Protobuf.Encode.uint64 value.offset )
        , ( 3, Protobuf.Encode.uint64 value.totalLength )
        , ( 4, Protobuf.Encode.bool value.hasMore )
        ]


{-| `Proto__Io__Haveno__Protobuffer__RestoreAccountRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__RestoreAccountRequest =
    { zipBytes : Bytes.Bytes
    , offset : Protobuf.Types.Int64.Int64
    , totalLength : Protobuf.Types.Int64.Int64
    , hasMore : Bool
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__BackupAccountReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__BackupAccountReply : { zipBytes : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__BackupAccountReply =
    { zipBytes = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__BackupAccountReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__BackupAccountReply : Proto__Io__Haveno__Protobuffer__BackupAccountReply
defaultProto__Io__Haveno__Protobuffer__BackupAccountReply =
    { zipBytes = Protobuf.Encode.encode <| Protobuf.Encode.string "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__BackupAccountReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__BackupAccountReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__BackupAccountReply
decodeProto__Io__Haveno__Protobuffer__BackupAccountReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__BackupAccountReply
        [ Protobuf.Decode.optional 1 Protobuf.Decode.bytes (\a r -> { r | zipBytes = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__BackupAccountReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__BackupAccountReply :
    Proto__Io__Haveno__Protobuffer__BackupAccountReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__BackupAccountReply value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.bytes value.zipBytes ) ]


{-| `Proto__Io__Haveno__Protobuffer__BackupAccountReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__BackupAccountReply =
    { zipBytes : Bytes.Bytes }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__BackupAccountRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__BackupAccountRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__BackupAccountRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__BackupAccountRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__BackupAccountRequest : Proto__Io__Haveno__Protobuffer__BackupAccountRequest
defaultProto__Io__Haveno__Protobuffer__BackupAccountRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__BackupAccountRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__BackupAccountRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__BackupAccountRequest
decodeProto__Io__Haveno__Protobuffer__BackupAccountRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__BackupAccountRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__BackupAccountRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__BackupAccountRequest :
    Proto__Io__Haveno__Protobuffer__BackupAccountRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__BackupAccountRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__BackupAccountRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__BackupAccountRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__DeleteAccountReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__DeleteAccountReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__DeleteAccountReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__DeleteAccountReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__DeleteAccountReply : Proto__Io__Haveno__Protobuffer__DeleteAccountReply
defaultProto__Io__Haveno__Protobuffer__DeleteAccountReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__DeleteAccountReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__DeleteAccountReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__DeleteAccountReply
decodeProto__Io__Haveno__Protobuffer__DeleteAccountReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__DeleteAccountReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__DeleteAccountReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__DeleteAccountReply :
    Proto__Io__Haveno__Protobuffer__DeleteAccountReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__DeleteAccountReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__DeleteAccountReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__DeleteAccountReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__DeleteAccountRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__DeleteAccountRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__DeleteAccountRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__DeleteAccountRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__DeleteAccountRequest : Proto__Io__Haveno__Protobuffer__DeleteAccountRequest
defaultProto__Io__Haveno__Protobuffer__DeleteAccountRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__DeleteAccountRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__DeleteAccountRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__DeleteAccountRequest
decodeProto__Io__Haveno__Protobuffer__DeleteAccountRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__DeleteAccountRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__DeleteAccountRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__DeleteAccountRequest :
    Proto__Io__Haveno__Protobuffer__DeleteAccountRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__DeleteAccountRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__DeleteAccountRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__DeleteAccountRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CloseAccountReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CloseAccountReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__CloseAccountReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__CloseAccountReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CloseAccountReply : Proto__Io__Haveno__Protobuffer__CloseAccountReply
defaultProto__Io__Haveno__Protobuffer__CloseAccountReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CloseAccountReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CloseAccountReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CloseAccountReply
decodeProto__Io__Haveno__Protobuffer__CloseAccountReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__CloseAccountReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CloseAccountReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CloseAccountReply :
    Proto__Io__Haveno__Protobuffer__CloseAccountReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CloseAccountReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__CloseAccountReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__CloseAccountReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CloseAccountRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CloseAccountRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__CloseAccountRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__CloseAccountRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CloseAccountRequest : Proto__Io__Haveno__Protobuffer__CloseAccountRequest
defaultProto__Io__Haveno__Protobuffer__CloseAccountRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CloseAccountRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CloseAccountRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CloseAccountRequest
decodeProto__Io__Haveno__Protobuffer__CloseAccountRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__CloseAccountRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CloseAccountRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CloseAccountRequest :
    Proto__Io__Haveno__Protobuffer__CloseAccountRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CloseAccountRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__CloseAccountRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__CloseAccountRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ChangePasswordReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ChangePasswordReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__ChangePasswordReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__ChangePasswordReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ChangePasswordReply : Proto__Io__Haveno__Protobuffer__ChangePasswordReply
defaultProto__Io__Haveno__Protobuffer__ChangePasswordReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ChangePasswordReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ChangePasswordReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ChangePasswordReply
decodeProto__Io__Haveno__Protobuffer__ChangePasswordReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__ChangePasswordReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ChangePasswordReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ChangePasswordReply :
    Proto__Io__Haveno__Protobuffer__ChangePasswordReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ChangePasswordReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__ChangePasswordReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__ChangePasswordReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ChangePasswordRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ChangePasswordRequest : { oldPassword : Int, newPassword : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__ChangePasswordRequest =
    { oldPassword = 1, newPassword = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__ChangePasswordRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ChangePasswordRequest : Proto__Io__Haveno__Protobuffer__ChangePasswordRequest
defaultProto__Io__Haveno__Protobuffer__ChangePasswordRequest =
    { oldPassword = "", newPassword = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ChangePasswordRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ChangePasswordRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ChangePasswordRequest
decodeProto__Io__Haveno__Protobuffer__ChangePasswordRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__ChangePasswordRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | oldPassword = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | newPassword = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ChangePasswordRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ChangePasswordRequest :
    Proto__Io__Haveno__Protobuffer__ChangePasswordRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ChangePasswordRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.oldPassword ), ( 2, Protobuf.Encode.string value.newPassword ) ]


{-| `Proto__Io__Haveno__Protobuffer__ChangePasswordRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__ChangePasswordRequest =
    { oldPassword : String, newPassword : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__IsAppInitializedReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__IsAppInitializedReply : { isAppInitialized : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__IsAppInitializedReply =
    { isAppInitialized = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__IsAppInitializedReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__IsAppInitializedReply : Proto__Io__Haveno__Protobuffer__IsAppInitializedReply
defaultProto__Io__Haveno__Protobuffer__IsAppInitializedReply =
    { isAppInitialized = False }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__IsAppInitializedReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__IsAppInitializedReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__IsAppInitializedReply
decodeProto__Io__Haveno__Protobuffer__IsAppInitializedReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__IsAppInitializedReply
        [ Protobuf.Decode.optional 1 Protobuf.Decode.bool (\a r -> { r | isAppInitialized = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__IsAppInitializedReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__IsAppInitializedReply :
    Proto__Io__Haveno__Protobuffer__IsAppInitializedReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__IsAppInitializedReply value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.bool value.isAppInitialized ) ]


{-| `Proto__Io__Haveno__Protobuffer__IsAppInitializedReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__IsAppInitializedReply =
    { isAppInitialized : Bool }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__IsAppInitializedRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__IsAppInitializedRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__IsAppInitializedRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__IsAppInitializedRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__IsAppInitializedRequest : Proto__Io__Haveno__Protobuffer__IsAppInitializedRequest
defaultProto__Io__Haveno__Protobuffer__IsAppInitializedRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__IsAppInitializedRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__IsAppInitializedRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__IsAppInitializedRequest
decodeProto__Io__Haveno__Protobuffer__IsAppInitializedRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__IsAppInitializedRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__IsAppInitializedRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__IsAppInitializedRequest :
    Proto__Io__Haveno__Protobuffer__IsAppInitializedRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__IsAppInitializedRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__IsAppInitializedRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__IsAppInitializedRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__OpenAccountReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__OpenAccountReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__OpenAccountReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__OpenAccountReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__OpenAccountReply : Proto__Io__Haveno__Protobuffer__OpenAccountReply
defaultProto__Io__Haveno__Protobuffer__OpenAccountReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__OpenAccountReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__OpenAccountReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__OpenAccountReply
decodeProto__Io__Haveno__Protobuffer__OpenAccountReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__OpenAccountReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__OpenAccountReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__OpenAccountReply :
    Proto__Io__Haveno__Protobuffer__OpenAccountReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__OpenAccountReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__OpenAccountReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__OpenAccountReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__OpenAccountRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__OpenAccountRequest : { password : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__OpenAccountRequest =
    { password = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__OpenAccountRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__OpenAccountRequest : Proto__Io__Haveno__Protobuffer__OpenAccountRequest
defaultProto__Io__Haveno__Protobuffer__OpenAccountRequest =
    { password = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__OpenAccountRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__OpenAccountRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__OpenAccountRequest
decodeProto__Io__Haveno__Protobuffer__OpenAccountRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__OpenAccountRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | password = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__OpenAccountRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__OpenAccountRequest :
    Proto__Io__Haveno__Protobuffer__OpenAccountRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__OpenAccountRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.password ) ]


{-| `Proto__Io__Haveno__Protobuffer__OpenAccountRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__OpenAccountRequest =
    { password : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CreateAccountReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CreateAccountReply : {}
fieldNumbersProto__Io__Haveno__Protobuffer__CreateAccountReply =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__CreateAccountReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CreateAccountReply : Proto__Io__Haveno__Protobuffer__CreateAccountReply
defaultProto__Io__Haveno__Protobuffer__CreateAccountReply =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CreateAccountReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CreateAccountReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CreateAccountReply
decodeProto__Io__Haveno__Protobuffer__CreateAccountReply =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__CreateAccountReply []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CreateAccountReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CreateAccountReply :
    Proto__Io__Haveno__Protobuffer__CreateAccountReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CreateAccountReply _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__CreateAccountReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__CreateAccountReply =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CreateAccountRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CreateAccountRequest : { password : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CreateAccountRequest =
    { password = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__CreateAccountRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CreateAccountRequest : Proto__Io__Haveno__Protobuffer__CreateAccountRequest
defaultProto__Io__Haveno__Protobuffer__CreateAccountRequest =
    { password = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CreateAccountRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CreateAccountRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CreateAccountRequest
decodeProto__Io__Haveno__Protobuffer__CreateAccountRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CreateAccountRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | password = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CreateAccountRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CreateAccountRequest :
    Proto__Io__Haveno__Protobuffer__CreateAccountRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CreateAccountRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.password ) ]


{-| `Proto__Io__Haveno__Protobuffer__CreateAccountRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__CreateAccountRequest =
    { password : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__IsAccountOpenReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__IsAccountOpenReply : { isAccountOpen : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__IsAccountOpenReply =
    { isAccountOpen = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__IsAccountOpenReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__IsAccountOpenReply : Proto__Io__Haveno__Protobuffer__IsAccountOpenReply
defaultProto__Io__Haveno__Protobuffer__IsAccountOpenReply =
    { isAccountOpen = False }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__IsAccountOpenReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__IsAccountOpenReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__IsAccountOpenReply
decodeProto__Io__Haveno__Protobuffer__IsAccountOpenReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__IsAccountOpenReply
        [ Protobuf.Decode.optional 1 Protobuf.Decode.bool (\a r -> { r | isAccountOpen = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__IsAccountOpenReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__IsAccountOpenReply :
    Proto__Io__Haveno__Protobuffer__IsAccountOpenReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__IsAccountOpenReply value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.bool value.isAccountOpen ) ]


{-| `Proto__Io__Haveno__Protobuffer__IsAccountOpenReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__IsAccountOpenReply =
    { isAccountOpen : Bool }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__IsAccountOpenRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__IsAccountOpenRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__IsAccountOpenRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__IsAccountOpenRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__IsAccountOpenRequest : Proto__Io__Haveno__Protobuffer__IsAccountOpenRequest
defaultProto__Io__Haveno__Protobuffer__IsAccountOpenRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__IsAccountOpenRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__IsAccountOpenRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__IsAccountOpenRequest
decodeProto__Io__Haveno__Protobuffer__IsAccountOpenRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__IsAccountOpenRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__IsAccountOpenRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__IsAccountOpenRequest :
    Proto__Io__Haveno__Protobuffer__IsAccountOpenRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__IsAccountOpenRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__IsAccountOpenRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__IsAccountOpenRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AccountExistsReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AccountExistsReply : { accountExists : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__AccountExistsReply =
    { accountExists = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__AccountExistsReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AccountExistsReply : Proto__Io__Haveno__Protobuffer__AccountExistsReply
defaultProto__Io__Haveno__Protobuffer__AccountExistsReply =
    { accountExists = False }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AccountExistsReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AccountExistsReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AccountExistsReply
decodeProto__Io__Haveno__Protobuffer__AccountExistsReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AccountExistsReply
        [ Protobuf.Decode.optional 1 Protobuf.Decode.bool (\a r -> { r | accountExists = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AccountExistsReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AccountExistsReply :
    Proto__Io__Haveno__Protobuffer__AccountExistsReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AccountExistsReply value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.bool value.accountExists ) ]


{-| `Proto__Io__Haveno__Protobuffer__AccountExistsReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__AccountExistsReply =
    { accountExists : Bool }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AccountExistsRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AccountExistsRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__AccountExistsRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__AccountExistsRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AccountExistsRequest : Proto__Io__Haveno__Protobuffer__AccountExistsRequest
defaultProto__Io__Haveno__Protobuffer__AccountExistsRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AccountExistsRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AccountExistsRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AccountExistsRequest
decodeProto__Io__Haveno__Protobuffer__AccountExistsRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__AccountExistsRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AccountExistsRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AccountExistsRequest :
    Proto__Io__Haveno__Protobuffer__AccountExistsRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AccountExistsRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__AccountExistsRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__AccountExistsRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetVersionReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetVersionReply : { version : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetVersionReply =
    { version = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetVersionReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetVersionReply : Proto__Io__Haveno__Protobuffer__GetVersionReply
defaultProto__Io__Haveno__Protobuffer__GetVersionReply =
    { version = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetVersionReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetVersionReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetVersionReply
decodeProto__Io__Haveno__Protobuffer__GetVersionReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetVersionReply
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | version = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetVersionReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetVersionReply :
    Proto__Io__Haveno__Protobuffer__GetVersionReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetVersionReply value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.version ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetVersionReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetVersionReply =
    { version : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetVersionRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetVersionRequest : {}
fieldNumbersProto__Io__Haveno__Protobuffer__GetVersionRequest =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__GetVersionRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetVersionRequest : Proto__Io__Haveno__Protobuffer__GetVersionRequest
defaultProto__Io__Haveno__Protobuffer__GetVersionRequest =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetVersionRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetVersionRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetVersionRequest
decodeProto__Io__Haveno__Protobuffer__GetVersionRequest =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__GetVersionRequest []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetVersionRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetVersionRequest :
    Proto__Io__Haveno__Protobuffer__GetVersionRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetVersionRequest _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__GetVersionRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetVersionRequest =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetMethodHelpReply`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetMethodHelpReply : { methodHelp : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetMethodHelpReply =
    { methodHelp = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetMethodHelpReply. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetMethodHelpReply : Proto__Io__Haveno__Protobuffer__GetMethodHelpReply
defaultProto__Io__Haveno__Protobuffer__GetMethodHelpReply =
    { methodHelp = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetMethodHelpReply` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetMethodHelpReply :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetMethodHelpReply
decodeProto__Io__Haveno__Protobuffer__GetMethodHelpReply =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetMethodHelpReply
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | methodHelp = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetMethodHelpReply` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetMethodHelpReply :
    Proto__Io__Haveno__Protobuffer__GetMethodHelpReply -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetMethodHelpReply value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.methodHelp ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetMethodHelpReply` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetMethodHelpReply =
    { methodHelp : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetMethodHelpRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetMethodHelpRequest : { methodName : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetMethodHelpRequest =
    { methodName = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetMethodHelpRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetMethodHelpRequest : Proto__Io__Haveno__Protobuffer__GetMethodHelpRequest
defaultProto__Io__Haveno__Protobuffer__GetMethodHelpRequest =
    { methodName = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetMethodHelpRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetMethodHelpRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetMethodHelpRequest
decodeProto__Io__Haveno__Protobuffer__GetMethodHelpRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetMethodHelpRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | methodName = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetMethodHelpRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetMethodHelpRequest :
    Proto__Io__Haveno__Protobuffer__GetMethodHelpRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetMethodHelpRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.methodName ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetMethodHelpRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetMethodHelpRequest =
    { methodName : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PaymentAccountFormField`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountFormField :
    { id : Int
    , component : Int
    , type_ : Int
    , label : Int
    , value : Int
    , minLength : Int
    , maxLength : Int
    , supportedCurrencies : Int
    , supportedCountries : Int
    , supportedSepaEuroCountries : Int
    , supportedSepaNonEuroCountries : Int
    , requiredForCountries : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountFormField =
    { id = 1
    , component = 2
    , type_ = 3
    , label = 4
    , value = 5
    , minLength = 6
    , maxLength = 7
    , supportedCurrencies = 8
    , supportedCountries = 9
    , supportedSepaEuroCountries = 10
    , supportedSepaNonEuroCountries = 11
    , requiredForCountries = 12
    }


{-| Default for Proto__Io__Haveno__Protobuffer__PaymentAccountFormField. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PaymentAccountFormField : Proto__Io__Haveno__Protobuffer__PaymentAccountFormField
defaultProto__Io__Haveno__Protobuffer__PaymentAccountFormField =
    { id = Proto.Io.Haveno.Protobuffer.PaymentAccountFormField.FieldId.defaultFieldId
    , component = Proto.Io.Haveno.Protobuffer.PaymentAccountFormField.Component.defaultComponent
    , type_ = ""
    , label = ""
    , value = ""
    , minLength = 0
    , maxLength = 0
    , supportedCurrencies = []
    , supportedCountries = []
    , supportedSepaEuroCountries = []
    , supportedSepaNonEuroCountries = []
    , requiredForCountries = []
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PaymentAccountFormField` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PaymentAccountFormField :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PaymentAccountFormField
decodeProto__Io__Haveno__Protobuffer__PaymentAccountFormField =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PaymentAccountFormField
        [ Protobuf.Decode.optional
            1
            Proto.Io.Haveno.Protobuffer.PaymentAccountFormField.FieldId.decodeFieldId
            (\a r -> { r | id = a })
        , Protobuf.Decode.optional
            2
            Proto.Io.Haveno.Protobuffer.PaymentAccountFormField.Component.decodeComponent
            (\a r -> { r | component = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | type_ = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | label = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | value = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.uint32 (\a r -> { r | minLength = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.uint32 (\a r -> { r | maxLength = a })
        , Protobuf.Decode.repeated
            8
            decodeProto__Io__Haveno__Protobuffer__TradeCurrency
            .supportedCurrencies
            (\a r -> { r | supportedCurrencies = a })
        , Protobuf.Decode.repeated
            9
            decodeProto__Io__Haveno__Protobuffer__Country
            .supportedCountries
            (\a r -> { r | supportedCountries = a })
        , Protobuf.Decode.repeated
            10
            decodeProto__Io__Haveno__Protobuffer__Country
            .supportedSepaEuroCountries
            (\a r -> { r | supportedSepaEuroCountries = a })
        , Protobuf.Decode.repeated
            11
            decodeProto__Io__Haveno__Protobuffer__Country
            .supportedSepaNonEuroCountries
            (\a r -> { r | supportedSepaNonEuroCountries = a })
        , Protobuf.Decode.repeated
            12
            Protobuf.Decode.string
            .requiredForCountries
            (\a r -> { r | requiredForCountries = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PaymentAccountFormField` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PaymentAccountFormField :
    Proto__Io__Haveno__Protobuffer__PaymentAccountFormField -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PaymentAccountFormField value =
    Protobuf.Encode.message
        [ ( 1, Proto.Io.Haveno.Protobuffer.PaymentAccountFormField.FieldId.encodeFieldId value.id )
        , ( 2, Proto.Io.Haveno.Protobuffer.PaymentAccountFormField.Component.encodeComponent value.component )
        , ( 3, Protobuf.Encode.string value.type_ )
        , ( 4, Protobuf.Encode.string value.label )
        , ( 5, Protobuf.Encode.string value.value )
        , ( 6, Protobuf.Encode.uint32 value.minLength )
        , ( 7, Protobuf.Encode.uint32 value.maxLength )
        , ( 8, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__TradeCurrency) value.supportedCurrencies )
        , ( 9, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__Country) value.supportedCountries )
        , ( 10, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__Country) value.supportedSepaEuroCountries )
        , ( 11
          , (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__Country) value.supportedSepaNonEuroCountries
          )
        , ( 12, (Protobuf.Encode.list Protobuf.Encode.string) value.requiredForCountries )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PaymentAccountFormField` message

-}
type alias Proto__Io__Haveno__Protobuffer__PaymentAccountFormField =
    { id : Proto.Io.Haveno.Protobuffer.PaymentAccountFormField.FieldId.FieldId
    , component : Proto.Io.Haveno.Protobuffer.PaymentAccountFormField.Component.Component
    , type_ : String
    , label : String
    , value : String
    , minLength : Int
    , maxLength : Int
    , supportedCurrencies : List Proto__Io__Haveno__Protobuffer__TradeCurrency
    , supportedCountries : List Proto__Io__Haveno__Protobuffer__Country
    , supportedSepaEuroCountries : List Proto__Io__Haveno__Protobuffer__Country
    , supportedSepaNonEuroCountries : List Proto__Io__Haveno__Protobuffer__Country
    , requiredForCountries : List String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PaymentAccountForm`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountForm : { id : Int, fields : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountForm =
    { id = 1, fields = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__PaymentAccountForm. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PaymentAccountForm : Proto__Io__Haveno__Protobuffer__PaymentAccountForm
defaultProto__Io__Haveno__Protobuffer__PaymentAccountForm =
    { id = Proto.Io.Haveno.Protobuffer.PaymentAccountForm.FormId.defaultFormId, fields = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PaymentAccountForm` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PaymentAccountForm :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PaymentAccountForm
decodeProto__Io__Haveno__Protobuffer__PaymentAccountForm =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PaymentAccountForm
        [ Protobuf.Decode.optional
            1
            Proto.Io.Haveno.Protobuffer.PaymentAccountForm.FormId.decodeFormId
            (\a r -> { r | id = a })
        , Protobuf.Decode.repeated
            2
            decodeProto__Io__Haveno__Protobuffer__PaymentAccountFormField
            .fields
            (\a r -> { r | fields = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PaymentAccountForm` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PaymentAccountForm :
    Proto__Io__Haveno__Protobuffer__PaymentAccountForm -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PaymentAccountForm value =
    Protobuf.Encode.message
        [ ( 1, Proto.Io.Haveno.Protobuffer.PaymentAccountForm.FormId.encodeFormId value.id )
        , ( 2, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__PaymentAccountFormField) value.fields )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PaymentAccountForm` message

-}
type alias Proto__Io__Haveno__Protobuffer__PaymentAccountForm =
    { id : Proto.Io.Haveno.Protobuffer.PaymentAccountForm.FormId.FormId
    , fields : List Proto__Io__Haveno__Protobuffer__PaymentAccountFormField
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MockPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MockPayload : { messageVersion : Int, message : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MockPayload =
    { messageVersion = 1, message = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__MockPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MockPayload : Proto__Io__Haveno__Protobuffer__MockPayload
defaultProto__Io__Haveno__Protobuffer__MockPayload =
    { messageVersion = "", message = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MockPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MockPayload : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MockPayload
decodeProto__Io__Haveno__Protobuffer__MockPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MockPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | messageVersion = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | message = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MockPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MockPayload :
    Proto__Io__Haveno__Protobuffer__MockPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MockPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.messageVersion ), ( 2, Protobuf.Encode.string value.message ) ]


{-| `Proto__Io__Haveno__Protobuffer__MockPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__MockPayload =
    { messageVersion : String, message : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MockMailboxPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MockMailboxPayload : { message : Int, senderNodeAddress : Int, uid : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MockMailboxPayload =
    { message = 1, senderNodeAddress = 2, uid = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__MockMailboxPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MockMailboxPayload : Proto__Io__Haveno__Protobuffer__MockMailboxPayload
defaultProto__Io__Haveno__Protobuffer__MockMailboxPayload =
    { message = "", senderNodeAddress = Nothing, uid = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MockMailboxPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MockMailboxPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MockMailboxPayload
decodeProto__Io__Haveno__Protobuffer__MockMailboxPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MockMailboxPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | message = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | senderNodeAddress = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | uid = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MockMailboxPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MockMailboxPayload :
    Proto__Io__Haveno__Protobuffer__MockMailboxPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MockMailboxPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.message )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.senderNodeAddress
          )
        , ( 3, Protobuf.Encode.string value.uid )
        ]


{-| `Proto__Io__Haveno__Protobuffer__MockMailboxPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__MockMailboxPayload =
    { message : String, senderNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress, uid : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MarketAlertFilter`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MarketAlertFilter :
    { paymentAccount : Int, triggerValue : Int, isBuyOffer : Int, alertIds : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MarketAlertFilter =
    { paymentAccount = 1, triggerValue = 2, isBuyOffer = 3, alertIds = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__MarketAlertFilter. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MarketAlertFilter : Proto__Io__Haveno__Protobuffer__MarketAlertFilter
defaultProto__Io__Haveno__Protobuffer__MarketAlertFilter =
    { paymentAccount = Nothing, triggerValue = 0, isBuyOffer = False, alertIds = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MarketAlertFilter` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MarketAlertFilter :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MarketAlertFilter
decodeProto__Io__Haveno__Protobuffer__MarketAlertFilter =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MarketAlertFilter
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentAccount)
            (\a r -> { r | paymentAccount = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int32 (\a r -> { r | triggerValue = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.bool (\a r -> { r | isBuyOffer = a })
        , Protobuf.Decode.repeated 4 Protobuf.Decode.string .alertIds (\a r -> { r | alertIds = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MarketAlertFilter` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MarketAlertFilter :
    Proto__Io__Haveno__Protobuffer__MarketAlertFilter -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MarketAlertFilter value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentAccount >> Maybe.withDefault Protobuf.Encode.none)
                value.paymentAccount
          )
        , ( 2, Protobuf.Encode.int32 value.triggerValue )
        , ( 3, Protobuf.Encode.bool value.isBuyOffer )
        , ( 4, (Protobuf.Encode.list Protobuf.Encode.string) value.alertIds )
        ]


{-| `Proto__Io__Haveno__Protobuffer__MarketAlertFilter` message

-}
type alias Proto__Io__Haveno__Protobuffer__MarketAlertFilter =
    { paymentAccount : Maybe Proto__Io__Haveno__Protobuffer__PaymentAccount
    , triggerValue : Int
    , isBuyOffer : Bool
    , alertIds : List String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PriceAlertFilter`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PriceAlertFilter : { currencyCode : Int, high : Int, low : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PriceAlertFilter =
    { currencyCode = 1, high = 2, low = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__PriceAlertFilter. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PriceAlertFilter : Proto__Io__Haveno__Protobuffer__PriceAlertFilter
defaultProto__Io__Haveno__Protobuffer__PriceAlertFilter =
    { currencyCode = "", high = Protobuf.Types.Int64.fromInts 0 0, low = Protobuf.Types.Int64.fromInts 0 0 }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PriceAlertFilter` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PriceAlertFilter :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PriceAlertFilter
decodeProto__Io__Haveno__Protobuffer__PriceAlertFilter =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PriceAlertFilter
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | currencyCode = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int64 (\a r -> { r | high = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | low = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PriceAlertFilter` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PriceAlertFilter :
    Proto__Io__Haveno__Protobuffer__PriceAlertFilter -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PriceAlertFilter value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.currencyCode )
        , ( 2, Protobuf.Encode.int64 value.high )
        , ( 3, Protobuf.Encode.int64 value.low )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PriceAlertFilter` message

-}
type alias Proto__Io__Haveno__Protobuffer__PriceAlertFilter =
    { currencyCode : String, high : Protobuf.Types.Int64.Int64, low : Protobuf.Types.Int64.Int64 }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Region`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Region : { code : Int, name : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__Region =
    { code = 1, name = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__Region. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__Region : Proto__Io__Haveno__Protobuffer__Region
defaultProto__Io__Haveno__Protobuffer__Region =
    { code = "", name = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Region` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Region : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__Region
decodeProto__Io__Haveno__Protobuffer__Region =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__Region
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | code = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | name = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Region` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Region : Proto__Io__Haveno__Protobuffer__Region -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__Region value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.code ), ( 2, Protobuf.Encode.string value.name ) ]


{-| `Proto__Io__Haveno__Protobuffer__Region` message

-}
type alias Proto__Io__Haveno__Protobuffer__Region =
    { code : String, name : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Country`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Country : { code : Int, name : Int, region : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__Country =
    { code = 1, name = 2, region = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__Country. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__Country : Proto__Io__Haveno__Protobuffer__Country
defaultProto__Io__Haveno__Protobuffer__Country =
    { code = "", name = "", region = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Country` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Country : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__Country
decodeProto__Io__Haveno__Protobuffer__Country =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__Country
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | code = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | name = a })
        , Protobuf.Decode.optional
            3
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Region)
            (\a r -> { r | region = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Country` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Country : Proto__Io__Haveno__Protobuffer__Country -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__Country value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.code )
        , ( 2, Protobuf.Encode.string value.name )
        , ( 3
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Region >> Maybe.withDefault Protobuf.Encode.none)
                value.region
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__Country` message

-}
type alias Proto__Io__Haveno__Protobuffer__Country =
    { code : String, name : String, region : Maybe Proto__Io__Haveno__Protobuffer__Region }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__TraditionalCurrency`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__TraditionalCurrency : {}
fieldNumbersProto__Io__Haveno__Protobuffer__TraditionalCurrency =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__TraditionalCurrency. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__TraditionalCurrency : Proto__Io__Haveno__Protobuffer__TraditionalCurrency
defaultProto__Io__Haveno__Protobuffer__TraditionalCurrency =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__TraditionalCurrency` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__TraditionalCurrency :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__TraditionalCurrency
decodeProto__Io__Haveno__Protobuffer__TraditionalCurrency =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__TraditionalCurrency []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__TraditionalCurrency` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__TraditionalCurrency :
    Proto__Io__Haveno__Protobuffer__TraditionalCurrency -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__TraditionalCurrency _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__TraditionalCurrency` message

-}
type alias Proto__Io__Haveno__Protobuffer__TraditionalCurrency =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CryptoCurrency`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CryptoCurrency : { isAsset : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CryptoCurrency =
    { isAsset = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__CryptoCurrency. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CryptoCurrency : Proto__Io__Haveno__Protobuffer__CryptoCurrency
defaultProto__Io__Haveno__Protobuffer__CryptoCurrency =
    { isAsset = False }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CryptoCurrency` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CryptoCurrency :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CryptoCurrency
decodeProto__Io__Haveno__Protobuffer__CryptoCurrency =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CryptoCurrency
        [ Protobuf.Decode.optional 1 Protobuf.Decode.bool (\a r -> { r | isAsset = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CryptoCurrency` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CryptoCurrency :
    Proto__Io__Haveno__Protobuffer__CryptoCurrency -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CryptoCurrency value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.bool value.isAsset ) ]


{-| `Proto__Io__Haveno__Protobuffer__CryptoCurrency` message

-}
type alias Proto__Io__Haveno__Protobuffer__CryptoCurrency =
    { isAsset : Bool }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__TradeCurrency`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__TradeCurrency :
    { code : Int, name : Int, message : FieldNumbersProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message }
fieldNumbersProto__Io__Haveno__Protobuffer__TradeCurrency =
    { code = 1, name = 2, message = fieldNumbersProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message }


{-| Default for Proto__Io__Haveno__Protobuffer__TradeCurrency. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__TradeCurrency : Proto__Io__Haveno__Protobuffer__TradeCurrency
defaultProto__Io__Haveno__Protobuffer__TradeCurrency =
    { code = "", name = "", message = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__TradeCurrency` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__TradeCurrency :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__TradeCurrency
decodeProto__Io__Haveno__Protobuffer__TradeCurrency =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__TradeCurrency
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | code = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | name = a })
        , decodeProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message (\a r -> { r | message = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__TradeCurrency` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__TradeCurrency :
    Proto__Io__Haveno__Protobuffer__TradeCurrency -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__TradeCurrency value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.code )
        , ( 2, Protobuf.Encode.string value.name )
        , encodeProto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message value.message
        ]


{-| `Proto__Io__Haveno__Protobuffer__TradeCurrency` message

-}
type alias Proto__Io__Haveno__Protobuffer__TradeCurrency =
    { code : String, name : String, message : Maybe Proto__Io__Haveno__Protobuffer__TradeCurrency__Message__Message }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Currency`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Currency : { currencyCode : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__Currency =
    { currencyCode = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__Currency. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__Currency : Proto__Io__Haveno__Protobuffer__Currency
defaultProto__Io__Haveno__Protobuffer__Currency =
    { currencyCode = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Currency` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Currency : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__Currency
decodeProto__Io__Haveno__Protobuffer__Currency =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__Currency
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | currencyCode = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Currency` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Currency : Proto__Io__Haveno__Protobuffer__Currency -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__Currency value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.currencyCode ) ]


{-| `Proto__Io__Haveno__Protobuffer__Currency` message

-}
type alias Proto__Io__Haveno__Protobuffer__Currency =
    { currencyCode : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PaymentMethod`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentMethod :
    { id : Int, maxTradePeriod : Int, maxTradeLimit : Int, supportedAssetCodes : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentMethod =
    { id = 1, maxTradePeriod = 2, maxTradeLimit = 3, supportedAssetCodes = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__PaymentMethod. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PaymentMethod : Proto__Io__Haveno__Protobuffer__PaymentMethod
defaultProto__Io__Haveno__Protobuffer__PaymentMethod =
    { id = ""
    , maxTradePeriod = Protobuf.Types.Int64.fromInts 0 0
    , maxTradeLimit = Protobuf.Types.Int64.fromInts 0 0
    , supportedAssetCodes = []
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PaymentMethod` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PaymentMethod :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PaymentMethod
decodeProto__Io__Haveno__Protobuffer__PaymentMethod =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PaymentMethod
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | id = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int64 (\a r -> { r | maxTradePeriod = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | maxTradeLimit = a })
        , Protobuf.Decode.repeated
            4
            Protobuf.Decode.string
            .supportedAssetCodes
            (\a r -> { r | supportedAssetCodes = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PaymentMethod` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PaymentMethod :
    Proto__Io__Haveno__Protobuffer__PaymentMethod -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PaymentMethod value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.id )
        , ( 2, Protobuf.Encode.int64 value.maxTradePeriod )
        , ( 3, Protobuf.Encode.int64 value.maxTradeLimit )
        , ( 4, (Protobuf.Encode.list Protobuf.Encode.string) value.supportedAssetCodes )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PaymentMethod` message

-}
type alias Proto__Io__Haveno__Protobuffer__PaymentMethod =
    { id : String
    , maxTradePeriod : Protobuf.Types.Int64.Int64
    , maxTradeLimit : Protobuf.Types.Int64.Int64
    , supportedAssetCodes : List String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PaymentAccount`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccount :
    { id : Int
    , creationDate : Int
    , paymentMethod : Int
    , accountName : Int
    , tradeCurrencies : Int
    , selectedTradeCurrency : Int
    , paymentAccountPayload : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccount =
    { id = 1
    , creationDate = 2
    , paymentMethod = 3
    , accountName = 4
    , tradeCurrencies = 5
    , selectedTradeCurrency = 6
    , paymentAccountPayload = 7
    }


{-| Default for Proto__Io__Haveno__Protobuffer__PaymentAccount. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PaymentAccount : Proto__Io__Haveno__Protobuffer__PaymentAccount
defaultProto__Io__Haveno__Protobuffer__PaymentAccount =
    { id = ""
    , creationDate = Protobuf.Types.Int64.fromInts 0 0
    , paymentMethod = Nothing
    , accountName = ""
    , tradeCurrencies = []
    , selectedTradeCurrency = Nothing
    , paymentAccountPayload = Nothing
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PaymentAccount` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PaymentAccount :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PaymentAccount
decodeProto__Io__Haveno__Protobuffer__PaymentAccount =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PaymentAccount
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | id = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int64 (\a r -> { r | creationDate = a })
        , Protobuf.Decode.optional
            3
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentMethod)
            (\a r -> { r | paymentMethod = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | accountName = a })
        , Protobuf.Decode.repeated
            5
            decodeProto__Io__Haveno__Protobuffer__TradeCurrency
            .tradeCurrencies
            (\a r -> { r | tradeCurrencies = a })
        , Protobuf.Decode.optional
            6
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__TradeCurrency)
            (\a r -> { r | selectedTradeCurrency = a })
        , Protobuf.Decode.optional
            7
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload)
            (\a r -> { r | paymentAccountPayload = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PaymentAccount` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PaymentAccount :
    Proto__Io__Haveno__Protobuffer__PaymentAccount -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PaymentAccount value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.id )
        , ( 2, Protobuf.Encode.int64 value.creationDate )
        , ( 3
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentMethod >> Maybe.withDefault Protobuf.Encode.none)
                value.paymentMethod
          )
        , ( 4, Protobuf.Encode.string value.accountName )
        , ( 5, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__TradeCurrency) value.tradeCurrencies )
        , ( 6
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__TradeCurrency >> Maybe.withDefault Protobuf.Encode.none)
                value.selectedTradeCurrency
          )
        , ( 7
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.paymentAccountPayload
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PaymentAccount` message

-}
type alias Proto__Io__Haveno__Protobuffer__PaymentAccount =
    { id : String
    , creationDate : Protobuf.Types.Int64.Int64
    , paymentMethod : Maybe Proto__Io__Haveno__Protobuffer__PaymentMethod
    , accountName : String
    , tradeCurrencies : List Proto__Io__Haveno__Protobuffer__TradeCurrency
    , selectedTradeCurrency : Maybe Proto__Io__Haveno__Protobuffer__TradeCurrency
    , paymentAccountPayload : Maybe Proto__Io__Haveno__Protobuffer__PaymentAccountPayload
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__BlockChainExplorer`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__BlockChainExplorer : { name : Int, txUrl : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__BlockChainExplorer =
    { name = 1, txUrl = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__BlockChainExplorer. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__BlockChainExplorer : Proto__Io__Haveno__Protobuffer__BlockChainExplorer
defaultProto__Io__Haveno__Protobuffer__BlockChainExplorer =
    { name = "", txUrl = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__BlockChainExplorer` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__BlockChainExplorer :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__BlockChainExplorer
decodeProto__Io__Haveno__Protobuffer__BlockChainExplorer =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__BlockChainExplorer
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | name = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | txUrl = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__BlockChainExplorer` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__BlockChainExplorer :
    Proto__Io__Haveno__Protobuffer__BlockChainExplorer -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__BlockChainExplorer value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.name ), ( 2, Protobuf.Encode.string value.txUrl ) ]


{-| `Proto__Io__Haveno__Protobuffer__BlockChainExplorer` message

-}
type alias Proto__Io__Haveno__Protobuffer__BlockChainExplorer =
    { name : String, txUrl : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__UserPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__UserPayload :
    { accountId : Int
    , paymentAccounts : Int
    , currentPaymentAccount : Int
    , acceptedLanguageLocaleCodes : Int
    , developersAlert : Int
    , displayedAlert : Int
    , developersFilter : Int
    , acceptedArbitrators : Int
    , acceptedMediators : Int
    , registeredArbitrator : Int
    , registeredMediator : Int
    , priceAlertFilter : Int
    , marketAlertFilters : Int
    , acceptedRefundAgents : Int
    , registeredRefundAgent : Int
    , cookie : Int
    , walletCreationDate : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__UserPayload =
    { accountId = 1
    , paymentAccounts = 2
    , currentPaymentAccount = 3
    , acceptedLanguageLocaleCodes = 4
    , developersAlert = 5
    , displayedAlert = 6
    , developersFilter = 7
    , acceptedArbitrators = 8
    , acceptedMediators = 9
    , registeredArbitrator = 10
    , registeredMediator = 11
    , priceAlertFilter = 12
    , marketAlertFilters = 13
    , acceptedRefundAgents = 14
    , registeredRefundAgent = 15
    , cookie = 16
    , walletCreationDate = 17
    }


{-| Default for Proto__Io__Haveno__Protobuffer__UserPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__UserPayload : Proto__Io__Haveno__Protobuffer__UserPayload
defaultProto__Io__Haveno__Protobuffer__UserPayload =
    { accountId = ""
    , paymentAccounts = []
    , currentPaymentAccount = Nothing
    , acceptedLanguageLocaleCodes = []
    , developersAlert = Nothing
    , displayedAlert = Nothing
    , developersFilter = Nothing
    , acceptedArbitrators = []
    , acceptedMediators = []
    , registeredArbitrator = Nothing
    , registeredMediator = Nothing
    , priceAlertFilter = Nothing
    , marketAlertFilters = []
    , acceptedRefundAgents = []
    , registeredRefundAgent = Nothing
    , cookie = Dict.empty
    , walletCreationDate = Protobuf.Types.Int64.fromInts 0 0
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__UserPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__UserPayload : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__UserPayload
decodeProto__Io__Haveno__Protobuffer__UserPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__UserPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | accountId = a })
        , Protobuf.Decode.repeated
            2
            decodeProto__Io__Haveno__Protobuffer__PaymentAccount
            .paymentAccounts
            (\a r -> { r | paymentAccounts = a })
        , Protobuf.Decode.optional
            3
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentAccount)
            (\a r -> { r | currentPaymentAccount = a })
        , Protobuf.Decode.repeated
            4
            Protobuf.Decode.string
            .acceptedLanguageLocaleCodes
            (\a r -> { r | acceptedLanguageLocaleCodes = a })
        , Protobuf.Decode.optional
            5
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Alert)
            (\a r -> { r | developersAlert = a })
        , Protobuf.Decode.optional
            6
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Alert)
            (\a r -> { r | displayedAlert = a })
        , Protobuf.Decode.optional
            7
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Filter)
            (\a r -> { r | developersFilter = a })
        , Protobuf.Decode.repeated
            8
            decodeProto__Io__Haveno__Protobuffer__Arbitrator
            .acceptedArbitrators
            (\a r -> { r | acceptedArbitrators = a })
        , Protobuf.Decode.repeated
            9
            decodeProto__Io__Haveno__Protobuffer__Mediator
            .acceptedMediators
            (\a r -> { r | acceptedMediators = a })
        , Protobuf.Decode.optional
            10
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Arbitrator)
            (\a r -> { r | registeredArbitrator = a })
        , Protobuf.Decode.optional
            11
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Mediator)
            (\a r -> { r | registeredMediator = a })
        , Protobuf.Decode.optional
            12
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PriceAlertFilter)
            (\a r -> { r | priceAlertFilter = a })
        , Protobuf.Decode.repeated
            13
            decodeProto__Io__Haveno__Protobuffer__MarketAlertFilter
            .marketAlertFilters
            (\a r -> { r | marketAlertFilters = a })
        , Protobuf.Decode.repeated
            14
            decodeProto__Io__Haveno__Protobuffer__RefundAgent
            .acceptedRefundAgents
            (\a r -> { r | acceptedRefundAgents = a })
        , Protobuf.Decode.optional
            15
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__RefundAgent)
            (\a r -> { r | registeredRefundAgent = a })
        , Protobuf.Decode.mapped
            16
            ( "", "" )
            Protobuf.Decode.string
            Protobuf.Decode.string
            .cookie
            (\a r -> { r | cookie = a })
        , Protobuf.Decode.optional 17 Protobuf.Decode.int64 (\a r -> { r | walletCreationDate = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__UserPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__UserPayload :
    Proto__Io__Haveno__Protobuffer__UserPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__UserPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.accountId )
        , ( 2, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__PaymentAccount) value.paymentAccounts )
        , ( 3
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentAccount >> Maybe.withDefault Protobuf.Encode.none)
                value.currentPaymentAccount
          )
        , ( 4, (Protobuf.Encode.list Protobuf.Encode.string) value.acceptedLanguageLocaleCodes )
        , ( 5
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Alert >> Maybe.withDefault Protobuf.Encode.none)
                value.developersAlert
          )
        , ( 6
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Alert >> Maybe.withDefault Protobuf.Encode.none)
                value.displayedAlert
          )
        , ( 7
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Filter >> Maybe.withDefault Protobuf.Encode.none)
                value.developersFilter
          )
        , ( 8, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__Arbitrator) value.acceptedArbitrators )
        , ( 9, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__Mediator) value.acceptedMediators )
        , ( 10
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Arbitrator >> Maybe.withDefault Protobuf.Encode.none)
                value.registeredArbitrator
          )
        , ( 11
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Mediator >> Maybe.withDefault Protobuf.Encode.none)
                value.registeredMediator
          )
        , ( 12
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PriceAlertFilter >> Maybe.withDefault Protobuf.Encode.none)
                value.priceAlertFilter
          )
        , ( 13
          , (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__MarketAlertFilter) value.marketAlertFilters
          )
        , ( 14, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__RefundAgent) value.acceptedRefundAgents )
        , ( 15
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__RefundAgent >> Maybe.withDefault Protobuf.Encode.none)
                value.registeredRefundAgent
          )
        , ( 16, Protobuf.Encode.dict Protobuf.Encode.string Protobuf.Encode.string value.cookie )
        , ( 17, Protobuf.Encode.int64 value.walletCreationDate )
        ]


{-| `Proto__Io__Haveno__Protobuffer__UserPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__UserPayload =
    { accountId : String
    , paymentAccounts : List Proto__Io__Haveno__Protobuffer__PaymentAccount
    , currentPaymentAccount : Maybe Proto__Io__Haveno__Protobuffer__PaymentAccount
    , acceptedLanguageLocaleCodes : List String
    , developersAlert : Maybe Proto__Io__Haveno__Protobuffer__Alert
    , displayedAlert : Maybe Proto__Io__Haveno__Protobuffer__Alert
    , developersFilter : Maybe Proto__Io__Haveno__Protobuffer__Filter
    , acceptedArbitrators : List Proto__Io__Haveno__Protobuffer__Arbitrator
    , acceptedMediators : List Proto__Io__Haveno__Protobuffer__Mediator
    , registeredArbitrator : Maybe Proto__Io__Haveno__Protobuffer__Arbitrator
    , registeredMediator : Maybe Proto__Io__Haveno__Protobuffer__Mediator
    , priceAlertFilter : Maybe Proto__Io__Haveno__Protobuffer__PriceAlertFilter
    , marketAlertFilters : List Proto__Io__Haveno__Protobuffer__MarketAlertFilter
    , acceptedRefundAgents : List Proto__Io__Haveno__Protobuffer__RefundAgent
    , registeredRefundAgent : Maybe Proto__Io__Haveno__Protobuffer__RefundAgent
    , cookie : Dict.Dict String String
    , walletCreationDate : Protobuf.Types.Int64.Int64
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__XmrNodeSettings`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__XmrNodeSettings :
    { blockchainPath : Int, bootstrapUrl : Int, startupFlags : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__XmrNodeSettings =
    { blockchainPath = 1, bootstrapUrl = 2, startupFlags = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__XmrNodeSettings. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__XmrNodeSettings : Proto__Io__Haveno__Protobuffer__XmrNodeSettings
defaultProto__Io__Haveno__Protobuffer__XmrNodeSettings =
    { blockchainPath = "", bootstrapUrl = "", startupFlags = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__XmrNodeSettings` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__XmrNodeSettings :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__XmrNodeSettings
decodeProto__Io__Haveno__Protobuffer__XmrNodeSettings =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__XmrNodeSettings
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | blockchainPath = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | bootstrapUrl = a })
        , Protobuf.Decode.repeated 3 Protobuf.Decode.string .startupFlags (\a r -> { r | startupFlags = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__XmrNodeSettings` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__XmrNodeSettings :
    Proto__Io__Haveno__Protobuffer__XmrNodeSettings -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__XmrNodeSettings value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.blockchainPath )
        , ( 2, Protobuf.Encode.string value.bootstrapUrl )
        , ( 3, (Protobuf.Encode.list Protobuf.Encode.string) value.startupFlags )
        ]


{-| `Proto__Io__Haveno__Protobuffer__XmrNodeSettings` message

-}
type alias Proto__Io__Haveno__Protobuffer__XmrNodeSettings =
    { blockchainPath : String, bootstrapUrl : String, startupFlags : List String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AutoConfirmSettings`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AutoConfirmSettings :
    { enabled : Int, requiredConfirmations : Int, tradeLimit : Int, serviceAddresses : Int, currencyCode : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__AutoConfirmSettings =
    { enabled = 1, requiredConfirmations = 2, tradeLimit = 3, serviceAddresses = 4, currencyCode = 5 }


{-| Default for Proto__Io__Haveno__Protobuffer__AutoConfirmSettings. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AutoConfirmSettings : Proto__Io__Haveno__Protobuffer__AutoConfirmSettings
defaultProto__Io__Haveno__Protobuffer__AutoConfirmSettings =
    { enabled = False
    , requiredConfirmations = 0
    , tradeLimit = Protobuf.Types.Int64.fromInts 0 0
    , serviceAddresses = []
    , currencyCode = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AutoConfirmSettings` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AutoConfirmSettings :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AutoConfirmSettings
decodeProto__Io__Haveno__Protobuffer__AutoConfirmSettings =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AutoConfirmSettings
        [ Protobuf.Decode.optional 1 Protobuf.Decode.bool (\a r -> { r | enabled = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int32 (\a r -> { r | requiredConfirmations = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | tradeLimit = a })
        , Protobuf.Decode.repeated 4 Protobuf.Decode.string .serviceAddresses (\a r -> { r | serviceAddresses = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | currencyCode = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AutoConfirmSettings` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AutoConfirmSettings :
    Proto__Io__Haveno__Protobuffer__AutoConfirmSettings -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AutoConfirmSettings value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.bool value.enabled )
        , ( 2, Protobuf.Encode.int32 value.requiredConfirmations )
        , ( 3, Protobuf.Encode.int64 value.tradeLimit )
        , ( 4, (Protobuf.Encode.list Protobuf.Encode.string) value.serviceAddresses )
        , ( 5, Protobuf.Encode.string value.currencyCode )
        ]


{-| `Proto__Io__Haveno__Protobuffer__AutoConfirmSettings` message

-}
type alias Proto__Io__Haveno__Protobuffer__AutoConfirmSettings =
    { enabled : Bool
    , requiredConfirmations : Int
    , tradeLimit : Protobuf.Types.Int64.Int64
    , serviceAddresses : List String
    , currencyCode : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PreferencesPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PreferencesPayload :
    { userLanguage : Int
    , userCountry : Int
    , traditionalCurrencies : Int
    , cryptoCurrencies : Int
    , blockChainExplorerMainNet : Int
    , blockChainExplorerTestNet : Int
    , backupDirectory : Int
    , autoSelectArbitrators : Int
    , dontShowAgainMap : Int
    , tacAccepted : Int
    , useTorForXmrOrdinal : Int
    , showOwnOffersInOfferBook : Int
    , preferredTradeCurrency : Int
    , withdrawalTxFeeInVbytes : Int
    , useCustomWithdrawalTxFee : Int
    , maxPriceDistanceInPercent : Int
    , offerBookChartScreenCurrencyCode : Int
    , tradeChartsScreenCurrencyCode : Int
    , buyScreenCurrencyCode : Int
    , sellScreenCurrencyCode : Int
    , tradeStatisticsTickUnitIndex : Int
    , resyncSpvRequested : Int
    , sortMarketCurrenciesNumerically : Int
    , usePercentageBasedPrice : Int
    , peerTagMap : Int
    , moneroNodes : Int
    , ignoreTradersList : Int
    , directoryChooserPath : Int
    , useAnimations : Int
    , selectedPaymentAccountForCreateOffer : Int
    , bridgeAddresses : Int
    , bridgeOptionOrdinal : Int
    , torTransportOrdinal : Int
    , customBridges : Int
    , moneroNodesOptionOrdinal : Int
    , referralId : Int
    , phoneKeyAndToken : Int
    , useSoundForMobileNotifications : Int
    , useTradeNotifications : Int
    , useMarketNotifications : Int
    , usePriceNotifications : Int
    , useStandbyMode : Int
    , rpcUser : Int
    , rpcPw : Int
    , takeOfferSelectedPaymentAccountId : Int
    , buyerSecurityDepositAsPercent : Int
    , ignoreDustThreshold : Int
    , buyerSecurityDepositAsPercentForCrypto : Int
    , blockNotifyPort : Int
    , cssTheme : Int
    , tacAcceptedV120 : Int
    , autoConfirmSettings : Int
    , bsqAverageTrimThreshold : Int
    , hideNonAccountPaymentMethods : Int
    , showOffersMatchingMyAccounts : Int
    , denyApiTaker : Int
    , notifyOnPreRelease : Int
    , xmrNodeSettings : Int
    , clearDataAfterDays : Int
    , buyScreenCryptoCurrencyCode : Int
    , sellScreenCryptoCurrencyCode : Int
    , splitOfferOutput : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__PreferencesPayload =
    { userLanguage = 1
    , userCountry = 2
    , traditionalCurrencies = 3
    , cryptoCurrencies = 4
    , blockChainExplorerMainNet = 5
    , blockChainExplorerTestNet = 6
    , backupDirectory = 7
    , autoSelectArbitrators = 8
    , dontShowAgainMap = 9
    , tacAccepted = 10
    , useTorForXmrOrdinal = 11
    , showOwnOffersInOfferBook = 12
    , preferredTradeCurrency = 13
    , withdrawalTxFeeInVbytes = 14
    , useCustomWithdrawalTxFee = 15
    , maxPriceDistanceInPercent = 16
    , offerBookChartScreenCurrencyCode = 17
    , tradeChartsScreenCurrencyCode = 18
    , buyScreenCurrencyCode = 19
    , sellScreenCurrencyCode = 20
    , tradeStatisticsTickUnitIndex = 21
    , resyncSpvRequested = 22
    , sortMarketCurrenciesNumerically = 23
    , usePercentageBasedPrice = 24
    , peerTagMap = 25
    , moneroNodes = 26
    , ignoreTradersList = 27
    , directoryChooserPath = 28
    , useAnimations = 29
    , selectedPaymentAccountForCreateOffer = 30
    , bridgeAddresses = 31
    , bridgeOptionOrdinal = 32
    , torTransportOrdinal = 33
    , customBridges = 34
    , moneroNodesOptionOrdinal = 35
    , referralId = 36
    , phoneKeyAndToken = 37
    , useSoundForMobileNotifications = 38
    , useTradeNotifications = 39
    , useMarketNotifications = 40
    , usePriceNotifications = 41
    , useStandbyMode = 42
    , rpcUser = 43
    , rpcPw = 44
    , takeOfferSelectedPaymentAccountId = 45
    , buyerSecurityDepositAsPercent = 46
    , ignoreDustThreshold = 47
    , buyerSecurityDepositAsPercentForCrypto = 48
    , blockNotifyPort = 49
    , cssTheme = 50
    , tacAcceptedV120 = 51
    , autoConfirmSettings = 52
    , bsqAverageTrimThreshold = 53
    , hideNonAccountPaymentMethods = 54
    , showOffersMatchingMyAccounts = 55
    , denyApiTaker = 56
    , notifyOnPreRelease = 57
    , xmrNodeSettings = 58
    , clearDataAfterDays = 59
    , buyScreenCryptoCurrencyCode = 60
    , sellScreenCryptoCurrencyCode = 61
    , splitOfferOutput = 62
    }


{-| Default for Proto__Io__Haveno__Protobuffer__PreferencesPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PreferencesPayload : Proto__Io__Haveno__Protobuffer__PreferencesPayload
defaultProto__Io__Haveno__Protobuffer__PreferencesPayload =
    { userLanguage = ""
    , userCountry = Nothing
    , traditionalCurrencies = []
    , cryptoCurrencies = []
    , blockChainExplorerMainNet = Nothing
    , blockChainExplorerTestNet = Nothing
    , backupDirectory = ""
    , autoSelectArbitrators = False
    , dontShowAgainMap = Dict.empty
    , tacAccepted = False
    , useTorForXmrOrdinal = 0
    , showOwnOffersInOfferBook = False
    , preferredTradeCurrency = Nothing
    , withdrawalTxFeeInVbytes = Protobuf.Types.Int64.fromInts 0 0
    , useCustomWithdrawalTxFee = False
    , maxPriceDistanceInPercent = 0
    , offerBookChartScreenCurrencyCode = ""
    , tradeChartsScreenCurrencyCode = ""
    , buyScreenCurrencyCode = ""
    , sellScreenCurrencyCode = ""
    , tradeStatisticsTickUnitIndex = 0
    , resyncSpvRequested = False
    , sortMarketCurrenciesNumerically = False
    , usePercentageBasedPrice = False
    , peerTagMap = Dict.empty
    , moneroNodes = ""
    , ignoreTradersList = []
    , directoryChooserPath = ""
    , useAnimations = False
    , selectedPaymentAccountForCreateOffer = Nothing
    , bridgeAddresses = []
    , bridgeOptionOrdinal = 0
    , torTransportOrdinal = 0
    , customBridges = ""
    , moneroNodesOptionOrdinal = 0
    , referralId = ""
    , phoneKeyAndToken = ""
    , useSoundForMobileNotifications = False
    , useTradeNotifications = False
    , useMarketNotifications = False
    , usePriceNotifications = False
    , useStandbyMode = False
    , rpcUser = ""
    , rpcPw = ""
    , takeOfferSelectedPaymentAccountId = ""
    , buyerSecurityDepositAsPercent = 0
    , ignoreDustThreshold = 0
    , buyerSecurityDepositAsPercentForCrypto = 0
    , blockNotifyPort = 0
    , cssTheme = 0
    , tacAcceptedV120 = False
    , autoConfirmSettings = []
    , bsqAverageTrimThreshold = 0
    , hideNonAccountPaymentMethods = False
    , showOffersMatchingMyAccounts = False
    , denyApiTaker = False
    , notifyOnPreRelease = False
    , xmrNodeSettings = Nothing
    , clearDataAfterDays = 0
    , buyScreenCryptoCurrencyCode = ""
    , sellScreenCryptoCurrencyCode = ""
    , splitOfferOutput = False
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PreferencesPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PreferencesPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PreferencesPayload
decodeProto__Io__Haveno__Protobuffer__PreferencesPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PreferencesPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | userLanguage = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Country)
            (\a r -> { r | userCountry = a })
        , Protobuf.Decode.repeated
            3
            decodeProto__Io__Haveno__Protobuffer__TradeCurrency
            .traditionalCurrencies
            (\a r -> { r | traditionalCurrencies = a })
        , Protobuf.Decode.repeated
            4
            decodeProto__Io__Haveno__Protobuffer__TradeCurrency
            .cryptoCurrencies
            (\a r -> { r | cryptoCurrencies = a })
        , Protobuf.Decode.optional
            5
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__BlockChainExplorer)
            (\a r -> { r | blockChainExplorerMainNet = a })
        , Protobuf.Decode.optional
            6
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__BlockChainExplorer)
            (\a r -> { r | blockChainExplorerTestNet = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | backupDirectory = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.bool (\a r -> { r | autoSelectArbitrators = a })
        , Protobuf.Decode.mapped
            9
            ( "", False )
            Protobuf.Decode.string
            Protobuf.Decode.bool
            .dontShowAgainMap
            (\a r -> { r | dontShowAgainMap = a })
        , Protobuf.Decode.optional 10 Protobuf.Decode.bool (\a r -> { r | tacAccepted = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.int32 (\a r -> { r | useTorForXmrOrdinal = a })
        , Protobuf.Decode.optional 12 Protobuf.Decode.bool (\a r -> { r | showOwnOffersInOfferBook = a })
        , Protobuf.Decode.optional
            13
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__TradeCurrency)
            (\a r -> { r | preferredTradeCurrency = a })
        , Protobuf.Decode.optional 14 Protobuf.Decode.int64 (\a r -> { r | withdrawalTxFeeInVbytes = a })
        , Protobuf.Decode.optional 15 Protobuf.Decode.bool (\a r -> { r | useCustomWithdrawalTxFee = a })
        , Protobuf.Decode.optional 16 Protobuf.Decode.double (\a r -> { r | maxPriceDistanceInPercent = a })
        , Protobuf.Decode.optional 17 Protobuf.Decode.string (\a r -> { r | offerBookChartScreenCurrencyCode = a })
        , Protobuf.Decode.optional 18 Protobuf.Decode.string (\a r -> { r | tradeChartsScreenCurrencyCode = a })
        , Protobuf.Decode.optional 19 Protobuf.Decode.string (\a r -> { r | buyScreenCurrencyCode = a })
        , Protobuf.Decode.optional 20 Protobuf.Decode.string (\a r -> { r | sellScreenCurrencyCode = a })
        , Protobuf.Decode.optional 21 Protobuf.Decode.int32 (\a r -> { r | tradeStatisticsTickUnitIndex = a })
        , Protobuf.Decode.optional 22 Protobuf.Decode.bool (\a r -> { r | resyncSpvRequested = a })
        , Protobuf.Decode.optional 23 Protobuf.Decode.bool (\a r -> { r | sortMarketCurrenciesNumerically = a })
        , Protobuf.Decode.optional 24 Protobuf.Decode.bool (\a r -> { r | usePercentageBasedPrice = a })
        , Protobuf.Decode.mapped
            25
            ( "", "" )
            Protobuf.Decode.string
            Protobuf.Decode.string
            .peerTagMap
            (\a r -> { r | peerTagMap = a })
        , Protobuf.Decode.optional 26 Protobuf.Decode.string (\a r -> { r | moneroNodes = a })
        , Protobuf.Decode.repeated 27 Protobuf.Decode.string .ignoreTradersList (\a r -> { r | ignoreTradersList = a })
        , Protobuf.Decode.optional 28 Protobuf.Decode.string (\a r -> { r | directoryChooserPath = a })
        , Protobuf.Decode.optional 29 Protobuf.Decode.bool (\a r -> { r | useAnimations = a })
        , Protobuf.Decode.optional
            30
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentAccount)
            (\a r -> { r | selectedPaymentAccountForCreateOffer = a })
        , Protobuf.Decode.repeated 31 Protobuf.Decode.string .bridgeAddresses (\a r -> { r | bridgeAddresses = a })
        , Protobuf.Decode.optional 32 Protobuf.Decode.int32 (\a r -> { r | bridgeOptionOrdinal = a })
        , Protobuf.Decode.optional 33 Protobuf.Decode.int32 (\a r -> { r | torTransportOrdinal = a })
        , Protobuf.Decode.optional 34 Protobuf.Decode.string (\a r -> { r | customBridges = a })
        , Protobuf.Decode.optional 35 Protobuf.Decode.int32 (\a r -> { r | moneroNodesOptionOrdinal = a })
        , Protobuf.Decode.optional 36 Protobuf.Decode.string (\a r -> { r | referralId = a })
        , Protobuf.Decode.optional 37 Protobuf.Decode.string (\a r -> { r | phoneKeyAndToken = a })
        , Protobuf.Decode.optional 38 Protobuf.Decode.bool (\a r -> { r | useSoundForMobileNotifications = a })
        , Protobuf.Decode.optional 39 Protobuf.Decode.bool (\a r -> { r | useTradeNotifications = a })
        , Protobuf.Decode.optional 40 Protobuf.Decode.bool (\a r -> { r | useMarketNotifications = a })
        , Protobuf.Decode.optional 41 Protobuf.Decode.bool (\a r -> { r | usePriceNotifications = a })
        , Protobuf.Decode.optional 42 Protobuf.Decode.bool (\a r -> { r | useStandbyMode = a })
        , Protobuf.Decode.optional 43 Protobuf.Decode.string (\a r -> { r | rpcUser = a })
        , Protobuf.Decode.optional 44 Protobuf.Decode.string (\a r -> { r | rpcPw = a })
        , Protobuf.Decode.optional 45 Protobuf.Decode.string (\a r -> { r | takeOfferSelectedPaymentAccountId = a })
        , Protobuf.Decode.optional 46 Protobuf.Decode.double (\a r -> { r | buyerSecurityDepositAsPercent = a })
        , Protobuf.Decode.optional 47 Protobuf.Decode.int32 (\a r -> { r | ignoreDustThreshold = a })
        , Protobuf.Decode.optional
            48
            Protobuf.Decode.double
            (\a r -> { r | buyerSecurityDepositAsPercentForCrypto = a })
        , Protobuf.Decode.optional 49 Protobuf.Decode.int32 (\a r -> { r | blockNotifyPort = a })
        , Protobuf.Decode.optional 50 Protobuf.Decode.int32 (\a r -> { r | cssTheme = a })
        , Protobuf.Decode.optional 51 Protobuf.Decode.bool (\a r -> { r | tacAcceptedV120 = a })
        , Protobuf.Decode.repeated
            52
            decodeProto__Io__Haveno__Protobuffer__AutoConfirmSettings
            .autoConfirmSettings
            (\a r -> { r | autoConfirmSettings = a })
        , Protobuf.Decode.optional 53 Protobuf.Decode.double (\a r -> { r | bsqAverageTrimThreshold = a })
        , Protobuf.Decode.optional 54 Protobuf.Decode.bool (\a r -> { r | hideNonAccountPaymentMethods = a })
        , Protobuf.Decode.optional 55 Protobuf.Decode.bool (\a r -> { r | showOffersMatchingMyAccounts = a })
        , Protobuf.Decode.optional 56 Protobuf.Decode.bool (\a r -> { r | denyApiTaker = a })
        , Protobuf.Decode.optional 57 Protobuf.Decode.bool (\a r -> { r | notifyOnPreRelease = a })
        , Protobuf.Decode.optional
            58
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__XmrNodeSettings)
            (\a r -> { r | xmrNodeSettings = a })
        , Protobuf.Decode.optional 59 Protobuf.Decode.int32 (\a r -> { r | clearDataAfterDays = a })
        , Protobuf.Decode.optional 60 Protobuf.Decode.string (\a r -> { r | buyScreenCryptoCurrencyCode = a })
        , Protobuf.Decode.optional 61 Protobuf.Decode.string (\a r -> { r | sellScreenCryptoCurrencyCode = a })
        , Protobuf.Decode.optional 62 Protobuf.Decode.bool (\a r -> { r | splitOfferOutput = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PreferencesPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PreferencesPayload :
    Proto__Io__Haveno__Protobuffer__PreferencesPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PreferencesPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.userLanguage )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Country >> Maybe.withDefault Protobuf.Encode.none)
                value.userCountry
          )
        , ( 3, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__TradeCurrency) value.traditionalCurrencies )
        , ( 4, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__TradeCurrency) value.cryptoCurrencies )
        , ( 5
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__BlockChainExplorer
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.blockChainExplorerMainNet
          )
        , ( 6
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__BlockChainExplorer
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.blockChainExplorerTestNet
          )
        , ( 7, Protobuf.Encode.string value.backupDirectory )
        , ( 8, Protobuf.Encode.bool value.autoSelectArbitrators )
        , ( 9, Protobuf.Encode.dict Protobuf.Encode.string Protobuf.Encode.bool value.dontShowAgainMap )
        , ( 10, Protobuf.Encode.bool value.tacAccepted )
        , ( 11, Protobuf.Encode.int32 value.useTorForXmrOrdinal )
        , ( 12, Protobuf.Encode.bool value.showOwnOffersInOfferBook )
        , ( 13
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__TradeCurrency >> Maybe.withDefault Protobuf.Encode.none)
                value.preferredTradeCurrency
          )
        , ( 14, Protobuf.Encode.int64 value.withdrawalTxFeeInVbytes )
        , ( 15, Protobuf.Encode.bool value.useCustomWithdrawalTxFee )
        , ( 16, Protobuf.Encode.double value.maxPriceDistanceInPercent )
        , ( 17, Protobuf.Encode.string value.offerBookChartScreenCurrencyCode )
        , ( 18, Protobuf.Encode.string value.tradeChartsScreenCurrencyCode )
        , ( 19, Protobuf.Encode.string value.buyScreenCurrencyCode )
        , ( 20, Protobuf.Encode.string value.sellScreenCurrencyCode )
        , ( 21, Protobuf.Encode.int32 value.tradeStatisticsTickUnitIndex )
        , ( 22, Protobuf.Encode.bool value.resyncSpvRequested )
        , ( 23, Protobuf.Encode.bool value.sortMarketCurrenciesNumerically )
        , ( 24, Protobuf.Encode.bool value.usePercentageBasedPrice )
        , ( 25, Protobuf.Encode.dict Protobuf.Encode.string Protobuf.Encode.string value.peerTagMap )
        , ( 26, Protobuf.Encode.string value.moneroNodes )
        , ( 27, (Protobuf.Encode.list Protobuf.Encode.string) value.ignoreTradersList )
        , ( 28, Protobuf.Encode.string value.directoryChooserPath )
        , ( 29, Protobuf.Encode.bool value.useAnimations )
        , ( 30
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentAccount >> Maybe.withDefault Protobuf.Encode.none)
                value.selectedPaymentAccountForCreateOffer
          )
        , ( 31, (Protobuf.Encode.list Protobuf.Encode.string) value.bridgeAddresses )
        , ( 32, Protobuf.Encode.int32 value.bridgeOptionOrdinal )
        , ( 33, Protobuf.Encode.int32 value.torTransportOrdinal )
        , ( 34, Protobuf.Encode.string value.customBridges )
        , ( 35, Protobuf.Encode.int32 value.moneroNodesOptionOrdinal )
        , ( 36, Protobuf.Encode.string value.referralId )
        , ( 37, Protobuf.Encode.string value.phoneKeyAndToken )
        , ( 38, Protobuf.Encode.bool value.useSoundForMobileNotifications )
        , ( 39, Protobuf.Encode.bool value.useTradeNotifications )
        , ( 40, Protobuf.Encode.bool value.useMarketNotifications )
        , ( 41, Protobuf.Encode.bool value.usePriceNotifications )
        , ( 42, Protobuf.Encode.bool value.useStandbyMode )
        , ( 43, Protobuf.Encode.string value.rpcUser )
        , ( 44, Protobuf.Encode.string value.rpcPw )
        , ( 45, Protobuf.Encode.string value.takeOfferSelectedPaymentAccountId )
        , ( 46, Protobuf.Encode.double value.buyerSecurityDepositAsPercent )
        , ( 47, Protobuf.Encode.int32 value.ignoreDustThreshold )
        , ( 48, Protobuf.Encode.double value.buyerSecurityDepositAsPercentForCrypto )
        , ( 49, Protobuf.Encode.int32 value.blockNotifyPort )
        , ( 50, Protobuf.Encode.int32 value.cssTheme )
        , ( 51, Protobuf.Encode.bool value.tacAcceptedV120 )
        , ( 52
          , (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__AutoConfirmSettings) value.autoConfirmSettings
          )
        , ( 53, Protobuf.Encode.double value.bsqAverageTrimThreshold )
        , ( 54, Protobuf.Encode.bool value.hideNonAccountPaymentMethods )
        , ( 55, Protobuf.Encode.bool value.showOffersMatchingMyAccounts )
        , ( 56, Protobuf.Encode.bool value.denyApiTaker )
        , ( 57, Protobuf.Encode.bool value.notifyOnPreRelease )
        , ( 58
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__XmrNodeSettings >> Maybe.withDefault Protobuf.Encode.none)
                value.xmrNodeSettings
          )
        , ( 59, Protobuf.Encode.int32 value.clearDataAfterDays )
        , ( 60, Protobuf.Encode.string value.buyScreenCryptoCurrencyCode )
        , ( 61, Protobuf.Encode.string value.sellScreenCryptoCurrencyCode )
        , ( 62, Protobuf.Encode.bool value.splitOfferOutput )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PreferencesPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__PreferencesPayload =
    { userLanguage : String
    , userCountry : Maybe Proto__Io__Haveno__Protobuffer__Country
    , traditionalCurrencies : List Proto__Io__Haveno__Protobuffer__TradeCurrency
    , cryptoCurrencies : List Proto__Io__Haveno__Protobuffer__TradeCurrency
    , blockChainExplorerMainNet : Maybe Proto__Io__Haveno__Protobuffer__BlockChainExplorer
    , blockChainExplorerTestNet : Maybe Proto__Io__Haveno__Protobuffer__BlockChainExplorer
    , backupDirectory : String
    , autoSelectArbitrators : Bool
    , dontShowAgainMap : Dict.Dict String Bool
    , tacAccepted : Bool
    , useTorForXmrOrdinal : Int
    , showOwnOffersInOfferBook : Bool
    , preferredTradeCurrency : Maybe Proto__Io__Haveno__Protobuffer__TradeCurrency
    , withdrawalTxFeeInVbytes : Protobuf.Types.Int64.Int64
    , useCustomWithdrawalTxFee : Bool
    , maxPriceDistanceInPercent : Float
    , offerBookChartScreenCurrencyCode : String
    , tradeChartsScreenCurrencyCode : String
    , buyScreenCurrencyCode : String
    , sellScreenCurrencyCode : String
    , tradeStatisticsTickUnitIndex : Int
    , resyncSpvRequested : Bool
    , sortMarketCurrenciesNumerically : Bool
    , usePercentageBasedPrice : Bool
    , peerTagMap : Dict.Dict String String
    , moneroNodes : String
    , ignoreTradersList : List String
    , directoryChooserPath : String
    , useAnimations : Bool
    , selectedPaymentAccountForCreateOffer : Maybe Proto__Io__Haveno__Protobuffer__PaymentAccount
    , bridgeAddresses : List String
    , bridgeOptionOrdinal : Int
    , torTransportOrdinal : Int
    , customBridges : String
    , moneroNodesOptionOrdinal : Int
    , referralId : String
    , phoneKeyAndToken : String
    , useSoundForMobileNotifications : Bool
    , useTradeNotifications : Bool
    , useMarketNotifications : Bool
    , usePriceNotifications : Bool
    , useStandbyMode : Bool
    , rpcUser : String
    , rpcPw : String
    , takeOfferSelectedPaymentAccountId : String
    , buyerSecurityDepositAsPercent : Float
    , ignoreDustThreshold : Int
    , buyerSecurityDepositAsPercentForCrypto : Float
    , blockNotifyPort : Int
    , cssTheme : Int
    , tacAcceptedV120 : Bool
    , autoConfirmSettings : List Proto__Io__Haveno__Protobuffer__AutoConfirmSettings
    , bsqAverageTrimThreshold : Float
    , hideNonAccountPaymentMethods : Bool
    , showOffersMatchingMyAccounts : Bool
    , denyApiTaker : Bool
    , notifyOnPreRelease : Bool
    , xmrNodeSettings : Maybe Proto__Io__Haveno__Protobuffer__XmrNodeSettings
    , clearDataAfterDays : Int
    , buyScreenCryptoCurrencyCode : String
    , sellScreenCryptoCurrencyCode : String
    , splitOfferOutput : Bool
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RefundDisputeList`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RefundDisputeList : { dispute : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__RefundDisputeList =
    { dispute = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__RefundDisputeList. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RefundDisputeList : Proto__Io__Haveno__Protobuffer__RefundDisputeList
defaultProto__Io__Haveno__Protobuffer__RefundDisputeList =
    { dispute = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RefundDisputeList` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RefundDisputeList :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RefundDisputeList
decodeProto__Io__Haveno__Protobuffer__RefundDisputeList =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__RefundDisputeList
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__Dispute
            .dispute
            (\a r -> { r | dispute = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RefundDisputeList` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RefundDisputeList :
    Proto__Io__Haveno__Protobuffer__RefundDisputeList -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RefundDisputeList value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__Dispute) value.dispute ) ]


{-| `Proto__Io__Haveno__Protobuffer__RefundDisputeList` message

-}
type alias Proto__Io__Haveno__Protobuffer__RefundDisputeList =
    { dispute : List Proto__Io__Haveno__Protobuffer__Dispute }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MediationDisputeList`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MediationDisputeList : { dispute : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MediationDisputeList =
    { dispute = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__MediationDisputeList. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MediationDisputeList : Proto__Io__Haveno__Protobuffer__MediationDisputeList
defaultProto__Io__Haveno__Protobuffer__MediationDisputeList =
    { dispute = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MediationDisputeList` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MediationDisputeList :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MediationDisputeList
decodeProto__Io__Haveno__Protobuffer__MediationDisputeList =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MediationDisputeList
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__Dispute
            .dispute
            (\a r -> { r | dispute = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MediationDisputeList` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MediationDisputeList :
    Proto__Io__Haveno__Protobuffer__MediationDisputeList -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MediationDisputeList value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__Dispute) value.dispute ) ]


{-| `Proto__Io__Haveno__Protobuffer__MediationDisputeList` message

-}
type alias Proto__Io__Haveno__Protobuffer__MediationDisputeList =
    { dispute : List Proto__Io__Haveno__Protobuffer__Dispute }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ArbitrationDisputeList`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ArbitrationDisputeList : { dispute : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__ArbitrationDisputeList =
    { dispute = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__ArbitrationDisputeList. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ArbitrationDisputeList : Proto__Io__Haveno__Protobuffer__ArbitrationDisputeList
defaultProto__Io__Haveno__Protobuffer__ArbitrationDisputeList =
    { dispute = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ArbitrationDisputeList` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ArbitrationDisputeList :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ArbitrationDisputeList
decodeProto__Io__Haveno__Protobuffer__ArbitrationDisputeList =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__ArbitrationDisputeList
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__Dispute
            .dispute
            (\a r -> { r | dispute = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ArbitrationDisputeList` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ArbitrationDisputeList :
    Proto__Io__Haveno__Protobuffer__ArbitrationDisputeList -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ArbitrationDisputeList value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__Dispute) value.dispute ) ]


{-| `Proto__Io__Haveno__Protobuffer__ArbitrationDisputeList` message

-}
type alias Proto__Io__Haveno__Protobuffer__ArbitrationDisputeList =
    { dispute : List Proto__Io__Haveno__Protobuffer__Dispute }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__EncryptedConnectionList`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__EncryptedConnectionList :
    { salt : Int, items : Int, currentConnectionUrl : Int, refreshPeriod : Int, autoSwitch : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__EncryptedConnectionList =
    { salt = 1, items = 2, currentConnectionUrl = 3, refreshPeriod = 4, autoSwitch = 5 }


{-| Default for Proto__Io__Haveno__Protobuffer__EncryptedConnectionList. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__EncryptedConnectionList : Proto__Io__Haveno__Protobuffer__EncryptedConnectionList
defaultProto__Io__Haveno__Protobuffer__EncryptedConnectionList =
    { salt = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , items = []
    , currentConnectionUrl = ""
    , refreshPeriod = Protobuf.Types.Int64.fromInts 0 0
    , autoSwitch = False
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__EncryptedConnectionList` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__EncryptedConnectionList :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__EncryptedConnectionList
decodeProto__Io__Haveno__Protobuffer__EncryptedConnectionList =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__EncryptedConnectionList
        [ Protobuf.Decode.optional 1 Protobuf.Decode.bytes (\a r -> { r | salt = a })
        , Protobuf.Decode.repeated
            2
            decodeProto__Io__Haveno__Protobuffer__EncryptedConnection
            .items
            (\a r -> { r | items = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | currentConnectionUrl = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.int64 (\a r -> { r | refreshPeriod = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.bool (\a r -> { r | autoSwitch = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__EncryptedConnectionList` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__EncryptedConnectionList :
    Proto__Io__Haveno__Protobuffer__EncryptedConnectionList -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__EncryptedConnectionList value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.bytes value.salt )
        , ( 2, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__EncryptedConnection) value.items )
        , ( 3, Protobuf.Encode.string value.currentConnectionUrl )
        , ( 4, Protobuf.Encode.int64 value.refreshPeriod )
        , ( 5, Protobuf.Encode.bool value.autoSwitch )
        ]


{-| `Proto__Io__Haveno__Protobuffer__EncryptedConnectionList` message

-}
type alias Proto__Io__Haveno__Protobuffer__EncryptedConnectionList =
    { salt : Bytes.Bytes
    , items : List Proto__Io__Haveno__Protobuffer__EncryptedConnection
    , currentConnectionUrl : String
    , refreshPeriod : Protobuf.Types.Int64.Int64
    , autoSwitch : Bool
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__EncryptedConnection`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__EncryptedConnection :
    { url : Int, username : Int, encryptedPassword : Int, encryptionSalt : Int, priority : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__EncryptedConnection =
    { url = 1, username = 2, encryptedPassword = 3, encryptionSalt = 4, priority = 5 }


{-| Default for Proto__Io__Haveno__Protobuffer__EncryptedConnection. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__EncryptedConnection : Proto__Io__Haveno__Protobuffer__EncryptedConnection
defaultProto__Io__Haveno__Protobuffer__EncryptedConnection =
    { url = ""
    , username = ""
    , encryptedPassword = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , encryptionSalt = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , priority = 0
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__EncryptedConnection` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__EncryptedConnection :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__EncryptedConnection
decodeProto__Io__Haveno__Protobuffer__EncryptedConnection =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__EncryptedConnection
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | url = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | username = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.bytes (\a r -> { r | encryptedPassword = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.bytes (\a r -> { r | encryptionSalt = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.int32 (\a r -> { r | priority = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__EncryptedConnection` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__EncryptedConnection :
    Proto__Io__Haveno__Protobuffer__EncryptedConnection -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__EncryptedConnection value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.url )
        , ( 2, Protobuf.Encode.string value.username )
        , ( 3, Protobuf.Encode.bytes value.encryptedPassword )
        , ( 4, Protobuf.Encode.bytes value.encryptionSalt )
        , ( 5, Protobuf.Encode.int32 value.priority )
        ]


{-| `Proto__Io__Haveno__Protobuffer__EncryptedConnection` message

-}
type alias Proto__Io__Haveno__Protobuffer__EncryptedConnection =
    { url : String, username : String, encryptedPassword : Bytes.Bytes, encryptionSalt : Bytes.Bytes, priority : Int }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__TradePeer`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__TradePeer :
    { nodeAddress : Int
    , pubKeyRing : Int
    , accountId : Int
    , paymentAccountId : Int
    , paymentMethodId : Int
    , paymentAccountPayloadHash : Int
    , encryptedPaymentAccountPayload : Int
    , paymentAccountKey : Int
    , paymentAccountPayload : Int
    , payoutAddressString : Int
    , contractAsJson : Int
    , contractSignature : Int
    , accountAgeWitnessNonce : Int
    , accountAgeWitnessSignature : Int
    , accountAgeWitness : Int
    , currentDate : Int
    , mediatedPayoutTxSignature : Int
    , paymentSentMessage : Int
    , paymentReceivedMessage : Int
    , disputeClosedMessage : Int
    , reserveTxHash : Int
    , reserveTxHex : Int
    , reserveTxKey : Int
    , reserveTxKeyImages : Int
    , preparedMultisigHex : Int
    , madeMultisigHex : Int
    , exchangedMultisigHex : Int
    , updatedMultisigHex : Int
    , depositsConfirmedMessageAcked : Int
    , depositTxHash : Int
    , depositTxHex : Int
    , depositTxKey : Int
    , depositTxFee : Int
    , securityDeposit : Int
    , unsignedPayoutTxHex : Int
    , payoutTxFee : Int
    , payoutAmount : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__TradePeer =
    { nodeAddress = 1
    , pubKeyRing = 2
    , accountId = 3
    , paymentAccountId = 4
    , paymentMethodId = 5
    , paymentAccountPayloadHash = 6
    , encryptedPaymentAccountPayload = 7
    , paymentAccountKey = 8
    , paymentAccountPayload = 9
    , payoutAddressString = 10
    , contractAsJson = 11
    , contractSignature = 12
    , accountAgeWitnessNonce = 18
    , accountAgeWitnessSignature = 19
    , accountAgeWitness = 20
    , currentDate = 21
    , mediatedPayoutTxSignature = 22
    , paymentSentMessage = 23
    , paymentReceivedMessage = 24
    , disputeClosedMessage = 25
    , reserveTxHash = 26
    , reserveTxHex = 27
    , reserveTxKey = 28
    , reserveTxKeyImages = 29
    , preparedMultisigHex = 30
    , madeMultisigHex = 31
    , exchangedMultisigHex = 32
    , updatedMultisigHex = 33
    , depositsConfirmedMessageAcked = 34
    , depositTxHash = 35
    , depositTxHex = 36
    , depositTxKey = 37
    , depositTxFee = 38
    , securityDeposit = 39
    , unsignedPayoutTxHex = 40
    , payoutTxFee = 41
    , payoutAmount = 42
    }


{-| Default for Proto__Io__Haveno__Protobuffer__TradePeer. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__TradePeer : Proto__Io__Haveno__Protobuffer__TradePeer
defaultProto__Io__Haveno__Protobuffer__TradePeer =
    { nodeAddress = Nothing
    , pubKeyRing = Nothing
    , accountId = ""
    , paymentAccountId = ""
    , paymentMethodId = ""
    , paymentAccountPayloadHash = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , encryptedPaymentAccountPayload = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , paymentAccountKey = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , paymentAccountPayload = Nothing
    , payoutAddressString = ""
    , contractAsJson = ""
    , contractSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , accountAgeWitnessNonce = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , accountAgeWitnessSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , accountAgeWitness = Nothing
    , currentDate = Protobuf.Types.Int64.fromInts 0 0
    , mediatedPayoutTxSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , paymentSentMessage = Nothing
    , paymentReceivedMessage = Nothing
    , disputeClosedMessage = Nothing
    , reserveTxHash = ""
    , reserveTxHex = ""
    , reserveTxKey = ""
    , reserveTxKeyImages = []
    , preparedMultisigHex = ""
    , madeMultisigHex = ""
    , exchangedMultisigHex = ""
    , updatedMultisigHex = ""
    , depositsConfirmedMessageAcked = False
    , depositTxHash = ""
    , depositTxHex = ""
    , depositTxKey = ""
    , depositTxFee = Protobuf.Types.Int64.fromInts 0 0
    , securityDeposit = Protobuf.Types.Int64.fromInts 0 0
    , unsignedPayoutTxHex = ""
    , payoutTxFee = Protobuf.Types.Int64.fromInts 0 0
    , payoutAmount = Protobuf.Types.Int64.fromInts 0 0
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__TradePeer` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__TradePeer : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__TradePeer
decodeProto__Io__Haveno__Protobuffer__TradePeer =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__TradePeer
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | nodeAddress = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PubKeyRing)
            (\a r -> { r | pubKeyRing = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | accountId = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | paymentAccountId = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | paymentMethodId = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.bytes (\a r -> { r | paymentAccountPayloadHash = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.bytes (\a r -> { r | encryptedPaymentAccountPayload = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.bytes (\a r -> { r | paymentAccountKey = a })
        , Protobuf.Decode.optional
            9
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload)
            (\a r -> { r | paymentAccountPayload = a })
        , Protobuf.Decode.optional 10 Protobuf.Decode.string (\a r -> { r | payoutAddressString = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.string (\a r -> { r | contractAsJson = a })
        , Protobuf.Decode.optional 12 Protobuf.Decode.bytes (\a r -> { r | contractSignature = a })
        , Protobuf.Decode.optional 18 Protobuf.Decode.bytes (\a r -> { r | accountAgeWitnessNonce = a })
        , Protobuf.Decode.optional 19 Protobuf.Decode.bytes (\a r -> { r | accountAgeWitnessSignature = a })
        , Protobuf.Decode.optional
            20
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__AccountAgeWitness)
            (\a r -> { r | accountAgeWitness = a })
        , Protobuf.Decode.optional 21 Protobuf.Decode.int64 (\a r -> { r | currentDate = a })
        , Protobuf.Decode.optional 22 Protobuf.Decode.bytes (\a r -> { r | mediatedPayoutTxSignature = a })
        , Protobuf.Decode.optional
            23
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentSentMessage)
            (\a r -> { r | paymentSentMessage = a })
        , Protobuf.Decode.optional
            24
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentReceivedMessage)
            (\a r -> { r | paymentReceivedMessage = a })
        , Protobuf.Decode.optional
            25
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__DisputeClosedMessage)
            (\a r -> { r | disputeClosedMessage = a })
        , Protobuf.Decode.optional 26 Protobuf.Decode.string (\a r -> { r | reserveTxHash = a })
        , Protobuf.Decode.optional 27 Protobuf.Decode.string (\a r -> { r | reserveTxHex = a })
        , Protobuf.Decode.optional 28 Protobuf.Decode.string (\a r -> { r | reserveTxKey = a })
        , Protobuf.Decode.repeated
            29
            Protobuf.Decode.string
            .reserveTxKeyImages
            (\a r -> { r | reserveTxKeyImages = a })
        , Protobuf.Decode.optional 30 Protobuf.Decode.string (\a r -> { r | preparedMultisigHex = a })
        , Protobuf.Decode.optional 31 Protobuf.Decode.string (\a r -> { r | madeMultisigHex = a })
        , Protobuf.Decode.optional 32 Protobuf.Decode.string (\a r -> { r | exchangedMultisigHex = a })
        , Protobuf.Decode.optional 33 Protobuf.Decode.string (\a r -> { r | updatedMultisigHex = a })
        , Protobuf.Decode.optional 34 Protobuf.Decode.bool (\a r -> { r | depositsConfirmedMessageAcked = a })
        , Protobuf.Decode.optional 35 Protobuf.Decode.string (\a r -> { r | depositTxHash = a })
        , Protobuf.Decode.optional 36 Protobuf.Decode.string (\a r -> { r | depositTxHex = a })
        , Protobuf.Decode.optional 37 Protobuf.Decode.string (\a r -> { r | depositTxKey = a })
        , Protobuf.Decode.optional 38 Protobuf.Decode.int64 (\a r -> { r | depositTxFee = a })
        , Protobuf.Decode.optional 39 Protobuf.Decode.int64 (\a r -> { r | securityDeposit = a })
        , Protobuf.Decode.optional 40 Protobuf.Decode.string (\a r -> { r | unsignedPayoutTxHex = a })
        , Protobuf.Decode.optional 41 Protobuf.Decode.int64 (\a r -> { r | payoutTxFee = a })
        , Protobuf.Decode.optional 42 Protobuf.Decode.int64 (\a r -> { r | payoutAmount = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__TradePeer` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__TradePeer : Proto__Io__Haveno__Protobuffer__TradePeer -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__TradePeer value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.nodeAddress
          )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PubKeyRing >> Maybe.withDefault Protobuf.Encode.none)
                value.pubKeyRing
          )
        , ( 3, Protobuf.Encode.string value.accountId )
        , ( 4, Protobuf.Encode.string value.paymentAccountId )
        , ( 5, Protobuf.Encode.string value.paymentMethodId )
        , ( 6, Protobuf.Encode.bytes value.paymentAccountPayloadHash )
        , ( 7, Protobuf.Encode.bytes value.encryptedPaymentAccountPayload )
        , ( 8, Protobuf.Encode.bytes value.paymentAccountKey )
        , ( 9
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.paymentAccountPayload
          )
        , ( 10, Protobuf.Encode.string value.payoutAddressString )
        , ( 11, Protobuf.Encode.string value.contractAsJson )
        , ( 12, Protobuf.Encode.bytes value.contractSignature )
        , ( 18, Protobuf.Encode.bytes value.accountAgeWitnessNonce )
        , ( 19, Protobuf.Encode.bytes value.accountAgeWitnessSignature )
        , ( 20
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__AccountAgeWitness >> Maybe.withDefault Protobuf.Encode.none
            )
                value.accountAgeWitness
          )
        , ( 21, Protobuf.Encode.int64 value.currentDate )
        , ( 22, Protobuf.Encode.bytes value.mediatedPayoutTxSignature )
        , ( 23
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentSentMessage
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.paymentSentMessage
          )
        , ( 24
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentReceivedMessage
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.paymentReceivedMessage
          )
        , ( 25
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__DisputeClosedMessage
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.disputeClosedMessage
          )
        , ( 26, Protobuf.Encode.string value.reserveTxHash )
        , ( 27, Protobuf.Encode.string value.reserveTxHex )
        , ( 28, Protobuf.Encode.string value.reserveTxKey )
        , ( 29, (Protobuf.Encode.list Protobuf.Encode.string) value.reserveTxKeyImages )
        , ( 30, Protobuf.Encode.string value.preparedMultisigHex )
        , ( 31, Protobuf.Encode.string value.madeMultisigHex )
        , ( 32, Protobuf.Encode.string value.exchangedMultisigHex )
        , ( 33, Protobuf.Encode.string value.updatedMultisigHex )
        , ( 34, Protobuf.Encode.bool value.depositsConfirmedMessageAcked )
        , ( 35, Protobuf.Encode.string value.depositTxHash )
        , ( 36, Protobuf.Encode.string value.depositTxHex )
        , ( 37, Protobuf.Encode.string value.depositTxKey )
        , ( 38, Protobuf.Encode.int64 value.depositTxFee )
        , ( 39, Protobuf.Encode.int64 value.securityDeposit )
        , ( 40, Protobuf.Encode.string value.unsignedPayoutTxHex )
        , ( 41, Protobuf.Encode.int64 value.payoutTxFee )
        , ( 42, Protobuf.Encode.int64 value.payoutAmount )
        ]


{-| `Proto__Io__Haveno__Protobuffer__TradePeer` message

-}
type alias Proto__Io__Haveno__Protobuffer__TradePeer =
    { nodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , pubKeyRing : Maybe Proto__Io__Haveno__Protobuffer__PubKeyRing
    , accountId : String
    , paymentAccountId : String
    , paymentMethodId : String
    , paymentAccountPayloadHash : Bytes.Bytes
    , encryptedPaymentAccountPayload : Bytes.Bytes
    , paymentAccountKey : Bytes.Bytes
    , paymentAccountPayload : Maybe Proto__Io__Haveno__Protobuffer__PaymentAccountPayload
    , payoutAddressString : String
    , contractAsJson : String
    , contractSignature : Bytes.Bytes
    , accountAgeWitnessNonce : Bytes.Bytes
    , accountAgeWitnessSignature : Bytes.Bytes
    , accountAgeWitness : Maybe Proto__Io__Haveno__Protobuffer__AccountAgeWitness
    , currentDate : Protobuf.Types.Int64.Int64
    , mediatedPayoutTxSignature : Bytes.Bytes
    , paymentSentMessage : Maybe Proto__Io__Haveno__Protobuffer__PaymentSentMessage
    , paymentReceivedMessage : Maybe Proto__Io__Haveno__Protobuffer__PaymentReceivedMessage
    , disputeClosedMessage : Maybe Proto__Io__Haveno__Protobuffer__DisputeClosedMessage
    , reserveTxHash : String
    , reserveTxHex : String
    , reserveTxKey : String
    , reserveTxKeyImages : List String
    , preparedMultisigHex : String
    , madeMultisigHex : String
    , exchangedMultisigHex : String
    , updatedMultisigHex : String
    , depositsConfirmedMessageAcked : Bool
    , depositTxHash : String
    , depositTxHex : String
    , depositTxKey : String
    , depositTxFee : Protobuf.Types.Int64.Int64
    , securityDeposit : Protobuf.Types.Int64.Int64
    , unsignedPayoutTxHex : String
    , payoutTxFee : Protobuf.Types.Int64.Int64
    , payoutAmount : Protobuf.Types.Int64.Int64
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ProcessModel`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ProcessModel :
    { offerId : Int
    , accountId : Int
    , pubKeyRing : Int
    , payoutTxSignature : Int
    , useSavingsWallet : Int
    , fundsNeededForTrade : Int
    , paymentSentMessageState : Int
    , paymentSentMessageStateArbitrator : Int
    , makerSignature : Int
    , maker : Int
    , taker : Int
    , arbitrator : Int
    , tempTradePeerNodeAddress : Int
    , multisigAddress : Int
    , mediatedPayoutTxSignature : Int
    , buyerPayoutAmountFromMediation : Int
    , sellerPayoutAmountFromMediation : Int
    , tradeProtocolErrorHeight : Int
    , tradeFeeAddress : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__ProcessModel =
    { offerId = 1
    , accountId = 2
    , pubKeyRing = 3
    , payoutTxSignature = 4
    , useSavingsWallet = 5
    , fundsNeededForTrade = 6
    , paymentSentMessageState = 7
    , paymentSentMessageStateArbitrator = 8
    , makerSignature = 9
    , maker = 10
    , taker = 11
    , arbitrator = 12
    , tempTradePeerNodeAddress = 13
    , multisigAddress = 14
    , mediatedPayoutTxSignature = 15
    , buyerPayoutAmountFromMediation = 16
    , sellerPayoutAmountFromMediation = 17
    , tradeProtocolErrorHeight = 18
    , tradeFeeAddress = 19
    }


{-| Default for Proto__Io__Haveno__Protobuffer__ProcessModel. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ProcessModel : Proto__Io__Haveno__Protobuffer__ProcessModel
defaultProto__Io__Haveno__Protobuffer__ProcessModel =
    { offerId = ""
    , accountId = ""
    , pubKeyRing = Nothing
    , payoutTxSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , useSavingsWallet = False
    , fundsNeededForTrade = Protobuf.Types.Int64.fromInts 0 0
    , paymentSentMessageState = ""
    , paymentSentMessageStateArbitrator = ""
    , makerSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , maker = Nothing
    , taker = Nothing
    , arbitrator = Nothing
    , tempTradePeerNodeAddress = Nothing
    , multisigAddress = ""
    , mediatedPayoutTxSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , buyerPayoutAmountFromMediation = Protobuf.Types.Int64.fromInts 0 0
    , sellerPayoutAmountFromMediation = Protobuf.Types.Int64.fromInts 0 0
    , tradeProtocolErrorHeight = Protobuf.Types.Int64.fromInts 0 0
    , tradeFeeAddress = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ProcessModel` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ProcessModel :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ProcessModel
decodeProto__Io__Haveno__Protobuffer__ProcessModel =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__ProcessModel
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | offerId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | accountId = a })
        , Protobuf.Decode.optional
            3
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PubKeyRing)
            (\a r -> { r | pubKeyRing = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.bytes (\a r -> { r | payoutTxSignature = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.bool (\a r -> { r | useSavingsWallet = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.int64 (\a r -> { r | fundsNeededForTrade = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | paymentSentMessageState = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.string (\a r -> { r | paymentSentMessageStateArbitrator = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.bytes (\a r -> { r | makerSignature = a })
        , Protobuf.Decode.optional
            10
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__TradePeer)
            (\a r -> { r | maker = a })
        , Protobuf.Decode.optional
            11
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__TradePeer)
            (\a r -> { r | taker = a })
        , Protobuf.Decode.optional
            12
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__TradePeer)
            (\a r -> { r | arbitrator = a })
        , Protobuf.Decode.optional
            13
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | tempTradePeerNodeAddress = a })
        , Protobuf.Decode.optional 14 Protobuf.Decode.string (\a r -> { r | multisigAddress = a })
        , Protobuf.Decode.optional 15 Protobuf.Decode.bytes (\a r -> { r | mediatedPayoutTxSignature = a })
        , Protobuf.Decode.optional 16 Protobuf.Decode.int64 (\a r -> { r | buyerPayoutAmountFromMediation = a })
        , Protobuf.Decode.optional 17 Protobuf.Decode.int64 (\a r -> { r | sellerPayoutAmountFromMediation = a })
        , Protobuf.Decode.optional 18 Protobuf.Decode.int64 (\a r -> { r | tradeProtocolErrorHeight = a })
        , Protobuf.Decode.optional 19 Protobuf.Decode.string (\a r -> { r | tradeFeeAddress = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ProcessModel` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ProcessModel :
    Proto__Io__Haveno__Protobuffer__ProcessModel -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ProcessModel value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.offerId )
        , ( 2, Protobuf.Encode.string value.accountId )
        , ( 3
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PubKeyRing >> Maybe.withDefault Protobuf.Encode.none)
                value.pubKeyRing
          )
        , ( 4, Protobuf.Encode.bytes value.payoutTxSignature )
        , ( 5, Protobuf.Encode.bool value.useSavingsWallet )
        , ( 6, Protobuf.Encode.int64 value.fundsNeededForTrade )
        , ( 7, Protobuf.Encode.string value.paymentSentMessageState )
        , ( 8, Protobuf.Encode.string value.paymentSentMessageStateArbitrator )
        , ( 9, Protobuf.Encode.bytes value.makerSignature )
        , ( 10
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__TradePeer >> Maybe.withDefault Protobuf.Encode.none)
                value.maker
          )
        , ( 11
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__TradePeer >> Maybe.withDefault Protobuf.Encode.none)
                value.taker
          )
        , ( 12
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__TradePeer >> Maybe.withDefault Protobuf.Encode.none)
                value.arbitrator
          )
        , ( 13
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.tempTradePeerNodeAddress
          )
        , ( 14, Protobuf.Encode.string value.multisigAddress )
        , ( 15, Protobuf.Encode.bytes value.mediatedPayoutTxSignature )
        , ( 16, Protobuf.Encode.int64 value.buyerPayoutAmountFromMediation )
        , ( 17, Protobuf.Encode.int64 value.sellerPayoutAmountFromMediation )
        , ( 18, Protobuf.Encode.int64 value.tradeProtocolErrorHeight )
        , ( 19, Protobuf.Encode.string value.tradeFeeAddress )
        ]


{-| `Proto__Io__Haveno__Protobuffer__ProcessModel` message

-}
type alias Proto__Io__Haveno__Protobuffer__ProcessModel =
    { offerId : String
    , accountId : String
    , pubKeyRing : Maybe Proto__Io__Haveno__Protobuffer__PubKeyRing
    , payoutTxSignature : Bytes.Bytes
    , useSavingsWallet : Bool
    , fundsNeededForTrade : Protobuf.Types.Int64.Int64
    , paymentSentMessageState : String
    , paymentSentMessageStateArbitrator : String
    , makerSignature : Bytes.Bytes
    , maker : Maybe Proto__Io__Haveno__Protobuffer__TradePeer
    , taker : Maybe Proto__Io__Haveno__Protobuffer__TradePeer
    , arbitrator : Maybe Proto__Io__Haveno__Protobuffer__TradePeer
    , tempTradePeerNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , multisigAddress : String
    , mediatedPayoutTxSignature : Bytes.Bytes
    , buyerPayoutAmountFromMediation : Protobuf.Types.Int64.Int64
    , sellerPayoutAmountFromMediation : Protobuf.Types.Int64.Int64
    , tradeProtocolErrorHeight : Protobuf.Types.Int64.Int64
    , tradeFeeAddress : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ArbitratorTrade`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ArbitratorTrade : { trade : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__ArbitratorTrade =
    { trade = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__ArbitratorTrade. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ArbitratorTrade : Proto__Io__Haveno__Protobuffer__ArbitratorTrade
defaultProto__Io__Haveno__Protobuffer__ArbitratorTrade =
    { trade = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ArbitratorTrade` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ArbitratorTrade :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ArbitratorTrade
decodeProto__Io__Haveno__Protobuffer__ArbitratorTrade =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__ArbitratorTrade
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Trade)
            (\a r -> { r | trade = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ArbitratorTrade` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ArbitratorTrade :
    Proto__Io__Haveno__Protobuffer__ArbitratorTrade -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ArbitratorTrade value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Trade >> Maybe.withDefault Protobuf.Encode.none)
                value.trade
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__ArbitratorTrade` message

-}
type alias Proto__Io__Haveno__Protobuffer__ArbitratorTrade =
    { trade : Maybe Proto__Io__Haveno__Protobuffer__Trade }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SellerAsTakerTrade`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SellerAsTakerTrade : { trade : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SellerAsTakerTrade =
    { trade = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__SellerAsTakerTrade. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SellerAsTakerTrade : Proto__Io__Haveno__Protobuffer__SellerAsTakerTrade
defaultProto__Io__Haveno__Protobuffer__SellerAsTakerTrade =
    { trade = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SellerAsTakerTrade` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SellerAsTakerTrade :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SellerAsTakerTrade
decodeProto__Io__Haveno__Protobuffer__SellerAsTakerTrade =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SellerAsTakerTrade
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Trade)
            (\a r -> { r | trade = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SellerAsTakerTrade` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SellerAsTakerTrade :
    Proto__Io__Haveno__Protobuffer__SellerAsTakerTrade -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SellerAsTakerTrade value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Trade >> Maybe.withDefault Protobuf.Encode.none)
                value.trade
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SellerAsTakerTrade` message

-}
type alias Proto__Io__Haveno__Protobuffer__SellerAsTakerTrade =
    { trade : Maybe Proto__Io__Haveno__Protobuffer__Trade }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SellerAsMakerTrade`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SellerAsMakerTrade : { trade : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SellerAsMakerTrade =
    { trade = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__SellerAsMakerTrade. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SellerAsMakerTrade : Proto__Io__Haveno__Protobuffer__SellerAsMakerTrade
defaultProto__Io__Haveno__Protobuffer__SellerAsMakerTrade =
    { trade = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SellerAsMakerTrade` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SellerAsMakerTrade :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SellerAsMakerTrade
decodeProto__Io__Haveno__Protobuffer__SellerAsMakerTrade =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SellerAsMakerTrade
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Trade)
            (\a r -> { r | trade = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SellerAsMakerTrade` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SellerAsMakerTrade :
    Proto__Io__Haveno__Protobuffer__SellerAsMakerTrade -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SellerAsMakerTrade value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Trade >> Maybe.withDefault Protobuf.Encode.none)
                value.trade
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SellerAsMakerTrade` message

-}
type alias Proto__Io__Haveno__Protobuffer__SellerAsMakerTrade =
    { trade : Maybe Proto__Io__Haveno__Protobuffer__Trade }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__BuyerAsTakerTrade`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade : { trade : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade =
    { trade = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__BuyerAsTakerTrade. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade : Proto__Io__Haveno__Protobuffer__BuyerAsTakerTrade
defaultProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade =
    { trade = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__BuyerAsTakerTrade` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__BuyerAsTakerTrade
decodeProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Trade)
            (\a r -> { r | trade = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__BuyerAsTakerTrade` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade :
    Proto__Io__Haveno__Protobuffer__BuyerAsTakerTrade -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__BuyerAsTakerTrade value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Trade >> Maybe.withDefault Protobuf.Encode.none)
                value.trade
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__BuyerAsTakerTrade` message

-}
type alias Proto__Io__Haveno__Protobuffer__BuyerAsTakerTrade =
    { trade : Maybe Proto__Io__Haveno__Protobuffer__Trade }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__BuyerAsMakerTrade`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade : { trade : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade =
    { trade = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__BuyerAsMakerTrade. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade : Proto__Io__Haveno__Protobuffer__BuyerAsMakerTrade
defaultProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade =
    { trade = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__BuyerAsMakerTrade` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__BuyerAsMakerTrade
decodeProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Trade)
            (\a r -> { r | trade = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__BuyerAsMakerTrade` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade :
    Proto__Io__Haveno__Protobuffer__BuyerAsMakerTrade -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__BuyerAsMakerTrade value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Trade >> Maybe.withDefault Protobuf.Encode.none)
                value.trade
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__BuyerAsMakerTrade` message

-}
type alias Proto__Io__Haveno__Protobuffer__BuyerAsMakerTrade =
    { trade : Maybe Proto__Io__Haveno__Protobuffer__Trade }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Trade`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Trade :
    { offer : Int
    , processModel : Int
    , payoutTxId : Int
    , payoutTxHex : Int
    , payoutTxKey : Int
    , amount : Int
    , takeOfferDate : Int
    , price : Int
    , state : Int
    , payoutState : Int
    , disputeState : Int
    , periodState : Int
    , contract : Int
    , contractAsJson : Int
    , contractHash : Int
    , arbitratorNodeAddress : Int
    , mediatorNodeAddress : Int
    , errorMessage : Int
    , counterCurrencyTxId : Int
    , chatMessage : Int
    , mediationResultState : Int
    , lockTime : Int
    , startTime : Int
    , refundAgentNodeAddress : Int
    , refundResultState : Int
    , counterCurrencyExtraData : Int
    , uid : Int
    , isCompleted : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__Trade =
    { offer = 1
    , processModel = 2
    , payoutTxId = 3
    , payoutTxHex = 4
    , payoutTxKey = 5
    , amount = 6
    , takeOfferDate = 7
    , price = 8
    , state = 9
    , payoutState = 10
    , disputeState = 11
    , periodState = 12
    , contract = 13
    , contractAsJson = 14
    , contractHash = 15
    , arbitratorNodeAddress = 16
    , mediatorNodeAddress = 17
    , errorMessage = 18
    , counterCurrencyTxId = 19
    , chatMessage = 20
    , mediationResultState = 21
    , lockTime = 22
    , startTime = 23
    , refundAgentNodeAddress = 24
    , refundResultState = 25
    , counterCurrencyExtraData = 26
    , uid = 27
    , isCompleted = 28
    }


{-| Default for Proto__Io__Haveno__Protobuffer__Trade. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__Trade : Proto__Io__Haveno__Protobuffer__Trade
defaultProto__Io__Haveno__Protobuffer__Trade =
    { offer = Nothing
    , processModel = Nothing
    , payoutTxId = ""
    , payoutTxHex = ""
    , payoutTxKey = ""
    , amount = Protobuf.Types.Int64.fromInts 0 0
    , takeOfferDate = Protobuf.Types.Int64.fromInts 0 0
    , price = Protobuf.Types.Int64.fromInts 0 0
    , state = Proto.Io.Haveno.Protobuffer.Trade.State.defaultState
    , payoutState = Proto.Io.Haveno.Protobuffer.Trade.PayoutState.defaultPayoutState
    , disputeState = Proto.Io.Haveno.Protobuffer.Trade.DisputeState.defaultDisputeState
    , periodState = Proto.Io.Haveno.Protobuffer.Trade.TradePeriodState.defaultTradePeriodState
    , contract = Nothing
    , contractAsJson = ""
    , contractHash = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , arbitratorNodeAddress = Nothing
    , mediatorNodeAddress = Nothing
    , errorMessage = ""
    , counterCurrencyTxId = ""
    , chatMessage = []
    , mediationResultState = Proto.Io.Haveno.Protobuffer.MediationResultState.defaultMediationResultState
    , lockTime = Protobuf.Types.Int64.fromInts 0 0
    , startTime = Protobuf.Types.Int64.fromInts 0 0
    , refundAgentNodeAddress = Nothing
    , refundResultState = Proto.Io.Haveno.Protobuffer.RefundResultState.defaultRefundResultState
    , counterCurrencyExtraData = ""
    , uid = ""
    , isCompleted = False
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Trade` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Trade : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__Trade
decodeProto__Io__Haveno__Protobuffer__Trade =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__Trade
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Offer)
            (\a r -> { r | offer = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__ProcessModel)
            (\a r -> { r | processModel = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | payoutTxId = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | payoutTxHex = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | payoutTxKey = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.int64 (\a r -> { r | amount = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.int64 (\a r -> { r | takeOfferDate = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.int64 (\a r -> { r | price = a })
        , Protobuf.Decode.optional 9 Proto.Io.Haveno.Protobuffer.Trade.State.decodeState (\a r -> { r | state = a })
        , Protobuf.Decode.optional
            10
            Proto.Io.Haveno.Protobuffer.Trade.PayoutState.decodePayoutState
            (\a r -> { r | payoutState = a })
        , Protobuf.Decode.optional
            11
            Proto.Io.Haveno.Protobuffer.Trade.DisputeState.decodeDisputeState
            (\a r -> { r | disputeState = a })
        , Protobuf.Decode.optional
            12
            Proto.Io.Haveno.Protobuffer.Trade.TradePeriodState.decodeTradePeriodState
            (\a r -> { r | periodState = a })
        , Protobuf.Decode.optional
            13
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Contract)
            (\a r -> { r | contract = a })
        , Protobuf.Decode.optional 14 Protobuf.Decode.string (\a r -> { r | contractAsJson = a })
        , Protobuf.Decode.optional 15 Protobuf.Decode.bytes (\a r -> { r | contractHash = a })
        , Protobuf.Decode.optional
            16
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | arbitratorNodeAddress = a })
        , Protobuf.Decode.optional
            17
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | mediatorNodeAddress = a })
        , Protobuf.Decode.optional 18 Protobuf.Decode.string (\a r -> { r | errorMessage = a })
        , Protobuf.Decode.optional 19 Protobuf.Decode.string (\a r -> { r | counterCurrencyTxId = a })
        , Protobuf.Decode.repeated
            20
            decodeProto__Io__Haveno__Protobuffer__ChatMessage
            .chatMessage
            (\a r -> { r | chatMessage = a })
        , Protobuf.Decode.optional
            21
            Proto.Io.Haveno.Protobuffer.MediationResultState.decodeMediationResultState
            (\a r -> { r | mediationResultState = a })
        , Protobuf.Decode.optional 22 Protobuf.Decode.int64 (\a r -> { r | lockTime = a })
        , Protobuf.Decode.optional 23 Protobuf.Decode.int64 (\a r -> { r | startTime = a })
        , Protobuf.Decode.optional
            24
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | refundAgentNodeAddress = a })
        , Protobuf.Decode.optional
            25
            Proto.Io.Haveno.Protobuffer.RefundResultState.decodeRefundResultState
            (\a r -> { r | refundResultState = a })
        , Protobuf.Decode.optional 26 Protobuf.Decode.string (\a r -> { r | counterCurrencyExtraData = a })
        , Protobuf.Decode.optional 27 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional 28 Protobuf.Decode.bool (\a r -> { r | isCompleted = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Trade` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Trade : Proto__Io__Haveno__Protobuffer__Trade -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__Trade value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Offer >> Maybe.withDefault Protobuf.Encode.none)
                value.offer
          )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__ProcessModel >> Maybe.withDefault Protobuf.Encode.none)
                value.processModel
          )
        , ( 3, Protobuf.Encode.string value.payoutTxId )
        , ( 4, Protobuf.Encode.string value.payoutTxHex )
        , ( 5, Protobuf.Encode.string value.payoutTxKey )
        , ( 6, Protobuf.Encode.int64 value.amount )
        , ( 7, Protobuf.Encode.int64 value.takeOfferDate )
        , ( 8, Protobuf.Encode.int64 value.price )
        , ( 9, Proto.Io.Haveno.Protobuffer.Trade.State.encodeState value.state )
        , ( 10, Proto.Io.Haveno.Protobuffer.Trade.PayoutState.encodePayoutState value.payoutState )
        , ( 11, Proto.Io.Haveno.Protobuffer.Trade.DisputeState.encodeDisputeState value.disputeState )
        , ( 12, Proto.Io.Haveno.Protobuffer.Trade.TradePeriodState.encodeTradePeriodState value.periodState )
        , ( 13
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Contract >> Maybe.withDefault Protobuf.Encode.none)
                value.contract
          )
        , ( 14, Protobuf.Encode.string value.contractAsJson )
        , ( 15, Protobuf.Encode.bytes value.contractHash )
        , ( 16
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.arbitratorNodeAddress
          )
        , ( 17
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.mediatorNodeAddress
          )
        , ( 18, Protobuf.Encode.string value.errorMessage )
        , ( 19, Protobuf.Encode.string value.counterCurrencyTxId )
        , ( 20, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__ChatMessage) value.chatMessage )
        , ( 21, Proto.Io.Haveno.Protobuffer.MediationResultState.encodeMediationResultState value.mediationResultState )
        , ( 22, Protobuf.Encode.int64 value.lockTime )
        , ( 23, Protobuf.Encode.int64 value.startTime )
        , ( 24
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.refundAgentNodeAddress
          )
        , ( 25, Proto.Io.Haveno.Protobuffer.RefundResultState.encodeRefundResultState value.refundResultState )
        , ( 26, Protobuf.Encode.string value.counterCurrencyExtraData )
        , ( 27, Protobuf.Encode.string value.uid )
        , ( 28, Protobuf.Encode.bool value.isCompleted )
        ]


{-| `Proto__Io__Haveno__Protobuffer__Trade` message

-}
type alias Proto__Io__Haveno__Protobuffer__Trade =
    { offer : Maybe Proto__Io__Haveno__Protobuffer__Offer
    , processModel : Maybe Proto__Io__Haveno__Protobuffer__ProcessModel
    , payoutTxId : String
    , payoutTxHex : String
    , payoutTxKey : String
    , amount : Protobuf.Types.Int64.Int64
    , takeOfferDate : Protobuf.Types.Int64.Int64
    , price : Protobuf.Types.Int64.Int64
    , state : Proto.Io.Haveno.Protobuffer.Trade.State.State
    , payoutState : Proto.Io.Haveno.Protobuffer.Trade.PayoutState.PayoutState
    , disputeState : Proto.Io.Haveno.Protobuffer.Trade.DisputeState.DisputeState
    , periodState : Proto.Io.Haveno.Protobuffer.Trade.TradePeriodState.TradePeriodState
    , contract : Maybe Proto__Io__Haveno__Protobuffer__Contract
    , contractAsJson : String
    , contractHash : Bytes.Bytes
    , arbitratorNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , mediatorNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , errorMessage : String
    , counterCurrencyTxId : String
    , chatMessage : List Proto__Io__Haveno__Protobuffer__ChatMessage
    , mediationResultState : Proto.Io.Haveno.Protobuffer.MediationResultState.MediationResultState
    , lockTime : Protobuf.Types.Int64.Int64
    , startTime : Protobuf.Types.Int64.Int64
    , refundAgentNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , refundResultState : Proto.Io.Haveno.Protobuffer.RefundResultState.RefundResultState
    , counterCurrencyExtraData : String
    , uid : String
    , isCompleted : Bool
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Tradable`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Tradable :
    { message : FieldNumbersProto__Io__Haveno__Protobuffer__Tradable__Message__Message }
fieldNumbersProto__Io__Haveno__Protobuffer__Tradable =
    { message = fieldNumbersProto__Io__Haveno__Protobuffer__Tradable__Message__Message }


{-| Default for Proto__Io__Haveno__Protobuffer__Tradable. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__Tradable : Proto__Io__Haveno__Protobuffer__Tradable
defaultProto__Io__Haveno__Protobuffer__Tradable =
    { message = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Tradable` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Tradable : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__Tradable
decodeProto__Io__Haveno__Protobuffer__Tradable =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__Tradable
        [ decodeProto__Io__Haveno__Protobuffer__Tradable__Message__Message (\a r -> { r | message = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Tradable` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Tradable : Proto__Io__Haveno__Protobuffer__Tradable -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__Tradable value =
    Protobuf.Encode.message [ encodeProto__Io__Haveno__Protobuffer__Tradable__Message__Message value.message ]


{-| `Proto__Io__Haveno__Protobuffer__Tradable` message

-}
type alias Proto__Io__Haveno__Protobuffer__Tradable =
    { message : Maybe Proto__Io__Haveno__Protobuffer__Tradable__Message__Message }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__OpenOffer`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__OpenOffer :
    { offer : Int
    , state : Int
    , triggerPrice : Int
    , reserveExactAmount : Int
    , splitOutputTxHash : Int
    , splitOutputTxFee : Int
    , scheduledTxHashes : Int
    , scheduledAmount : Int
    , reserveTxHash : Int
    , reserveTxHex : Int
    , reserveTxKey : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__OpenOffer =
    { offer = 1
    , state = 2
    , triggerPrice = 3
    , reserveExactAmount = 4
    , splitOutputTxHash = 5
    , splitOutputTxFee = 6
    , scheduledTxHashes = 7
    , scheduledAmount = 8
    , reserveTxHash = 9
    , reserveTxHex = 10
    , reserveTxKey = 11
    }


{-| Default for Proto__Io__Haveno__Protobuffer__OpenOffer. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__OpenOffer : Proto__Io__Haveno__Protobuffer__OpenOffer
defaultProto__Io__Haveno__Protobuffer__OpenOffer =
    { offer = Nothing
    , state = Proto.Io.Haveno.Protobuffer.OpenOffer.State.defaultState
    , triggerPrice = Protobuf.Types.Int64.fromInts 0 0
    , reserveExactAmount = False
    , splitOutputTxHash = ""
    , splitOutputTxFee = Protobuf.Types.Int64.fromInts 0 0
    , scheduledTxHashes = []
    , scheduledAmount = ""
    , reserveTxHash = ""
    , reserveTxHex = ""
    , reserveTxKey = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__OpenOffer` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__OpenOffer : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__OpenOffer
decodeProto__Io__Haveno__Protobuffer__OpenOffer =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__OpenOffer
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Offer)
            (\a r -> { r | offer = a })
        , Protobuf.Decode.optional 2 Proto.Io.Haveno.Protobuffer.OpenOffer.State.decodeState (\a r -> { r | state = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | triggerPrice = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.bool (\a r -> { r | reserveExactAmount = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | splitOutputTxHash = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.int64 (\a r -> { r | splitOutputTxFee = a })
        , Protobuf.Decode.repeated 7 Protobuf.Decode.string .scheduledTxHashes (\a r -> { r | scheduledTxHashes = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.string (\a r -> { r | scheduledAmount = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.string (\a r -> { r | reserveTxHash = a })
        , Protobuf.Decode.optional 10 Protobuf.Decode.string (\a r -> { r | reserveTxHex = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.string (\a r -> { r | reserveTxKey = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__OpenOffer` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__OpenOffer : Proto__Io__Haveno__Protobuffer__OpenOffer -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__OpenOffer value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Offer >> Maybe.withDefault Protobuf.Encode.none)
                value.offer
          )
        , ( 2, Proto.Io.Haveno.Protobuffer.OpenOffer.State.encodeState value.state )
        , ( 3, Protobuf.Encode.int64 value.triggerPrice )
        , ( 4, Protobuf.Encode.bool value.reserveExactAmount )
        , ( 5, Protobuf.Encode.string value.splitOutputTxHash )
        , ( 6, Protobuf.Encode.int64 value.splitOutputTxFee )
        , ( 7, (Protobuf.Encode.list Protobuf.Encode.string) value.scheduledTxHashes )
        , ( 8, Protobuf.Encode.string value.scheduledAmount )
        , ( 9, Protobuf.Encode.string value.reserveTxHash )
        , ( 10, Protobuf.Encode.string value.reserveTxHex )
        , ( 11, Protobuf.Encode.string value.reserveTxKey )
        ]


{-| `Proto__Io__Haveno__Protobuffer__OpenOffer` message

-}
type alias Proto__Io__Haveno__Protobuffer__OpenOffer =
    { offer : Maybe Proto__Io__Haveno__Protobuffer__Offer
    , state : Proto.Io.Haveno.Protobuffer.OpenOffer.State.State
    , triggerPrice : Protobuf.Types.Int64.Int64
    , reserveExactAmount : Bool
    , splitOutputTxHash : String
    , splitOutputTxFee : Protobuf.Types.Int64.Int64
    , scheduledTxHashes : List String
    , scheduledAmount : String
    , reserveTxHash : String
    , reserveTxHex : String
    , reserveTxKey : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SignedOffer`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SignedOffer :
    { timeStamp : Int
    , traderId : Int
    , offerId : Int
    , tradeAmount : Int
    , penaltyAmount : Int
    , reserveTxHash : Int
    , reserveTxHex : Int
    , reserveTxKeyImages : Int
    , reserveTxMinerFee : Int
    , arbitratorSignature : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__SignedOffer =
    { timeStamp = 1
    , traderId = 2
    , offerId = 3
    , tradeAmount = 4
    , penaltyAmount = 5
    , reserveTxHash = 6
    , reserveTxHex = 7
    , reserveTxKeyImages = 8
    , reserveTxMinerFee = 9
    , arbitratorSignature = 10
    }


{-| Default for Proto__Io__Haveno__Protobuffer__SignedOffer. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SignedOffer : Proto__Io__Haveno__Protobuffer__SignedOffer
defaultProto__Io__Haveno__Protobuffer__SignedOffer =
    { timeStamp = Protobuf.Types.Int64.fromInts 0 0
    , traderId = 0
    , offerId = ""
    , tradeAmount = Protobuf.Types.Int64.fromInts 0 0
    , penaltyAmount = Protobuf.Types.Int64.fromInts 0 0
    , reserveTxHash = ""
    , reserveTxHex = ""
    , reserveTxKeyImages = []
    , reserveTxMinerFee = Protobuf.Types.Int64.fromInts 0 0
    , arbitratorSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SignedOffer` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SignedOffer : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SignedOffer
decodeProto__Io__Haveno__Protobuffer__SignedOffer =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SignedOffer
        [ Protobuf.Decode.optional 1 Protobuf.Decode.int64 (\a r -> { r | timeStamp = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int32 (\a r -> { r | traderId = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | offerId = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.uint64 (\a r -> { r | tradeAmount = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.uint64 (\a r -> { r | penaltyAmount = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | reserveTxHash = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | reserveTxHex = a })
        , Protobuf.Decode.repeated 8 Protobuf.Decode.string .reserveTxKeyImages (\a r -> { r | reserveTxKeyImages = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.uint64 (\a r -> { r | reserveTxMinerFee = a })
        , Protobuf.Decode.optional 10 Protobuf.Decode.bytes (\a r -> { r | arbitratorSignature = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SignedOffer` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SignedOffer :
    Proto__Io__Haveno__Protobuffer__SignedOffer -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SignedOffer value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.int64 value.timeStamp )
        , ( 2, Protobuf.Encode.int32 value.traderId )
        , ( 3, Protobuf.Encode.string value.offerId )
        , ( 4, Protobuf.Encode.uint64 value.tradeAmount )
        , ( 5, Protobuf.Encode.uint64 value.penaltyAmount )
        , ( 6, Protobuf.Encode.string value.reserveTxHash )
        , ( 7, Protobuf.Encode.string value.reserveTxHex )
        , ( 8, (Protobuf.Encode.list Protobuf.Encode.string) value.reserveTxKeyImages )
        , ( 9, Protobuf.Encode.uint64 value.reserveTxMinerFee )
        , ( 10, Protobuf.Encode.bytes value.arbitratorSignature )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SignedOffer` message

-}
type alias Proto__Io__Haveno__Protobuffer__SignedOffer =
    { timeStamp : Protobuf.Types.Int64.Int64
    , traderId : Int
    , offerId : String
    , tradeAmount : Protobuf.Types.Int64.Int64
    , penaltyAmount : Protobuf.Types.Int64.Int64
    , reserveTxHash : String
    , reserveTxHex : String
    , reserveTxKeyImages : List String
    , reserveTxMinerFee : Protobuf.Types.Int64.Int64
    , arbitratorSignature : Bytes.Bytes
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SignedOfferList`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SignedOfferList : { signedOffer : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SignedOfferList =
    { signedOffer = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__SignedOfferList. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SignedOfferList : Proto__Io__Haveno__Protobuffer__SignedOfferList
defaultProto__Io__Haveno__Protobuffer__SignedOfferList =
    { signedOffer = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SignedOfferList` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SignedOfferList :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SignedOfferList
decodeProto__Io__Haveno__Protobuffer__SignedOfferList =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SignedOfferList
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__SignedOffer
            .signedOffer
            (\a r -> { r | signedOffer = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SignedOfferList` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SignedOfferList :
    Proto__Io__Haveno__Protobuffer__SignedOfferList -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SignedOfferList value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__SignedOffer) value.signedOffer ) ]


{-| `Proto__Io__Haveno__Protobuffer__SignedOfferList` message

-}
type alias Proto__Io__Haveno__Protobuffer__SignedOfferList =
    { signedOffer : List Proto__Io__Haveno__Protobuffer__SignedOffer }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Offer`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Offer : { offerPayload : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__Offer =
    { offerPayload = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__Offer. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__Offer : Proto__Io__Haveno__Protobuffer__Offer
defaultProto__Io__Haveno__Protobuffer__Offer =
    { offerPayload = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Offer` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Offer : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__Offer
decodeProto__Io__Haveno__Protobuffer__Offer =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__Offer
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__OfferPayload)
            (\a r -> { r | offerPayload = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Offer` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Offer : Proto__Io__Haveno__Protobuffer__Offer -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__Offer value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__OfferPayload >> Maybe.withDefault Protobuf.Encode.none)
                value.offerPayload
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__Offer` message

-}
type alias Proto__Io__Haveno__Protobuffer__Offer =
    { offerPayload : Maybe Proto__Io__Haveno__Protobuffer__OfferPayload }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__TradableList`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__TradableList : { tradable : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__TradableList =
    { tradable = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__TradableList. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__TradableList : Proto__Io__Haveno__Protobuffer__TradableList
defaultProto__Io__Haveno__Protobuffer__TradableList =
    { tradable = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__TradableList` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__TradableList :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__TradableList
decodeProto__Io__Haveno__Protobuffer__TradableList =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__TradableList
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__Tradable
            .tradable
            (\a r -> { r | tradable = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__TradableList` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__TradableList :
    Proto__Io__Haveno__Protobuffer__TradableList -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__TradableList value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__Tradable) value.tradable ) ]


{-| `Proto__Io__Haveno__Protobuffer__TradableList` message

-}
type alias Proto__Io__Haveno__Protobuffer__TradableList =
    { tradable : List Proto__Io__Haveno__Protobuffer__Tradable }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PaymentAccountList`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountList : { paymentAccount : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountList =
    { paymentAccount = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__PaymentAccountList. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PaymentAccountList : Proto__Io__Haveno__Protobuffer__PaymentAccountList
defaultProto__Io__Haveno__Protobuffer__PaymentAccountList =
    { paymentAccount = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PaymentAccountList` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PaymentAccountList :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PaymentAccountList
decodeProto__Io__Haveno__Protobuffer__PaymentAccountList =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PaymentAccountList
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__PaymentAccount
            .paymentAccount
            (\a r -> { r | paymentAccount = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PaymentAccountList` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PaymentAccountList :
    Proto__Io__Haveno__Protobuffer__PaymentAccountList -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PaymentAccountList value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__PaymentAccount) value.paymentAccount ) ]


{-| `Proto__Io__Haveno__Protobuffer__PaymentAccountList` message

-}
type alias Proto__Io__Haveno__Protobuffer__PaymentAccountList =
    { paymentAccount : List Proto__Io__Haveno__Protobuffer__PaymentAccount }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__NavigationPath`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__NavigationPath : { path : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__NavigationPath =
    { path = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__NavigationPath. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__NavigationPath : Proto__Io__Haveno__Protobuffer__NavigationPath
defaultProto__Io__Haveno__Protobuffer__NavigationPath =
    { path = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__NavigationPath` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__NavigationPath :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__NavigationPath
decodeProto__Io__Haveno__Protobuffer__NavigationPath =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__NavigationPath
        [ Protobuf.Decode.repeated 1 Protobuf.Decode.string .path (\a r -> { r | path = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__NavigationPath` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__NavigationPath :
    Proto__Io__Haveno__Protobuffer__NavigationPath -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__NavigationPath value =
    Protobuf.Encode.message [ ( 1, (Protobuf.Encode.list Protobuf.Encode.string) value.path ) ]


{-| `Proto__Io__Haveno__Protobuffer__NavigationPath` message

-}
type alias Proto__Io__Haveno__Protobuffer__NavigationPath =
    { path : List String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__XmrAddressEntry`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__XmrAddressEntry :
    { subaddressIndex : Int, addressString : Int, offerId : Int, context : Int, coinLockedInMultiSig : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__XmrAddressEntry =
    { subaddressIndex = 7, addressString = 8, offerId = 9, context = 10, coinLockedInMultiSig = 11 }


{-| Default for Proto__Io__Haveno__Protobuffer__XmrAddressEntry. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__XmrAddressEntry : Proto__Io__Haveno__Protobuffer__XmrAddressEntry
defaultProto__Io__Haveno__Protobuffer__XmrAddressEntry =
    { subaddressIndex = 0
    , addressString = ""
    , offerId = ""
    , context = Proto.Io.Haveno.Protobuffer.XmrAddressEntry.Context.defaultContext
    , coinLockedInMultiSig = Protobuf.Types.Int64.fromInts 0 0
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__XmrAddressEntry` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__XmrAddressEntry :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__XmrAddressEntry
decodeProto__Io__Haveno__Protobuffer__XmrAddressEntry =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__XmrAddressEntry
        [ Protobuf.Decode.optional 7 Protobuf.Decode.int32 (\a r -> { r | subaddressIndex = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.string (\a r -> { r | addressString = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.string (\a r -> { r | offerId = a })
        , Protobuf.Decode.optional
            10
            Proto.Io.Haveno.Protobuffer.XmrAddressEntry.Context.decodeContext
            (\a r -> { r | context = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.int64 (\a r -> { r | coinLockedInMultiSig = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__XmrAddressEntry` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__XmrAddressEntry :
    Proto__Io__Haveno__Protobuffer__XmrAddressEntry -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__XmrAddressEntry value =
    Protobuf.Encode.message
        [ ( 7, Protobuf.Encode.int32 value.subaddressIndex )
        , ( 8, Protobuf.Encode.string value.addressString )
        , ( 9, Protobuf.Encode.string value.offerId )
        , ( 10, Proto.Io.Haveno.Protobuffer.XmrAddressEntry.Context.encodeContext value.context )
        , ( 11, Protobuf.Encode.int64 value.coinLockedInMultiSig )
        ]


{-| `Proto__Io__Haveno__Protobuffer__XmrAddressEntry` message

-}
type alias Proto__Io__Haveno__Protobuffer__XmrAddressEntry =
    { subaddressIndex : Int
    , addressString : String
    , offerId : String
    , context : Proto.Io.Haveno.Protobuffer.XmrAddressEntry.Context.Context
    , coinLockedInMultiSig : Protobuf.Types.Int64.Int64
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__XmrAddressEntryList`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__XmrAddressEntryList : { xmrAddressEntry : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__XmrAddressEntryList =
    { xmrAddressEntry = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__XmrAddressEntryList. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__XmrAddressEntryList : Proto__Io__Haveno__Protobuffer__XmrAddressEntryList
defaultProto__Io__Haveno__Protobuffer__XmrAddressEntryList =
    { xmrAddressEntry = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__XmrAddressEntryList` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__XmrAddressEntryList :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__XmrAddressEntryList
decodeProto__Io__Haveno__Protobuffer__XmrAddressEntryList =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__XmrAddressEntryList
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__XmrAddressEntry
            .xmrAddressEntry
            (\a r -> { r | xmrAddressEntry = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__XmrAddressEntryList` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__XmrAddressEntryList :
    Proto__Io__Haveno__Protobuffer__XmrAddressEntryList -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__XmrAddressEntryList value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__XmrAddressEntry) value.xmrAddressEntry ) ]


{-| `Proto__Io__Haveno__Protobuffer__XmrAddressEntryList` message

-}
type alias Proto__Io__Haveno__Protobuffer__XmrAddressEntryList =
    { xmrAddressEntry : List Proto__Io__Haveno__Protobuffer__XmrAddressEntry }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AddressEntry`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AddressEntry :
    { offerId : Int, context : Int, pubKey : Int, pubKeyHash : Int, coinLockedInMultiSig : Int, segwit : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__AddressEntry =
    { offerId = 7, context = 8, pubKey = 9, pubKeyHash = 10, coinLockedInMultiSig = 11, segwit = 12 }


{-| Default for Proto__Io__Haveno__Protobuffer__AddressEntry. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AddressEntry : Proto__Io__Haveno__Protobuffer__AddressEntry
defaultProto__Io__Haveno__Protobuffer__AddressEntry =
    { offerId = ""
    , context = Proto.Io.Haveno.Protobuffer.AddressEntry.Context.defaultContext
    , pubKey = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , pubKeyHash = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , coinLockedInMultiSig = Protobuf.Types.Int64.fromInts 0 0
    , segwit = False
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AddressEntry` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AddressEntry :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AddressEntry
decodeProto__Io__Haveno__Protobuffer__AddressEntry =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AddressEntry
        [ Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | offerId = a })
        , Protobuf.Decode.optional
            8
            Proto.Io.Haveno.Protobuffer.AddressEntry.Context.decodeContext
            (\a r -> { r | context = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.bytes (\a r -> { r | pubKey = a })
        , Protobuf.Decode.optional 10 Protobuf.Decode.bytes (\a r -> { r | pubKeyHash = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.int64 (\a r -> { r | coinLockedInMultiSig = a })
        , Protobuf.Decode.optional 12 Protobuf.Decode.bool (\a r -> { r | segwit = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AddressEntry` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AddressEntry :
    Proto__Io__Haveno__Protobuffer__AddressEntry -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AddressEntry value =
    Protobuf.Encode.message
        [ ( 7, Protobuf.Encode.string value.offerId )
        , ( 8, Proto.Io.Haveno.Protobuffer.AddressEntry.Context.encodeContext value.context )
        , ( 9, Protobuf.Encode.bytes value.pubKey )
        , ( 10, Protobuf.Encode.bytes value.pubKeyHash )
        , ( 11, Protobuf.Encode.int64 value.coinLockedInMultiSig )
        , ( 12, Protobuf.Encode.bool value.segwit )
        ]


{-| `Proto__Io__Haveno__Protobuffer__AddressEntry` message

-}
type alias Proto__Io__Haveno__Protobuffer__AddressEntry =
    { offerId : String
    , context : Proto.Io.Haveno.Protobuffer.AddressEntry.Context.Context
    , pubKey : Bytes.Bytes
    , pubKeyHash : Bytes.Bytes
    , coinLockedInMultiSig : Protobuf.Types.Int64.Int64
    , segwit : Bool
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AddressEntryList`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AddressEntryList : { addressEntry : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__AddressEntryList =
    { addressEntry = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__AddressEntryList. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AddressEntryList : Proto__Io__Haveno__Protobuffer__AddressEntryList
defaultProto__Io__Haveno__Protobuffer__AddressEntryList =
    { addressEntry = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AddressEntryList` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AddressEntryList :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AddressEntryList
decodeProto__Io__Haveno__Protobuffer__AddressEntryList =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AddressEntryList
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__AddressEntry
            .addressEntry
            (\a r -> { r | addressEntry = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AddressEntryList` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AddressEntryList :
    Proto__Io__Haveno__Protobuffer__AddressEntryList -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AddressEntryList value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__AddressEntry) value.addressEntry ) ]


{-| `Proto__Io__Haveno__Protobuffer__AddressEntryList` message

-}
type alias Proto__Io__Haveno__Protobuffer__AddressEntryList =
    { addressEntry : List Proto__Io__Haveno__Protobuffer__AddressEntry }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PeerList`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PeerList : { peer : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PeerList =
    { peer = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__PeerList. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PeerList : Proto__Io__Haveno__Protobuffer__PeerList
defaultProto__Io__Haveno__Protobuffer__PeerList =
    { peer = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PeerList` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PeerList : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PeerList
decodeProto__Io__Haveno__Protobuffer__PeerList =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PeerList
        [ Protobuf.Decode.repeated 1 decodeProto__Io__Haveno__Protobuffer__Peer .peer (\a r -> { r | peer = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PeerList` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PeerList : Proto__Io__Haveno__Protobuffer__PeerList -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PeerList value =
    Protobuf.Encode.message [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__Peer) value.peer ) ]


{-| `Proto__Io__Haveno__Protobuffer__PeerList` message

-}
type alias Proto__Io__Haveno__Protobuffer__PeerList =
    { peer : List Proto__Io__Haveno__Protobuffer__Peer }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__TradeStatistics3Store`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__TradeStatistics3Store : { items : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__TradeStatistics3Store =
    { items = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__TradeStatistics3Store. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__TradeStatistics3Store : Proto__Io__Haveno__Protobuffer__TradeStatistics3Store
defaultProto__Io__Haveno__Protobuffer__TradeStatistics3Store =
    { items = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__TradeStatistics3Store` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__TradeStatistics3Store :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__TradeStatistics3Store
decodeProto__Io__Haveno__Protobuffer__TradeStatistics3Store =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__TradeStatistics3Store
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__TradeStatistics3
            .items
            (\a r -> { r | items = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__TradeStatistics3Store` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__TradeStatistics3Store :
    Proto__Io__Haveno__Protobuffer__TradeStatistics3Store -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__TradeStatistics3Store value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__TradeStatistics3) value.items ) ]


{-| `Proto__Io__Haveno__Protobuffer__TradeStatistics3Store` message

-}
type alias Proto__Io__Haveno__Protobuffer__TradeStatistics3Store =
    { items : List Proto__Io__Haveno__Protobuffer__TradeStatistics3 }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SignedWitnessStore`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SignedWitnessStore : { items : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SignedWitnessStore =
    { items = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__SignedWitnessStore. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SignedWitnessStore : Proto__Io__Haveno__Protobuffer__SignedWitnessStore
defaultProto__Io__Haveno__Protobuffer__SignedWitnessStore =
    { items = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SignedWitnessStore` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SignedWitnessStore :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SignedWitnessStore
decodeProto__Io__Haveno__Protobuffer__SignedWitnessStore =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SignedWitnessStore
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__SignedWitness
            .items
            (\a r -> { r | items = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SignedWitnessStore` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SignedWitnessStore :
    Proto__Io__Haveno__Protobuffer__SignedWitnessStore -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SignedWitnessStore value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__SignedWitness) value.items ) ]


{-| `Proto__Io__Haveno__Protobuffer__SignedWitnessStore` message

-}
type alias Proto__Io__Haveno__Protobuffer__SignedWitnessStore =
    { items : List Proto__Io__Haveno__Protobuffer__SignedWitness }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AccountAgeWitnessStore`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore : { items : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore =
    { items = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__AccountAgeWitnessStore. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore : Proto__Io__Haveno__Protobuffer__AccountAgeWitnessStore
defaultProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore =
    { items = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AccountAgeWitnessStore` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AccountAgeWitnessStore
decodeProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__AccountAgeWitness
            .items
            (\a r -> { r | items = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AccountAgeWitnessStore` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore :
    Proto__Io__Haveno__Protobuffer__AccountAgeWitnessStore -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AccountAgeWitnessStore value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__AccountAgeWitness) value.items ) ]


{-| `Proto__Io__Haveno__Protobuffer__AccountAgeWitnessStore` message

-}
type alias Proto__Io__Haveno__Protobuffer__AccountAgeWitnessStore =
    { items : List Proto__Io__Haveno__Protobuffer__AccountAgeWitness }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MapValue`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MapValue : { sequenceNr : Int, timeStamp : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MapValue =
    { sequenceNr = 1, timeStamp = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__MapValue. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MapValue : Proto__Io__Haveno__Protobuffer__MapValue
defaultProto__Io__Haveno__Protobuffer__MapValue =
    { sequenceNr = 0, timeStamp = Protobuf.Types.Int64.fromInts 0 0 }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MapValue` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MapValue : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MapValue
decodeProto__Io__Haveno__Protobuffer__MapValue =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MapValue
        [ Protobuf.Decode.optional 1 Protobuf.Decode.int32 (\a r -> { r | sequenceNr = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int64 (\a r -> { r | timeStamp = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MapValue` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MapValue : Proto__Io__Haveno__Protobuffer__MapValue -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MapValue value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.int32 value.sequenceNr ), ( 2, Protobuf.Encode.int64 value.timeStamp ) ]


{-| `Proto__Io__Haveno__Protobuffer__MapValue` message

-}
type alias Proto__Io__Haveno__Protobuffer__MapValue =
    { sequenceNr : Int, timeStamp : Protobuf.Types.Int64.Int64 }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ByteArray`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ByteArray : { bytes : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__ByteArray =
    { bytes = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__ByteArray. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ByteArray : Proto__Io__Haveno__Protobuffer__ByteArray
defaultProto__Io__Haveno__Protobuffer__ByteArray =
    { bytes = Protobuf.Encode.encode <| Protobuf.Encode.string "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ByteArray` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ByteArray : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ByteArray
decodeProto__Io__Haveno__Protobuffer__ByteArray =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__ByteArray
        [ Protobuf.Decode.optional 1 Protobuf.Decode.bytes (\a r -> { r | bytes = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ByteArray` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ByteArray : Proto__Io__Haveno__Protobuffer__ByteArray -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ByteArray value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.bytes value.bytes ) ]


{-| `Proto__Io__Haveno__Protobuffer__ByteArray` message

-}
type alias Proto__Io__Haveno__Protobuffer__ByteArray =
    { bytes : Bytes.Bytes }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SequenceNumberEntry`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SequenceNumberEntry : { bytes : Int, mapValue : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SequenceNumberEntry =
    { bytes = 1, mapValue = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__SequenceNumberEntry. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SequenceNumberEntry : Proto__Io__Haveno__Protobuffer__SequenceNumberEntry
defaultProto__Io__Haveno__Protobuffer__SequenceNumberEntry =
    { bytes = Nothing, mapValue = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SequenceNumberEntry` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SequenceNumberEntry :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SequenceNumberEntry
decodeProto__Io__Haveno__Protobuffer__SequenceNumberEntry =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SequenceNumberEntry
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__ByteArray)
            (\a r -> { r | bytes = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__MapValue)
            (\a r -> { r | mapValue = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SequenceNumberEntry` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SequenceNumberEntry :
    Proto__Io__Haveno__Protobuffer__SequenceNumberEntry -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SequenceNumberEntry value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__ByteArray >> Maybe.withDefault Protobuf.Encode.none)
                value.bytes
          )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__MapValue >> Maybe.withDefault Protobuf.Encode.none)
                value.mapValue
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SequenceNumberEntry` message

-}
type alias Proto__Io__Haveno__Protobuffer__SequenceNumberEntry =
    { bytes : Maybe Proto__Io__Haveno__Protobuffer__ByteArray
    , mapValue : Maybe Proto__Io__Haveno__Protobuffer__MapValue
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SequenceNumberMap`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SequenceNumberMap : { sequenceNumberEntries : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SequenceNumberMap =
    { sequenceNumberEntries = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__SequenceNumberMap. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SequenceNumberMap : Proto__Io__Haveno__Protobuffer__SequenceNumberMap
defaultProto__Io__Haveno__Protobuffer__SequenceNumberMap =
    { sequenceNumberEntries = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SequenceNumberMap` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SequenceNumberMap :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SequenceNumberMap
decodeProto__Io__Haveno__Protobuffer__SequenceNumberMap =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SequenceNumberMap
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__SequenceNumberEntry
            .sequenceNumberEntries
            (\a r -> { r | sequenceNumberEntries = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SequenceNumberMap` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SequenceNumberMap :
    Proto__Io__Haveno__Protobuffer__SequenceNumberMap -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SequenceNumberMap value =
    Protobuf.Encode.message
        [ ( 1
          , (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__SequenceNumberEntry) value.sequenceNumberEntries
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SequenceNumberMap` message

-}
type alias Proto__Io__Haveno__Protobuffer__SequenceNumberMap =
    { sequenceNumberEntries : List Proto__Io__Haveno__Protobuffer__SequenceNumberEntry }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PersistableEnvelope`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PersistableEnvelope :
    { message : FieldNumbersProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message }
fieldNumbersProto__Io__Haveno__Protobuffer__PersistableEnvelope =
    { message = fieldNumbersProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message }


{-| Default for Proto__Io__Haveno__Protobuffer__PersistableEnvelope. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PersistableEnvelope : Proto__Io__Haveno__Protobuffer__PersistableEnvelope
defaultProto__Io__Haveno__Protobuffer__PersistableEnvelope =
    { message = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PersistableEnvelope` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PersistableEnvelope :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PersistableEnvelope
decodeProto__Io__Haveno__Protobuffer__PersistableEnvelope =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PersistableEnvelope
        [ decodeProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message (\a r -> { r | message = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PersistableEnvelope` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PersistableEnvelope :
    Proto__Io__Haveno__Protobuffer__PersistableEnvelope -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PersistableEnvelope value =
    Protobuf.Encode.message
        [ encodeProto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message value.message ]


{-| `Proto__Io__Haveno__Protobuffer__PersistableEnvelope` message

-}
type alias Proto__Io__Haveno__Protobuffer__PersistableEnvelope =
    { message : Maybe Proto__Io__Haveno__Protobuffer__PersistableEnvelope__Message__Message }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SwiftAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SwiftAccountPayload :
    { beneficiaryName : Int
    , beneficiaryAccountNr : Int
    , beneficiaryAddress : Int
    , beneficiaryCity : Int
    , beneficiaryPhone : Int
    , specialInstructions : Int
    , bankSwiftCode : Int
    , bankCountryCode : Int
    , bankName : Int
    , bankBranch : Int
    , bankAddress : Int
    , intermediarySwiftCode : Int
    , intermediaryCountryCode : Int
    , intermediaryName : Int
    , intermediaryBranch : Int
    , intermediaryAddress : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__SwiftAccountPayload =
    { beneficiaryName = 1
    , beneficiaryAccountNr = 2
    , beneficiaryAddress = 3
    , beneficiaryCity = 4
    , beneficiaryPhone = 5
    , specialInstructions = 6
    , bankSwiftCode = 7
    , bankCountryCode = 8
    , bankName = 9
    , bankBranch = 10
    , bankAddress = 11
    , intermediarySwiftCode = 12
    , intermediaryCountryCode = 13
    , intermediaryName = 14
    , intermediaryBranch = 15
    , intermediaryAddress = 16
    }


{-| Default for Proto__Io__Haveno__Protobuffer__SwiftAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SwiftAccountPayload : Proto__Io__Haveno__Protobuffer__SwiftAccountPayload
defaultProto__Io__Haveno__Protobuffer__SwiftAccountPayload =
    { beneficiaryName = ""
    , beneficiaryAccountNr = ""
    , beneficiaryAddress = ""
    , beneficiaryCity = ""
    , beneficiaryPhone = ""
    , specialInstructions = ""
    , bankSwiftCode = ""
    , bankCountryCode = ""
    , bankName = ""
    , bankBranch = ""
    , bankAddress = ""
    , intermediarySwiftCode = ""
    , intermediaryCountryCode = ""
    , intermediaryName = ""
    , intermediaryBranch = ""
    , intermediaryAddress = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SwiftAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SwiftAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SwiftAccountPayload
decodeProto__Io__Haveno__Protobuffer__SwiftAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SwiftAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | beneficiaryName = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | beneficiaryAccountNr = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | beneficiaryAddress = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | beneficiaryCity = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | beneficiaryPhone = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | specialInstructions = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | bankSwiftCode = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.string (\a r -> { r | bankCountryCode = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.string (\a r -> { r | bankName = a })
        , Protobuf.Decode.optional 10 Protobuf.Decode.string (\a r -> { r | bankBranch = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.string (\a r -> { r | bankAddress = a })
        , Protobuf.Decode.optional 12 Protobuf.Decode.string (\a r -> { r | intermediarySwiftCode = a })
        , Protobuf.Decode.optional 13 Protobuf.Decode.string (\a r -> { r | intermediaryCountryCode = a })
        , Protobuf.Decode.optional 14 Protobuf.Decode.string (\a r -> { r | intermediaryName = a })
        , Protobuf.Decode.optional 15 Protobuf.Decode.string (\a r -> { r | intermediaryBranch = a })
        , Protobuf.Decode.optional 16 Protobuf.Decode.string (\a r -> { r | intermediaryAddress = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SwiftAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SwiftAccountPayload :
    Proto__Io__Haveno__Protobuffer__SwiftAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SwiftAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.beneficiaryName )
        , ( 2, Protobuf.Encode.string value.beneficiaryAccountNr )
        , ( 3, Protobuf.Encode.string value.beneficiaryAddress )
        , ( 4, Protobuf.Encode.string value.beneficiaryCity )
        , ( 5, Protobuf.Encode.string value.beneficiaryPhone )
        , ( 6, Protobuf.Encode.string value.specialInstructions )
        , ( 7, Protobuf.Encode.string value.bankSwiftCode )
        , ( 8, Protobuf.Encode.string value.bankCountryCode )
        , ( 9, Protobuf.Encode.string value.bankName )
        , ( 10, Protobuf.Encode.string value.bankBranch )
        , ( 11, Protobuf.Encode.string value.bankAddress )
        , ( 12, Protobuf.Encode.string value.intermediarySwiftCode )
        , ( 13, Protobuf.Encode.string value.intermediaryCountryCode )
        , ( 14, Protobuf.Encode.string value.intermediaryName )
        , ( 15, Protobuf.Encode.string value.intermediaryBranch )
        , ( 16, Protobuf.Encode.string value.intermediaryAddress )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SwiftAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__SwiftAccountPayload =
    { beneficiaryName : String
    , beneficiaryAccountNr : String
    , beneficiaryAddress : String
    , beneficiaryCity : String
    , beneficiaryPhone : String
    , specialInstructions : String
    , bankSwiftCode : String
    , bankCountryCode : String
    , bankName : String
    , bankBranch : String
    , bankAddress : String
    , intermediarySwiftCode : String
    , intermediaryCountryCode : String
    , intermediaryName : String
    , intermediaryBranch : String
    , intermediaryAddress : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__VerseAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__VerseAccountPayload : { holderName : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__VerseAccountPayload =
    { holderName = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__VerseAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__VerseAccountPayload : Proto__Io__Haveno__Protobuffer__VerseAccountPayload
defaultProto__Io__Haveno__Protobuffer__VerseAccountPayload =
    { holderName = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__VerseAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__VerseAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__VerseAccountPayload
decodeProto__Io__Haveno__Protobuffer__VerseAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__VerseAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | holderName = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__VerseAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__VerseAccountPayload :
    Proto__Io__Haveno__Protobuffer__VerseAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__VerseAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.holderName ) ]


{-| `Proto__Io__Haveno__Protobuffer__VerseAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__VerseAccountPayload =
    { holderName : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__TikkieAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__TikkieAccountPayload : { iban : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__TikkieAccountPayload =
    { iban = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__TikkieAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__TikkieAccountPayload : Proto__Io__Haveno__Protobuffer__TikkieAccountPayload
defaultProto__Io__Haveno__Protobuffer__TikkieAccountPayload =
    { iban = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__TikkieAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__TikkieAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__TikkieAccountPayload
decodeProto__Io__Haveno__Protobuffer__TikkieAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__TikkieAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | iban = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__TikkieAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__TikkieAccountPayload :
    Proto__Io__Haveno__Protobuffer__TikkieAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__TikkieAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.iban ) ]


{-| `Proto__Io__Haveno__Protobuffer__TikkieAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__TikkieAccountPayload =
    { iban : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StrikeAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__StrikeAccountPayload : { holderName : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__StrikeAccountPayload =
    { holderName = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__StrikeAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__StrikeAccountPayload : Proto__Io__Haveno__Protobuffer__StrikeAccountPayload
defaultProto__Io__Haveno__Protobuffer__StrikeAccountPayload =
    { holderName = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__StrikeAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__StrikeAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__StrikeAccountPayload
decodeProto__Io__Haveno__Protobuffer__StrikeAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__StrikeAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | holderName = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__StrikeAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__StrikeAccountPayload :
    Proto__Io__Haveno__Protobuffer__StrikeAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__StrikeAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.holderName ) ]


{-| `Proto__Io__Haveno__Protobuffer__StrikeAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__StrikeAccountPayload =
    { holderName : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SatispayAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SatispayAccountPayload : { mobileNr : Int, holderName : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SatispayAccountPayload =
    { mobileNr = 1, holderName = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__SatispayAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SatispayAccountPayload : Proto__Io__Haveno__Protobuffer__SatispayAccountPayload
defaultProto__Io__Haveno__Protobuffer__SatispayAccountPayload =
    { mobileNr = "", holderName = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SatispayAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SatispayAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SatispayAccountPayload
decodeProto__Io__Haveno__Protobuffer__SatispayAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SatispayAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | mobileNr = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | holderName = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SatispayAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SatispayAccountPayload :
    Proto__Io__Haveno__Protobuffer__SatispayAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SatispayAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.mobileNr ), ( 2, Protobuf.Encode.string value.holderName ) ]


{-| `Proto__Io__Haveno__Protobuffer__SatispayAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__SatispayAccountPayload =
    { mobileNr : String, holderName : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MoneseAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MoneseAccountPayload : { mobileNr : Int, holderName : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MoneseAccountPayload =
    { mobileNr = 1, holderName = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__MoneseAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MoneseAccountPayload : Proto__Io__Haveno__Protobuffer__MoneseAccountPayload
defaultProto__Io__Haveno__Protobuffer__MoneseAccountPayload =
    { mobileNr = "", holderName = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MoneseAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MoneseAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MoneseAccountPayload
decodeProto__Io__Haveno__Protobuffer__MoneseAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MoneseAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | mobileNr = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | holderName = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MoneseAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MoneseAccountPayload :
    Proto__Io__Haveno__Protobuffer__MoneseAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MoneseAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.mobileNr ), ( 2, Protobuf.Encode.string value.holderName ) ]


{-| `Proto__Io__Haveno__Protobuffer__MoneseAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__MoneseAccountPayload =
    { mobileNr : String, holderName : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PixAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PixAccountPayload : { pixKey : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PixAccountPayload =
    { pixKey = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__PixAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PixAccountPayload : Proto__Io__Haveno__Protobuffer__PixAccountPayload
defaultProto__Io__Haveno__Protobuffer__PixAccountPayload =
    { pixKey = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PixAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PixAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PixAccountPayload
decodeProto__Io__Haveno__Protobuffer__PixAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PixAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | pixKey = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PixAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PixAccountPayload :
    Proto__Io__Haveno__Protobuffer__PixAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PixAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.pixKey ) ]


{-| `Proto__Io__Haveno__Protobuffer__PixAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__PixAccountPayload =
    { pixKey : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__BizumAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__BizumAccountPayload : { mobileNr : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__BizumAccountPayload =
    { mobileNr = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__BizumAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__BizumAccountPayload : Proto__Io__Haveno__Protobuffer__BizumAccountPayload
defaultProto__Io__Haveno__Protobuffer__BizumAccountPayload =
    { mobileNr = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__BizumAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__BizumAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__BizumAccountPayload
decodeProto__Io__Haveno__Protobuffer__BizumAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__BizumAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | mobileNr = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__BizumAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__BizumAccountPayload :
    Proto__Io__Haveno__Protobuffer__BizumAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__BizumAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.mobileNr ) ]


{-| `Proto__Io__Haveno__Protobuffer__BizumAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__BizumAccountPayload =
    { mobileNr : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__NequiAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__NequiAccountPayload : { mobileNr : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__NequiAccountPayload =
    { mobileNr = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__NequiAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__NequiAccountPayload : Proto__Io__Haveno__Protobuffer__NequiAccountPayload
defaultProto__Io__Haveno__Protobuffer__NequiAccountPayload =
    { mobileNr = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__NequiAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__NequiAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__NequiAccountPayload
decodeProto__Io__Haveno__Protobuffer__NequiAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__NequiAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | mobileNr = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__NequiAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__NequiAccountPayload :
    Proto__Io__Haveno__Protobuffer__NequiAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__NequiAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.mobileNr ) ]


{-| `Proto__Io__Haveno__Protobuffer__NequiAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__NequiAccountPayload =
    { mobileNr : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CelPayAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CelPayAccountPayload : { email : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CelPayAccountPayload =
    { email = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__CelPayAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CelPayAccountPayload : Proto__Io__Haveno__Protobuffer__CelPayAccountPayload
defaultProto__Io__Haveno__Protobuffer__CelPayAccountPayload =
    { email = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CelPayAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CelPayAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CelPayAccountPayload
decodeProto__Io__Haveno__Protobuffer__CelPayAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CelPayAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | email = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CelPayAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CelPayAccountPayload :
    Proto__Io__Haveno__Protobuffer__CelPayAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CelPayAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.email ) ]


{-| `Proto__Io__Haveno__Protobuffer__CelPayAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__CelPayAccountPayload =
    { email : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CapitualAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CapitualAccountPayload : { accountNr : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CapitualAccountPayload =
    { accountNr = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__CapitualAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CapitualAccountPayload : Proto__Io__Haveno__Protobuffer__CapitualAccountPayload
defaultProto__Io__Haveno__Protobuffer__CapitualAccountPayload =
    { accountNr = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CapitualAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CapitualAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CapitualAccountPayload
decodeProto__Io__Haveno__Protobuffer__CapitualAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CapitualAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | accountNr = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CapitualAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CapitualAccountPayload :
    Proto__Io__Haveno__Protobuffer__CapitualAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CapitualAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.accountNr ) ]


{-| `Proto__Io__Haveno__Protobuffer__CapitualAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__CapitualAccountPayload =
    { accountNr : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PaxumAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PaxumAccountPayload : { email : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PaxumAccountPayload =
    { email = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__PaxumAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PaxumAccountPayload : Proto__Io__Haveno__Protobuffer__PaxumAccountPayload
defaultProto__Io__Haveno__Protobuffer__PaxumAccountPayload =
    { email = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PaxumAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PaxumAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PaxumAccountPayload
decodeProto__Io__Haveno__Protobuffer__PaxumAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PaxumAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | email = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PaxumAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PaxumAccountPayload :
    Proto__Io__Haveno__Protobuffer__PaxumAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PaxumAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.email ) ]


{-| `Proto__Io__Haveno__Protobuffer__PaxumAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__PaxumAccountPayload =
    { email : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PayseraAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PayseraAccountPayload : { email : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PayseraAccountPayload =
    { email = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__PayseraAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PayseraAccountPayload : Proto__Io__Haveno__Protobuffer__PayseraAccountPayload
defaultProto__Io__Haveno__Protobuffer__PayseraAccountPayload =
    { email = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PayseraAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PayseraAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PayseraAccountPayload
decodeProto__Io__Haveno__Protobuffer__PayseraAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PayseraAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | email = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PayseraAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PayseraAccountPayload :
    Proto__Io__Haveno__Protobuffer__PayseraAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PayseraAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.email ) ]


{-| `Proto__Io__Haveno__Protobuffer__PayseraAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__PayseraAccountPayload =
    { email : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload :
    { email : Int, holderName : Int, beneficiaryAddress : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload =
    { email = 1, holderName = 2, beneficiaryAddress = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload :
    Proto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload
defaultProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload =
    { email = "", holderName = "", beneficiaryAddress = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload
decodeProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | email = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | holderName = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | beneficiaryAddress = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload :
    Proto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.email )
        , ( 2, Protobuf.Encode.string value.holderName )
        , ( 3, Protobuf.Encode.string value.beneficiaryAddress )
        ]


{-| `Proto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__TransferwiseUsdAccountPayload =
    { email : String, holderName : String, beneficiaryAddress : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__TransferwiseAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload : { email : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload =
    { email = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__TransferwiseAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload :
    Proto__Io__Haveno__Protobuffer__TransferwiseAccountPayload
defaultProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload =
    { email = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__TransferwiseAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__TransferwiseAccountPayload
decodeProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | email = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__TransferwiseAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload :
    Proto__Io__Haveno__Protobuffer__TransferwiseAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__TransferwiseAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.email ) ]


{-| `Proto__Io__Haveno__Protobuffer__TransferwiseAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__TransferwiseAccountPayload =
    { email : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload : { accountNr : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload =
    { accountNr = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload :
    Proto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload
defaultProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload =
    { accountNr = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload
decodeProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | accountNr = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload :
    Proto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.accountNr ) ]


{-| `Proto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__AdvancedCashAccountPayload =
    { accountNr : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PromptPayAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PromptPayAccountPayload : { promptPayId : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PromptPayAccountPayload =
    { promptPayId = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__PromptPayAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PromptPayAccountPayload : Proto__Io__Haveno__Protobuffer__PromptPayAccountPayload
defaultProto__Io__Haveno__Protobuffer__PromptPayAccountPayload =
    { promptPayId = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PromptPayAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PromptPayAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PromptPayAccountPayload
decodeProto__Io__Haveno__Protobuffer__PromptPayAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PromptPayAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | promptPayId = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PromptPayAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PromptPayAccountPayload :
    Proto__Io__Haveno__Protobuffer__PromptPayAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PromptPayAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.promptPayId ) ]


{-| `Proto__Io__Haveno__Protobuffer__PromptPayAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__PromptPayAccountPayload =
    { promptPayId : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload : { extraInfo : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload =
    { extraInfo = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload : Proto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload
defaultProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload =
    { extraInfo = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload
decodeProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | extraInfo = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload :
    Proto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.extraInfo ) ]


{-| `Proto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__CashAtAtmAccountPayload =
    { extraInfo : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PayByMailAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PayByMailAccountPayload :
    { postalAddress : Int, contact : Int, extraInfo : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PayByMailAccountPayload =
    { postalAddress = 1, contact = 2, extraInfo = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__PayByMailAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PayByMailAccountPayload : Proto__Io__Haveno__Protobuffer__PayByMailAccountPayload
defaultProto__Io__Haveno__Protobuffer__PayByMailAccountPayload =
    { postalAddress = "", contact = "", extraInfo = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PayByMailAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PayByMailAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PayByMailAccountPayload
decodeProto__Io__Haveno__Protobuffer__PayByMailAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PayByMailAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | postalAddress = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | contact = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | extraInfo = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PayByMailAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PayByMailAccountPayload :
    Proto__Io__Haveno__Protobuffer__PayByMailAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PayByMailAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.postalAddress )
        , ( 2, Protobuf.Encode.string value.contact )
        , ( 3, Protobuf.Encode.string value.extraInfo )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PayByMailAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__PayByMailAccountPayload =
    { postalAddress : String, contact : String, extraInfo : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PaytmAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PaytmAccountPayload : { emailOrMobileNr : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PaytmAccountPayload =
    { emailOrMobileNr = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__PaytmAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PaytmAccountPayload : Proto__Io__Haveno__Protobuffer__PaytmAccountPayload
defaultProto__Io__Haveno__Protobuffer__PaytmAccountPayload =
    { emailOrMobileNr = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PaytmAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PaytmAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PaytmAccountPayload
decodeProto__Io__Haveno__Protobuffer__PaytmAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PaytmAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | emailOrMobileNr = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PaytmAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PaytmAccountPayload :
    Proto__Io__Haveno__Protobuffer__PaytmAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PaytmAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.emailOrMobileNr ) ]


{-| `Proto__Io__Haveno__Protobuffer__PaytmAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__PaytmAccountPayload =
    { emailOrMobileNr : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__UpiAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__UpiAccountPayload : { virtualPaymentAddress : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__UpiAccountPayload =
    { virtualPaymentAddress = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__UpiAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__UpiAccountPayload : Proto__Io__Haveno__Protobuffer__UpiAccountPayload
defaultProto__Io__Haveno__Protobuffer__UpiAccountPayload =
    { virtualPaymentAddress = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__UpiAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__UpiAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__UpiAccountPayload
decodeProto__Io__Haveno__Protobuffer__UpiAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__UpiAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | virtualPaymentAddress = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__UpiAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__UpiAccountPayload :
    Proto__Io__Haveno__Protobuffer__UpiAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__UpiAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.virtualPaymentAddress ) ]


{-| `Proto__Io__Haveno__Protobuffer__UpiAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__UpiAccountPayload =
    { virtualPaymentAddress : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ImpsAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ImpsAccountPayload : {}
fieldNumbersProto__Io__Haveno__Protobuffer__ImpsAccountPayload =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__ImpsAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ImpsAccountPayload : Proto__Io__Haveno__Protobuffer__ImpsAccountPayload
defaultProto__Io__Haveno__Protobuffer__ImpsAccountPayload =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ImpsAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ImpsAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ImpsAccountPayload
decodeProto__Io__Haveno__Protobuffer__ImpsAccountPayload =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__ImpsAccountPayload []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ImpsAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ImpsAccountPayload :
    Proto__Io__Haveno__Protobuffer__ImpsAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ImpsAccountPayload _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__ImpsAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__ImpsAccountPayload =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RtgsAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RtgsAccountPayload : {}
fieldNumbersProto__Io__Haveno__Protobuffer__RtgsAccountPayload =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__RtgsAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RtgsAccountPayload : Proto__Io__Haveno__Protobuffer__RtgsAccountPayload
defaultProto__Io__Haveno__Protobuffer__RtgsAccountPayload =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RtgsAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RtgsAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RtgsAccountPayload
decodeProto__Io__Haveno__Protobuffer__RtgsAccountPayload =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__RtgsAccountPayload []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RtgsAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RtgsAccountPayload :
    Proto__Io__Haveno__Protobuffer__RtgsAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RtgsAccountPayload _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__RtgsAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__RtgsAccountPayload =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__NeftAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__NeftAccountPayload : {}
fieldNumbersProto__Io__Haveno__Protobuffer__NeftAccountPayload =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__NeftAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__NeftAccountPayload : Proto__Io__Haveno__Protobuffer__NeftAccountPayload
defaultProto__Io__Haveno__Protobuffer__NeftAccountPayload =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__NeftAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__NeftAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__NeftAccountPayload
decodeProto__Io__Haveno__Protobuffer__NeftAccountPayload =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__NeftAccountPayload []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__NeftAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__NeftAccountPayload :
    Proto__Io__Haveno__Protobuffer__NeftAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__NeftAccountPayload _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__NeftAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__NeftAccountPayload =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload :
    { holderName : Int
    , accountNr : Int
    , ifsc : Int
    , message : FieldNumbersProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message
    }
fieldNumbersProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload =
    { holderName = 1
    , accountNr = 2
    , ifsc = 3
    , message = fieldNumbersProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message
    }


{-| Default for Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload : Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload
defaultProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload =
    { holderName = "", accountNr = "", ifsc = "", message = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload
decodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | holderName = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | accountNr = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | ifsc = a })
        , decodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message (\a r -> { r | message = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload :
    Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.holderName )
        , ( 2, Protobuf.Encode.string value.accountNr )
        , ( 3, Protobuf.Encode.string value.ifsc )
        , encodeProto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message value.message
        ]


{-| `Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload =
    { holderName : String
    , accountNr : String
    , ifsc : String
    , message : Maybe Proto__Io__Haveno__Protobuffer__IfscBasedAccountPayload__Message__Message
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__F2FAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__F2FAccountPayload : { contact : Int, city : Int, extraInfo : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__F2FAccountPayload =
    { contact = 1, city = 2, extraInfo = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__F2FAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__F2FAccountPayload : Proto__Io__Haveno__Protobuffer__F2FAccountPayload
defaultProto__Io__Haveno__Protobuffer__F2FAccountPayload =
    { contact = "", city = "", extraInfo = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__F2FAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__F2FAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__F2FAccountPayload
decodeProto__Io__Haveno__Protobuffer__F2FAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__F2FAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | contact = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | city = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | extraInfo = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__F2FAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__F2FAccountPayload :
    Proto__Io__Haveno__Protobuffer__F2FAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__F2FAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.contact )
        , ( 2, Protobuf.Encode.string value.city )
        , ( 3, Protobuf.Encode.string value.extraInfo )
        ]


{-| `Proto__Io__Haveno__Protobuffer__F2FAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__F2FAccountPayload =
    { contact : String, city : String, extraInfo : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload : { postalAddress : Int, holderName : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload =
    { postalAddress = 1, holderName = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload :
    Proto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload
defaultProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload =
    { postalAddress = "", holderName = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload
decodeProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | postalAddress = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | holderName = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload :
    Proto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.postalAddress ), ( 2, Protobuf.Encode.string value.holderName ) ]


{-| `Proto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__USPostalMoneyOrderAccountPayload =
    { postalAddress : String, holderName : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SwishAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SwishAccountPayload : { mobileNr : Int, holderName : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SwishAccountPayload =
    { mobileNr = 1, holderName = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__SwishAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SwishAccountPayload : Proto__Io__Haveno__Protobuffer__SwishAccountPayload
defaultProto__Io__Haveno__Protobuffer__SwishAccountPayload =
    { mobileNr = "", holderName = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SwishAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SwishAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SwishAccountPayload
decodeProto__Io__Haveno__Protobuffer__SwishAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SwishAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | mobileNr = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | holderName = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SwishAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SwishAccountPayload :
    Proto__Io__Haveno__Protobuffer__SwishAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SwishAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.mobileNr ), ( 2, Protobuf.Encode.string value.holderName ) ]


{-| `Proto__Io__Haveno__Protobuffer__SwishAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__SwishAccountPayload =
    { mobileNr : String, holderName : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload : { accountNr : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload =
    { accountNr = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload :
    Proto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload
defaultProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload =
    { accountNr = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload
decodeProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | accountNr = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload :
    Proto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.accountNr ) ]


{-| `Proto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__PerfectMoneyAccountPayload =
    { accountNr : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RevolutAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RevolutAccountPayload : { username : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__RevolutAccountPayload =
    { username = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__RevolutAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RevolutAccountPayload : Proto__Io__Haveno__Protobuffer__RevolutAccountPayload
defaultProto__Io__Haveno__Protobuffer__RevolutAccountPayload =
    { username = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RevolutAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RevolutAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RevolutAccountPayload
decodeProto__Io__Haveno__Protobuffer__RevolutAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__RevolutAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | username = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RevolutAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RevolutAccountPayload :
    Proto__Io__Haveno__Protobuffer__RevolutAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RevolutAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.username ) ]


{-| `Proto__Io__Haveno__Protobuffer__RevolutAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__RevolutAccountPayload =
    { username : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PopmoneyAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload : { accountId : Int, holderName : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload =
    { accountId = 1, holderName = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__PopmoneyAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload : Proto__Io__Haveno__Protobuffer__PopmoneyAccountPayload
defaultProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload =
    { accountId = "", holderName = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PopmoneyAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PopmoneyAccountPayload
decodeProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | accountId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | holderName = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PopmoneyAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload :
    Proto__Io__Haveno__Protobuffer__PopmoneyAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PopmoneyAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.accountId ), ( 2, Protobuf.Encode.string value.holderName ) ]


{-| `Proto__Io__Haveno__Protobuffer__PopmoneyAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__PopmoneyAccountPayload =
    { accountId : String, holderName : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PayPalAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PayPalAccountPayload : { emailOrMobileNrOrUsername : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PayPalAccountPayload =
    { emailOrMobileNrOrUsername = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__PayPalAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PayPalAccountPayload : Proto__Io__Haveno__Protobuffer__PayPalAccountPayload
defaultProto__Io__Haveno__Protobuffer__PayPalAccountPayload =
    { emailOrMobileNrOrUsername = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PayPalAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PayPalAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PayPalAccountPayload
decodeProto__Io__Haveno__Protobuffer__PayPalAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PayPalAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | emailOrMobileNrOrUsername = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PayPalAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PayPalAccountPayload :
    Proto__Io__Haveno__Protobuffer__PayPalAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PayPalAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.emailOrMobileNrOrUsername ) ]


{-| `Proto__Io__Haveno__Protobuffer__PayPalAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__PayPalAccountPayload =
    { emailOrMobileNrOrUsername : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__VenmoAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__VenmoAccountPayload : { emailOrMobileNrOrUsername : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__VenmoAccountPayload =
    { emailOrMobileNrOrUsername = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__VenmoAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__VenmoAccountPayload : Proto__Io__Haveno__Protobuffer__VenmoAccountPayload
defaultProto__Io__Haveno__Protobuffer__VenmoAccountPayload =
    { emailOrMobileNrOrUsername = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__VenmoAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__VenmoAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__VenmoAccountPayload
decodeProto__Io__Haveno__Protobuffer__VenmoAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__VenmoAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | emailOrMobileNrOrUsername = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__VenmoAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__VenmoAccountPayload :
    Proto__Io__Haveno__Protobuffer__VenmoAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__VenmoAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.emailOrMobileNrOrUsername ) ]


{-| `Proto__Io__Haveno__Protobuffer__VenmoAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__VenmoAccountPayload =
    { emailOrMobileNrOrUsername : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload : { accountId : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload =
    { accountId = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload : Proto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload
defaultProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload =
    { accountId = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload
decodeProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | accountId = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload :
    Proto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.accountId ) ]


{-| `Proto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__MoneyBeamAccountPayload =
    { accountId : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CashAppAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CashAppAccountPayload : { emailOrMobileNrOrCashtag : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CashAppAccountPayload =
    { emailOrMobileNrOrCashtag = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__CashAppAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CashAppAccountPayload : Proto__Io__Haveno__Protobuffer__CashAppAccountPayload
defaultProto__Io__Haveno__Protobuffer__CashAppAccountPayload =
    { emailOrMobileNrOrCashtag = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CashAppAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CashAppAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CashAppAccountPayload
decodeProto__Io__Haveno__Protobuffer__CashAppAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CashAppAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | emailOrMobileNrOrCashtag = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CashAppAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CashAppAccountPayload :
    Proto__Io__Haveno__Protobuffer__CashAppAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CashAppAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.emailOrMobileNrOrCashtag ) ]


{-| `Proto__Io__Haveno__Protobuffer__CashAppAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__CashAppAccountPayload =
    { emailOrMobileNrOrCashtag : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__UpholdAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__UpholdAccountPayload : { accountId : Int, accountOwner : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__UpholdAccountPayload =
    { accountId = 1, accountOwner = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__UpholdAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__UpholdAccountPayload : Proto__Io__Haveno__Protobuffer__UpholdAccountPayload
defaultProto__Io__Haveno__Protobuffer__UpholdAccountPayload =
    { accountId = "", accountOwner = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__UpholdAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__UpholdAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__UpholdAccountPayload
decodeProto__Io__Haveno__Protobuffer__UpholdAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__UpholdAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | accountId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | accountOwner = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__UpholdAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__UpholdAccountPayload :
    Proto__Io__Haveno__Protobuffer__UpholdAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__UpholdAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.accountId ), ( 2, Protobuf.Encode.string value.accountOwner ) ]


{-| `Proto__Io__Haveno__Protobuffer__UpholdAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__UpholdAccountPayload =
    { accountId : String, accountOwner : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__OKPayAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__OKPayAccountPayload : { accountNr : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__OKPayAccountPayload =
    { accountNr = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__OKPayAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__OKPayAccountPayload : Proto__Io__Haveno__Protobuffer__OKPayAccountPayload
defaultProto__Io__Haveno__Protobuffer__OKPayAccountPayload =
    { accountNr = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__OKPayAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__OKPayAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__OKPayAccountPayload
decodeProto__Io__Haveno__Protobuffer__OKPayAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__OKPayAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | accountNr = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__OKPayAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__OKPayAccountPayload :
    Proto__Io__Haveno__Protobuffer__OKPayAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__OKPayAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.accountNr ) ]


{-| `Proto__Io__Haveno__Protobuffer__OKPayAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__OKPayAccountPayload =
    { accountNr : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__InteracETransferAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload :
    { email : Int, holderName : Int, question : Int, answer : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload =
    { email = 1, holderName = 2, question = 3, answer = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__InteracETransferAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload :
    Proto__Io__Haveno__Protobuffer__InteracETransferAccountPayload
defaultProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload =
    { email = "", holderName = "", question = "", answer = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__InteracETransferAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__InteracETransferAccountPayload
decodeProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | email = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | holderName = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | question = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | answer = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__InteracETransferAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload :
    Proto__Io__Haveno__Protobuffer__InteracETransferAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__InteracETransferAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.email )
        , ( 2, Protobuf.Encode.string value.holderName )
        , ( 3, Protobuf.Encode.string value.question )
        , ( 4, Protobuf.Encode.string value.answer )
        ]


{-| `Proto__Io__Haveno__Protobuffer__InteracETransferAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__InteracETransferAccountPayload =
    { email : String, holderName : String, question : String, answer : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload :
    { holderName : Int, sortCode : Int, accountNr : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload =
    { holderName = 1, sortCode = 2, accountNr = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload :
    Proto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload
defaultProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload =
    { holderName = "", sortCode = "", accountNr = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload
decodeProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | holderName = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | sortCode = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | accountNr = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload :
    Proto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.holderName )
        , ( 2, Protobuf.Encode.string value.sortCode )
        , ( 3, Protobuf.Encode.string value.accountNr )
        ]


{-| `Proto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__FasterPaymentsAccountPayload =
    { holderName : String, sortCode : String, accountNr : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload : { address : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload =
    { address = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload :
    Proto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload
defaultProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload =
    { address = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload
decodeProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | address = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload :
    Proto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.address ) ]


{-| `Proto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__InstantCryptoCurrencyAccountPayload =
    { address : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload : { address : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload =
    { address = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload :
    Proto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload
defaultProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload =
    { address = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload
decodeProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | address = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload :
    Proto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.address ) ]


{-| `Proto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__CryptoCurrencyAccountPayload =
    { address : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SepaInstantAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload : { holderName : Int, iban : Int, bic : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload =
    { holderName = 1, iban = 2, bic = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__SepaInstantAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload :
    Proto__Io__Haveno__Protobuffer__SepaInstantAccountPayload
defaultProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload =
    { holderName = "", iban = "", bic = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SepaInstantAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SepaInstantAccountPayload
decodeProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | holderName = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | iban = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | bic = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SepaInstantAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload :
    Proto__Io__Haveno__Protobuffer__SepaInstantAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SepaInstantAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.holderName )
        , ( 2, Protobuf.Encode.string value.iban )
        , ( 3, Protobuf.Encode.string value.bic )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SepaInstantAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__SepaInstantAccountPayload =
    { holderName : String, iban : String, bic : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SepaAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SepaAccountPayload :
    { holderName : Int, iban : Int, bic : Int, email : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SepaAccountPayload =
    { holderName = 1, iban = 2, bic = 3, email = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__SepaAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SepaAccountPayload : Proto__Io__Haveno__Protobuffer__SepaAccountPayload
defaultProto__Io__Haveno__Protobuffer__SepaAccountPayload =
    { holderName = "", iban = "", bic = "", email = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SepaAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SepaAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SepaAccountPayload
decodeProto__Io__Haveno__Protobuffer__SepaAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SepaAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | holderName = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | iban = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | bic = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | email = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SepaAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SepaAccountPayload :
    Proto__Io__Haveno__Protobuffer__SepaAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SepaAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.holderName )
        , ( 2, Protobuf.Encode.string value.iban )
        , ( 3, Protobuf.Encode.string value.bic )
        , ( 4, Protobuf.Encode.string value.email )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SepaAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__SepaAccountPayload =
    { holderName : String, iban : String, bic : String, email : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload : { emailOrMobileNr : Int, countryCode : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload =
    { emailOrMobileNr = 1, countryCode = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload :
    Proto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload
defaultProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload =
    { emailOrMobileNr = "", countryCode = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload
decodeProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | emailOrMobileNr = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | countryCode = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload :
    Proto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.emailOrMobileNr ), ( 2, Protobuf.Encode.string value.countryCode ) ]


{-| `Proto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__AmazonGiftCardAccountPayload =
    { emailOrMobileNr : String, countryCode : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__WesternUnionAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload :
    { holderName : Int, city : Int, state : Int, email : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload =
    { holderName = 1, city = 2, state = 3, email = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__WesternUnionAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload :
    Proto__Io__Haveno__Protobuffer__WesternUnionAccountPayload
defaultProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload =
    { holderName = "", city = "", state = "", email = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__WesternUnionAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__WesternUnionAccountPayload
decodeProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | holderName = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | city = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | state = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | email = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__WesternUnionAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload :
    Proto__Io__Haveno__Protobuffer__WesternUnionAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__WesternUnionAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.holderName )
        , ( 2, Protobuf.Encode.string value.city )
        , ( 3, Protobuf.Encode.string value.state )
        , ( 4, Protobuf.Encode.string value.email )
        ]


{-| `Proto__Io__Haveno__Protobuffer__WesternUnionAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__WesternUnionAccountPayload =
    { holderName : String, city : String, state : String, email : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__HalCashAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__HalCashAccountPayload : { mobileNr : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__HalCashAccountPayload =
    { mobileNr = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__HalCashAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__HalCashAccountPayload : Proto__Io__Haveno__Protobuffer__HalCashAccountPayload
defaultProto__Io__Haveno__Protobuffer__HalCashAccountPayload =
    { mobileNr = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__HalCashAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__HalCashAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__HalCashAccountPayload
decodeProto__Io__Haveno__Protobuffer__HalCashAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__HalCashAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | mobileNr = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__HalCashAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__HalCashAccountPayload :
    Proto__Io__Haveno__Protobuffer__HalCashAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__HalCashAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.mobileNr ) ]


{-| `Proto__Io__Haveno__Protobuffer__HalCashAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__HalCashAccountPayload =
    { mobileNr : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MoneyGramAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload :
    { holderName : Int, countryCode : Int, state : Int, email : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload =
    { holderName = 1, countryCode = 2, state = 3, email = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__MoneyGramAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload : Proto__Io__Haveno__Protobuffer__MoneyGramAccountPayload
defaultProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload =
    { holderName = "", countryCode = "", state = "", email = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MoneyGramAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MoneyGramAccountPayload
decodeProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | holderName = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | countryCode = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | state = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | email = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MoneyGramAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload :
    Proto__Io__Haveno__Protobuffer__MoneyGramAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MoneyGramAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.holderName )
        , ( 2, Protobuf.Encode.string value.countryCode )
        , ( 3, Protobuf.Encode.string value.state )
        , ( 4, Protobuf.Encode.string value.email )
        ]


{-| `Proto__Io__Haveno__Protobuffer__MoneyGramAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__MoneyGramAccountPayload =
    { holderName : String, countryCode : String, state : String, email : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CashDepositAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CashDepositAccountPayload :
    { holderName : Int
    , holderEmail : Int
    , bankName : Int
    , bankId : Int
    , branchId : Int
    , accountNr : Int
    , accountType : Int
    , requirements : Int
    , holderTaxId : Int
    , nationalAccountId : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__CashDepositAccountPayload =
    { holderName = 1
    , holderEmail = 2
    , bankName = 3
    , bankId = 4
    , branchId = 5
    , accountNr = 6
    , accountType = 7
    , requirements = 8
    , holderTaxId = 9
    , nationalAccountId = 10
    }


{-| Default for Proto__Io__Haveno__Protobuffer__CashDepositAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CashDepositAccountPayload :
    Proto__Io__Haveno__Protobuffer__CashDepositAccountPayload
defaultProto__Io__Haveno__Protobuffer__CashDepositAccountPayload =
    { holderName = ""
    , holderEmail = ""
    , bankName = ""
    , bankId = ""
    , branchId = ""
    , accountNr = ""
    , accountType = ""
    , requirements = ""
    , holderTaxId = ""
    , nationalAccountId = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CashDepositAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CashDepositAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CashDepositAccountPayload
decodeProto__Io__Haveno__Protobuffer__CashDepositAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CashDepositAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | holderName = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | holderEmail = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | bankName = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | bankId = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | branchId = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | accountNr = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | accountType = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.string (\a r -> { r | requirements = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.string (\a r -> { r | holderTaxId = a })
        , Protobuf.Decode.optional 10 Protobuf.Decode.string (\a r -> { r | nationalAccountId = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CashDepositAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CashDepositAccountPayload :
    Proto__Io__Haveno__Protobuffer__CashDepositAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CashDepositAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.holderName )
        , ( 2, Protobuf.Encode.string value.holderEmail )
        , ( 3, Protobuf.Encode.string value.bankName )
        , ( 4, Protobuf.Encode.string value.bankId )
        , ( 5, Protobuf.Encode.string value.branchId )
        , ( 6, Protobuf.Encode.string value.accountNr )
        , ( 7, Protobuf.Encode.string value.accountType )
        , ( 8, Protobuf.Encode.string value.requirements )
        , ( 9, Protobuf.Encode.string value.holderTaxId )
        , ( 10, Protobuf.Encode.string value.nationalAccountId )
        ]


{-| `Proto__Io__Haveno__Protobuffer__CashDepositAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__CashDepositAccountPayload =
    { holderName : String
    , holderEmail : String
    , bankName : String
    , bankId : String
    , branchId : String
    , accountNr : String
    , accountType : String
    , requirements : String
    , holderTaxId : String
    , nationalAccountId : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload : { acceptedBanks : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload =
    { acceptedBanks = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload :
    Proto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload
defaultProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload =
    { acceptedBanks = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload
decodeProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload
        [ Protobuf.Decode.repeated 1 Protobuf.Decode.string .acceptedBanks (\a r -> { r | acceptedBanks = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload :
    Proto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload value =
    Protobuf.Encode.message [ ( 1, (Protobuf.Encode.list Protobuf.Encode.string) value.acceptedBanks ) ]


{-| `Proto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__SpecificBanksAccountPayload =
    { acceptedBanks : List String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AustraliaPayidPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AustraliaPayidPayload :
    { bankAccountName : Int, payid : Int, extraInfo : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__AustraliaPayidPayload =
    { bankAccountName = 1, payid = 2, extraInfo = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__AustraliaPayidPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AustraliaPayidPayload : Proto__Io__Haveno__Protobuffer__AustraliaPayidPayload
defaultProto__Io__Haveno__Protobuffer__AustraliaPayidPayload =
    { bankAccountName = "", payid = "", extraInfo = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AustraliaPayidPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AustraliaPayidPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AustraliaPayidPayload
decodeProto__Io__Haveno__Protobuffer__AustraliaPayidPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AustraliaPayidPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | bankAccountName = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | payid = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | extraInfo = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AustraliaPayidPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AustraliaPayidPayload :
    Proto__Io__Haveno__Protobuffer__AustraliaPayidPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AustraliaPayidPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.bankAccountName )
        , ( 2, Protobuf.Encode.string value.payid )
        , ( 3, Protobuf.Encode.string value.extraInfo )
        ]


{-| `Proto__Io__Haveno__Protobuffer__AustraliaPayidPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__AustraliaPayidPayload =
    { bankAccountName : String, payid : String, extraInfo : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__JapanBankAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__JapanBankAccountPayload :
    { bankName : Int
    , bankCode : Int
    , bankBranchName : Int
    , bankBranchCode : Int
    , bankAccountType : Int
    , bankAccountName : Int
    , bankAccountNumber : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__JapanBankAccountPayload =
    { bankName = 1
    , bankCode = 2
    , bankBranchName = 3
    , bankBranchCode = 4
    , bankAccountType = 5
    , bankAccountName = 6
    , bankAccountNumber = 7
    }


{-| Default for Proto__Io__Haveno__Protobuffer__JapanBankAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__JapanBankAccountPayload : Proto__Io__Haveno__Protobuffer__JapanBankAccountPayload
defaultProto__Io__Haveno__Protobuffer__JapanBankAccountPayload =
    { bankName = ""
    , bankCode = ""
    , bankBranchName = ""
    , bankBranchCode = ""
    , bankAccountType = ""
    , bankAccountName = ""
    , bankAccountNumber = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__JapanBankAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__JapanBankAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__JapanBankAccountPayload
decodeProto__Io__Haveno__Protobuffer__JapanBankAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__JapanBankAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | bankName = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | bankCode = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | bankBranchName = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | bankBranchCode = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | bankAccountType = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | bankAccountName = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | bankAccountNumber = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__JapanBankAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__JapanBankAccountPayload :
    Proto__Io__Haveno__Protobuffer__JapanBankAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__JapanBankAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.bankName )
        , ( 2, Protobuf.Encode.string value.bankCode )
        , ( 3, Protobuf.Encode.string value.bankBranchName )
        , ( 4, Protobuf.Encode.string value.bankBranchCode )
        , ( 5, Protobuf.Encode.string value.bankAccountType )
        , ( 6, Protobuf.Encode.string value.bankAccountName )
        , ( 7, Protobuf.Encode.string value.bankAccountNumber )
        ]


{-| `Proto__Io__Haveno__Protobuffer__JapanBankAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__JapanBankAccountPayload =
    { bankName : String
    , bankCode : String
    , bankBranchName : String
    , bankBranchCode : String
    , bankAccountType : String
    , bankAccountName : String
    , bankAccountNumber : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SameBankAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SameBankAccountPayload : {}
fieldNumbersProto__Io__Haveno__Protobuffer__SameBankAccountPayload =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__SameBankAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SameBankAccountPayload : Proto__Io__Haveno__Protobuffer__SameBankAccountPayload
defaultProto__Io__Haveno__Protobuffer__SameBankAccountPayload =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SameBankAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SameBankAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SameBankAccountPayload
decodeProto__Io__Haveno__Protobuffer__SameBankAccountPayload =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__SameBankAccountPayload []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SameBankAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SameBankAccountPayload :
    Proto__Io__Haveno__Protobuffer__SameBankAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SameBankAccountPayload _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__SameBankAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__SameBankAccountPayload =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__NationalBankAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__NationalBankAccountPayload : {}
fieldNumbersProto__Io__Haveno__Protobuffer__NationalBankAccountPayload =
    {}


{-| Default for Proto__Io__Haveno__Protobuffer__NationalBankAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__NationalBankAccountPayload :
    Proto__Io__Haveno__Protobuffer__NationalBankAccountPayload
defaultProto__Io__Haveno__Protobuffer__NationalBankAccountPayload =
    {}


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__NationalBankAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__NationalBankAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__NationalBankAccountPayload
decodeProto__Io__Haveno__Protobuffer__NationalBankAccountPayload =
    Protobuf.Decode.message defaultProto__Io__Haveno__Protobuffer__NationalBankAccountPayload []


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__NationalBankAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__NationalBankAccountPayload :
    Proto__Io__Haveno__Protobuffer__NationalBankAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__NationalBankAccountPayload _ =
    Protobuf.Encode.message []


{-| `Proto__Io__Haveno__Protobuffer__NationalBankAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__NationalBankAccountPayload =
    {}


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload : { holderAddress : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload =
    { holderAddress = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload :
    Proto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload
defaultProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload =
    { holderAddress = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload
decodeProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | holderAddress = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload :
    Proto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.holderAddress ) ]


{-| `Proto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__DomesticWireTransferAccountPayload =
    { holderAddress : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AchTransferAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AchTransferAccountPayload : { holderAddress : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__AchTransferAccountPayload =
    { holderAddress = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__AchTransferAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AchTransferAccountPayload :
    Proto__Io__Haveno__Protobuffer__AchTransferAccountPayload
defaultProto__Io__Haveno__Protobuffer__AchTransferAccountPayload =
    { holderAddress = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AchTransferAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AchTransferAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AchTransferAccountPayload
decodeProto__Io__Haveno__Protobuffer__AchTransferAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AchTransferAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | holderAddress = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AchTransferAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AchTransferAccountPayload :
    Proto__Io__Haveno__Protobuffer__AchTransferAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AchTransferAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.holderAddress ) ]


{-| `Proto__Io__Haveno__Protobuffer__AchTransferAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__AchTransferAccountPayload =
    { holderAddress : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__BankAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__BankAccountPayload :
    { holderName : Int
    , bankName : Int
    , bankId : Int
    , branchId : Int
    , accountNr : Int
    , accountType : Int
    , holderTaxId : Int
    , email : Int
    , message : FieldNumbersProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message
    , nationalAccountId : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__BankAccountPayload =
    { holderName = 1
    , bankName = 2
    , bankId = 3
    , branchId = 4
    , accountNr = 5
    , accountType = 6
    , holderTaxId = 7
    , email = 8
    , message = fieldNumbersProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message
    , nationalAccountId = 12
    }


{-| Default for Proto__Io__Haveno__Protobuffer__BankAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__BankAccountPayload : Proto__Io__Haveno__Protobuffer__BankAccountPayload
defaultProto__Io__Haveno__Protobuffer__BankAccountPayload =
    { holderName = ""
    , bankName = ""
    , bankId = ""
    , branchId = ""
    , accountNr = ""
    , accountType = ""
    , holderTaxId = ""
    , email = ""
    , message = Nothing
    , nationalAccountId = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__BankAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__BankAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__BankAccountPayload
decodeProto__Io__Haveno__Protobuffer__BankAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__BankAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | holderName = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | bankName = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | bankId = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | branchId = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | accountNr = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | accountType = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | holderTaxId = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.string (\a r -> { r | email = a })
        , decodeProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message (\a r -> { r | message = a })
        , Protobuf.Decode.optional 12 Protobuf.Decode.string (\a r -> { r | nationalAccountId = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__BankAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__BankAccountPayload :
    Proto__Io__Haveno__Protobuffer__BankAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__BankAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.holderName )
        , ( 2, Protobuf.Encode.string value.bankName )
        , ( 3, Protobuf.Encode.string value.bankId )
        , ( 4, Protobuf.Encode.string value.branchId )
        , ( 5, Protobuf.Encode.string value.accountNr )
        , ( 6, Protobuf.Encode.string value.accountType )
        , ( 7, Protobuf.Encode.string value.holderTaxId )
        , ( 8, Protobuf.Encode.string value.email )
        , encodeProto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message value.message
        , ( 12, Protobuf.Encode.string value.nationalAccountId )
        ]


{-| `Proto__Io__Haveno__Protobuffer__BankAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__BankAccountPayload =
    { holderName : String
    , bankName : String
    , bankId : String
    , branchId : String
    , accountNr : String
    , accountType : String
    , holderTaxId : String
    , email : String
    , message : Maybe Proto__Io__Haveno__Protobuffer__BankAccountPayload__Message__Message
    , nationalAccountId : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload :
    { countryCode : Int
    , acceptedCountryCodes : Int
    , message : FieldNumbersProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message
    }
fieldNumbersProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload =
    { countryCode = 1
    , acceptedCountryCodes = 2
    , message = fieldNumbersProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message
    }


{-| Default for Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload :
    Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload
defaultProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload =
    { countryCode = "", acceptedCountryCodes = [], message = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload
decodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | countryCode = a })
        , Protobuf.Decode.repeated
            2
            Protobuf.Decode.string
            .acceptedCountryCodes
            (\a r -> { r | acceptedCountryCodes = a })
        , decodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message
            (\a r -> { r | message = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload :
    Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.countryCode )
        , ( 2, (Protobuf.Encode.list Protobuf.Encode.string) value.acceptedCountryCodes )
        , encodeProto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message value.message
        ]


{-| `Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload =
    { countryCode : String
    , acceptedCountryCodes : List String
    , message : Maybe Proto__Io__Haveno__Protobuffer__CountryBasedPaymentAccountPayload__Message__Message
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ZelleAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ZelleAccountPayload : { holderName : Int, emailOrMobileNr : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__ZelleAccountPayload =
    { holderName = 1, emailOrMobileNr = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__ZelleAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ZelleAccountPayload : Proto__Io__Haveno__Protobuffer__ZelleAccountPayload
defaultProto__Io__Haveno__Protobuffer__ZelleAccountPayload =
    { holderName = "", emailOrMobileNr = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ZelleAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ZelleAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ZelleAccountPayload
decodeProto__Io__Haveno__Protobuffer__ZelleAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__ZelleAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | holderName = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | emailOrMobileNr = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ZelleAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ZelleAccountPayload :
    Proto__Io__Haveno__Protobuffer__ZelleAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ZelleAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.holderName ), ( 2, Protobuf.Encode.string value.emailOrMobileNr ) ]


{-| `Proto__Io__Haveno__Protobuffer__ZelleAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__ZelleAccountPayload =
    { holderName : String, emailOrMobileNr : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload : { email : Int, holderName : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload =
    { email = 1, holderName = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload :
    Proto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload
defaultProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload =
    { email = "", holderName = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload
decodeProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | email = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | holderName = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload :
    Proto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.email ), ( 2, Protobuf.Encode.string value.holderName ) ]


{-| `Proto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__ChaseQuickPayAccountPayload =
    { email : String, holderName : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__WeChatPayAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload : { accountNr : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload =
    { accountNr = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__WeChatPayAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload : Proto__Io__Haveno__Protobuffer__WeChatPayAccountPayload
defaultProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload =
    { accountNr = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__WeChatPayAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__WeChatPayAccountPayload
decodeProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | accountNr = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__WeChatPayAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload :
    Proto__Io__Haveno__Protobuffer__WeChatPayAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__WeChatPayAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.accountNr ) ]


{-| `Proto__Io__Haveno__Protobuffer__WeChatPayAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__WeChatPayAccountPayload =
    { accountNr : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AliPayAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AliPayAccountPayload : { accountNr : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__AliPayAccountPayload =
    { accountNr = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__AliPayAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AliPayAccountPayload : Proto__Io__Haveno__Protobuffer__AliPayAccountPayload
defaultProto__Io__Haveno__Protobuffer__AliPayAccountPayload =
    { accountNr = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AliPayAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AliPayAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AliPayAccountPayload
decodeProto__Io__Haveno__Protobuffer__AliPayAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AliPayAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | accountNr = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AliPayAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AliPayAccountPayload :
    Proto__Io__Haveno__Protobuffer__AliPayAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AliPayAccountPayload value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.accountNr ) ]


{-| `Proto__Io__Haveno__Protobuffer__AliPayAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__AliPayAccountPayload =
    { accountNr : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PaymentAccountPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountPayload :
    { id : Int
    , paymentMethodId : Int
    , maxTradePeriod : Int
    , excludeFromJsonData : Int
    , message : FieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message
    }
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountPayload =
    { id = 1
    , paymentMethodId = 2
    , maxTradePeriod = 3
    , excludeFromJsonData = 4
    , message = fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message
    }


{-| Default for Proto__Io__Haveno__Protobuffer__PaymentAccountPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PaymentAccountPayload : Proto__Io__Haveno__Protobuffer__PaymentAccountPayload
defaultProto__Io__Haveno__Protobuffer__PaymentAccountPayload =
    { id = ""
    , paymentMethodId = ""
    , maxTradePeriod = Protobuf.Types.Int64.fromInts 0 0
    , excludeFromJsonData = Dict.empty
    , message = Nothing
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PaymentAccountPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PaymentAccountPayload
decodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PaymentAccountPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | id = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | paymentMethodId = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | maxTradePeriod = a })
        , Protobuf.Decode.mapped
            4
            ( "", "" )
            Protobuf.Decode.string
            Protobuf.Decode.string
            .excludeFromJsonData
            (\a r -> { r | excludeFromJsonData = a })
        , decodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message (\a r -> { r | message = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PaymentAccountPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload :
    Proto__Io__Haveno__Protobuffer__PaymentAccountPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.id )
        , ( 2, Protobuf.Encode.string value.paymentMethodId )
        , ( 3, Protobuf.Encode.int64 value.maxTradePeriod )
        , ( 4, Protobuf.Encode.dict Protobuf.Encode.string Protobuf.Encode.string value.excludeFromJsonData )
        , encodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message value.message
        ]


{-| `Proto__Io__Haveno__Protobuffer__PaymentAccountPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__PaymentAccountPayload =
    { id : String
    , paymentMethodId : String
    , maxTradePeriod : Protobuf.Types.Int64.Int64
    , excludeFromJsonData : Dict.Dict String String
    , message : Maybe Proto__Io__Haveno__Protobuffer__PaymentAccountPayload__Message__Message
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RawTransactionInput`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RawTransactionInput : { index : Int, parentTransaction : Int, value : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__RawTransactionInput =
    { index = 1, parentTransaction = 2, value = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__RawTransactionInput. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RawTransactionInput : Proto__Io__Haveno__Protobuffer__RawTransactionInput
defaultProto__Io__Haveno__Protobuffer__RawTransactionInput =
    { index = Protobuf.Types.Int64.fromInts 0 0
    , parentTransaction = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , value = Protobuf.Types.Int64.fromInts 0 0
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RawTransactionInput` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RawTransactionInput :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RawTransactionInput
decodeProto__Io__Haveno__Protobuffer__RawTransactionInput =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__RawTransactionInput
        [ Protobuf.Decode.optional 1 Protobuf.Decode.int64 (\a r -> { r | index = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.bytes (\a r -> { r | parentTransaction = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | value = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RawTransactionInput` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RawTransactionInput :
    Proto__Io__Haveno__Protobuffer__RawTransactionInput -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RawTransactionInput value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.int64 value.index )
        , ( 2, Protobuf.Encode.bytes value.parentTransaction )
        , ( 3, Protobuf.Encode.int64 value.value )
        ]


{-| `Proto__Io__Haveno__Protobuffer__RawTransactionInput` message

-}
type alias Proto__Io__Haveno__Protobuffer__RawTransactionInput =
    { index : Protobuf.Types.Int64.Int64, parentTransaction : Bytes.Bytes, value : Protobuf.Types.Int64.Int64 }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Contract`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Contract :
    { offerPayload : Int
    , tradeAmount : Int
    , tradePrice : Int
    , arbitratorNodeAddress : Int
    , isBuyerMakerAndSellerTaker : Int
    , makerAccountId : Int
    , takerAccountId : Int
    , makerPaymentMethodId : Int
    , takerPaymentMethodId : Int
    , makerPaymentAccountPayloadHash : Int
    , takerPaymentAccountPayloadHash : Int
    , makerPubKeyRing : Int
    , takerPubKeyRing : Int
    , buyerNodeAddress : Int
    , sellerNodeAddress : Int
    , makerPayoutAddressString : Int
    , takerPayoutAddressString : Int
    , makerDepositTxHash : Int
    , takerDepositTxHash : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__Contract =
    { offerPayload = 1
    , tradeAmount = 2
    , tradePrice = 3
    , arbitratorNodeAddress = 4
    , isBuyerMakerAndSellerTaker = 5
    , makerAccountId = 6
    , takerAccountId = 7
    , makerPaymentMethodId = 8
    , takerPaymentMethodId = 9
    , makerPaymentAccountPayloadHash = 10
    , takerPaymentAccountPayloadHash = 11
    , makerPubKeyRing = 12
    , takerPubKeyRing = 13
    , buyerNodeAddress = 14
    , sellerNodeAddress = 15
    , makerPayoutAddressString = 16
    , takerPayoutAddressString = 17
    , makerDepositTxHash = 18
    , takerDepositTxHash = 19
    }


{-| Default for Proto__Io__Haveno__Protobuffer__Contract. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__Contract : Proto__Io__Haveno__Protobuffer__Contract
defaultProto__Io__Haveno__Protobuffer__Contract =
    { offerPayload = Nothing
    , tradeAmount = Protobuf.Types.Int64.fromInts 0 0
    , tradePrice = Protobuf.Types.Int64.fromInts 0 0
    , arbitratorNodeAddress = Nothing
    , isBuyerMakerAndSellerTaker = False
    , makerAccountId = ""
    , takerAccountId = ""
    , makerPaymentMethodId = ""
    , takerPaymentMethodId = ""
    , makerPaymentAccountPayloadHash = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , takerPaymentAccountPayloadHash = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , makerPubKeyRing = Nothing
    , takerPubKeyRing = Nothing
    , buyerNodeAddress = Nothing
    , sellerNodeAddress = Nothing
    , makerPayoutAddressString = ""
    , takerPayoutAddressString = ""
    , makerDepositTxHash = ""
    , takerDepositTxHash = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Contract` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Contract : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__Contract
decodeProto__Io__Haveno__Protobuffer__Contract =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__Contract
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__OfferPayload)
            (\a r -> { r | offerPayload = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int64 (\a r -> { r | tradeAmount = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | tradePrice = a })
        , Protobuf.Decode.optional
            4
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | arbitratorNodeAddress = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.bool (\a r -> { r | isBuyerMakerAndSellerTaker = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | makerAccountId = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | takerAccountId = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.string (\a r -> { r | makerPaymentMethodId = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.string (\a r -> { r | takerPaymentMethodId = a })
        , Protobuf.Decode.optional 10 Protobuf.Decode.bytes (\a r -> { r | makerPaymentAccountPayloadHash = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.bytes (\a r -> { r | takerPaymentAccountPayloadHash = a })
        , Protobuf.Decode.optional
            12
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PubKeyRing)
            (\a r -> { r | makerPubKeyRing = a })
        , Protobuf.Decode.optional
            13
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PubKeyRing)
            (\a r -> { r | takerPubKeyRing = a })
        , Protobuf.Decode.optional
            14
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | buyerNodeAddress = a })
        , Protobuf.Decode.optional
            15
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | sellerNodeAddress = a })
        , Protobuf.Decode.optional 16 Protobuf.Decode.string (\a r -> { r | makerPayoutAddressString = a })
        , Protobuf.Decode.optional 17 Protobuf.Decode.string (\a r -> { r | takerPayoutAddressString = a })
        , Protobuf.Decode.optional 18 Protobuf.Decode.string (\a r -> { r | makerDepositTxHash = a })
        , Protobuf.Decode.optional 19 Protobuf.Decode.string (\a r -> { r | takerDepositTxHash = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Contract` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Contract : Proto__Io__Haveno__Protobuffer__Contract -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__Contract value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__OfferPayload >> Maybe.withDefault Protobuf.Encode.none)
                value.offerPayload
          )
        , ( 2, Protobuf.Encode.int64 value.tradeAmount )
        , ( 3, Protobuf.Encode.int64 value.tradePrice )
        , ( 4
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.arbitratorNodeAddress
          )
        , ( 5, Protobuf.Encode.bool value.isBuyerMakerAndSellerTaker )
        , ( 6, Protobuf.Encode.string value.makerAccountId )
        , ( 7, Protobuf.Encode.string value.takerAccountId )
        , ( 8, Protobuf.Encode.string value.makerPaymentMethodId )
        , ( 9, Protobuf.Encode.string value.takerPaymentMethodId )
        , ( 10, Protobuf.Encode.bytes value.makerPaymentAccountPayloadHash )
        , ( 11, Protobuf.Encode.bytes value.takerPaymentAccountPayloadHash )
        , ( 12
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PubKeyRing >> Maybe.withDefault Protobuf.Encode.none)
                value.makerPubKeyRing
          )
        , ( 13
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PubKeyRing >> Maybe.withDefault Protobuf.Encode.none)
                value.takerPubKeyRing
          )
        , ( 14
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.buyerNodeAddress
          )
        , ( 15
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.sellerNodeAddress
          )
        , ( 16, Protobuf.Encode.string value.makerPayoutAddressString )
        , ( 17, Protobuf.Encode.string value.takerPayoutAddressString )
        , ( 18, Protobuf.Encode.string value.makerDepositTxHash )
        , ( 19, Protobuf.Encode.string value.takerDepositTxHash )
        ]


{-| `Proto__Io__Haveno__Protobuffer__Contract` message

-}
type alias Proto__Io__Haveno__Protobuffer__Contract =
    { offerPayload : Maybe Proto__Io__Haveno__Protobuffer__OfferPayload
    , tradeAmount : Protobuf.Types.Int64.Int64
    , tradePrice : Protobuf.Types.Int64.Int64
    , arbitratorNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , isBuyerMakerAndSellerTaker : Bool
    , makerAccountId : String
    , takerAccountId : String
    , makerPaymentMethodId : String
    , takerPaymentMethodId : String
    , makerPaymentAccountPayloadHash : Bytes.Bytes
    , takerPaymentAccountPayloadHash : Bytes.Bytes
    , makerPubKeyRing : Maybe Proto__Io__Haveno__Protobuffer__PubKeyRing
    , takerPubKeyRing : Maybe Proto__Io__Haveno__Protobuffer__PubKeyRing
    , buyerNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , sellerNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , makerPayoutAddressString : String
    , takerPayoutAddressString : String
    , makerDepositTxHash : String
    , takerDepositTxHash : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__DisputeResult`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__DisputeResult :
    { tradeId : Int
    , traderId : Int
    , winner : Int
    , reasonOrdinal : Int
    , tamperProofEvidence : Int
    , idVerification : Int
    , screenCast : Int
    , summaryNotes : Int
    , chatMessage : Int
    , arbitratorSignature : Int
    , buyerPayoutAmountBeforeCost : Int
    , sellerPayoutAmountBeforeCost : Int
    , subtractFeeFrom : Int
    , arbitratorPubKey : Int
    , closeDate : Int
    , isLoserPublisher : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__DisputeResult =
    { tradeId = 1
    , traderId = 2
    , winner = 3
    , reasonOrdinal = 4
    , tamperProofEvidence = 5
    , idVerification = 6
    , screenCast = 7
    , summaryNotes = 8
    , chatMessage = 9
    , arbitratorSignature = 10
    , buyerPayoutAmountBeforeCost = 11
    , sellerPayoutAmountBeforeCost = 12
    , subtractFeeFrom = 13
    , arbitratorPubKey = 14
    , closeDate = 15
    , isLoserPublisher = 16
    }


{-| Default for Proto__Io__Haveno__Protobuffer__DisputeResult. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__DisputeResult : Proto__Io__Haveno__Protobuffer__DisputeResult
defaultProto__Io__Haveno__Protobuffer__DisputeResult =
    { tradeId = ""
    , traderId = 0
    , winner = Proto.Io.Haveno.Protobuffer.DisputeResult.Winner.defaultWinner
    , reasonOrdinal = 0
    , tamperProofEvidence = False
    , idVerification = False
    , screenCast = False
    , summaryNotes = ""
    , chatMessage = Nothing
    , arbitratorSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , buyerPayoutAmountBeforeCost = Protobuf.Types.Int64.fromInts 0 0
    , sellerPayoutAmountBeforeCost = Protobuf.Types.Int64.fromInts 0 0
    , subtractFeeFrom = Proto.Io.Haveno.Protobuffer.DisputeResult.SubtractFeeFrom.defaultSubtractFeeFrom
    , arbitratorPubKey = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , closeDate = Protobuf.Types.Int64.fromInts 0 0
    , isLoserPublisher = False
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__DisputeResult` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__DisputeResult :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__DisputeResult
decodeProto__Io__Haveno__Protobuffer__DisputeResult =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__DisputeResult
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int32 (\a r -> { r | traderId = a })
        , Protobuf.Decode.optional
            3
            Proto.Io.Haveno.Protobuffer.DisputeResult.Winner.decodeWinner
            (\a r -> { r | winner = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.int32 (\a r -> { r | reasonOrdinal = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.bool (\a r -> { r | tamperProofEvidence = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.bool (\a r -> { r | idVerification = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.bool (\a r -> { r | screenCast = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.string (\a r -> { r | summaryNotes = a })
        , Protobuf.Decode.optional
            9
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__ChatMessage)
            (\a r -> { r | chatMessage = a })
        , Protobuf.Decode.optional 10 Protobuf.Decode.bytes (\a r -> { r | arbitratorSignature = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.int64 (\a r -> { r | buyerPayoutAmountBeforeCost = a })
        , Protobuf.Decode.optional 12 Protobuf.Decode.int64 (\a r -> { r | sellerPayoutAmountBeforeCost = a })
        , Protobuf.Decode.optional
            13
            Proto.Io.Haveno.Protobuffer.DisputeResult.SubtractFeeFrom.decodeSubtractFeeFrom
            (\a r -> { r | subtractFeeFrom = a })
        , Protobuf.Decode.optional 14 Protobuf.Decode.bytes (\a r -> { r | arbitratorPubKey = a })
        , Protobuf.Decode.optional 15 Protobuf.Decode.int64 (\a r -> { r | closeDate = a })
        , Protobuf.Decode.optional 16 Protobuf.Decode.bool (\a r -> { r | isLoserPublisher = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__DisputeResult` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__DisputeResult :
    Proto__Io__Haveno__Protobuffer__DisputeResult -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__DisputeResult value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.tradeId )
        , ( 2, Protobuf.Encode.int32 value.traderId )
        , ( 3, Proto.Io.Haveno.Protobuffer.DisputeResult.Winner.encodeWinner value.winner )
        , ( 4, Protobuf.Encode.int32 value.reasonOrdinal )
        , ( 5, Protobuf.Encode.bool value.tamperProofEvidence )
        , ( 6, Protobuf.Encode.bool value.idVerification )
        , ( 7, Protobuf.Encode.bool value.screenCast )
        , ( 8, Protobuf.Encode.string value.summaryNotes )
        , ( 9
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__ChatMessage >> Maybe.withDefault Protobuf.Encode.none)
                value.chatMessage
          )
        , ( 10, Protobuf.Encode.bytes value.arbitratorSignature )
        , ( 11, Protobuf.Encode.int64 value.buyerPayoutAmountBeforeCost )
        , ( 12, Protobuf.Encode.int64 value.sellerPayoutAmountBeforeCost )
        , ( 13, Proto.Io.Haveno.Protobuffer.DisputeResult.SubtractFeeFrom.encodeSubtractFeeFrom value.subtractFeeFrom )
        , ( 14, Protobuf.Encode.bytes value.arbitratorPubKey )
        , ( 15, Protobuf.Encode.int64 value.closeDate )
        , ( 16, Protobuf.Encode.bool value.isLoserPublisher )
        ]


{-| `Proto__Io__Haveno__Protobuffer__DisputeResult` message

-}
type alias Proto__Io__Haveno__Protobuffer__DisputeResult =
    { tradeId : String
    , traderId : Int
    , winner : Proto.Io.Haveno.Protobuffer.DisputeResult.Winner.Winner
    , reasonOrdinal : Int
    , tamperProofEvidence : Bool
    , idVerification : Bool
    , screenCast : Bool
    , summaryNotes : String
    , chatMessage : Maybe Proto__Io__Haveno__Protobuffer__ChatMessage
    , arbitratorSignature : Bytes.Bytes
    , buyerPayoutAmountBeforeCost : Protobuf.Types.Int64.Int64
    , sellerPayoutAmountBeforeCost : Protobuf.Types.Int64.Int64
    , subtractFeeFrom : Proto.Io.Haveno.Protobuffer.DisputeResult.SubtractFeeFrom.SubtractFeeFrom
    , arbitratorPubKey : Bytes.Bytes
    , closeDate : Protobuf.Types.Int64.Int64
    , isLoserPublisher : Bool
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Attachment`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Attachment : { fileName : Int, bytes : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__Attachment =
    { fileName = 1, bytes = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__Attachment. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__Attachment : Proto__Io__Haveno__Protobuffer__Attachment
defaultProto__Io__Haveno__Protobuffer__Attachment =
    { fileName = "", bytes = Protobuf.Encode.encode <| Protobuf.Encode.string "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Attachment` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Attachment : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__Attachment
decodeProto__Io__Haveno__Protobuffer__Attachment =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__Attachment
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | fileName = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.bytes (\a r -> { r | bytes = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Attachment` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Attachment : Proto__Io__Haveno__Protobuffer__Attachment -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__Attachment value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.fileName ), ( 2, Protobuf.Encode.bytes value.bytes ) ]


{-| `Proto__Io__Haveno__Protobuffer__Attachment` message

-}
type alias Proto__Io__Haveno__Protobuffer__Attachment =
    { fileName : String, bytes : Bytes.Bytes }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Dispute`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Dispute :
    { tradeId : Int
    , id : Int
    , traderId : Int
    , isOpener : Int
    , disputeOpenerIsBuyer : Int
    , disputeOpenerIsMaker : Int
    , openingDate : Int
    , traderPubKeyRing : Int
    , tradeDate : Int
    , contract : Int
    , contractHash : Int
    , payoutTxSerialized : Int
    , payoutTxId : Int
    , contractAsJson : Int
    , makerContractSignature : Int
    , takerContractSignature : Int
    , makerPaymentAccountPayload : Int
    , takerPaymentAccountPayload : Int
    , agentPubKeyRing : Int
    , isSupportTicket : Int
    , chatMessage : Int
    , isClosed : Int
    , disputeResult : Int
    , disputePayoutTxId : Int
    , supportType : Int
    , mediatorsDisputeResult : Int
    , delayedPayoutTxId : Int
    , donationAddressOfDelayedPayoutTx : Int
    , state : Int
    , tradePeriodEnd : Int
    , extraData : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__Dispute =
    { tradeId = 1
    , id = 2
    , traderId = 3
    , isOpener = 4
    , disputeOpenerIsBuyer = 5
    , disputeOpenerIsMaker = 6
    , openingDate = 7
    , traderPubKeyRing = 8
    , tradeDate = 9
    , contract = 10
    , contractHash = 11
    , payoutTxSerialized = 12
    , payoutTxId = 13
    , contractAsJson = 14
    , makerContractSignature = 15
    , takerContractSignature = 16
    , makerPaymentAccountPayload = 17
    , takerPaymentAccountPayload = 18
    , agentPubKeyRing = 19
    , isSupportTicket = 20
    , chatMessage = 21
    , isClosed = 22
    , disputeResult = 23
    , disputePayoutTxId = 24
    , supportType = 25
    , mediatorsDisputeResult = 26
    , delayedPayoutTxId = 27
    , donationAddressOfDelayedPayoutTx = 28
    , state = 29
    , tradePeriodEnd = 30
    , extraData = 31
    }


{-| Default for Proto__Io__Haveno__Protobuffer__Dispute. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__Dispute : Proto__Io__Haveno__Protobuffer__Dispute
defaultProto__Io__Haveno__Protobuffer__Dispute =
    { tradeId = ""
    , id = ""
    , traderId = 0
    , isOpener = False
    , disputeOpenerIsBuyer = False
    , disputeOpenerIsMaker = False
    , openingDate = Protobuf.Types.Int64.fromInts 0 0
    , traderPubKeyRing = Nothing
    , tradeDate = Protobuf.Types.Int64.fromInts 0 0
    , contract = Nothing
    , contractHash = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , payoutTxSerialized = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , payoutTxId = ""
    , contractAsJson = ""
    , makerContractSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , takerContractSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , makerPaymentAccountPayload = Nothing
    , takerPaymentAccountPayload = Nothing
    , agentPubKeyRing = Nothing
    , isSupportTicket = False
    , chatMessage = []
    , isClosed = False
    , disputeResult = Nothing
    , disputePayoutTxId = ""
    , supportType = Proto.Io.Haveno.Protobuffer.SupportType.defaultSupportType
    , mediatorsDisputeResult = ""
    , delayedPayoutTxId = ""
    , donationAddressOfDelayedPayoutTx = ""
    , state = Proto.Io.Haveno.Protobuffer.Dispute.State.defaultState
    , tradePeriodEnd = Protobuf.Types.Int64.fromInts 0 0
    , extraData = Dict.empty
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Dispute` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Dispute : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__Dispute
decodeProto__Io__Haveno__Protobuffer__Dispute =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__Dispute
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | id = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int32 (\a r -> { r | traderId = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.bool (\a r -> { r | isOpener = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.bool (\a r -> { r | disputeOpenerIsBuyer = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.bool (\a r -> { r | disputeOpenerIsMaker = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.int64 (\a r -> { r | openingDate = a })
        , Protobuf.Decode.optional
            8
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PubKeyRing)
            (\a r -> { r | traderPubKeyRing = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.int64 (\a r -> { r | tradeDate = a })
        , Protobuf.Decode.optional
            10
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Contract)
            (\a r -> { r | contract = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.bytes (\a r -> { r | contractHash = a })
        , Protobuf.Decode.optional 12 Protobuf.Decode.bytes (\a r -> { r | payoutTxSerialized = a })
        , Protobuf.Decode.optional 13 Protobuf.Decode.string (\a r -> { r | payoutTxId = a })
        , Protobuf.Decode.optional 14 Protobuf.Decode.string (\a r -> { r | contractAsJson = a })
        , Protobuf.Decode.optional 15 Protobuf.Decode.bytes (\a r -> { r | makerContractSignature = a })
        , Protobuf.Decode.optional 16 Protobuf.Decode.bytes (\a r -> { r | takerContractSignature = a })
        , Protobuf.Decode.optional
            17
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload)
            (\a r -> { r | makerPaymentAccountPayload = a })
        , Protobuf.Decode.optional
            18
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload)
            (\a r -> { r | takerPaymentAccountPayload = a })
        , Protobuf.Decode.optional
            19
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PubKeyRing)
            (\a r -> { r | agentPubKeyRing = a })
        , Protobuf.Decode.optional 20 Protobuf.Decode.bool (\a r -> { r | isSupportTicket = a })
        , Protobuf.Decode.repeated
            21
            decodeProto__Io__Haveno__Protobuffer__ChatMessage
            .chatMessage
            (\a r -> { r | chatMessage = a })
        , Protobuf.Decode.optional 22 Protobuf.Decode.bool (\a r -> { r | isClosed = a })
        , Protobuf.Decode.optional
            23
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__DisputeResult)
            (\a r -> { r | disputeResult = a })
        , Protobuf.Decode.optional 24 Protobuf.Decode.string (\a r -> { r | disputePayoutTxId = a })
        , Protobuf.Decode.optional
            25
            Proto.Io.Haveno.Protobuffer.SupportType.decodeSupportType
            (\a r -> { r | supportType = a })
        , Protobuf.Decode.optional 26 Protobuf.Decode.string (\a r -> { r | mediatorsDisputeResult = a })
        , Protobuf.Decode.optional 27 Protobuf.Decode.string (\a r -> { r | delayedPayoutTxId = a })
        , Protobuf.Decode.optional 28 Protobuf.Decode.string (\a r -> { r | donationAddressOfDelayedPayoutTx = a })
        , Protobuf.Decode.optional 29 Proto.Io.Haveno.Protobuffer.Dispute.State.decodeState (\a r -> { r | state = a })
        , Protobuf.Decode.optional 30 Protobuf.Decode.int64 (\a r -> { r | tradePeriodEnd = a })
        , Protobuf.Decode.mapped
            31
            ( "", "" )
            Protobuf.Decode.string
            Protobuf.Decode.string
            .extraData
            (\a r -> { r | extraData = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Dispute` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Dispute : Proto__Io__Haveno__Protobuffer__Dispute -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__Dispute value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.tradeId )
        , ( 2, Protobuf.Encode.string value.id )
        , ( 3, Protobuf.Encode.int32 value.traderId )
        , ( 4, Protobuf.Encode.bool value.isOpener )
        , ( 5, Protobuf.Encode.bool value.disputeOpenerIsBuyer )
        , ( 6, Protobuf.Encode.bool value.disputeOpenerIsMaker )
        , ( 7, Protobuf.Encode.int64 value.openingDate )
        , ( 8
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PubKeyRing >> Maybe.withDefault Protobuf.Encode.none)
                value.traderPubKeyRing
          )
        , ( 9, Protobuf.Encode.int64 value.tradeDate )
        , ( 10
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Contract >> Maybe.withDefault Protobuf.Encode.none)
                value.contract
          )
        , ( 11, Protobuf.Encode.bytes value.contractHash )
        , ( 12, Protobuf.Encode.bytes value.payoutTxSerialized )
        , ( 13, Protobuf.Encode.string value.payoutTxId )
        , ( 14, Protobuf.Encode.string value.contractAsJson )
        , ( 15, Protobuf.Encode.bytes value.makerContractSignature )
        , ( 16, Protobuf.Encode.bytes value.takerContractSignature )
        , ( 17
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.makerPaymentAccountPayload
          )
        , ( 18
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentAccountPayload
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.takerPaymentAccountPayload
          )
        , ( 19
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PubKeyRing >> Maybe.withDefault Protobuf.Encode.none)
                value.agentPubKeyRing
          )
        , ( 20, Protobuf.Encode.bool value.isSupportTicket )
        , ( 21, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__ChatMessage) value.chatMessage )
        , ( 22, Protobuf.Encode.bool value.isClosed )
        , ( 23
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__DisputeResult >> Maybe.withDefault Protobuf.Encode.none)
                value.disputeResult
          )
        , ( 24, Protobuf.Encode.string value.disputePayoutTxId )
        , ( 25, Proto.Io.Haveno.Protobuffer.SupportType.encodeSupportType value.supportType )
        , ( 26, Protobuf.Encode.string value.mediatorsDisputeResult )
        , ( 27, Protobuf.Encode.string value.delayedPayoutTxId )
        , ( 28, Protobuf.Encode.string value.donationAddressOfDelayedPayoutTx )
        , ( 29, Proto.Io.Haveno.Protobuffer.Dispute.State.encodeState value.state )
        , ( 30, Protobuf.Encode.int64 value.tradePeriodEnd )
        , ( 31, Protobuf.Encode.dict Protobuf.Encode.string Protobuf.Encode.string value.extraData )
        ]


{-| `Proto__Io__Haveno__Protobuffer__Dispute` message

-}
type alias Proto__Io__Haveno__Protobuffer__Dispute =
    { tradeId : String
    , id : String
    , traderId : Int
    , isOpener : Bool
    , disputeOpenerIsBuyer : Bool
    , disputeOpenerIsMaker : Bool
    , openingDate : Protobuf.Types.Int64.Int64
    , traderPubKeyRing : Maybe Proto__Io__Haveno__Protobuffer__PubKeyRing
    , tradeDate : Protobuf.Types.Int64.Int64
    , contract : Maybe Proto__Io__Haveno__Protobuffer__Contract
    , contractHash : Bytes.Bytes
    , payoutTxSerialized : Bytes.Bytes
    , payoutTxId : String
    , contractAsJson : String
    , makerContractSignature : Bytes.Bytes
    , takerContractSignature : Bytes.Bytes
    , makerPaymentAccountPayload : Maybe Proto__Io__Haveno__Protobuffer__PaymentAccountPayload
    , takerPaymentAccountPayload : Maybe Proto__Io__Haveno__Protobuffer__PaymentAccountPayload
    , agentPubKeyRing : Maybe Proto__Io__Haveno__Protobuffer__PubKeyRing
    , isSupportTicket : Bool
    , chatMessage : List Proto__Io__Haveno__Protobuffer__ChatMessage
    , isClosed : Bool
    , disputeResult : Maybe Proto__Io__Haveno__Protobuffer__DisputeResult
    , disputePayoutTxId : String
    , supportType : Proto.Io.Haveno.Protobuffer.SupportType.SupportType
    , mediatorsDisputeResult : String
    , delayedPayoutTxId : String
    , donationAddressOfDelayedPayoutTx : String
    , state : Proto.Io.Haveno.Protobuffer.Dispute.State.State
    , tradePeriodEnd : Protobuf.Types.Int64.Int64
    , extraData : Dict.Dict String String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SignedWitness`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SignedWitness :
    { verificationMethod : Int
    , accountAgeWitnessHash : Int
    , signature : Int
    , signerPubKey : Int
    , witnessOwnerPubKey : Int
    , date : Int
    , tradeAmount : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__SignedWitness =
    { verificationMethod = 1
    , accountAgeWitnessHash = 2
    , signature = 3
    , signerPubKey = 4
    , witnessOwnerPubKey = 5
    , date = 6
    , tradeAmount = 7
    }


{-| Default for Proto__Io__Haveno__Protobuffer__SignedWitness. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SignedWitness : Proto__Io__Haveno__Protobuffer__SignedWitness
defaultProto__Io__Haveno__Protobuffer__SignedWitness =
    { verificationMethod = Proto.Io.Haveno.Protobuffer.SignedWitness.VerificationMethod.defaultVerificationMethod
    , accountAgeWitnessHash = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , signature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , signerPubKey = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , witnessOwnerPubKey = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , date = Protobuf.Types.Int64.fromInts 0 0
    , tradeAmount = Protobuf.Types.Int64.fromInts 0 0
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SignedWitness` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SignedWitness :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SignedWitness
decodeProto__Io__Haveno__Protobuffer__SignedWitness =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SignedWitness
        [ Protobuf.Decode.optional
            1
            Proto.Io.Haveno.Protobuffer.SignedWitness.VerificationMethod.decodeVerificationMethod
            (\a r -> { r | verificationMethod = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.bytes (\a r -> { r | accountAgeWitnessHash = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.bytes (\a r -> { r | signature = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.bytes (\a r -> { r | signerPubKey = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.bytes (\a r -> { r | witnessOwnerPubKey = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.int64 (\a r -> { r | date = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.int64 (\a r -> { r | tradeAmount = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SignedWitness` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SignedWitness :
    Proto__Io__Haveno__Protobuffer__SignedWitness -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SignedWitness value =
    Protobuf.Encode.message
        [ ( 1
          , Proto.Io.Haveno.Protobuffer.SignedWitness.VerificationMethod.encodeVerificationMethod
                value.verificationMethod
          )
        , ( 2, Protobuf.Encode.bytes value.accountAgeWitnessHash )
        , ( 3, Protobuf.Encode.bytes value.signature )
        , ( 4, Protobuf.Encode.bytes value.signerPubKey )
        , ( 5, Protobuf.Encode.bytes value.witnessOwnerPubKey )
        , ( 6, Protobuf.Encode.int64 value.date )
        , ( 7, Protobuf.Encode.int64 value.tradeAmount )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SignedWitness` message

-}
type alias Proto__Io__Haveno__Protobuffer__SignedWitness =
    { verificationMethod : Proto.Io.Haveno.Protobuffer.SignedWitness.VerificationMethod.VerificationMethod
    , accountAgeWitnessHash : Bytes.Bytes
    , signature : Bytes.Bytes
    , signerPubKey : Bytes.Bytes
    , witnessOwnerPubKey : Bytes.Bytes
    , date : Protobuf.Types.Int64.Int64
    , tradeAmount : Protobuf.Types.Int64.Int64
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AccountAgeWitness`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AccountAgeWitness : { hash : Int, date : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__AccountAgeWitness =
    { hash = 1, date = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__AccountAgeWitness. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AccountAgeWitness : Proto__Io__Haveno__Protobuffer__AccountAgeWitness
defaultProto__Io__Haveno__Protobuffer__AccountAgeWitness =
    { hash = Protobuf.Encode.encode <| Protobuf.Encode.string "", date = Protobuf.Types.Int64.fromInts 0 0 }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AccountAgeWitness` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AccountAgeWitness :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AccountAgeWitness
decodeProto__Io__Haveno__Protobuffer__AccountAgeWitness =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AccountAgeWitness
        [ Protobuf.Decode.optional 1 Protobuf.Decode.bytes (\a r -> { r | hash = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int64 (\a r -> { r | date = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AccountAgeWitness` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AccountAgeWitness :
    Proto__Io__Haveno__Protobuffer__AccountAgeWitness -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AccountAgeWitness value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.bytes value.hash ), ( 2, Protobuf.Encode.int64 value.date ) ]


{-| `Proto__Io__Haveno__Protobuffer__AccountAgeWitness` message

-}
type alias Proto__Io__Haveno__Protobuffer__AccountAgeWitness =
    { hash : Bytes.Bytes, date : Protobuf.Types.Int64.Int64 }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__OfferPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__OfferPayload :
    { id : Int
    , date : Int
    , ownerNodeAddress : Int
    , pubKeyRing : Int
    , direction : Int
    , price : Int
    , marketPriceMarginPct : Int
    , useMarketBasedPrice : Int
    , amount : Int
    , minAmount : Int
    , makerFeePct : Int
    , takerFeePct : Int
    , penaltyFeePct : Int
    , buyerSecurityDepositPct : Int
    , sellerSecurityDepositPct : Int
    , baseCurrencyCode : Int
    , counterCurrencyCode : Int
    , paymentMethodId : Int
    , makerPaymentAccountId : Int
    , countryCode : Int
    , acceptedCountryCodes : Int
    , bankId : Int
    , acceptedBankIds : Int
    , versionNr : Int
    , blockHeightAtOfferCreation : Int
    , maxTradeLimit : Int
    , maxTradePeriod : Int
    , useAutoClose : Int
    , useReOpenAfterAutoClose : Int
    , lowerClosePrice : Int
    , upperClosePrice : Int
    , isPrivateOffer : Int
    , hashOfChallenge : Int
    , extraData : Int
    , protocolVersion : Int
    , arbitratorSigner : Int
    , arbitratorSignature : Int
    , reserveTxKeyImages : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__OfferPayload =
    { id = 1
    , date = 2
    , ownerNodeAddress = 3
    , pubKeyRing = 4
    , direction = 5
    , price = 6
    , marketPriceMarginPct = 7
    , useMarketBasedPrice = 8
    , amount = 9
    , minAmount = 10
    , makerFeePct = 11
    , takerFeePct = 12
    , penaltyFeePct = 13
    , buyerSecurityDepositPct = 14
    , sellerSecurityDepositPct = 15
    , baseCurrencyCode = 16
    , counterCurrencyCode = 17
    , paymentMethodId = 18
    , makerPaymentAccountId = 19
    , countryCode = 20
    , acceptedCountryCodes = 21
    , bankId = 22
    , acceptedBankIds = 23
    , versionNr = 24
    , blockHeightAtOfferCreation = 25
    , maxTradeLimit = 26
    , maxTradePeriod = 27
    , useAutoClose = 28
    , useReOpenAfterAutoClose = 29
    , lowerClosePrice = 30
    , upperClosePrice = 31
    , isPrivateOffer = 32
    , hashOfChallenge = 33
    , extraData = 34
    , protocolVersion = 35
    , arbitratorSigner = 36
    , arbitratorSignature = 37
    , reserveTxKeyImages = 38
    }


{-| Default for Proto__Io__Haveno__Protobuffer__OfferPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__OfferPayload : Proto__Io__Haveno__Protobuffer__OfferPayload
defaultProto__Io__Haveno__Protobuffer__OfferPayload =
    { id = ""
    , date = Protobuf.Types.Int64.fromInts 0 0
    , ownerNodeAddress = Nothing
    , pubKeyRing = Nothing
    , direction = Proto.Io.Haveno.Protobuffer.OfferDirection.defaultOfferDirection
    , price = Protobuf.Types.Int64.fromInts 0 0
    , marketPriceMarginPct = 0
    , useMarketBasedPrice = False
    , amount = Protobuf.Types.Int64.fromInts 0 0
    , minAmount = Protobuf.Types.Int64.fromInts 0 0
    , makerFeePct = 0
    , takerFeePct = 0
    , penaltyFeePct = 0
    , buyerSecurityDepositPct = 0
    , sellerSecurityDepositPct = 0
    , baseCurrencyCode = ""
    , counterCurrencyCode = ""
    , paymentMethodId = ""
    , makerPaymentAccountId = ""
    , countryCode = ""
    , acceptedCountryCodes = []
    , bankId = ""
    , acceptedBankIds = []
    , versionNr = ""
    , blockHeightAtOfferCreation = Protobuf.Types.Int64.fromInts 0 0
    , maxTradeLimit = Protobuf.Types.Int64.fromInts 0 0
    , maxTradePeriod = Protobuf.Types.Int64.fromInts 0 0
    , useAutoClose = False
    , useReOpenAfterAutoClose = False
    , lowerClosePrice = Protobuf.Types.Int64.fromInts 0 0
    , upperClosePrice = Protobuf.Types.Int64.fromInts 0 0
    , isPrivateOffer = False
    , hashOfChallenge = ""
    , extraData = Dict.empty
    , protocolVersion = 0
    , arbitratorSigner = Nothing
    , arbitratorSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , reserveTxKeyImages = []
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__OfferPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__OfferPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__OfferPayload
decodeProto__Io__Haveno__Protobuffer__OfferPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__OfferPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | id = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int64 (\a r -> { r | date = a })
        , Protobuf.Decode.optional
            3
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | ownerNodeAddress = a })
        , Protobuf.Decode.optional
            4
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PubKeyRing)
            (\a r -> { r | pubKeyRing = a })
        , Protobuf.Decode.optional
            5
            Proto.Io.Haveno.Protobuffer.OfferDirection.decodeOfferDirection
            (\a r -> { r | direction = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.int64 (\a r -> { r | price = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.double (\a r -> { r | marketPriceMarginPct = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.bool (\a r -> { r | useMarketBasedPrice = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.int64 (\a r -> { r | amount = a })
        , Protobuf.Decode.optional 10 Protobuf.Decode.int64 (\a r -> { r | minAmount = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.double (\a r -> { r | makerFeePct = a })
        , Protobuf.Decode.optional 12 Protobuf.Decode.double (\a r -> { r | takerFeePct = a })
        , Protobuf.Decode.optional 13 Protobuf.Decode.double (\a r -> { r | penaltyFeePct = a })
        , Protobuf.Decode.optional 14 Protobuf.Decode.double (\a r -> { r | buyerSecurityDepositPct = a })
        , Protobuf.Decode.optional 15 Protobuf.Decode.double (\a r -> { r | sellerSecurityDepositPct = a })
        , Protobuf.Decode.optional 16 Protobuf.Decode.string (\a r -> { r | baseCurrencyCode = a })
        , Protobuf.Decode.optional 17 Protobuf.Decode.string (\a r -> { r | counterCurrencyCode = a })
        , Protobuf.Decode.optional 18 Protobuf.Decode.string (\a r -> { r | paymentMethodId = a })
        , Protobuf.Decode.optional 19 Protobuf.Decode.string (\a r -> { r | makerPaymentAccountId = a })
        , Protobuf.Decode.optional 20 Protobuf.Decode.string (\a r -> { r | countryCode = a })
        , Protobuf.Decode.repeated
            21
            Protobuf.Decode.string
            .acceptedCountryCodes
            (\a r -> { r | acceptedCountryCodes = a })
        , Protobuf.Decode.optional 22 Protobuf.Decode.string (\a r -> { r | bankId = a })
        , Protobuf.Decode.repeated 23 Protobuf.Decode.string .acceptedBankIds (\a r -> { r | acceptedBankIds = a })
        , Protobuf.Decode.optional 24 Protobuf.Decode.string (\a r -> { r | versionNr = a })
        , Protobuf.Decode.optional 25 Protobuf.Decode.int64 (\a r -> { r | blockHeightAtOfferCreation = a })
        , Protobuf.Decode.optional 26 Protobuf.Decode.int64 (\a r -> { r | maxTradeLimit = a })
        , Protobuf.Decode.optional 27 Protobuf.Decode.int64 (\a r -> { r | maxTradePeriod = a })
        , Protobuf.Decode.optional 28 Protobuf.Decode.bool (\a r -> { r | useAutoClose = a })
        , Protobuf.Decode.optional 29 Protobuf.Decode.bool (\a r -> { r | useReOpenAfterAutoClose = a })
        , Protobuf.Decode.optional 30 Protobuf.Decode.int64 (\a r -> { r | lowerClosePrice = a })
        , Protobuf.Decode.optional 31 Protobuf.Decode.int64 (\a r -> { r | upperClosePrice = a })
        , Protobuf.Decode.optional 32 Protobuf.Decode.bool (\a r -> { r | isPrivateOffer = a })
        , Protobuf.Decode.optional 33 Protobuf.Decode.string (\a r -> { r | hashOfChallenge = a })
        , Protobuf.Decode.mapped
            34
            ( "", "" )
            Protobuf.Decode.string
            Protobuf.Decode.string
            .extraData
            (\a r -> { r | extraData = a })
        , Protobuf.Decode.optional 35 Protobuf.Decode.int32 (\a r -> { r | protocolVersion = a })
        , Protobuf.Decode.optional
            36
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | arbitratorSigner = a })
        , Protobuf.Decode.optional 37 Protobuf.Decode.bytes (\a r -> { r | arbitratorSignature = a })
        , Protobuf.Decode.repeated
            38
            Protobuf.Decode.string
            .reserveTxKeyImages
            (\a r -> { r | reserveTxKeyImages = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__OfferPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__OfferPayload :
    Proto__Io__Haveno__Protobuffer__OfferPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__OfferPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.id )
        , ( 2, Protobuf.Encode.int64 value.date )
        , ( 3
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.ownerNodeAddress
          )
        , ( 4
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PubKeyRing >> Maybe.withDefault Protobuf.Encode.none)
                value.pubKeyRing
          )
        , ( 5, Proto.Io.Haveno.Protobuffer.OfferDirection.encodeOfferDirection value.direction )
        , ( 6, Protobuf.Encode.int64 value.price )
        , ( 7, Protobuf.Encode.double value.marketPriceMarginPct )
        , ( 8, Protobuf.Encode.bool value.useMarketBasedPrice )
        , ( 9, Protobuf.Encode.int64 value.amount )
        , ( 10, Protobuf.Encode.int64 value.minAmount )
        , ( 11, Protobuf.Encode.double value.makerFeePct )
        , ( 12, Protobuf.Encode.double value.takerFeePct )
        , ( 13, Protobuf.Encode.double value.penaltyFeePct )
        , ( 14, Protobuf.Encode.double value.buyerSecurityDepositPct )
        , ( 15, Protobuf.Encode.double value.sellerSecurityDepositPct )
        , ( 16, Protobuf.Encode.string value.baseCurrencyCode )
        , ( 17, Protobuf.Encode.string value.counterCurrencyCode )
        , ( 18, Protobuf.Encode.string value.paymentMethodId )
        , ( 19, Protobuf.Encode.string value.makerPaymentAccountId )
        , ( 20, Protobuf.Encode.string value.countryCode )
        , ( 21, (Protobuf.Encode.list Protobuf.Encode.string) value.acceptedCountryCodes )
        , ( 22, Protobuf.Encode.string value.bankId )
        , ( 23, (Protobuf.Encode.list Protobuf.Encode.string) value.acceptedBankIds )
        , ( 24, Protobuf.Encode.string value.versionNr )
        , ( 25, Protobuf.Encode.int64 value.blockHeightAtOfferCreation )
        , ( 26, Protobuf.Encode.int64 value.maxTradeLimit )
        , ( 27, Protobuf.Encode.int64 value.maxTradePeriod )
        , ( 28, Protobuf.Encode.bool value.useAutoClose )
        , ( 29, Protobuf.Encode.bool value.useReOpenAfterAutoClose )
        , ( 30, Protobuf.Encode.int64 value.lowerClosePrice )
        , ( 31, Protobuf.Encode.int64 value.upperClosePrice )
        , ( 32, Protobuf.Encode.bool value.isPrivateOffer )
        , ( 33, Protobuf.Encode.string value.hashOfChallenge )
        , ( 34, Protobuf.Encode.dict Protobuf.Encode.string Protobuf.Encode.string value.extraData )
        , ( 35, Protobuf.Encode.int32 value.protocolVersion )
        , ( 36
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.arbitratorSigner
          )
        , ( 37, Protobuf.Encode.bytes value.arbitratorSignature )
        , ( 38, (Protobuf.Encode.list Protobuf.Encode.string) value.reserveTxKeyImages )
        ]


{-| `Proto__Io__Haveno__Protobuffer__OfferPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__OfferPayload =
    { id : String
    , date : Protobuf.Types.Int64.Int64
    , ownerNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , pubKeyRing : Maybe Proto__Io__Haveno__Protobuffer__PubKeyRing
    , direction : Proto.Io.Haveno.Protobuffer.OfferDirection.OfferDirection
    , price : Protobuf.Types.Int64.Int64
    , marketPriceMarginPct : Float
    , useMarketBasedPrice : Bool
    , amount : Protobuf.Types.Int64.Int64
    , minAmount : Protobuf.Types.Int64.Int64
    , makerFeePct : Float
    , takerFeePct : Float
    , penaltyFeePct : Float
    , buyerSecurityDepositPct : Float
    , sellerSecurityDepositPct : Float
    , baseCurrencyCode : String
    , counterCurrencyCode : String
    , paymentMethodId : String
    , makerPaymentAccountId : String
    , countryCode : String
    , acceptedCountryCodes : List String
    , bankId : String
    , acceptedBankIds : List String
    , versionNr : String
    , blockHeightAtOfferCreation : Protobuf.Types.Int64.Int64
    , maxTradeLimit : Protobuf.Types.Int64.Int64
    , maxTradePeriod : Protobuf.Types.Int64.Int64
    , useAutoClose : Bool
    , useReOpenAfterAutoClose : Bool
    , lowerClosePrice : Protobuf.Types.Int64.Int64
    , upperClosePrice : Protobuf.Types.Int64.Int64
    , isPrivateOffer : Bool
    , hashOfChallenge : String
    , extraData : Dict.Dict String String
    , protocolVersion : Int
    , arbitratorSigner : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , arbitratorSignature : Bytes.Bytes
    , reserveTxKeyImages : List String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MailboxStoragePayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MailboxStoragePayload :
    { prefixedSealedAndSignedMessage : Int
    , senderPubKeyForAddOperationBytes : Int
    , ownerPubKeyBytes : Int
    , extraData : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__MailboxStoragePayload =
    { prefixedSealedAndSignedMessage = 1, senderPubKeyForAddOperationBytes = 2, ownerPubKeyBytes = 3, extraData = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__MailboxStoragePayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MailboxStoragePayload : Proto__Io__Haveno__Protobuffer__MailboxStoragePayload
defaultProto__Io__Haveno__Protobuffer__MailboxStoragePayload =
    { prefixedSealedAndSignedMessage = Nothing
    , senderPubKeyForAddOperationBytes = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , ownerPubKeyBytes = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , extraData = Dict.empty
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MailboxStoragePayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MailboxStoragePayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MailboxStoragePayload
decodeProto__Io__Haveno__Protobuffer__MailboxStoragePayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MailboxStoragePayload
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage)
            (\a r -> { r | prefixedSealedAndSignedMessage = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.bytes (\a r -> { r | senderPubKeyForAddOperationBytes = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.bytes (\a r -> { r | ownerPubKeyBytes = a })
        , Protobuf.Decode.mapped
            4
            ( "", "" )
            Protobuf.Decode.string
            Protobuf.Decode.string
            .extraData
            (\a r -> { r | extraData = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MailboxStoragePayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MailboxStoragePayload :
    Proto__Io__Haveno__Protobuffer__MailboxStoragePayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MailboxStoragePayload value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.prefixedSealedAndSignedMessage
          )
        , ( 2, Protobuf.Encode.bytes value.senderPubKeyForAddOperationBytes )
        , ( 3, Protobuf.Encode.bytes value.ownerPubKeyBytes )
        , ( 4, Protobuf.Encode.dict Protobuf.Encode.string Protobuf.Encode.string value.extraData )
        ]


{-| `Proto__Io__Haveno__Protobuffer__MailboxStoragePayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__MailboxStoragePayload =
    { prefixedSealedAndSignedMessage : Maybe Proto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage
    , senderPubKeyForAddOperationBytes : Bytes.Bytes
    , ownerPubKeyBytes : Bytes.Bytes
    , extraData : Dict.Dict String String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__TradeStatistics3`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__TradeStatistics3 :
    { currency : Int
    , price : Int
    , amount : Int
    , paymentMethod : Int
    , date : Int
    , arbitrator : Int
    , hash : Int
    , makerDepositTxId : Int
    , takerDepositTxId : Int
    , extraData : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__TradeStatistics3 =
    { currency = 1
    , price = 2
    , amount = 3
    , paymentMethod = 4
    , date = 5
    , arbitrator = 6
    , hash = 7
    , makerDepositTxId = 8
    , takerDepositTxId = 9
    , extraData = 10
    }


{-| Default for Proto__Io__Haveno__Protobuffer__TradeStatistics3. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__TradeStatistics3 : Proto__Io__Haveno__Protobuffer__TradeStatistics3
defaultProto__Io__Haveno__Protobuffer__TradeStatistics3 =
    { currency = ""
    , price = Protobuf.Types.Int64.fromInts 0 0
    , amount = Protobuf.Types.Int64.fromInts 0 0
    , paymentMethod = ""
    , date = Protobuf.Types.Int64.fromInts 0 0
    , arbitrator = ""
    , hash = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , makerDepositTxId = ""
    , takerDepositTxId = ""
    , extraData = Dict.empty
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__TradeStatistics3` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__TradeStatistics3 :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__TradeStatistics3
decodeProto__Io__Haveno__Protobuffer__TradeStatistics3 =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__TradeStatistics3
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | currency = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int64 (\a r -> { r | price = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | amount = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | paymentMethod = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.int64 (\a r -> { r | date = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | arbitrator = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.bytes (\a r -> { r | hash = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.string (\a r -> { r | makerDepositTxId = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.string (\a r -> { r | takerDepositTxId = a })
        , Protobuf.Decode.mapped
            10
            ( "", "" )
            Protobuf.Decode.string
            Protobuf.Decode.string
            .extraData
            (\a r -> { r | extraData = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__TradeStatistics3` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__TradeStatistics3 :
    Proto__Io__Haveno__Protobuffer__TradeStatistics3 -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__TradeStatistics3 value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.currency )
        , ( 2, Protobuf.Encode.int64 value.price )
        , ( 3, Protobuf.Encode.int64 value.amount )
        , ( 4, Protobuf.Encode.string value.paymentMethod )
        , ( 5, Protobuf.Encode.int64 value.date )
        , ( 6, Protobuf.Encode.string value.arbitrator )
        , ( 7, Protobuf.Encode.bytes value.hash )
        , ( 8, Protobuf.Encode.string value.makerDepositTxId )
        , ( 9, Protobuf.Encode.string value.takerDepositTxId )
        , ( 10, Protobuf.Encode.dict Protobuf.Encode.string Protobuf.Encode.string value.extraData )
        ]


{-| `Proto__Io__Haveno__Protobuffer__TradeStatistics3` message

-}
type alias Proto__Io__Haveno__Protobuffer__TradeStatistics3 =
    { currency : String
    , price : Protobuf.Types.Int64.Int64
    , amount : Protobuf.Types.Int64.Int64
    , paymentMethod : String
    , date : Protobuf.Types.Int64.Int64
    , arbitrator : String
    , hash : Bytes.Bytes
    , makerDepositTxId : String
    , takerDepositTxId : String
    , extraData : Dict.Dict String String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Filter`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Filter :
    { nodeAddressesBannedFromTrading : Int
    , bannedOfferIds : Int
    , bannedPaymentAccounts : Int
    , signatureAsBase64 : Int
    , ownerPubKeyBytes : Int
    , extraData : Int
    , bannedCurrencies : Int
    , bannedPaymentMethods : Int
    , arbitrators : Int
    , seedNodes : Int
    , priceRelayNodes : Int
    , preventPublicXmrNetwork : Int
    , xmrNodes : Int
    , disableTradeBelowVersion : Int
    , mediators : Int
    , refundAgents : Int
    , bannedSignerPubKeys : Int
    , xmrFeeReceiverAddresses : Int
    , creationDate : Int
    , signerPubKeyAsHex : Int
    , bannedPrivilegedDevPubKeys : Int
    , disableAutoConf : Int
    , bannedAutoConfExplorers : Int
    , nodeAddressesBannedFromNetwork : Int
    , disableApi : Int
    , disableMempoolValidation : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__Filter =
    { nodeAddressesBannedFromTrading = 1
    , bannedOfferIds = 2
    , bannedPaymentAccounts = 3
    , signatureAsBase64 = 4
    , ownerPubKeyBytes = 5
    , extraData = 6
    , bannedCurrencies = 7
    , bannedPaymentMethods = 8
    , arbitrators = 9
    , seedNodes = 10
    , priceRelayNodes = 11
    , preventPublicXmrNetwork = 12
    , xmrNodes = 13
    , disableTradeBelowVersion = 14
    , mediators = 15
    , refundAgents = 16
    , bannedSignerPubKeys = 17
    , xmrFeeReceiverAddresses = 18
    , creationDate = 19
    , signerPubKeyAsHex = 20
    , bannedPrivilegedDevPubKeys = 21
    , disableAutoConf = 22
    , bannedAutoConfExplorers = 23
    , nodeAddressesBannedFromNetwork = 24
    , disableApi = 25
    , disableMempoolValidation = 26
    }


{-| Default for Proto__Io__Haveno__Protobuffer__Filter. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__Filter : Proto__Io__Haveno__Protobuffer__Filter
defaultProto__Io__Haveno__Protobuffer__Filter =
    { nodeAddressesBannedFromTrading = []
    , bannedOfferIds = []
    , bannedPaymentAccounts = []
    , signatureAsBase64 = ""
    , ownerPubKeyBytes = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , extraData = Dict.empty
    , bannedCurrencies = []
    , bannedPaymentMethods = []
    , arbitrators = []
    , seedNodes = []
    , priceRelayNodes = []
    , preventPublicXmrNetwork = False
    , xmrNodes = []
    , disableTradeBelowVersion = ""
    , mediators = []
    , refundAgents = []
    , bannedSignerPubKeys = []
    , xmrFeeReceiverAddresses = []
    , creationDate = Protobuf.Types.Int64.fromInts 0 0
    , signerPubKeyAsHex = ""
    , bannedPrivilegedDevPubKeys = []
    , disableAutoConf = False
    , bannedAutoConfExplorers = []
    , nodeAddressesBannedFromNetwork = []
    , disableApi = False
    , disableMempoolValidation = False
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Filter` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Filter : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__Filter
decodeProto__Io__Haveno__Protobuffer__Filter =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__Filter
        [ Protobuf.Decode.repeated
            1
            Protobuf.Decode.string
            .nodeAddressesBannedFromTrading
            (\a r -> { r | nodeAddressesBannedFromTrading = a })
        , Protobuf.Decode.repeated 2 Protobuf.Decode.string .bannedOfferIds (\a r -> { r | bannedOfferIds = a })
        , Protobuf.Decode.repeated
            3
            decodeProto__Io__Haveno__Protobuffer__PaymentAccountFilter
            .bannedPaymentAccounts
            (\a r -> { r | bannedPaymentAccounts = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | signatureAsBase64 = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.bytes (\a r -> { r | ownerPubKeyBytes = a })
        , Protobuf.Decode.mapped
            6
            ( "", "" )
            Protobuf.Decode.string
            Protobuf.Decode.string
            .extraData
            (\a r -> { r | extraData = a })
        , Protobuf.Decode.repeated 7 Protobuf.Decode.string .bannedCurrencies (\a r -> { r | bannedCurrencies = a })
        , Protobuf.Decode.repeated
            8
            Protobuf.Decode.string
            .bannedPaymentMethods
            (\a r -> { r | bannedPaymentMethods = a })
        , Protobuf.Decode.repeated 9 Protobuf.Decode.string .arbitrators (\a r -> { r | arbitrators = a })
        , Protobuf.Decode.repeated 10 Protobuf.Decode.string .seedNodes (\a r -> { r | seedNodes = a })
        , Protobuf.Decode.repeated 11 Protobuf.Decode.string .priceRelayNodes (\a r -> { r | priceRelayNodes = a })
        , Protobuf.Decode.optional 12 Protobuf.Decode.bool (\a r -> { r | preventPublicXmrNetwork = a })
        , Protobuf.Decode.repeated 13 Protobuf.Decode.string .xmrNodes (\a r -> { r | xmrNodes = a })
        , Protobuf.Decode.optional 14 Protobuf.Decode.string (\a r -> { r | disableTradeBelowVersion = a })
        , Protobuf.Decode.repeated 15 Protobuf.Decode.string .mediators (\a r -> { r | mediators = a })
        , Protobuf.Decode.repeated 16 Protobuf.Decode.string .refundAgents (\a r -> { r | refundAgents = a })
        , Protobuf.Decode.repeated
            17
            Protobuf.Decode.string
            .bannedSignerPubKeys
            (\a r -> { r | bannedSignerPubKeys = a })
        , Protobuf.Decode.repeated
            18
            Protobuf.Decode.string
            .xmrFeeReceiverAddresses
            (\a r -> { r | xmrFeeReceiverAddresses = a })
        , Protobuf.Decode.optional 19 Protobuf.Decode.int64 (\a r -> { r | creationDate = a })
        , Protobuf.Decode.optional 20 Protobuf.Decode.string (\a r -> { r | signerPubKeyAsHex = a })
        , Protobuf.Decode.repeated
            21
            Protobuf.Decode.string
            .bannedPrivilegedDevPubKeys
            (\a r -> { r | bannedPrivilegedDevPubKeys = a })
        , Protobuf.Decode.optional 22 Protobuf.Decode.bool (\a r -> { r | disableAutoConf = a })
        , Protobuf.Decode.repeated
            23
            Protobuf.Decode.string
            .bannedAutoConfExplorers
            (\a r -> { r | bannedAutoConfExplorers = a })
        , Protobuf.Decode.repeated
            24
            Protobuf.Decode.string
            .nodeAddressesBannedFromNetwork
            (\a r -> { r | nodeAddressesBannedFromNetwork = a })
        , Protobuf.Decode.optional 25 Protobuf.Decode.bool (\a r -> { r | disableApi = a })
        , Protobuf.Decode.optional 26 Protobuf.Decode.bool (\a r -> { r | disableMempoolValidation = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Filter` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Filter : Proto__Io__Haveno__Protobuffer__Filter -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__Filter value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list Protobuf.Encode.string) value.nodeAddressesBannedFromTrading )
        , ( 2, (Protobuf.Encode.list Protobuf.Encode.string) value.bannedOfferIds )
        , ( 3
          , (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__PaymentAccountFilter)
                value.bannedPaymentAccounts
          )
        , ( 4, Protobuf.Encode.string value.signatureAsBase64 )
        , ( 5, Protobuf.Encode.bytes value.ownerPubKeyBytes )
        , ( 6, Protobuf.Encode.dict Protobuf.Encode.string Protobuf.Encode.string value.extraData )
        , ( 7, (Protobuf.Encode.list Protobuf.Encode.string) value.bannedCurrencies )
        , ( 8, (Protobuf.Encode.list Protobuf.Encode.string) value.bannedPaymentMethods )
        , ( 9, (Protobuf.Encode.list Protobuf.Encode.string) value.arbitrators )
        , ( 10, (Protobuf.Encode.list Protobuf.Encode.string) value.seedNodes )
        , ( 11, (Protobuf.Encode.list Protobuf.Encode.string) value.priceRelayNodes )
        , ( 12, Protobuf.Encode.bool value.preventPublicXmrNetwork )
        , ( 13, (Protobuf.Encode.list Protobuf.Encode.string) value.xmrNodes )
        , ( 14, Protobuf.Encode.string value.disableTradeBelowVersion )
        , ( 15, (Protobuf.Encode.list Protobuf.Encode.string) value.mediators )
        , ( 16, (Protobuf.Encode.list Protobuf.Encode.string) value.refundAgents )
        , ( 17, (Protobuf.Encode.list Protobuf.Encode.string) value.bannedSignerPubKeys )
        , ( 18, (Protobuf.Encode.list Protobuf.Encode.string) value.xmrFeeReceiverAddresses )
        , ( 19, Protobuf.Encode.int64 value.creationDate )
        , ( 20, Protobuf.Encode.string value.signerPubKeyAsHex )
        , ( 21, (Protobuf.Encode.list Protobuf.Encode.string) value.bannedPrivilegedDevPubKeys )
        , ( 22, Protobuf.Encode.bool value.disableAutoConf )
        , ( 23, (Protobuf.Encode.list Protobuf.Encode.string) value.bannedAutoConfExplorers )
        , ( 24, (Protobuf.Encode.list Protobuf.Encode.string) value.nodeAddressesBannedFromNetwork )
        , ( 25, Protobuf.Encode.bool value.disableApi )
        , ( 26, Protobuf.Encode.bool value.disableMempoolValidation )
        ]


{-| `Proto__Io__Haveno__Protobuffer__Filter` message

-}
type alias Proto__Io__Haveno__Protobuffer__Filter =
    { nodeAddressesBannedFromTrading : List String
    , bannedOfferIds : List String
    , bannedPaymentAccounts : List Proto__Io__Haveno__Protobuffer__PaymentAccountFilter
    , signatureAsBase64 : String
    , ownerPubKeyBytes : Bytes.Bytes
    , extraData : Dict.Dict String String
    , bannedCurrencies : List String
    , bannedPaymentMethods : List String
    , arbitrators : List String
    , seedNodes : List String
    , priceRelayNodes : List String
    , preventPublicXmrNetwork : Bool
    , xmrNodes : List String
    , disableTradeBelowVersion : String
    , mediators : List String
    , refundAgents : List String
    , bannedSignerPubKeys : List String
    , xmrFeeReceiverAddresses : List String
    , creationDate : Protobuf.Types.Int64.Int64
    , signerPubKeyAsHex : String
    , bannedPrivilegedDevPubKeys : List String
    , disableAutoConf : Bool
    , bannedAutoConfExplorers : List String
    , nodeAddressesBannedFromNetwork : List String
    , disableApi : Bool
    , disableMempoolValidation : Bool
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RefundAgent`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RefundAgent :
    { nodeAddress : Int
    , languageCodes : Int
    , registrationDate : Int
    , registrationSignature : Int
    , registrationPubKey : Int
    , pubKeyRing : Int
    , emailAddress : Int
    , info : Int
    , extraData : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__RefundAgent =
    { nodeAddress = 1
    , languageCodes = 2
    , registrationDate = 3
    , registrationSignature = 4
    , registrationPubKey = 5
    , pubKeyRing = 6
    , emailAddress = 7
    , info = 8
    , extraData = 9
    }


{-| Default for Proto__Io__Haveno__Protobuffer__RefundAgent. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RefundAgent : Proto__Io__Haveno__Protobuffer__RefundAgent
defaultProto__Io__Haveno__Protobuffer__RefundAgent =
    { nodeAddress = Nothing
    , languageCodes = []
    , registrationDate = Protobuf.Types.Int64.fromInts 0 0
    , registrationSignature = ""
    , registrationPubKey = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , pubKeyRing = Nothing
    , emailAddress = ""
    , info = ""
    , extraData = Dict.empty
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RefundAgent` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RefundAgent : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RefundAgent
decodeProto__Io__Haveno__Protobuffer__RefundAgent =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__RefundAgent
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | nodeAddress = a })
        , Protobuf.Decode.repeated 2 Protobuf.Decode.string .languageCodes (\a r -> { r | languageCodes = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | registrationDate = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | registrationSignature = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.bytes (\a r -> { r | registrationPubKey = a })
        , Protobuf.Decode.optional
            6
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PubKeyRing)
            (\a r -> { r | pubKeyRing = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | emailAddress = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.string (\a r -> { r | info = a })
        , Protobuf.Decode.mapped
            9
            ( "", "" )
            Protobuf.Decode.string
            Protobuf.Decode.string
            .extraData
            (\a r -> { r | extraData = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RefundAgent` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RefundAgent :
    Proto__Io__Haveno__Protobuffer__RefundAgent -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RefundAgent value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.nodeAddress
          )
        , ( 2, (Protobuf.Encode.list Protobuf.Encode.string) value.languageCodes )
        , ( 3, Protobuf.Encode.int64 value.registrationDate )
        , ( 4, Protobuf.Encode.string value.registrationSignature )
        , ( 5, Protobuf.Encode.bytes value.registrationPubKey )
        , ( 6
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PubKeyRing >> Maybe.withDefault Protobuf.Encode.none)
                value.pubKeyRing
          )
        , ( 7, Protobuf.Encode.string value.emailAddress )
        , ( 8, Protobuf.Encode.string value.info )
        , ( 9, Protobuf.Encode.dict Protobuf.Encode.string Protobuf.Encode.string value.extraData )
        ]


{-| `Proto__Io__Haveno__Protobuffer__RefundAgent` message

-}
type alias Proto__Io__Haveno__Protobuffer__RefundAgent =
    { nodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , languageCodes : List String
    , registrationDate : Protobuf.Types.Int64.Int64
    , registrationSignature : String
    , registrationPubKey : Bytes.Bytes
    , pubKeyRing : Maybe Proto__Io__Haveno__Protobuffer__PubKeyRing
    , emailAddress : String
    , info : String
    , extraData : Dict.Dict String String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Mediator`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Mediator :
    { nodeAddress : Int
    , languageCodes : Int
    , registrationDate : Int
    , registrationSignature : Int
    , registrationPubKey : Int
    , pubKeyRing : Int
    , emailAddress : Int
    , info : Int
    , extraData : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__Mediator =
    { nodeAddress = 1
    , languageCodes = 2
    , registrationDate = 3
    , registrationSignature = 4
    , registrationPubKey = 5
    , pubKeyRing = 6
    , emailAddress = 7
    , info = 8
    , extraData = 9
    }


{-| Default for Proto__Io__Haveno__Protobuffer__Mediator. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__Mediator : Proto__Io__Haveno__Protobuffer__Mediator
defaultProto__Io__Haveno__Protobuffer__Mediator =
    { nodeAddress = Nothing
    , languageCodes = []
    , registrationDate = Protobuf.Types.Int64.fromInts 0 0
    , registrationSignature = ""
    , registrationPubKey = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , pubKeyRing = Nothing
    , emailAddress = ""
    , info = ""
    , extraData = Dict.empty
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Mediator` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Mediator : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__Mediator
decodeProto__Io__Haveno__Protobuffer__Mediator =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__Mediator
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | nodeAddress = a })
        , Protobuf.Decode.repeated 2 Protobuf.Decode.string .languageCodes (\a r -> { r | languageCodes = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | registrationDate = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | registrationSignature = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.bytes (\a r -> { r | registrationPubKey = a })
        , Protobuf.Decode.optional
            6
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PubKeyRing)
            (\a r -> { r | pubKeyRing = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | emailAddress = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.string (\a r -> { r | info = a })
        , Protobuf.Decode.mapped
            9
            ( "", "" )
            Protobuf.Decode.string
            Protobuf.Decode.string
            .extraData
            (\a r -> { r | extraData = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Mediator` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Mediator : Proto__Io__Haveno__Protobuffer__Mediator -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__Mediator value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.nodeAddress
          )
        , ( 2, (Protobuf.Encode.list Protobuf.Encode.string) value.languageCodes )
        , ( 3, Protobuf.Encode.int64 value.registrationDate )
        , ( 4, Protobuf.Encode.string value.registrationSignature )
        , ( 5, Protobuf.Encode.bytes value.registrationPubKey )
        , ( 6
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PubKeyRing >> Maybe.withDefault Protobuf.Encode.none)
                value.pubKeyRing
          )
        , ( 7, Protobuf.Encode.string value.emailAddress )
        , ( 8, Protobuf.Encode.string value.info )
        , ( 9, Protobuf.Encode.dict Protobuf.Encode.string Protobuf.Encode.string value.extraData )
        ]


{-| `Proto__Io__Haveno__Protobuffer__Mediator` message

-}
type alias Proto__Io__Haveno__Protobuffer__Mediator =
    { nodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , languageCodes : List String
    , registrationDate : Protobuf.Types.Int64.Int64
    , registrationSignature : String
    , registrationPubKey : Bytes.Bytes
    , pubKeyRing : Maybe Proto__Io__Haveno__Protobuffer__PubKeyRing
    , emailAddress : String
    , info : String
    , extraData : Dict.Dict String String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Arbitrator`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Arbitrator :
    { nodeAddress : Int
    , languageCodes : Int
    , registrationDate : Int
    , registrationSignature : Int
    , registrationPubKey : Int
    , pubKeyRing : Int
    , emailAddress : Int
    , info : Int
    , extraData : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__Arbitrator =
    { nodeAddress = 1
    , languageCodes = 2
    , registrationDate = 3
    , registrationSignature = 4
    , registrationPubKey = 5
    , pubKeyRing = 6
    , emailAddress = 7
    , info = 8
    , extraData = 9
    }


{-| Default for Proto__Io__Haveno__Protobuffer__Arbitrator. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__Arbitrator : Proto__Io__Haveno__Protobuffer__Arbitrator
defaultProto__Io__Haveno__Protobuffer__Arbitrator =
    { nodeAddress = Nothing
    , languageCodes = []
    , registrationDate = Protobuf.Types.Int64.fromInts 0 0
    , registrationSignature = ""
    , registrationPubKey = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , pubKeyRing = Nothing
    , emailAddress = ""
    , info = ""
    , extraData = Dict.empty
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Arbitrator` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Arbitrator : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__Arbitrator
decodeProto__Io__Haveno__Protobuffer__Arbitrator =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__Arbitrator
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | nodeAddress = a })
        , Protobuf.Decode.repeated 2 Protobuf.Decode.string .languageCodes (\a r -> { r | languageCodes = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | registrationDate = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | registrationSignature = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.bytes (\a r -> { r | registrationPubKey = a })
        , Protobuf.Decode.optional
            6
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PubKeyRing)
            (\a r -> { r | pubKeyRing = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | emailAddress = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.string (\a r -> { r | info = a })
        , Protobuf.Decode.mapped
            9
            ( "", "" )
            Protobuf.Decode.string
            Protobuf.Decode.string
            .extraData
            (\a r -> { r | extraData = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Arbitrator` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Arbitrator : Proto__Io__Haveno__Protobuffer__Arbitrator -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__Arbitrator value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.nodeAddress
          )
        , ( 2, (Protobuf.Encode.list Protobuf.Encode.string) value.languageCodes )
        , ( 3, Protobuf.Encode.int64 value.registrationDate )
        , ( 4, Protobuf.Encode.string value.registrationSignature )
        , ( 5, Protobuf.Encode.bytes value.registrationPubKey )
        , ( 6
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PubKeyRing >> Maybe.withDefault Protobuf.Encode.none)
                value.pubKeyRing
          )
        , ( 7, Protobuf.Encode.string value.emailAddress )
        , ( 8, Protobuf.Encode.string value.info )
        , ( 9, Protobuf.Encode.dict Protobuf.Encode.string Protobuf.Encode.string value.extraData )
        ]


{-| `Proto__Io__Haveno__Protobuffer__Arbitrator` message

-}
type alias Proto__Io__Haveno__Protobuffer__Arbitrator =
    { nodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , languageCodes : List String
    , registrationDate : Protobuf.Types.Int64.Int64
    , registrationSignature : String
    , registrationPubKey : Bytes.Bytes
    , pubKeyRing : Maybe Proto__Io__Haveno__Protobuffer__PubKeyRing
    , emailAddress : String
    , info : String
    , extraData : Dict.Dict String String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Alert`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Alert :
    { message : Int
    , version : Int
    , isUpdateInfo : Int
    , signatureAsBase64 : Int
    , ownerPubKeyBytes : Int
    , extraData : Int
    , isPreReleaseInfo : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__Alert =
    { message = 1
    , version = 2
    , isUpdateInfo = 3
    , signatureAsBase64 = 4
    , ownerPubKeyBytes = 5
    , extraData = 6
    , isPreReleaseInfo = 7
    }


{-| Default for Proto__Io__Haveno__Protobuffer__Alert. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__Alert : Proto__Io__Haveno__Protobuffer__Alert
defaultProto__Io__Haveno__Protobuffer__Alert =
    { message = ""
    , version = ""
    , isUpdateInfo = False
    , signatureAsBase64 = ""
    , ownerPubKeyBytes = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , extraData = Dict.empty
    , isPreReleaseInfo = False
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Alert` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Alert : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__Alert
decodeProto__Io__Haveno__Protobuffer__Alert =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__Alert
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | message = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | version = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.bool (\a r -> { r | isUpdateInfo = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | signatureAsBase64 = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.bytes (\a r -> { r | ownerPubKeyBytes = a })
        , Protobuf.Decode.mapped
            6
            ( "", "" )
            Protobuf.Decode.string
            Protobuf.Decode.string
            .extraData
            (\a r -> { r | extraData = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.bool (\a r -> { r | isPreReleaseInfo = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Alert` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Alert : Proto__Io__Haveno__Protobuffer__Alert -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__Alert value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.message )
        , ( 2, Protobuf.Encode.string value.version )
        , ( 3, Protobuf.Encode.bool value.isUpdateInfo )
        , ( 4, Protobuf.Encode.string value.signatureAsBase64 )
        , ( 5, Protobuf.Encode.bytes value.ownerPubKeyBytes )
        , ( 6, Protobuf.Encode.dict Protobuf.Encode.string Protobuf.Encode.string value.extraData )
        , ( 7, Protobuf.Encode.bool value.isPreReleaseInfo )
        ]


{-| `Proto__Io__Haveno__Protobuffer__Alert` message

-}
type alias Proto__Io__Haveno__Protobuffer__Alert =
    { message : String
    , version : String
    , isUpdateInfo : Bool
    , signatureAsBase64 : String
    , ownerPubKeyBytes : Bytes.Bytes
    , extraData : Dict.Dict String String
    , isPreReleaseInfo : Bool
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PaymentAccountFilter`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountFilter :
    { paymentMethodId : Int, getMethodName : Int, value : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentAccountFilter =
    { paymentMethodId = 1, getMethodName = 2, value = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__PaymentAccountFilter. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PaymentAccountFilter : Proto__Io__Haveno__Protobuffer__PaymentAccountFilter
defaultProto__Io__Haveno__Protobuffer__PaymentAccountFilter =
    { paymentMethodId = "", getMethodName = "", value = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PaymentAccountFilter` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PaymentAccountFilter :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PaymentAccountFilter
decodeProto__Io__Haveno__Protobuffer__PaymentAccountFilter =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PaymentAccountFilter
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | paymentMethodId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | getMethodName = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | value = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PaymentAccountFilter` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PaymentAccountFilter :
    Proto__Io__Haveno__Protobuffer__PaymentAccountFilter -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PaymentAccountFilter value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.paymentMethodId )
        , ( 2, Protobuf.Encode.string value.getMethodName )
        , ( 3, Protobuf.Encode.string value.value )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PaymentAccountFilter` message

-}
type alias Proto__Io__Haveno__Protobuffer__PaymentAccountFilter =
    { paymentMethodId : String, getMethodName : String, value : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PrivateNotificationPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PrivateNotificationPayload :
    { message : Int, signatureAsBase64 : Int, sigPublicKeyBytes : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PrivateNotificationPayload =
    { message = 1, signatureAsBase64 = 2, sigPublicKeyBytes = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__PrivateNotificationPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PrivateNotificationPayload :
    Proto__Io__Haveno__Protobuffer__PrivateNotificationPayload
defaultProto__Io__Haveno__Protobuffer__PrivateNotificationPayload =
    { message = "", signatureAsBase64 = "", sigPublicKeyBytes = Protobuf.Encode.encode <| Protobuf.Encode.string "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PrivateNotificationPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PrivateNotificationPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PrivateNotificationPayload
decodeProto__Io__Haveno__Protobuffer__PrivateNotificationPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PrivateNotificationPayload
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | message = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | signatureAsBase64 = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.bytes (\a r -> { r | sigPublicKeyBytes = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PrivateNotificationPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PrivateNotificationPayload :
    Proto__Io__Haveno__Protobuffer__PrivateNotificationPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PrivateNotificationPayload value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.message )
        , ( 2, Protobuf.Encode.string value.signatureAsBase64 )
        , ( 3, Protobuf.Encode.bytes value.sigPublicKeyBytes )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PrivateNotificationPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__PrivateNotificationPayload =
    { message : String, signatureAsBase64 : String, sigPublicKeyBytes : Bytes.Bytes }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey :
    { networkEnvelope : Int, signaturePubKeyBytes : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey =
    { networkEnvelope = 1, signaturePubKeyBytes = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey :
    Proto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey
defaultProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey =
    { networkEnvelope = Nothing, signaturePubKeyBytes = Protobuf.Encode.encode <| Protobuf.Encode.string "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey
decodeProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NetworkEnvelope)
            (\a r -> { r | networkEnvelope = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.bytes (\a r -> { r | signaturePubKeyBytes = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey :
    Proto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NetworkEnvelope >> Maybe.withDefault Protobuf.Encode.none)
                value.networkEnvelope
          )
        , ( 2, Protobuf.Encode.bytes value.signaturePubKeyBytes )
        ]


{-| `Proto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey` message

-}
type alias Proto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey =
    { networkEnvelope : Maybe Proto__Io__Haveno__Protobuffer__NetworkEnvelope, signaturePubKeyBytes : Bytes.Bytes }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MailboxItem`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MailboxItem :
    { protectedMailboxStorageEntry : Int, decryptedMessageWithPubKey : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MailboxItem =
    { protectedMailboxStorageEntry = 1, decryptedMessageWithPubKey = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__MailboxItem. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MailboxItem : Proto__Io__Haveno__Protobuffer__MailboxItem
defaultProto__Io__Haveno__Protobuffer__MailboxItem =
    { protectedMailboxStorageEntry = Nothing, decryptedMessageWithPubKey = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MailboxItem` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MailboxItem : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MailboxItem
decodeProto__Io__Haveno__Protobuffer__MailboxItem =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MailboxItem
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry)
            (\a r -> { r | protectedMailboxStorageEntry = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey)
            (\a r -> { r | decryptedMessageWithPubKey = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MailboxItem` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MailboxItem :
    Proto__Io__Haveno__Protobuffer__MailboxItem -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MailboxItem value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.protectedMailboxStorageEntry
          )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.decryptedMessageWithPubKey
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__MailboxItem` message

-}
type alias Proto__Io__Haveno__Protobuffer__MailboxItem =
    { protectedMailboxStorageEntry : Maybe Proto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry
    , decryptedMessageWithPubKey : Maybe Proto__Io__Haveno__Protobuffer__DecryptedMessageWithPubKey
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__IgnoredMailboxMap`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__IgnoredMailboxMap : { data : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__IgnoredMailboxMap =
    { data = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__IgnoredMailboxMap. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__IgnoredMailboxMap : Proto__Io__Haveno__Protobuffer__IgnoredMailboxMap
defaultProto__Io__Haveno__Protobuffer__IgnoredMailboxMap =
    { data = Dict.empty }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__IgnoredMailboxMap` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__IgnoredMailboxMap :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__IgnoredMailboxMap
decodeProto__Io__Haveno__Protobuffer__IgnoredMailboxMap =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__IgnoredMailboxMap
        [ Protobuf.Decode.mapped
            1
            ( "", Protobuf.Types.Int64.fromInts 0 0 )
            Protobuf.Decode.string
            Protobuf.Decode.uint64
            .data
            (\a r -> { r | data = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__IgnoredMailboxMap` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__IgnoredMailboxMap :
    Proto__Io__Haveno__Protobuffer__IgnoredMailboxMap -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__IgnoredMailboxMap value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.dict Protobuf.Encode.string Protobuf.Encode.uint64 value.data ) ]


{-| `Proto__Io__Haveno__Protobuffer__IgnoredMailboxMap` message

-}
type alias Proto__Io__Haveno__Protobuffer__IgnoredMailboxMap =
    { data : Dict.Dict String Protobuf.Types.Int64.Int64 }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RemovedPayloadsMap`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RemovedPayloadsMap : { dateByHashes : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__RemovedPayloadsMap =
    { dateByHashes = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__RemovedPayloadsMap. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RemovedPayloadsMap : Proto__Io__Haveno__Protobuffer__RemovedPayloadsMap
defaultProto__Io__Haveno__Protobuffer__RemovedPayloadsMap =
    { dateByHashes = Dict.empty }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RemovedPayloadsMap` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RemovedPayloadsMap :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RemovedPayloadsMap
decodeProto__Io__Haveno__Protobuffer__RemovedPayloadsMap =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__RemovedPayloadsMap
        [ Protobuf.Decode.mapped
            1
            ( "", Protobuf.Types.Int64.fromInts 0 0 )
            Protobuf.Decode.string
            Protobuf.Decode.uint64
            .dateByHashes
            (\a r -> { r | dateByHashes = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RemovedPayloadsMap` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RemovedPayloadsMap :
    Proto__Io__Haveno__Protobuffer__RemovedPayloadsMap -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RemovedPayloadsMap value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.dict Protobuf.Encode.string Protobuf.Encode.uint64 value.dateByHashes ) ]


{-| `Proto__Io__Haveno__Protobuffer__RemovedPayloadsMap` message

-}
type alias Proto__Io__Haveno__Protobuffer__RemovedPayloadsMap =
    { dateByHashes : Dict.Dict String Protobuf.Types.Int64.Int64 }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MailboxMessageList`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MailboxMessageList : { mailboxItem : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MailboxMessageList =
    { mailboxItem = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__MailboxMessageList. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MailboxMessageList : Proto__Io__Haveno__Protobuffer__MailboxMessageList
defaultProto__Io__Haveno__Protobuffer__MailboxMessageList =
    { mailboxItem = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MailboxMessageList` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MailboxMessageList :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MailboxMessageList
decodeProto__Io__Haveno__Protobuffer__MailboxMessageList =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MailboxMessageList
        [ Protobuf.Decode.repeated
            1
            decodeProto__Io__Haveno__Protobuffer__MailboxItem
            .mailboxItem
            (\a r -> { r | mailboxItem = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MailboxMessageList` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MailboxMessageList :
    Proto__Io__Haveno__Protobuffer__MailboxMessageList -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MailboxMessageList value =
    Protobuf.Encode.message
        [ ( 1, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__MailboxItem) value.mailboxItem ) ]


{-| `Proto__Io__Haveno__Protobuffer__MailboxMessageList` message

-}
type alias Proto__Io__Haveno__Protobuffer__MailboxMessageList =
    { mailboxItem : List Proto__Io__Haveno__Protobuffer__MailboxItem }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__DataAndSeqNrPair`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__DataAndSeqNrPair : { payload : Int, sequenceNumber : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__DataAndSeqNrPair =
    { payload = 1, sequenceNumber = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__DataAndSeqNrPair. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__DataAndSeqNrPair : Proto__Io__Haveno__Protobuffer__DataAndSeqNrPair
defaultProto__Io__Haveno__Protobuffer__DataAndSeqNrPair =
    { payload = Nothing, sequenceNumber = 0 }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__DataAndSeqNrPair` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__DataAndSeqNrPair :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__DataAndSeqNrPair
decodeProto__Io__Haveno__Protobuffer__DataAndSeqNrPair =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__DataAndSeqNrPair
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__StoragePayload)
            (\a r -> { r | payload = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int32 (\a r -> { r | sequenceNumber = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__DataAndSeqNrPair` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__DataAndSeqNrPair :
    Proto__Io__Haveno__Protobuffer__DataAndSeqNrPair -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__DataAndSeqNrPair value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__StoragePayload >> Maybe.withDefault Protobuf.Encode.none)
                value.payload
          )
        , ( 2, Protobuf.Encode.int32 value.sequenceNumber )
        ]


{-| `Proto__Io__Haveno__Protobuffer__DataAndSeqNrPair` message

-}
type alias Proto__Io__Haveno__Protobuffer__DataAndSeqNrPair =
    { payload : Maybe Proto__Io__Haveno__Protobuffer__StoragePayload, sequenceNumber : Int }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry : { entry : Int, receiversPubKeyBytes : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry =
    { entry = 1, receiversPubKeyBytes = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry :
    Proto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry
defaultProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry =
    { entry = Nothing, receiversPubKeyBytes = Protobuf.Encode.encode <| Protobuf.Encode.string "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry
decodeProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__ProtectedStorageEntry)
            (\a r -> { r | entry = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.bytes (\a r -> { r | receiversPubKeyBytes = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry :
    Proto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__ProtectedStorageEntry
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.entry
          )
        , ( 2, Protobuf.Encode.bytes value.receiversPubKeyBytes )
        ]


{-| `Proto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry` message

-}
type alias Proto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry =
    { entry : Maybe Proto__Io__Haveno__Protobuffer__ProtectedStorageEntry, receiversPubKeyBytes : Bytes.Bytes }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StorageEntryWrapper`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__StorageEntryWrapper :
    { message : FieldNumbersProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message }
fieldNumbersProto__Io__Haveno__Protobuffer__StorageEntryWrapper =
    { message = fieldNumbersProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message }


{-| Default for Proto__Io__Haveno__Protobuffer__StorageEntryWrapper. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__StorageEntryWrapper : Proto__Io__Haveno__Protobuffer__StorageEntryWrapper
defaultProto__Io__Haveno__Protobuffer__StorageEntryWrapper =
    { message = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__StorageEntryWrapper` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__StorageEntryWrapper
decodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__StorageEntryWrapper
        [ decodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message (\a r -> { r | message = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__StorageEntryWrapper` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper :
    Proto__Io__Haveno__Protobuffer__StorageEntryWrapper -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper value =
    Protobuf.Encode.message
        [ encodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message value.message ]


{-| `Proto__Io__Haveno__Protobuffer__StorageEntryWrapper` message

-}
type alias Proto__Io__Haveno__Protobuffer__StorageEntryWrapper =
    { message : Maybe Proto__Io__Haveno__Protobuffer__StorageEntryWrapper__Message__Message }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ProtectedStorageEntry`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ProtectedStorageEntry :
    { storagePayload : Int, ownerPubKeyBytes : Int, sequenceNumber : Int, signature : Int, creationTimeStamp : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__ProtectedStorageEntry =
    { storagePayload = 1, ownerPubKeyBytes = 2, sequenceNumber = 3, signature = 4, creationTimeStamp = 5 }


{-| Default for Proto__Io__Haveno__Protobuffer__ProtectedStorageEntry. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ProtectedStorageEntry : Proto__Io__Haveno__Protobuffer__ProtectedStorageEntry
defaultProto__Io__Haveno__Protobuffer__ProtectedStorageEntry =
    { storagePayload = Nothing
    , ownerPubKeyBytes = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , sequenceNumber = 0
    , signature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , creationTimeStamp = Protobuf.Types.Int64.fromInts 0 0
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ProtectedStorageEntry` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ProtectedStorageEntry :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ProtectedStorageEntry
decodeProto__Io__Haveno__Protobuffer__ProtectedStorageEntry =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__ProtectedStorageEntry
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__StoragePayload)
            (\a r -> { r | storagePayload = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.bytes (\a r -> { r | ownerPubKeyBytes = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int32 (\a r -> { r | sequenceNumber = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.bytes (\a r -> { r | signature = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.int64 (\a r -> { r | creationTimeStamp = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ProtectedStorageEntry` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ProtectedStorageEntry :
    Proto__Io__Haveno__Protobuffer__ProtectedStorageEntry -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ProtectedStorageEntry value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__StoragePayload >> Maybe.withDefault Protobuf.Encode.none)
                value.storagePayload
          )
        , ( 2, Protobuf.Encode.bytes value.ownerPubKeyBytes )
        , ( 3, Protobuf.Encode.int32 value.sequenceNumber )
        , ( 4, Protobuf.Encode.bytes value.signature )
        , ( 5, Protobuf.Encode.int64 value.creationTimeStamp )
        ]


{-| `Proto__Io__Haveno__Protobuffer__ProtectedStorageEntry` message

-}
type alias Proto__Io__Haveno__Protobuffer__ProtectedStorageEntry =
    { storagePayload : Maybe Proto__Io__Haveno__Protobuffer__StoragePayload
    , ownerPubKeyBytes : Bytes.Bytes
    , sequenceNumber : Int
    , signature : Bytes.Bytes
    , creationTimeStamp : Protobuf.Types.Int64.Int64
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PersistableNetworkPayload :
    { message : FieldNumbersProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message }
fieldNumbersProto__Io__Haveno__Protobuffer__PersistableNetworkPayload =
    { message = fieldNumbersProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message }


{-| Default for Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PersistableNetworkPayload :
    Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload
defaultProto__Io__Haveno__Protobuffer__PersistableNetworkPayload =
    { message = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload
decodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PersistableNetworkPayload
        [ decodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message
            (\a r -> { r | message = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload :
    Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload value =
    Protobuf.Encode.message
        [ encodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message value.message ]


{-| `Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload =
    { message : Maybe Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload__Message__Message }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__StoragePayload`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__StoragePayload :
    { message : FieldNumbersProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message }
fieldNumbersProto__Io__Haveno__Protobuffer__StoragePayload =
    { message = fieldNumbersProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message }


{-| Default for Proto__Io__Haveno__Protobuffer__StoragePayload. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__StoragePayload : Proto__Io__Haveno__Protobuffer__StoragePayload
defaultProto__Io__Haveno__Protobuffer__StoragePayload =
    { message = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__StoragePayload` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__StoragePayload :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__StoragePayload
decodeProto__Io__Haveno__Protobuffer__StoragePayload =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__StoragePayload
        [ decodeProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message (\a r -> { r | message = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__StoragePayload` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__StoragePayload :
    Proto__Io__Haveno__Protobuffer__StoragePayload -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__StoragePayload value =
    Protobuf.Encode.message [ encodeProto__Io__Haveno__Protobuffer__StoragePayload__Message__Message value.message ]


{-| `Proto__Io__Haveno__Protobuffer__StoragePayload` message

-}
type alias Proto__Io__Haveno__Protobuffer__StoragePayload =
    { message : Maybe Proto__Io__Haveno__Protobuffer__StoragePayload__Message__Message }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SealedAndSigned`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SealedAndSigned :
    { encryptedSecretKey : Int, encryptedPayloadWithHmac : Int, signature : Int, sigPublicKeyBytes : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SealedAndSigned =
    { encryptedSecretKey = 1, encryptedPayloadWithHmac = 2, signature = 3, sigPublicKeyBytes = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__SealedAndSigned. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SealedAndSigned : Proto__Io__Haveno__Protobuffer__SealedAndSigned
defaultProto__Io__Haveno__Protobuffer__SealedAndSigned =
    { encryptedSecretKey = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , encryptedPayloadWithHmac = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , signature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , sigPublicKeyBytes = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SealedAndSigned` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SealedAndSigned :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SealedAndSigned
decodeProto__Io__Haveno__Protobuffer__SealedAndSigned =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SealedAndSigned
        [ Protobuf.Decode.optional 1 Protobuf.Decode.bytes (\a r -> { r | encryptedSecretKey = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.bytes (\a r -> { r | encryptedPayloadWithHmac = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.bytes (\a r -> { r | signature = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.bytes (\a r -> { r | sigPublicKeyBytes = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SealedAndSigned` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SealedAndSigned :
    Proto__Io__Haveno__Protobuffer__SealedAndSigned -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SealedAndSigned value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.bytes value.encryptedSecretKey )
        , ( 2, Protobuf.Encode.bytes value.encryptedPayloadWithHmac )
        , ( 3, Protobuf.Encode.bytes value.signature )
        , ( 4, Protobuf.Encode.bytes value.sigPublicKeyBytes )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SealedAndSigned` message

-}
type alias Proto__Io__Haveno__Protobuffer__SealedAndSigned =
    { encryptedSecretKey : Bytes.Bytes
    , encryptedPayloadWithHmac : Bytes.Bytes
    , signature : Bytes.Bytes
    , sigPublicKeyBytes : Bytes.Bytes
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PubKeyRing`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PubKeyRing : { signaturePubKeyBytes : Int, encryptionPubKeyBytes : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PubKeyRing =
    { signaturePubKeyBytes = 1, encryptionPubKeyBytes = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__PubKeyRing. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PubKeyRing : Proto__Io__Haveno__Protobuffer__PubKeyRing
defaultProto__Io__Haveno__Protobuffer__PubKeyRing =
    { signaturePubKeyBytes = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , encryptionPubKeyBytes = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PubKeyRing` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PubKeyRing : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PubKeyRing
decodeProto__Io__Haveno__Protobuffer__PubKeyRing =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PubKeyRing
        [ Protobuf.Decode.optional 1 Protobuf.Decode.bytes (\a r -> { r | signaturePubKeyBytes = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.bytes (\a r -> { r | encryptionPubKeyBytes = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PubKeyRing` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PubKeyRing : Proto__Io__Haveno__Protobuffer__PubKeyRing -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PubKeyRing value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.bytes value.signaturePubKeyBytes )
        , ( 2, Protobuf.Encode.bytes value.encryptionPubKeyBytes )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PubKeyRing` message

-}
type alias Proto__Io__Haveno__Protobuffer__PubKeyRing =
    { signaturePubKeyBytes : Bytes.Bytes, encryptionPubKeyBytes : Bytes.Bytes }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Peer`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Peer : { nodeAddress : Int, date : Int, supportedCapabilities : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__Peer =
    { nodeAddress = 1, date = 2, supportedCapabilities = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__Peer. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__Peer : Proto__Io__Haveno__Protobuffer__Peer
defaultProto__Io__Haveno__Protobuffer__Peer =
    { nodeAddress = Nothing, date = Protobuf.Types.Int64.fromInts 0 0, supportedCapabilities = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Peer` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Peer : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__Peer
decodeProto__Io__Haveno__Protobuffer__Peer =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__Peer
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | nodeAddress = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int64 (\a r -> { r | date = a })
        , Protobuf.Decode.repeated
            3
            Protobuf.Decode.int32
            .supportedCapabilities
            (\a r -> { r | supportedCapabilities = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Peer` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Peer : Proto__Io__Haveno__Protobuffer__Peer -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__Peer value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.nodeAddress
          )
        , ( 2, Protobuf.Encode.int64 value.date )
        , ( 3, (Protobuf.Encode.list Protobuf.Encode.int32) value.supportedCapabilities )
        ]


{-| `Proto__Io__Haveno__Protobuffer__Peer` message

-}
type alias Proto__Io__Haveno__Protobuffer__Peer =
    { nodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , date : Protobuf.Types.Int64.Int64
    , supportedCapabilities : List Int
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__NodeAddress`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__NodeAddress : { hostName : Int, port_ : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__NodeAddress =
    { hostName = 1, port_ = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__NodeAddress. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__NodeAddress : Proto__Io__Haveno__Protobuffer__NodeAddress
defaultProto__Io__Haveno__Protobuffer__NodeAddress =
    { hostName = "", port_ = 0 }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__NodeAddress` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__NodeAddress : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__NodeAddress
decodeProto__Io__Haveno__Protobuffer__NodeAddress =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__NodeAddress
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | hostName = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int32 (\a r -> { r | port_ = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__NodeAddress` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__NodeAddress :
    Proto__Io__Haveno__Protobuffer__NodeAddress -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__NodeAddress value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.hostName ), ( 2, Protobuf.Encode.int32 value.port_ ) ]


{-| `Proto__Io__Haveno__Protobuffer__NodeAddress` message

-}
type alias Proto__Io__Haveno__Protobuffer__NodeAddress =
    { hostName : String, port_ : Int }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PrivateNotificationMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PrivateNotificationMessage :
    { uid : Int, senderNodeAddress : Int, privateNotificationPayload : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PrivateNotificationMessage =
    { uid = 1, senderNodeAddress = 2, privateNotificationPayload = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__PrivateNotificationMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PrivateNotificationMessage :
    Proto__Io__Haveno__Protobuffer__PrivateNotificationMessage
defaultProto__Io__Haveno__Protobuffer__PrivateNotificationMessage =
    { uid = "", senderNodeAddress = Nothing, privateNotificationPayload = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PrivateNotificationMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PrivateNotificationMessage :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PrivateNotificationMessage
decodeProto__Io__Haveno__Protobuffer__PrivateNotificationMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PrivateNotificationMessage
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | senderNodeAddress = a })
        , Protobuf.Decode.optional
            3
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PrivateNotificationPayload)
            (\a r -> { r | privateNotificationPayload = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PrivateNotificationMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PrivateNotificationMessage :
    Proto__Io__Haveno__Protobuffer__PrivateNotificationMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PrivateNotificationMessage value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.uid )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.senderNodeAddress
          )
        , ( 3
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PrivateNotificationPayload
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.privateNotificationPayload
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PrivateNotificationMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__PrivateNotificationMessage =
    { uid : String
    , senderNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , privateNotificationPayload : Maybe Proto__Io__Haveno__Protobuffer__PrivateNotificationPayload
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__DisputeClosedMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__DisputeClosedMessage :
    { uid : Int
    , disputeResult : Int
    , senderNodeAddress : Int
    , type_ : Int
    , updatedMultisigHex : Int
    , unsignedPayoutTxHex : Int
    , deferPublishPayout : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__DisputeClosedMessage =
    { uid = 1
    , disputeResult = 2
    , senderNodeAddress = 3
    , type_ = 4
    , updatedMultisigHex = 5
    , unsignedPayoutTxHex = 6
    , deferPublishPayout = 7
    }


{-| Default for Proto__Io__Haveno__Protobuffer__DisputeClosedMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__DisputeClosedMessage : Proto__Io__Haveno__Protobuffer__DisputeClosedMessage
defaultProto__Io__Haveno__Protobuffer__DisputeClosedMessage =
    { uid = ""
    , disputeResult = Nothing
    , senderNodeAddress = Nothing
    , type_ = Proto.Io.Haveno.Protobuffer.SupportType.defaultSupportType
    , updatedMultisigHex = ""
    , unsignedPayoutTxHex = ""
    , deferPublishPayout = False
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__DisputeClosedMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__DisputeClosedMessage :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__DisputeClosedMessage
decodeProto__Io__Haveno__Protobuffer__DisputeClosedMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__DisputeClosedMessage
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__DisputeResult)
            (\a r -> { r | disputeResult = a })
        , Protobuf.Decode.optional
            3
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | senderNodeAddress = a })
        , Protobuf.Decode.optional
            4
            Proto.Io.Haveno.Protobuffer.SupportType.decodeSupportType
            (\a r -> { r | type_ = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | updatedMultisigHex = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | unsignedPayoutTxHex = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.bool (\a r -> { r | deferPublishPayout = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__DisputeClosedMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__DisputeClosedMessage :
    Proto__Io__Haveno__Protobuffer__DisputeClosedMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__DisputeClosedMessage value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.uid )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__DisputeResult >> Maybe.withDefault Protobuf.Encode.none)
                value.disputeResult
          )
        , ( 3
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.senderNodeAddress
          )
        , ( 4, Proto.Io.Haveno.Protobuffer.SupportType.encodeSupportType value.type_ )
        , ( 5, Protobuf.Encode.string value.updatedMultisigHex )
        , ( 6, Protobuf.Encode.string value.unsignedPayoutTxHex )
        , ( 7, Protobuf.Encode.bool value.deferPublishPayout )
        ]


{-| `Proto__Io__Haveno__Protobuffer__DisputeClosedMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__DisputeClosedMessage =
    { uid : String
    , disputeResult : Maybe Proto__Io__Haveno__Protobuffer__DisputeResult
    , senderNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , type_ : Proto.Io.Haveno.Protobuffer.SupportType.SupportType
    , updatedMultisigHex : String
    , unsignedPayoutTxHex : String
    , deferPublishPayout : Bool
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__DisputeOpenedMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__DisputeOpenedMessage :
    { dispute : Int
    , senderNodeAddress : Int
    , uid : Int
    , type_ : Int
    , updatedMultisigHex : Int
    , paymentSentMessage : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__DisputeOpenedMessage =
    { dispute = 1, senderNodeAddress = 2, uid = 3, type_ = 4, updatedMultisigHex = 5, paymentSentMessage = 6 }


{-| Default for Proto__Io__Haveno__Protobuffer__DisputeOpenedMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__DisputeOpenedMessage : Proto__Io__Haveno__Protobuffer__DisputeOpenedMessage
defaultProto__Io__Haveno__Protobuffer__DisputeOpenedMessage =
    { dispute = Nothing
    , senderNodeAddress = Nothing
    , uid = ""
    , type_ = Proto.Io.Haveno.Protobuffer.SupportType.defaultSupportType
    , updatedMultisigHex = ""
    , paymentSentMessage = Nothing
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__DisputeOpenedMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__DisputeOpenedMessage :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__DisputeOpenedMessage
decodeProto__Io__Haveno__Protobuffer__DisputeOpenedMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__DisputeOpenedMessage
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__Dispute)
            (\a r -> { r | dispute = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | senderNodeAddress = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional
            4
            Proto.Io.Haveno.Protobuffer.SupportType.decodeSupportType
            (\a r -> { r | type_ = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | updatedMultisigHex = a })
        , Protobuf.Decode.optional
            6
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentSentMessage)
            (\a r -> { r | paymentSentMessage = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__DisputeOpenedMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__DisputeOpenedMessage :
    Proto__Io__Haveno__Protobuffer__DisputeOpenedMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__DisputeOpenedMessage value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__Dispute >> Maybe.withDefault Protobuf.Encode.none)
                value.dispute
          )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.senderNodeAddress
          )
        , ( 3, Protobuf.Encode.string value.uid )
        , ( 4, Proto.Io.Haveno.Protobuffer.SupportType.encodeSupportType value.type_ )
        , ( 5, Protobuf.Encode.string value.updatedMultisigHex )
        , ( 6
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentSentMessage
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.paymentSentMessage
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__DisputeOpenedMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__DisputeOpenedMessage =
    { dispute : Maybe Proto__Io__Haveno__Protobuffer__Dispute
    , senderNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , uid : String
    , type_ : Proto.Io.Haveno.Protobuffer.SupportType.SupportType
    , updatedMultisigHex : String
    , paymentSentMessage : Maybe Proto__Io__Haveno__Protobuffer__PaymentSentMessage
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__ChatMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__ChatMessage :
    { date : Int
    , tradeId : Int
    , traderId : Int
    , senderIsTrader : Int
    , message : Int
    , attachments : Int
    , arrived : Int
    , storedInMailbox : Int
    , isSystemMessage : Int
    , senderNodeAddress : Int
    , uid : Int
    , sendMessageError : Int
    , acknowledged : Int
    , ackError : Int
    , type_ : Int
    , wasDisplayed : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__ChatMessage =
    { date = 1
    , tradeId = 2
    , traderId = 3
    , senderIsTrader = 4
    , message = 5
    , attachments = 6
    , arrived = 7
    , storedInMailbox = 8
    , isSystemMessage = 9
    , senderNodeAddress = 10
    , uid = 11
    , sendMessageError = 12
    , acknowledged = 13
    , ackError = 14
    , type_ = 15
    , wasDisplayed = 16
    }


{-| Default for Proto__Io__Haveno__Protobuffer__ChatMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__ChatMessage : Proto__Io__Haveno__Protobuffer__ChatMessage
defaultProto__Io__Haveno__Protobuffer__ChatMessage =
    { date = Protobuf.Types.Int64.fromInts 0 0
    , tradeId = ""
    , traderId = 0
    , senderIsTrader = False
    , message = ""
    , attachments = []
    , arrived = False
    , storedInMailbox = False
    , isSystemMessage = False
    , senderNodeAddress = Nothing
    , uid = ""
    , sendMessageError = ""
    , acknowledged = False
    , ackError = ""
    , type_ = Proto.Io.Haveno.Protobuffer.SupportType.defaultSupportType
    , wasDisplayed = False
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__ChatMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__ChatMessage : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__ChatMessage
decodeProto__Io__Haveno__Protobuffer__ChatMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__ChatMessage
        [ Protobuf.Decode.optional 1 Protobuf.Decode.int64 (\a r -> { r | date = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int32 (\a r -> { r | traderId = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.bool (\a r -> { r | senderIsTrader = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | message = a })
        , Protobuf.Decode.repeated
            6
            decodeProto__Io__Haveno__Protobuffer__Attachment
            .attachments
            (\a r -> { r | attachments = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.bool (\a r -> { r | arrived = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.bool (\a r -> { r | storedInMailbox = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.bool (\a r -> { r | isSystemMessage = a })
        , Protobuf.Decode.optional
            10
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | senderNodeAddress = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional 12 Protobuf.Decode.string (\a r -> { r | sendMessageError = a })
        , Protobuf.Decode.optional 13 Protobuf.Decode.bool (\a r -> { r | acknowledged = a })
        , Protobuf.Decode.optional 14 Protobuf.Decode.string (\a r -> { r | ackError = a })
        , Protobuf.Decode.optional
            15
            Proto.Io.Haveno.Protobuffer.SupportType.decodeSupportType
            (\a r -> { r | type_ = a })
        , Protobuf.Decode.optional 16 Protobuf.Decode.bool (\a r -> { r | wasDisplayed = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__ChatMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__ChatMessage :
    Proto__Io__Haveno__Protobuffer__ChatMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__ChatMessage value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.int64 value.date )
        , ( 2, Protobuf.Encode.string value.tradeId )
        , ( 3, Protobuf.Encode.int32 value.traderId )
        , ( 4, Protobuf.Encode.bool value.senderIsTrader )
        , ( 5, Protobuf.Encode.string value.message )
        , ( 6, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__Attachment) value.attachments )
        , ( 7, Protobuf.Encode.bool value.arrived )
        , ( 8, Protobuf.Encode.bool value.storedInMailbox )
        , ( 9, Protobuf.Encode.bool value.isSystemMessage )
        , ( 10
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.senderNodeAddress
          )
        , ( 11, Protobuf.Encode.string value.uid )
        , ( 12, Protobuf.Encode.string value.sendMessageError )
        , ( 13, Protobuf.Encode.bool value.acknowledged )
        , ( 14, Protobuf.Encode.string value.ackError )
        , ( 15, Proto.Io.Haveno.Protobuffer.SupportType.encodeSupportType value.type_ )
        , ( 16, Protobuf.Encode.bool value.wasDisplayed )
        ]


{-| `Proto__Io__Haveno__Protobuffer__ChatMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__ChatMessage =
    { date : Protobuf.Types.Int64.Int64
    , tradeId : String
    , traderId : Int
    , senderIsTrader : Bool
    , message : String
    , attachments : List Proto__Io__Haveno__Protobuffer__Attachment
    , arrived : Bool
    , storedInMailbox : Bool
    , isSystemMessage : Bool
    , senderNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , uid : String
    , sendMessageError : String
    , acknowledged : Bool
    , ackError : String
    , type_ : Proto.Io.Haveno.Protobuffer.SupportType.SupportType
    , wasDisplayed : Bool
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage :
    { uid : Int, tradeId : Int, txSignature : Int, senderNodeAddress : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage =
    { uid = 1, tradeId = 3, txSignature = 2, senderNodeAddress = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage :
    Proto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage
defaultProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage =
    { uid = ""
    , tradeId = ""
    , txSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , senderNodeAddress = Nothing
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage
decodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.bytes (\a r -> { r | txSignature = a })
        , Protobuf.Decode.optional
            4
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | senderNodeAddress = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage :
    Proto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.uid )
        , ( 3, Protobuf.Encode.string value.tradeId )
        , ( 2, Protobuf.Encode.bytes value.txSignature )
        , ( 4
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.senderNodeAddress
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__MediatedPayoutTxSignatureMessage =
    { uid : String
    , tradeId : String
    , txSignature : Bytes.Bytes
    , senderNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage :
    { tradeId : Int, payoutTx : Int, senderNodeAddress : Int, uid : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage =
    { tradeId = 1, payoutTx = 2, senderNodeAddress = 3, uid = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage :
    Proto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage
defaultProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage =
    { tradeId = ""
    , payoutTx = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , senderNodeAddress = Nothing
    , uid = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage
decodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.bytes (\a r -> { r | payoutTx = a })
        , Protobuf.Decode.optional
            3
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | senderNodeAddress = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | uid = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage :
    Proto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.tradeId )
        , ( 2, Protobuf.Encode.bytes value.payoutTx )
        , ( 3
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.senderNodeAddress
          )
        , ( 4, Protobuf.Encode.string value.uid )
        ]


{-| `Proto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__MediatedPayoutTxPublishedMessage =
    { tradeId : String
    , payoutTx : Bytes.Bytes
    , senderNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , uid : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PaymentReceivedMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentReceivedMessage :
    { tradeId : Int
    , senderNodeAddress : Int
    , uid : Int
    , unsignedPayoutTxHex : Int
    , signedPayoutTxHex : Int
    , updatedMultisigHex : Int
    , deferPublishPayout : Int
    , buyerAccountAgeWitness : Int
    , buyerSignedWitness : Int
    , paymentSentMessage : Int
    , sellerSignature : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentReceivedMessage =
    { tradeId = 1
    , senderNodeAddress = 2
    , uid = 3
    , unsignedPayoutTxHex = 4
    , signedPayoutTxHex = 5
    , updatedMultisigHex = 6
    , deferPublishPayout = 7
    , buyerAccountAgeWitness = 8
    , buyerSignedWitness = 9
    , paymentSentMessage = 10
    , sellerSignature = 11
    }


{-| Default for Proto__Io__Haveno__Protobuffer__PaymentReceivedMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PaymentReceivedMessage : Proto__Io__Haveno__Protobuffer__PaymentReceivedMessage
defaultProto__Io__Haveno__Protobuffer__PaymentReceivedMessage =
    { tradeId = ""
    , senderNodeAddress = Nothing
    , uid = ""
    , unsignedPayoutTxHex = ""
    , signedPayoutTxHex = ""
    , updatedMultisigHex = ""
    , deferPublishPayout = False
    , buyerAccountAgeWitness = Nothing
    , buyerSignedWitness = Nothing
    , paymentSentMessage = Nothing
    , sellerSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PaymentReceivedMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PaymentReceivedMessage :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PaymentReceivedMessage
decodeProto__Io__Haveno__Protobuffer__PaymentReceivedMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PaymentReceivedMessage
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | senderNodeAddress = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | unsignedPayoutTxHex = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | signedPayoutTxHex = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | updatedMultisigHex = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.bool (\a r -> { r | deferPublishPayout = a })
        , Protobuf.Decode.optional
            8
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__AccountAgeWitness)
            (\a r -> { r | buyerAccountAgeWitness = a })
        , Protobuf.Decode.optional
            9
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__SignedWitness)
            (\a r -> { r | buyerSignedWitness = a })
        , Protobuf.Decode.optional
            10
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PaymentSentMessage)
            (\a r -> { r | paymentSentMessage = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.bytes (\a r -> { r | sellerSignature = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PaymentReceivedMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PaymentReceivedMessage :
    Proto__Io__Haveno__Protobuffer__PaymentReceivedMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PaymentReceivedMessage value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.tradeId )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.senderNodeAddress
          )
        , ( 3, Protobuf.Encode.string value.uid )
        , ( 4, Protobuf.Encode.string value.unsignedPayoutTxHex )
        , ( 5, Protobuf.Encode.string value.signedPayoutTxHex )
        , ( 6, Protobuf.Encode.string value.updatedMultisigHex )
        , ( 7, Protobuf.Encode.bool value.deferPublishPayout )
        , ( 8
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__AccountAgeWitness >> Maybe.withDefault Protobuf.Encode.none
            )
                value.buyerAccountAgeWitness
          )
        , ( 9
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__SignedWitness >> Maybe.withDefault Protobuf.Encode.none)
                value.buyerSignedWitness
          )
        , ( 10
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PaymentSentMessage
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.paymentSentMessage
          )
        , ( 11, Protobuf.Encode.bytes value.sellerSignature )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PaymentReceivedMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__PaymentReceivedMessage =
    { tradeId : String
    , senderNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , uid : String
    , unsignedPayoutTxHex : String
    , signedPayoutTxHex : String
    , updatedMultisigHex : String
    , deferPublishPayout : Bool
    , buyerAccountAgeWitness : Maybe Proto__Io__Haveno__Protobuffer__AccountAgeWitness
    , buyerSignedWitness : Maybe Proto__Io__Haveno__Protobuffer__SignedWitness
    , paymentSentMessage : Maybe Proto__Io__Haveno__Protobuffer__PaymentSentMessage
    , sellerSignature : Bytes.Bytes
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PaymentSentMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentSentMessage :
    { tradeId : Int
    , senderNodeAddress : Int
    , counterCurrencyTxId : Int
    , uid : Int
    , counterCurrencyExtraData : Int
    , payoutTxHex : Int
    , updatedMultisigHex : Int
    , paymentAccountKey : Int
    , sellerAccountAgeWitness : Int
    , buyerSignature : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__PaymentSentMessage =
    { tradeId = 1
    , senderNodeAddress = 2
    , counterCurrencyTxId = 3
    , uid = 4
    , counterCurrencyExtraData = 5
    , payoutTxHex = 6
    , updatedMultisigHex = 7
    , paymentAccountKey = 8
    , sellerAccountAgeWitness = 9
    , buyerSignature = 10
    }


{-| Default for Proto__Io__Haveno__Protobuffer__PaymentSentMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PaymentSentMessage : Proto__Io__Haveno__Protobuffer__PaymentSentMessage
defaultProto__Io__Haveno__Protobuffer__PaymentSentMessage =
    { tradeId = ""
    , senderNodeAddress = Nothing
    , counterCurrencyTxId = ""
    , uid = ""
    , counterCurrencyExtraData = ""
    , payoutTxHex = ""
    , updatedMultisigHex = ""
    , paymentAccountKey = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , sellerAccountAgeWitness = Nothing
    , buyerSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PaymentSentMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PaymentSentMessage :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PaymentSentMessage
decodeProto__Io__Haveno__Protobuffer__PaymentSentMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PaymentSentMessage
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | senderNodeAddress = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | counterCurrencyTxId = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | counterCurrencyExtraData = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | payoutTxHex = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | updatedMultisigHex = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.bytes (\a r -> { r | paymentAccountKey = a })
        , Protobuf.Decode.optional
            9
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__AccountAgeWitness)
            (\a r -> { r | sellerAccountAgeWitness = a })
        , Protobuf.Decode.optional 10 Protobuf.Decode.bytes (\a r -> { r | buyerSignature = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PaymentSentMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PaymentSentMessage :
    Proto__Io__Haveno__Protobuffer__PaymentSentMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PaymentSentMessage value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.tradeId )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.senderNodeAddress
          )
        , ( 3, Protobuf.Encode.string value.counterCurrencyTxId )
        , ( 4, Protobuf.Encode.string value.uid )
        , ( 5, Protobuf.Encode.string value.counterCurrencyExtraData )
        , ( 6, Protobuf.Encode.string value.payoutTxHex )
        , ( 7, Protobuf.Encode.string value.updatedMultisigHex )
        , ( 8, Protobuf.Encode.bytes value.paymentAccountKey )
        , ( 9
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__AccountAgeWitness >> Maybe.withDefault Protobuf.Encode.none
            )
                value.sellerAccountAgeWitness
          )
        , ( 10, Protobuf.Encode.bytes value.buyerSignature )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PaymentSentMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__PaymentSentMessage =
    { tradeId : String
    , senderNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , counterCurrencyTxId : String
    , uid : String
    , counterCurrencyExtraData : String
    , payoutTxHex : String
    , updatedMultisigHex : String
    , paymentAccountKey : Bytes.Bytes
    , sellerAccountAgeWitness : Maybe Proto__Io__Haveno__Protobuffer__AccountAgeWitness
    , buyerSignature : Bytes.Bytes
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__DepositsConfirmedMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage :
    { tradeId : Int
    , senderNodeAddress : Int
    , pubKeyRing : Int
    , uid : Int
    , sellerPaymentAccountKey : Int
    , updatedMultisigHex : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage =
    { tradeId = 1, senderNodeAddress = 2, pubKeyRing = 3, uid = 4, sellerPaymentAccountKey = 5, updatedMultisigHex = 6 }


{-| Default for Proto__Io__Haveno__Protobuffer__DepositsConfirmedMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage :
    Proto__Io__Haveno__Protobuffer__DepositsConfirmedMessage
defaultProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage =
    { tradeId = ""
    , senderNodeAddress = Nothing
    , pubKeyRing = Nothing
    , uid = ""
    , sellerPaymentAccountKey = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , updatedMultisigHex = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__DepositsConfirmedMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__DepositsConfirmedMessage
decodeProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | senderNodeAddress = a })
        , Protobuf.Decode.optional
            3
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PubKeyRing)
            (\a r -> { r | pubKeyRing = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.bytes (\a r -> { r | sellerPaymentAccountKey = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | updatedMultisigHex = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__DepositsConfirmedMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage :
    Proto__Io__Haveno__Protobuffer__DepositsConfirmedMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__DepositsConfirmedMessage value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.tradeId )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.senderNodeAddress
          )
        , ( 3
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PubKeyRing >> Maybe.withDefault Protobuf.Encode.none)
                value.pubKeyRing
          )
        , ( 4, Protobuf.Encode.string value.uid )
        , ( 5, Protobuf.Encode.bytes value.sellerPaymentAccountKey )
        , ( 6, Protobuf.Encode.string value.updatedMultisigHex )
        ]


{-| `Proto__Io__Haveno__Protobuffer__DepositsConfirmedMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__DepositsConfirmedMessage =
    { tradeId : String
    , senderNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , pubKeyRing : Maybe Proto__Io__Haveno__Protobuffer__PubKeyRing
    , uid : String
    , sellerPaymentAccountKey : Bytes.Bytes
    , updatedMultisigHex : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__DepositResponse`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__DepositResponse :
    { tradeId : Int
    , uid : Int
    , currentDate : Int
    , errorMessage : Int
    , buyerSecurityDeposit : Int
    , sellerSecurityDeposit : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__DepositResponse =
    { tradeId = 1, uid = 2, currentDate = 3, errorMessage = 4, buyerSecurityDeposit = 5, sellerSecurityDeposit = 6 }


{-| Default for Proto__Io__Haveno__Protobuffer__DepositResponse. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__DepositResponse : Proto__Io__Haveno__Protobuffer__DepositResponse
defaultProto__Io__Haveno__Protobuffer__DepositResponse =
    { tradeId = ""
    , uid = ""
    , currentDate = Protobuf.Types.Int64.fromInts 0 0
    , errorMessage = ""
    , buyerSecurityDeposit = Protobuf.Types.Int64.fromInts 0 0
    , sellerSecurityDeposit = Protobuf.Types.Int64.fromInts 0 0
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__DepositResponse` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__DepositResponse :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__DepositResponse
decodeProto__Io__Haveno__Protobuffer__DepositResponse =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__DepositResponse
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | currentDate = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | errorMessage = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.int64 (\a r -> { r | buyerSecurityDeposit = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.int64 (\a r -> { r | sellerSecurityDeposit = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__DepositResponse` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__DepositResponse :
    Proto__Io__Haveno__Protobuffer__DepositResponse -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__DepositResponse value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.tradeId )
        , ( 2, Protobuf.Encode.string value.uid )
        , ( 3, Protobuf.Encode.int64 value.currentDate )
        , ( 4, Protobuf.Encode.string value.errorMessage )
        , ( 5, Protobuf.Encode.int64 value.buyerSecurityDeposit )
        , ( 6, Protobuf.Encode.int64 value.sellerSecurityDeposit )
        ]


{-| `Proto__Io__Haveno__Protobuffer__DepositResponse` message

-}
type alias Proto__Io__Haveno__Protobuffer__DepositResponse =
    { tradeId : String
    , uid : String
    , currentDate : Protobuf.Types.Int64.Int64
    , errorMessage : String
    , buyerSecurityDeposit : Protobuf.Types.Int64.Int64
    , sellerSecurityDeposit : Protobuf.Types.Int64.Int64
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__DepositRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__DepositRequest :
    { tradeId : Int
    , uid : Int
    , currentDate : Int
    , contractSignature : Int
    , depositTxHex : Int
    , depositTxKey : Int
    , paymentAccountKey : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__DepositRequest =
    { tradeId = 1
    , uid = 2
    , currentDate = 3
    , contractSignature = 4
    , depositTxHex = 5
    , depositTxKey = 6
    , paymentAccountKey = 7
    }


{-| Default for Proto__Io__Haveno__Protobuffer__DepositRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__DepositRequest : Proto__Io__Haveno__Protobuffer__DepositRequest
defaultProto__Io__Haveno__Protobuffer__DepositRequest =
    { tradeId = ""
    , uid = ""
    , currentDate = Protobuf.Types.Int64.fromInts 0 0
    , contractSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , depositTxHex = ""
    , depositTxKey = ""
    , paymentAccountKey = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__DepositRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__DepositRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__DepositRequest
decodeProto__Io__Haveno__Protobuffer__DepositRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__DepositRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | currentDate = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.bytes (\a r -> { r | contractSignature = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | depositTxHex = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | depositTxKey = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.bytes (\a r -> { r | paymentAccountKey = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__DepositRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__DepositRequest :
    Proto__Io__Haveno__Protobuffer__DepositRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__DepositRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.tradeId )
        , ( 2, Protobuf.Encode.string value.uid )
        , ( 3, Protobuf.Encode.int64 value.currentDate )
        , ( 4, Protobuf.Encode.bytes value.contractSignature )
        , ( 5, Protobuf.Encode.string value.depositTxHex )
        , ( 6, Protobuf.Encode.string value.depositTxKey )
        , ( 7, Protobuf.Encode.bytes value.paymentAccountKey )
        ]


{-| `Proto__Io__Haveno__Protobuffer__DepositRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__DepositRequest =
    { tradeId : String
    , uid : String
    , currentDate : Protobuf.Types.Int64.Int64
    , contractSignature : Bytes.Bytes
    , depositTxHex : String
    , depositTxKey : String
    , paymentAccountKey : Bytes.Bytes
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SignContractResponse`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SignContractResponse :
    { tradeId : Int
    , uid : Int
    , currentDate : Int
    , contractAsJson : Int
    , contractSignature : Int
    , encryptedPaymentAccountPayload : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__SignContractResponse =
    { tradeId = 1
    , uid = 2
    , currentDate = 3
    , contractAsJson = 4
    , contractSignature = 5
    , encryptedPaymentAccountPayload = 6
    }


{-| Default for Proto__Io__Haveno__Protobuffer__SignContractResponse. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SignContractResponse : Proto__Io__Haveno__Protobuffer__SignContractResponse
defaultProto__Io__Haveno__Protobuffer__SignContractResponse =
    { tradeId = ""
    , uid = ""
    , currentDate = Protobuf.Types.Int64.fromInts 0 0
    , contractAsJson = ""
    , contractSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , encryptedPaymentAccountPayload = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SignContractResponse` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SignContractResponse :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SignContractResponse
decodeProto__Io__Haveno__Protobuffer__SignContractResponse =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SignContractResponse
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | currentDate = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | contractAsJson = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.bytes (\a r -> { r | contractSignature = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.bytes (\a r -> { r | encryptedPaymentAccountPayload = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SignContractResponse` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SignContractResponse :
    Proto__Io__Haveno__Protobuffer__SignContractResponse -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SignContractResponse value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.tradeId )
        , ( 2, Protobuf.Encode.string value.uid )
        , ( 3, Protobuf.Encode.int64 value.currentDate )
        , ( 4, Protobuf.Encode.string value.contractAsJson )
        , ( 5, Protobuf.Encode.bytes value.contractSignature )
        , ( 6, Protobuf.Encode.bytes value.encryptedPaymentAccountPayload )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SignContractResponse` message

-}
type alias Proto__Io__Haveno__Protobuffer__SignContractResponse =
    { tradeId : String
    , uid : String
    , currentDate : Protobuf.Types.Int64.Int64
    , contractAsJson : String
    , contractSignature : Bytes.Bytes
    , encryptedPaymentAccountPayload : Bytes.Bytes
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SignContractRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SignContractRequest :
    { tradeId : Int
    , uid : Int
    , currentDate : Int
    , accountId : Int
    , paymentAccountPayloadHash : Int
    , payoutAddress : Int
    , depositTxHash : Int
    , accountAgeWitnessSignatureOfDepositHash : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__SignContractRequest =
    { tradeId = 1
    , uid = 2
    , currentDate = 3
    , accountId = 4
    , paymentAccountPayloadHash = 5
    , payoutAddress = 6
    , depositTxHash = 7
    , accountAgeWitnessSignatureOfDepositHash = 8
    }


{-| Default for Proto__Io__Haveno__Protobuffer__SignContractRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SignContractRequest : Proto__Io__Haveno__Protobuffer__SignContractRequest
defaultProto__Io__Haveno__Protobuffer__SignContractRequest =
    { tradeId = ""
    , uid = ""
    , currentDate = Protobuf.Types.Int64.fromInts 0 0
    , accountId = ""
    , paymentAccountPayloadHash = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , payoutAddress = ""
    , depositTxHash = ""
    , accountAgeWitnessSignatureOfDepositHash = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SignContractRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SignContractRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SignContractRequest
decodeProto__Io__Haveno__Protobuffer__SignContractRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SignContractRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | currentDate = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | accountId = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.bytes (\a r -> { r | paymentAccountPayloadHash = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | payoutAddress = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | depositTxHash = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.bytes (\a r -> { r | accountAgeWitnessSignatureOfDepositHash = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SignContractRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SignContractRequest :
    Proto__Io__Haveno__Protobuffer__SignContractRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SignContractRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.tradeId )
        , ( 2, Protobuf.Encode.string value.uid )
        , ( 3, Protobuf.Encode.int64 value.currentDate )
        , ( 4, Protobuf.Encode.string value.accountId )
        , ( 5, Protobuf.Encode.bytes value.paymentAccountPayloadHash )
        , ( 6, Protobuf.Encode.string value.payoutAddress )
        , ( 7, Protobuf.Encode.string value.depositTxHash )
        , ( 8, Protobuf.Encode.bytes value.accountAgeWitnessSignatureOfDepositHash )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SignContractRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__SignContractRequest =
    { tradeId : String
    , uid : String
    , currentDate : Protobuf.Types.Int64.Int64
    , accountId : String
    , paymentAccountPayloadHash : Bytes.Bytes
    , payoutAddress : String
    , depositTxHash : String
    , accountAgeWitnessSignatureOfDepositHash : Bytes.Bytes
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__InitMultisigRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__InitMultisigRequest :
    { tradeId : Int
    , uid : Int
    , currentDate : Int
    , preparedMultisigHex : Int
    , madeMultisigHex : Int
    , exchangedMultisigHex : Int
    , tradeFeeAddress : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__InitMultisigRequest =
    { tradeId = 1
    , uid = 2
    , currentDate = 3
    , preparedMultisigHex = 4
    , madeMultisigHex = 5
    , exchangedMultisigHex = 6
    , tradeFeeAddress = 7
    }


{-| Default for Proto__Io__Haveno__Protobuffer__InitMultisigRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__InitMultisigRequest : Proto__Io__Haveno__Protobuffer__InitMultisigRequest
defaultProto__Io__Haveno__Protobuffer__InitMultisigRequest =
    { tradeId = ""
    , uid = ""
    , currentDate = Protobuf.Types.Int64.fromInts 0 0
    , preparedMultisigHex = ""
    , madeMultisigHex = ""
    , exchangedMultisigHex = ""
    , tradeFeeAddress = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__InitMultisigRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__InitMultisigRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__InitMultisigRequest
decodeProto__Io__Haveno__Protobuffer__InitMultisigRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__InitMultisigRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | currentDate = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | preparedMultisigHex = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | madeMultisigHex = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | exchangedMultisigHex = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | tradeFeeAddress = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__InitMultisigRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__InitMultisigRequest :
    Proto__Io__Haveno__Protobuffer__InitMultisigRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__InitMultisigRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.tradeId )
        , ( 2, Protobuf.Encode.string value.uid )
        , ( 3, Protobuf.Encode.int64 value.currentDate )
        , ( 4, Protobuf.Encode.string value.preparedMultisigHex )
        , ( 5, Protobuf.Encode.string value.madeMultisigHex )
        , ( 6, Protobuf.Encode.string value.exchangedMultisigHex )
        , ( 7, Protobuf.Encode.string value.tradeFeeAddress )
        ]


{-| `Proto__Io__Haveno__Protobuffer__InitMultisigRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__InitMultisigRequest =
    { tradeId : String
    , uid : String
    , currentDate : Protobuf.Types.Int64.Int64
    , preparedMultisigHex : String
    , madeMultisigHex : String
    , exchangedMultisigHex : String
    , tradeFeeAddress : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__InitTradeRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__InitTradeRequest :
    { tradeProtocolVersion : Int
    , offerId : Int
    , tradeAmount : Int
    , tradePrice : Int
    , paymentMethodId : Int
    , makerAccountId : Int
    , takerAccountId : Int
    , makerPaymentAccountId : Int
    , takerPaymentAccountId : Int
    , takerPubKeyRing : Int
    , uid : Int
    , accountAgeWitnessSignatureOfOfferId : Int
    , currentDate : Int
    , makerNodeAddress : Int
    , takerNodeAddress : Int
    , arbitratorNodeAddress : Int
    , reserveTxHash : Int
    , reserveTxHex : Int
    , reserveTxKey : Int
    , payoutAddress : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__InitTradeRequest =
    { tradeProtocolVersion = 1
    , offerId = 2
    , tradeAmount = 3
    , tradePrice = 4
    , paymentMethodId = 5
    , makerAccountId = 6
    , takerAccountId = 7
    , makerPaymentAccountId = 8
    , takerPaymentAccountId = 9
    , takerPubKeyRing = 10
    , uid = 11
    , accountAgeWitnessSignatureOfOfferId = 12
    , currentDate = 13
    , makerNodeAddress = 14
    , takerNodeAddress = 15
    , arbitratorNodeAddress = 16
    , reserveTxHash = 17
    , reserveTxHex = 18
    , reserveTxKey = 19
    , payoutAddress = 20
    }


{-| Default for Proto__Io__Haveno__Protobuffer__InitTradeRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__InitTradeRequest : Proto__Io__Haveno__Protobuffer__InitTradeRequest
defaultProto__Io__Haveno__Protobuffer__InitTradeRequest =
    { tradeProtocolVersion = Proto.Io.Haveno.Protobuffer.TradeProtocolVersion.defaultTradeProtocolVersion
    , offerId = ""
    , tradeAmount = Protobuf.Types.Int64.fromInts 0 0
    , tradePrice = Protobuf.Types.Int64.fromInts 0 0
    , paymentMethodId = ""
    , makerAccountId = ""
    , takerAccountId = ""
    , makerPaymentAccountId = ""
    , takerPaymentAccountId = ""
    , takerPubKeyRing = Nothing
    , uid = ""
    , accountAgeWitnessSignatureOfOfferId = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , currentDate = Protobuf.Types.Int64.fromInts 0 0
    , makerNodeAddress = Nothing
    , takerNodeAddress = Nothing
    , arbitratorNodeAddress = Nothing
    , reserveTxHash = ""
    , reserveTxHex = ""
    , reserveTxKey = ""
    , payoutAddress = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__InitTradeRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__InitTradeRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__InitTradeRequest
decodeProto__Io__Haveno__Protobuffer__InitTradeRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__InitTradeRequest
        [ Protobuf.Decode.optional
            1
            Proto.Io.Haveno.Protobuffer.TradeProtocolVersion.decodeTradeProtocolVersion
            (\a r -> { r | tradeProtocolVersion = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | offerId = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | tradeAmount = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.int64 (\a r -> { r | tradePrice = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | paymentMethodId = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | makerAccountId = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.string (\a r -> { r | takerAccountId = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.string (\a r -> { r | makerPaymentAccountId = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.string (\a r -> { r | takerPaymentAccountId = a })
        , Protobuf.Decode.optional
            10
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PubKeyRing)
            (\a r -> { r | takerPubKeyRing = a })
        , Protobuf.Decode.optional 11 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional 12 Protobuf.Decode.bytes (\a r -> { r | accountAgeWitnessSignatureOfOfferId = a })
        , Protobuf.Decode.optional 13 Protobuf.Decode.int64 (\a r -> { r | currentDate = a })
        , Protobuf.Decode.optional
            14
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | makerNodeAddress = a })
        , Protobuf.Decode.optional
            15
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | takerNodeAddress = a })
        , Protobuf.Decode.optional
            16
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | arbitratorNodeAddress = a })
        , Protobuf.Decode.optional 17 Protobuf.Decode.string (\a r -> { r | reserveTxHash = a })
        , Protobuf.Decode.optional 18 Protobuf.Decode.string (\a r -> { r | reserveTxHex = a })
        , Protobuf.Decode.optional 19 Protobuf.Decode.string (\a r -> { r | reserveTxKey = a })
        , Protobuf.Decode.optional 20 Protobuf.Decode.string (\a r -> { r | payoutAddress = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__InitTradeRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__InitTradeRequest :
    Proto__Io__Haveno__Protobuffer__InitTradeRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__InitTradeRequest value =
    Protobuf.Encode.message
        [ ( 1, Proto.Io.Haveno.Protobuffer.TradeProtocolVersion.encodeTradeProtocolVersion value.tradeProtocolVersion )
        , ( 2, Protobuf.Encode.string value.offerId )
        , ( 3, Protobuf.Encode.int64 value.tradeAmount )
        , ( 4, Protobuf.Encode.int64 value.tradePrice )
        , ( 5, Protobuf.Encode.string value.paymentMethodId )
        , ( 6, Protobuf.Encode.string value.makerAccountId )
        , ( 7, Protobuf.Encode.string value.takerAccountId )
        , ( 8, Protobuf.Encode.string value.makerPaymentAccountId )
        , ( 9, Protobuf.Encode.string value.takerPaymentAccountId )
        , ( 10
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PubKeyRing >> Maybe.withDefault Protobuf.Encode.none)
                value.takerPubKeyRing
          )
        , ( 11, Protobuf.Encode.string value.uid )
        , ( 12, Protobuf.Encode.bytes value.accountAgeWitnessSignatureOfOfferId )
        , ( 13, Protobuf.Encode.int64 value.currentDate )
        , ( 14
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.makerNodeAddress
          )
        , ( 15
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.takerNodeAddress
          )
        , ( 16
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.arbitratorNodeAddress
          )
        , ( 17, Protobuf.Encode.string value.reserveTxHash )
        , ( 18, Protobuf.Encode.string value.reserveTxHex )
        , ( 19, Protobuf.Encode.string value.reserveTxKey )
        , ( 20, Protobuf.Encode.string value.payoutAddress )
        ]


{-| `Proto__Io__Haveno__Protobuffer__InitTradeRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__InitTradeRequest =
    { tradeProtocolVersion : Proto.Io.Haveno.Protobuffer.TradeProtocolVersion.TradeProtocolVersion
    , offerId : String
    , tradeAmount : Protobuf.Types.Int64.Int64
    , tradePrice : Protobuf.Types.Int64.Int64
    , paymentMethodId : String
    , makerAccountId : String
    , takerAccountId : String
    , makerPaymentAccountId : String
    , takerPaymentAccountId : String
    , takerPubKeyRing : Maybe Proto__Io__Haveno__Protobuffer__PubKeyRing
    , uid : String
    , accountAgeWitnessSignatureOfOfferId : Bytes.Bytes
    , currentDate : Protobuf.Types.Int64.Int64
    , makerNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , takerNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , arbitratorNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , reserveTxHash : String
    , reserveTxHex : String
    , reserveTxKey : String
    , payoutAddress : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage :
    { nodeAddress : Int, sealedAndSigned : Int, addressPrefixHash : Int, uid : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage =
    { nodeAddress = 1, sealedAndSigned = 2, addressPrefixHash = 3, uid = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage :
    Proto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage
defaultProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage =
    { nodeAddress = Nothing
    , sealedAndSigned = Nothing
    , addressPrefixHash = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , uid = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage
decodeProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | nodeAddress = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__SealedAndSigned)
            (\a r -> { r | sealedAndSigned = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.bytes (\a r -> { r | addressPrefixHash = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | uid = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage :
    Proto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.nodeAddress
          )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__SealedAndSigned >> Maybe.withDefault Protobuf.Encode.none)
                value.sealedAndSigned
          )
        , ( 3, Protobuf.Encode.bytes value.addressPrefixHash )
        , ( 4, Protobuf.Encode.string value.uid )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__PrefixedSealedAndSignedMessage =
    { nodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , sealedAndSigned : Maybe Proto__Io__Haveno__Protobuffer__SealedAndSigned
    , addressPrefixHash : Bytes.Bytes
    , uid : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AckMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AckMessage :
    { uid : Int
    , senderNodeAddress : Int
    , sourceType : Int
    , sourceMsgClassName : Int
    , sourceUid : Int
    , sourceId : Int
    , success : Int
    , errorMessage : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__AckMessage =
    { uid = 1
    , senderNodeAddress = 2
    , sourceType = 3
    , sourceMsgClassName = 4
    , sourceUid = 5
    , sourceId = 6
    , success = 7
    , errorMessage = 8
    }


{-| Default for Proto__Io__Haveno__Protobuffer__AckMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AckMessage : Proto__Io__Haveno__Protobuffer__AckMessage
defaultProto__Io__Haveno__Protobuffer__AckMessage =
    { uid = ""
    , senderNodeAddress = Nothing
    , sourceType = ""
    , sourceMsgClassName = ""
    , sourceUid = ""
    , sourceId = ""
    , success = False
    , errorMessage = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AckMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AckMessage : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AckMessage
decodeProto__Io__Haveno__Protobuffer__AckMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AckMessage
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | senderNodeAddress = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | sourceType = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | sourceMsgClassName = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | sourceUid = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | sourceId = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.bool (\a r -> { r | success = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.string (\a r -> { r | errorMessage = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AckMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AckMessage : Proto__Io__Haveno__Protobuffer__AckMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AckMessage value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.uid )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.senderNodeAddress
          )
        , ( 3, Protobuf.Encode.string value.sourceType )
        , ( 4, Protobuf.Encode.string value.sourceMsgClassName )
        , ( 5, Protobuf.Encode.string value.sourceUid )
        , ( 6, Protobuf.Encode.string value.sourceId )
        , ( 7, Protobuf.Encode.bool value.success )
        , ( 8, Protobuf.Encode.string value.errorMessage )
        ]


{-| `Proto__Io__Haveno__Protobuffer__AckMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__AckMessage =
    { uid : String
    , senderNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , sourceType : String
    , sourceMsgClassName : String
    , sourceUid : String
    , sourceId : String
    , success : Bool
    , errorMessage : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__CloseConnectionMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__CloseConnectionMessage : { reason : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__CloseConnectionMessage =
    { reason = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__CloseConnectionMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__CloseConnectionMessage : Proto__Io__Haveno__Protobuffer__CloseConnectionMessage
defaultProto__Io__Haveno__Protobuffer__CloseConnectionMessage =
    { reason = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__CloseConnectionMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__CloseConnectionMessage :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__CloseConnectionMessage
decodeProto__Io__Haveno__Protobuffer__CloseConnectionMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__CloseConnectionMessage
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | reason = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__CloseConnectionMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__CloseConnectionMessage :
    Proto__Io__Haveno__Protobuffer__CloseConnectionMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__CloseConnectionMessage value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.reason ) ]


{-| `Proto__Io__Haveno__Protobuffer__CloseConnectionMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__CloseConnectionMessage =
    { reason : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage : { payload : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage =
    { payload = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage :
    Proto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage
defaultProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage =
    { payload = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage
decodeProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload)
            (\a r -> { r | payload = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage :
    Proto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.payload
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__AddPersistableNetworkPayloadMessage =
    { payload : Maybe Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage : { protectedStorageEntry : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage =
    { protectedStorageEntry = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage :
    Proto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage
defaultProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage =
    { protectedStorageEntry = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage
decodeProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry)
            (\a r -> { r | protectedStorageEntry = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage :
    Proto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.protectedStorageEntry
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__RemoveMailboxDataMessage =
    { protectedStorageEntry : Maybe Proto__Io__Haveno__Protobuffer__ProtectedMailboxStorageEntry }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RemoveDataMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RemoveDataMessage : { protectedStorageEntry : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__RemoveDataMessage =
    { protectedStorageEntry = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__RemoveDataMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RemoveDataMessage : Proto__Io__Haveno__Protobuffer__RemoveDataMessage
defaultProto__Io__Haveno__Protobuffer__RemoveDataMessage =
    { protectedStorageEntry = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RemoveDataMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RemoveDataMessage :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RemoveDataMessage
decodeProto__Io__Haveno__Protobuffer__RemoveDataMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__RemoveDataMessage
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__ProtectedStorageEntry)
            (\a r -> { r | protectedStorageEntry = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RemoveDataMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RemoveDataMessage :
    Proto__Io__Haveno__Protobuffer__RemoveDataMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RemoveDataMessage value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__ProtectedStorageEntry
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.protectedStorageEntry
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__RemoveDataMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__RemoveDataMessage =
    { protectedStorageEntry : Maybe Proto__Io__Haveno__Protobuffer__ProtectedStorageEntry }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__AddDataMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__AddDataMessage : { entry : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__AddDataMessage =
    { entry = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__AddDataMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__AddDataMessage : Proto__Io__Haveno__Protobuffer__AddDataMessage
defaultProto__Io__Haveno__Protobuffer__AddDataMessage =
    { entry = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__AddDataMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__AddDataMessage :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__AddDataMessage
decodeProto__Io__Haveno__Protobuffer__AddDataMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__AddDataMessage
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper)
            (\a r -> { r | entry = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__AddDataMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__AddDataMessage :
    Proto__Io__Haveno__Protobuffer__AddDataMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__AddDataMessage value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper
                >> Maybe.withDefault Protobuf.Encode.none
            )
                value.entry
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__AddDataMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__AddDataMessage =
    { entry : Maybe Proto__Io__Haveno__Protobuffer__StorageEntryWrapper }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__RefreshOfferMessage`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__RefreshOfferMessage :
    { hashOfDataAndSeqNr : Int, signature : Int, hashOfPayload : Int, sequenceNumber : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__RefreshOfferMessage =
    { hashOfDataAndSeqNr = 1, signature = 2, hashOfPayload = 3, sequenceNumber = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__RefreshOfferMessage. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__RefreshOfferMessage : Proto__Io__Haveno__Protobuffer__RefreshOfferMessage
defaultProto__Io__Haveno__Protobuffer__RefreshOfferMessage =
    { hashOfDataAndSeqNr = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , signature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , hashOfPayload = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    , sequenceNumber = 0
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__RefreshOfferMessage` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__RefreshOfferMessage :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__RefreshOfferMessage
decodeProto__Io__Haveno__Protobuffer__RefreshOfferMessage =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__RefreshOfferMessage
        [ Protobuf.Decode.optional 1 Protobuf.Decode.bytes (\a r -> { r | hashOfDataAndSeqNr = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.bytes (\a r -> { r | signature = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.bytes (\a r -> { r | hashOfPayload = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.int32 (\a r -> { r | sequenceNumber = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__RefreshOfferMessage` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__RefreshOfferMessage :
    Proto__Io__Haveno__Protobuffer__RefreshOfferMessage -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__RefreshOfferMessage value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.bytes value.hashOfDataAndSeqNr )
        , ( 2, Protobuf.Encode.bytes value.signature )
        , ( 3, Protobuf.Encode.bytes value.hashOfPayload )
        , ( 4, Protobuf.Encode.int32 value.sequenceNumber )
        ]


{-| `Proto__Io__Haveno__Protobuffer__RefreshOfferMessage` message

-}
type alias Proto__Io__Haveno__Protobuffer__RefreshOfferMessage =
    { hashOfDataAndSeqNr : Bytes.Bytes, signature : Bytes.Bytes, hashOfPayload : Bytes.Bytes, sequenceNumber : Int }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__OfferAvailabilityResponse`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse :
    { offerId : Int, availabilityResult : Int, supportedCapabilities : Int, uid : Int, makerSignature : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse =
    { offerId = 1, availabilityResult = 2, supportedCapabilities = 3, uid = 4, makerSignature = 5 }


{-| Default for Proto__Io__Haveno__Protobuffer__OfferAvailabilityResponse. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse :
    Proto__Io__Haveno__Protobuffer__OfferAvailabilityResponse
defaultProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse =
    { offerId = ""
    , availabilityResult = Proto.Io.Haveno.Protobuffer.AvailabilityResult.defaultAvailabilityResult
    , supportedCapabilities = []
    , uid = ""
    , makerSignature = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__OfferAvailabilityResponse` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__OfferAvailabilityResponse
decodeProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | offerId = a })
        , Protobuf.Decode.optional
            2
            Proto.Io.Haveno.Protobuffer.AvailabilityResult.decodeAvailabilityResult
            (\a r -> { r | availabilityResult = a })
        , Protobuf.Decode.repeated
            3
            Protobuf.Decode.int32
            .supportedCapabilities
            (\a r -> { r | supportedCapabilities = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.bytes (\a r -> { r | makerSignature = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__OfferAvailabilityResponse` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse :
    Proto__Io__Haveno__Protobuffer__OfferAvailabilityResponse -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__OfferAvailabilityResponse value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.offerId )
        , ( 2, Proto.Io.Haveno.Protobuffer.AvailabilityResult.encodeAvailabilityResult value.availabilityResult )
        , ( 3, (Protobuf.Encode.list Protobuf.Encode.int32) value.supportedCapabilities )
        , ( 4, Protobuf.Encode.string value.uid )
        , ( 5, Protobuf.Encode.bytes value.makerSignature )
        ]


{-| `Proto__Io__Haveno__Protobuffer__OfferAvailabilityResponse` message

-}
type alias Proto__Io__Haveno__Protobuffer__OfferAvailabilityResponse =
    { offerId : String
    , availabilityResult : Proto.Io.Haveno.Protobuffer.AvailabilityResult.AvailabilityResult
    , supportedCapabilities : List Int
    , uid : String
    , makerSignature : Bytes.Bytes
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__OfferAvailabilityRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest :
    { offerId : Int
    , pubKeyRing : Int
    , takersTradePrice : Int
    , supportedCapabilities : Int
    , uid : Int
    , isTakerApiUser : Int
    , tradeRequest : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest =
    { offerId = 1
    , pubKeyRing = 2
    , takersTradePrice = 3
    , supportedCapabilities = 4
    , uid = 5
    , isTakerApiUser = 6
    , tradeRequest = 7
    }


{-| Default for Proto__Io__Haveno__Protobuffer__OfferAvailabilityRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest :
    Proto__Io__Haveno__Protobuffer__OfferAvailabilityRequest
defaultProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest =
    { offerId = ""
    , pubKeyRing = Nothing
    , takersTradePrice = Protobuf.Types.Int64.fromInts 0 0
    , supportedCapabilities = []
    , uid = ""
    , isTakerApiUser = False
    , tradeRequest = Nothing
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__OfferAvailabilityRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__OfferAvailabilityRequest
decodeProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | offerId = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PubKeyRing)
            (\a r -> { r | pubKeyRing = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.int64 (\a r -> { r | takersTradePrice = a })
        , Protobuf.Decode.repeated
            4
            Protobuf.Decode.int32
            .supportedCapabilities
            (\a r -> { r | supportedCapabilities = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.bool (\a r -> { r | isTakerApiUser = a })
        , Protobuf.Decode.optional
            7
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__InitTradeRequest)
            (\a r -> { r | tradeRequest = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__OfferAvailabilityRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest :
    Proto__Io__Haveno__Protobuffer__OfferAvailabilityRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__OfferAvailabilityRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.offerId )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PubKeyRing >> Maybe.withDefault Protobuf.Encode.none)
                value.pubKeyRing
          )
        , ( 3, Protobuf.Encode.int64 value.takersTradePrice )
        , ( 4, (Protobuf.Encode.list Protobuf.Encode.int32) value.supportedCapabilities )
        , ( 5, Protobuf.Encode.string value.uid )
        , ( 6, Protobuf.Encode.bool value.isTakerApiUser )
        , ( 7
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__InitTradeRequest >> Maybe.withDefault Protobuf.Encode.none)
                value.tradeRequest
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__OfferAvailabilityRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__OfferAvailabilityRequest =
    { offerId : String
    , pubKeyRing : Maybe Proto__Io__Haveno__Protobuffer__PubKeyRing
    , takersTradePrice : Protobuf.Types.Int64.Int64
    , supportedCapabilities : List Int
    , uid : String
    , isTakerApiUser : Bool
    , tradeRequest : Maybe Proto__Io__Haveno__Protobuffer__InitTradeRequest
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SignOfferResponse`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SignOfferResponse : { offerId : Int, uid : Int, signedOfferPayload : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__SignOfferResponse =
    { offerId = 1, uid = 2, signedOfferPayload = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__SignOfferResponse. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SignOfferResponse : Proto__Io__Haveno__Protobuffer__SignOfferResponse
defaultProto__Io__Haveno__Protobuffer__SignOfferResponse =
    { offerId = "", uid = "", signedOfferPayload = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SignOfferResponse` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SignOfferResponse :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SignOfferResponse
decodeProto__Io__Haveno__Protobuffer__SignOfferResponse =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SignOfferResponse
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | offerId = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional
            3
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__OfferPayload)
            (\a r -> { r | signedOfferPayload = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SignOfferResponse` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SignOfferResponse :
    Proto__Io__Haveno__Protobuffer__SignOfferResponse -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SignOfferResponse value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.offerId )
        , ( 2, Protobuf.Encode.string value.uid )
        , ( 3
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__OfferPayload >> Maybe.withDefault Protobuf.Encode.none)
                value.signedOfferPayload
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SignOfferResponse` message

-}
type alias Proto__Io__Haveno__Protobuffer__SignOfferResponse =
    { offerId : String, uid : String, signedOfferPayload : Maybe Proto__Io__Haveno__Protobuffer__OfferPayload }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__SignOfferRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__SignOfferRequest :
    { offerId : Int
    , senderNodeAddress : Int
    , pubKeyRing : Int
    , senderAccountId : Int
    , offerPayload : Int
    , uid : Int
    , currentDate : Int
    , reserveTxHash : Int
    , reserveTxHex : Int
    , reserveTxKey : Int
    , reserveTxKeyImages : Int
    , payoutAddress : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__SignOfferRequest =
    { offerId = 1
    , senderNodeAddress = 2
    , pubKeyRing = 3
    , senderAccountId = 4
    , offerPayload = 5
    , uid = 6
    , currentDate = 7
    , reserveTxHash = 8
    , reserveTxHex = 9
    , reserveTxKey = 10
    , reserveTxKeyImages = 11
    , payoutAddress = 12
    }


{-| Default for Proto__Io__Haveno__Protobuffer__SignOfferRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__SignOfferRequest : Proto__Io__Haveno__Protobuffer__SignOfferRequest
defaultProto__Io__Haveno__Protobuffer__SignOfferRequest =
    { offerId = ""
    , senderNodeAddress = Nothing
    , pubKeyRing = Nothing
    , senderAccountId = ""
    , offerPayload = Nothing
    , uid = ""
    , currentDate = Protobuf.Types.Int64.fromInts 0 0
    , reserveTxHash = ""
    , reserveTxHex = ""
    , reserveTxKey = ""
    , reserveTxKeyImages = []
    , payoutAddress = ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__SignOfferRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__SignOfferRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__SignOfferRequest
decodeProto__Io__Haveno__Protobuffer__SignOfferRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__SignOfferRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | offerId = a })
        , Protobuf.Decode.optional
            2
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | senderNodeAddress = a })
        , Protobuf.Decode.optional
            3
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__PubKeyRing)
            (\a r -> { r | pubKeyRing = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | senderAccountId = a })
        , Protobuf.Decode.optional
            5
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__OfferPayload)
            (\a r -> { r | offerPayload = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional 7 Protobuf.Decode.int64 (\a r -> { r | currentDate = a })
        , Protobuf.Decode.optional 8 Protobuf.Decode.string (\a r -> { r | reserveTxHash = a })
        , Protobuf.Decode.optional 9 Protobuf.Decode.string (\a r -> { r | reserveTxHex = a })
        , Protobuf.Decode.optional 10 Protobuf.Decode.string (\a r -> { r | reserveTxKey = a })
        , Protobuf.Decode.repeated
            11
            Protobuf.Decode.string
            .reserveTxKeyImages
            (\a r -> { r | reserveTxKeyImages = a })
        , Protobuf.Decode.optional 12 Protobuf.Decode.string (\a r -> { r | payoutAddress = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__SignOfferRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__SignOfferRequest :
    Proto__Io__Haveno__Protobuffer__SignOfferRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__SignOfferRequest value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.offerId )
        , ( 2
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.senderNodeAddress
          )
        , ( 3
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__PubKeyRing >> Maybe.withDefault Protobuf.Encode.none)
                value.pubKeyRing
          )
        , ( 4, Protobuf.Encode.string value.senderAccountId )
        , ( 5
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__OfferPayload >> Maybe.withDefault Protobuf.Encode.none)
                value.offerPayload
          )
        , ( 6, Protobuf.Encode.string value.uid )
        , ( 7, Protobuf.Encode.int64 value.currentDate )
        , ( 8, Protobuf.Encode.string value.reserveTxHash )
        , ( 9, Protobuf.Encode.string value.reserveTxHex )
        , ( 10, Protobuf.Encode.string value.reserveTxKey )
        , ( 11, (Protobuf.Encode.list Protobuf.Encode.string) value.reserveTxKeyImages )
        , ( 12, Protobuf.Encode.string value.payoutAddress )
        ]


{-| `Proto__Io__Haveno__Protobuffer__SignOfferRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__SignOfferRequest =
    { offerId : String
    , senderNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , pubKeyRing : Maybe Proto__Io__Haveno__Protobuffer__PubKeyRing
    , senderAccountId : String
    , offerPayload : Maybe Proto__Io__Haveno__Protobuffer__OfferPayload
    , uid : String
    , currentDate : Protobuf.Types.Int64.Int64
    , reserveTxHash : String
    , reserveTxHex : String
    , reserveTxKey : String
    , reserveTxKeyImages : List String
    , payoutAddress : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetInventoryResponse`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetInventoryResponse : { inventory : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetInventoryResponse =
    { inventory = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetInventoryResponse. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetInventoryResponse : Proto__Io__Haveno__Protobuffer__GetInventoryResponse
defaultProto__Io__Haveno__Protobuffer__GetInventoryResponse =
    { inventory = Dict.empty }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetInventoryResponse` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetInventoryResponse :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetInventoryResponse
decodeProto__Io__Haveno__Protobuffer__GetInventoryResponse =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetInventoryResponse
        [ Protobuf.Decode.mapped
            1
            ( "", "" )
            Protobuf.Decode.string
            Protobuf.Decode.string
            .inventory
            (\a r -> { r | inventory = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetInventoryResponse` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetInventoryResponse :
    Proto__Io__Haveno__Protobuffer__GetInventoryResponse -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetInventoryResponse value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.dict Protobuf.Encode.string Protobuf.Encode.string value.inventory ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetInventoryResponse` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetInventoryResponse =
    { inventory : Dict.Dict String String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetInventoryRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetInventoryRequest : { version : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetInventoryRequest =
    { version = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetInventoryRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetInventoryRequest : Proto__Io__Haveno__Protobuffer__GetInventoryRequest
defaultProto__Io__Haveno__Protobuffer__GetInventoryRequest =
    { version = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetInventoryRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetInventoryRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetInventoryRequest
decodeProto__Io__Haveno__Protobuffer__GetInventoryRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetInventoryRequest
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | version = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetInventoryRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetInventoryRequest :
    Proto__Io__Haveno__Protobuffer__GetInventoryRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetInventoryRequest value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.string value.version ) ]


{-| `Proto__Io__Haveno__Protobuffer__GetInventoryRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetInventoryRequest =
    { version : String }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Pong`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Pong : { requestNonce : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__Pong =
    { requestNonce = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__Pong. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__Pong : Proto__Io__Haveno__Protobuffer__Pong
defaultProto__Io__Haveno__Protobuffer__Pong =
    { requestNonce = 0 }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Pong` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Pong : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__Pong
decodeProto__Io__Haveno__Protobuffer__Pong =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__Pong
        [ Protobuf.Decode.optional 1 Protobuf.Decode.int32 (\a r -> { r | requestNonce = a }) ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Pong` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Pong : Proto__Io__Haveno__Protobuffer__Pong -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__Pong value =
    Protobuf.Encode.message [ ( 1, Protobuf.Encode.int32 value.requestNonce ) ]


{-| `Proto__Io__Haveno__Protobuffer__Pong` message

-}
type alias Proto__Io__Haveno__Protobuffer__Pong =
    { requestNonce : Int }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__Ping`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__Ping : { nonce : Int, lastRoundTripTime : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__Ping =
    { nonce = 1, lastRoundTripTime = 2 }


{-| Default for Proto__Io__Haveno__Protobuffer__Ping. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__Ping : Proto__Io__Haveno__Protobuffer__Ping
defaultProto__Io__Haveno__Protobuffer__Ping =
    { nonce = 0, lastRoundTripTime = 0 }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__Ping` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__Ping : Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__Ping
decodeProto__Io__Haveno__Protobuffer__Ping =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__Ping
        [ Protobuf.Decode.optional 1 Protobuf.Decode.int32 (\a r -> { r | nonce = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int32 (\a r -> { r | lastRoundTripTime = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__Ping` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__Ping : Proto__Io__Haveno__Protobuffer__Ping -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__Ping value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.int32 value.nonce ), ( 2, Protobuf.Encode.int32 value.lastRoundTripTime ) ]


{-| `Proto__Io__Haveno__Protobuffer__Ping` message

-}
type alias Proto__Io__Haveno__Protobuffer__Ping =
    { nonce : Int, lastRoundTripTime : Int }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetPeersResponse`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetPeersResponse :
    { requestNonce : Int, reportedPeers : Int, supportedCapabilities : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetPeersResponse =
    { requestNonce = 1, reportedPeers = 2, supportedCapabilities = 3 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetPeersResponse. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetPeersResponse : Proto__Io__Haveno__Protobuffer__GetPeersResponse
defaultProto__Io__Haveno__Protobuffer__GetPeersResponse =
    { requestNonce = 0, reportedPeers = [], supportedCapabilities = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetPeersResponse` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetPeersResponse :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetPeersResponse
decodeProto__Io__Haveno__Protobuffer__GetPeersResponse =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetPeersResponse
        [ Protobuf.Decode.optional 1 Protobuf.Decode.int32 (\a r -> { r | requestNonce = a })
        , Protobuf.Decode.repeated
            2
            decodeProto__Io__Haveno__Protobuffer__Peer
            .reportedPeers
            (\a r -> { r | reportedPeers = a })
        , Protobuf.Decode.repeated
            3
            Protobuf.Decode.int32
            .supportedCapabilities
            (\a r -> { r | supportedCapabilities = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetPeersResponse` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetPeersResponse :
    Proto__Io__Haveno__Protobuffer__GetPeersResponse -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetPeersResponse value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.int32 value.requestNonce )
        , ( 2, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__Peer) value.reportedPeers )
        , ( 3, (Protobuf.Encode.list Protobuf.Encode.int32) value.supportedCapabilities )
        ]


{-| `Proto__Io__Haveno__Protobuffer__GetPeersResponse` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetPeersResponse =
    { requestNonce : Int, reportedPeers : List Proto__Io__Haveno__Protobuffer__Peer, supportedCapabilities : List Int }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetPeersRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetPeersRequest :
    { senderNodeAddress : Int, nonce : Int, supportedCapabilities : Int, reportedPeers : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetPeersRequest =
    { senderNodeAddress = 1, nonce = 2, supportedCapabilities = 3, reportedPeers = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetPeersRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetPeersRequest : Proto__Io__Haveno__Protobuffer__GetPeersRequest
defaultProto__Io__Haveno__Protobuffer__GetPeersRequest =
    { senderNodeAddress = Nothing, nonce = 0, supportedCapabilities = [], reportedPeers = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetPeersRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetPeersRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetPeersRequest
decodeProto__Io__Haveno__Protobuffer__GetPeersRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetPeersRequest
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | senderNodeAddress = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int32 (\a r -> { r | nonce = a })
        , Protobuf.Decode.repeated
            3
            Protobuf.Decode.int32
            .supportedCapabilities
            (\a r -> { r | supportedCapabilities = a })
        , Protobuf.Decode.repeated
            4
            decodeProto__Io__Haveno__Protobuffer__Peer
            .reportedPeers
            (\a r -> { r | reportedPeers = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetPeersRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetPeersRequest :
    Proto__Io__Haveno__Protobuffer__GetPeersRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetPeersRequest value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.senderNodeAddress
          )
        , ( 2, Protobuf.Encode.int32 value.nonce )
        , ( 3, (Protobuf.Encode.list Protobuf.Encode.int32) value.supportedCapabilities )
        , ( 4, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__Peer) value.reportedPeers )
        ]


{-| `Proto__Io__Haveno__Protobuffer__GetPeersRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetPeersRequest =
    { senderNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , nonce : Int
    , supportedCapabilities : List Int
    , reportedPeers : List Proto__Io__Haveno__Protobuffer__Peer
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__FileTransferPart`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__FileTransferPart :
    { senderNodeAddress : Int, uid : Int, tradeId : Int, traderId : Int, seqNumOrFileLength : Int, messageData : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__FileTransferPart =
    { senderNodeAddress = 1, uid = 2, tradeId = 3, traderId = 4, seqNumOrFileLength = 5, messageData = 6 }


{-| Default for Proto__Io__Haveno__Protobuffer__FileTransferPart. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__FileTransferPart : Proto__Io__Haveno__Protobuffer__FileTransferPart
defaultProto__Io__Haveno__Protobuffer__FileTransferPart =
    { senderNodeAddress = Nothing
    , uid = ""
    , tradeId = ""
    , traderId = 0
    , seqNumOrFileLength = Protobuf.Types.Int64.fromInts 0 0
    , messageData = Protobuf.Encode.encode <| Protobuf.Encode.string ""
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__FileTransferPart` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__FileTransferPart :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__FileTransferPart
decodeProto__Io__Haveno__Protobuffer__FileTransferPart =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__FileTransferPart
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | senderNodeAddress = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.string (\a r -> { r | uid = a })
        , Protobuf.Decode.optional 3 Protobuf.Decode.string (\a r -> { r | tradeId = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.int32 (\a r -> { r | traderId = a })
        , Protobuf.Decode.optional 5 Protobuf.Decode.int64 (\a r -> { r | seqNumOrFileLength = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.bytes (\a r -> { r | messageData = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__FileTransferPart` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__FileTransferPart :
    Proto__Io__Haveno__Protobuffer__FileTransferPart -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__FileTransferPart value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.senderNodeAddress
          )
        , ( 2, Protobuf.Encode.string value.uid )
        , ( 3, Protobuf.Encode.string value.tradeId )
        , ( 4, Protobuf.Encode.int32 value.traderId )
        , ( 5, Protobuf.Encode.int64 value.seqNumOrFileLength )
        , ( 6, Protobuf.Encode.bytes value.messageData )
        ]


{-| `Proto__Io__Haveno__Protobuffer__FileTransferPart` message

-}
type alias Proto__Io__Haveno__Protobuffer__FileTransferPart =
    { senderNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , uid : String
    , tradeId : String
    , traderId : Int
    , seqNumOrFileLength : Protobuf.Types.Int64.Int64
    , messageData : Bytes.Bytes
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetUpdatedDataRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest :
    { senderNodeAddress : Int, nonce : Int, excludedKeys : Int, version : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest =
    { senderNodeAddress = 1, nonce = 2, excludedKeys = 3, version = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__GetUpdatedDataRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest : Proto__Io__Haveno__Protobuffer__GetUpdatedDataRequest
defaultProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest =
    { senderNodeAddress = Nothing, nonce = 0, excludedKeys = [], version = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetUpdatedDataRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetUpdatedDataRequest
decodeProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest
        [ Protobuf.Decode.optional
            1
            (Protobuf.Decode.map Just decodeProto__Io__Haveno__Protobuffer__NodeAddress)
            (\a r -> { r | senderNodeAddress = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.int32 (\a r -> { r | nonce = a })
        , Protobuf.Decode.repeated 3 Protobuf.Decode.bytes .excludedKeys (\a r -> { r | excludedKeys = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | version = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetUpdatedDataRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest :
    Proto__Io__Haveno__Protobuffer__GetUpdatedDataRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetUpdatedDataRequest value =
    Protobuf.Encode.message
        [ ( 1
          , (Maybe.map encodeProto__Io__Haveno__Protobuffer__NodeAddress >> Maybe.withDefault Protobuf.Encode.none)
                value.senderNodeAddress
          )
        , ( 2, Protobuf.Encode.int32 value.nonce )
        , ( 3, (Protobuf.Encode.list Protobuf.Encode.bytes) value.excludedKeys )
        , ( 4, Protobuf.Encode.string value.version )
        ]


{-| `Proto__Io__Haveno__Protobuffer__GetUpdatedDataRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetUpdatedDataRequest =
    { senderNodeAddress : Maybe Proto__Io__Haveno__Protobuffer__NodeAddress
    , nonce : Int
    , excludedKeys : List Bytes.Bytes
    , version : String
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__GetDataResponse`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__GetDataResponse :
    { requestNonce : Int
    , isGetUpdatedDataResponse : Int
    , dataSet : Int
    , supportedCapabilities : Int
    , persistableNetworkPayloadItems : Int
    , wasTruncated : Int
    }
fieldNumbersProto__Io__Haveno__Protobuffer__GetDataResponse =
    { requestNonce = 1
    , isGetUpdatedDataResponse = 2
    , dataSet = 3
    , supportedCapabilities = 4
    , persistableNetworkPayloadItems = 5
    , wasTruncated = 6
    }


{-| Default for Proto__Io__Haveno__Protobuffer__GetDataResponse. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__GetDataResponse : Proto__Io__Haveno__Protobuffer__GetDataResponse
defaultProto__Io__Haveno__Protobuffer__GetDataResponse =
    { requestNonce = 0
    , isGetUpdatedDataResponse = False
    , dataSet = []
    , supportedCapabilities = []
    , persistableNetworkPayloadItems = []
    , wasTruncated = False
    }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__GetDataResponse` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__GetDataResponse :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__GetDataResponse
decodeProto__Io__Haveno__Protobuffer__GetDataResponse =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__GetDataResponse
        [ Protobuf.Decode.optional 1 Protobuf.Decode.int32 (\a r -> { r | requestNonce = a })
        , Protobuf.Decode.optional 2 Protobuf.Decode.bool (\a r -> { r | isGetUpdatedDataResponse = a })
        , Protobuf.Decode.repeated
            3
            decodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper
            .dataSet
            (\a r -> { r | dataSet = a })
        , Protobuf.Decode.repeated
            4
            Protobuf.Decode.int32
            .supportedCapabilities
            (\a r -> { r | supportedCapabilities = a })
        , Protobuf.Decode.repeated
            5
            decodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload
            .persistableNetworkPayloadItems
            (\a r -> { r | persistableNetworkPayloadItems = a })
        , Protobuf.Decode.optional 6 Protobuf.Decode.bool (\a r -> { r | wasTruncated = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__GetDataResponse` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__GetDataResponse :
    Proto__Io__Haveno__Protobuffer__GetDataResponse -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__GetDataResponse value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.int32 value.requestNonce )
        , ( 2, Protobuf.Encode.bool value.isGetUpdatedDataResponse )
        , ( 3, (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__StorageEntryWrapper) value.dataSet )
        , ( 4, (Protobuf.Encode.list Protobuf.Encode.int32) value.supportedCapabilities )
        , ( 5
          , (Protobuf.Encode.list encodeProto__Io__Haveno__Protobuffer__PersistableNetworkPayload)
                value.persistableNetworkPayloadItems
          )
        , ( 6, Protobuf.Encode.bool value.wasTruncated )
        ]


{-| `Proto__Io__Haveno__Protobuffer__GetDataResponse` message

-}
type alias Proto__Io__Haveno__Protobuffer__GetDataResponse =
    { requestNonce : Int
    , isGetUpdatedDataResponse : Bool
    , dataSet : List Proto__Io__Haveno__Protobuffer__StorageEntryWrapper
    , supportedCapabilities : List Int
    , persistableNetworkPayloadItems : List Proto__Io__Haveno__Protobuffer__PersistableNetworkPayload
    , wasTruncated : Bool
    }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest :
    { nonce : Int, excludedKeys : Int, supportedCapabilities : Int, version : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest =
    { nonce = 21, excludedKeys = 2, supportedCapabilities = 3, version = 4 }


{-| Default for Proto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest :
    Proto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest
defaultProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest =
    { nonce = 0, excludedKeys = [], supportedCapabilities = [], version = "" }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest
decodeProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest
        [ Protobuf.Decode.optional 21 Protobuf.Decode.int32 (\a r -> { r | nonce = a })
        , Protobuf.Decode.repeated 2 Protobuf.Decode.bytes .excludedKeys (\a r -> { r | excludedKeys = a })
        , Protobuf.Decode.repeated
            3
            Protobuf.Decode.int32
            .supportedCapabilities
            (\a r -> { r | supportedCapabilities = a })
        , Protobuf.Decode.optional 4 Protobuf.Decode.string (\a r -> { r | version = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest :
    Proto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest value =
    Protobuf.Encode.message
        [ ( 21, Protobuf.Encode.int32 value.nonce )
        , ( 2, (Protobuf.Encode.list Protobuf.Encode.bytes) value.excludedKeys )
        , ( 3, (Protobuf.Encode.list Protobuf.Encode.int32) value.supportedCapabilities )
        , ( 4, Protobuf.Encode.string value.version )
        ]


{-| `Proto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest` message

-}
type alias Proto__Io__Haveno__Protobuffer__PreliminaryGetDataRequest =
    { nonce : Int, excludedKeys : List Bytes.Bytes, supportedCapabilities : List Int, version : String }


{-| Unwrap a `NetworkEnvelope` from its wrapper `NetworkEnvelope_.`

-}
unwrapProto__Io__Haveno__Protobuffer__NetworkEnvelope :
    Proto__Io__Haveno__Protobuffer__NetworkEnvelope_ -> Proto__Io__Haveno__Protobuffer__NetworkEnvelope
unwrapProto__Io__Haveno__Protobuffer__NetworkEnvelope (Proto__Io__Haveno__Protobuffer__NetworkEnvelope_ wrapped) =
    wrapped


{-| Type wrapper for alias type `NetworkEnvelope` to avoid unlimited recursion.

For a more in-depth explanation why we need this, read this: https://github.com/elm/compiler/blob/master/hints/recursive-alias.md.

-}
type Proto__Io__Haveno__Protobuffer__NetworkEnvelope_
    = Proto__Io__Haveno__Protobuffer__NetworkEnvelope_ Proto__Io__Haveno__Protobuffer__NetworkEnvelope


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__BundleOfEnvelopes : { envelopes : Int }
fieldNumbersProto__Io__Haveno__Protobuffer__BundleOfEnvelopes =
    { envelopes = 1 }


{-| Default for Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__BundleOfEnvelopes : Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes
defaultProto__Io__Haveno__Protobuffer__BundleOfEnvelopes =
    { envelopes = [] }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__BundleOfEnvelopes :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes
decodeProto__Io__Haveno__Protobuffer__BundleOfEnvelopes =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__BundleOfEnvelopes
        [ Protobuf.Decode.repeated
            1
            (Protobuf.Decode.map Proto__Io__Haveno__Protobuffer__NetworkEnvelope_ <|
                 Protobuf.Decode.lazy <| \_ -> decodeProto__Io__Haveno__Protobuffer__NetworkEnvelope
            )
            .envelopes
            (\a r -> { r | envelopes = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__BundleOfEnvelopes :
    Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__BundleOfEnvelopes value =
    Protobuf.Encode.message
        [ ( 1
          , (Protobuf.Encode.list
                (unwrapProto__Io__Haveno__Protobuffer__NetworkEnvelope
                    >> encodeProto__Io__Haveno__Protobuffer__NetworkEnvelope
                )
            )
                value.envelopes
          )
        ]


{-| `Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes` message

-}
type alias Proto__Io__Haveno__Protobuffer__BundleOfEnvelopes =
    { envelopes : List Proto__Io__Haveno__Protobuffer__NetworkEnvelope_ }


{-| The field numbers for the fields of `Proto__Io__Haveno__Protobuffer__NetworkEnvelope`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersProto__Io__Haveno__Protobuffer__NetworkEnvelope :
    { messageVersion : Int, message : FieldNumbersProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message }
fieldNumbersProto__Io__Haveno__Protobuffer__NetworkEnvelope =
    { messageVersion = 1, message = fieldNumbersProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message }


{-| Default for Proto__Io__Haveno__Protobuffer__NetworkEnvelope. Should only be used for 'required' decoders as an initial value.

-}
defaultProto__Io__Haveno__Protobuffer__NetworkEnvelope : Proto__Io__Haveno__Protobuffer__NetworkEnvelope
defaultProto__Io__Haveno__Protobuffer__NetworkEnvelope =
    { messageVersion = "", message = Nothing }


{-| Declares how to decode a `Proto__Io__Haveno__Protobuffer__NetworkEnvelope` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeProto__Io__Haveno__Protobuffer__NetworkEnvelope :
    Protobuf.Decode.Decoder Proto__Io__Haveno__Protobuffer__NetworkEnvelope
decodeProto__Io__Haveno__Protobuffer__NetworkEnvelope =
    Protobuf.Decode.message
        defaultProto__Io__Haveno__Protobuffer__NetworkEnvelope
        [ Protobuf.Decode.optional 1 Protobuf.Decode.string (\a r -> { r | messageVersion = a })
        , decodeProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message (\a r -> { r | message = a })
        ]


{-| Declares how to encode a `Proto__Io__Haveno__Protobuffer__NetworkEnvelope` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeProto__Io__Haveno__Protobuffer__NetworkEnvelope :
    Proto__Io__Haveno__Protobuffer__NetworkEnvelope -> Protobuf.Encode.Encoder
encodeProto__Io__Haveno__Protobuffer__NetworkEnvelope value =
    Protobuf.Encode.message
        [ ( 1, Protobuf.Encode.string value.messageVersion )
        , encodeProto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message value.message
        ]


{-| `Proto__Io__Haveno__Protobuffer__NetworkEnvelope` message

-}
type alias Proto__Io__Haveno__Protobuffer__NetworkEnvelope =
    { messageVersion : String, message : Maybe Proto__Io__Haveno__Protobuffer__NetworkEnvelope__Message__Message }
