<!DOCTYPE html>
<html>
  <!-- 
    
NOTE: Temporarily using this file to manage project (not files)

NOTE: Use the debugger etc. in Firefox, not code logging (however, have to log in Elm)

NOTE: Transpile with: elm make src/Main.elm --output=src/static/js/elm.js --debug

NOTE: Save with crtlS and all files with ctrl-shift-s

NOTE: You can press Ctrl + K + D at the same time to skip a selection. If you went too far with your selection, you can use Ctrl + U to return.

NOTE: Source control on commit. Assume transpiles unless ! in commit. ~ in commit means working but messy (no comments and messy, just the moment got working)

NOTE: To get 'Errors' to show switch off and select e.g. 'Warnings' then turn off warnings and got back to just 'Errors'

NOTE: Remember, source control - review changes from last commit by simly comparing files in 'working copy'

NOTE: Network access, might have to register IP in both Atlas and Realm.

NOTE: View|Single to re-set split windows (do in top Right)
Click on the file tab (not file window) to use Nav etc.

NOTE: Challenger ObjectId is:
6353e8b6aedf80653eb34191

NOTE: Diff. re: User owned/member rankings (more just a list of refs) and Selected, which are the actual 
rankings (or Ladders)

NOTE: Cancel etc. btn should be defined in 'update' close to the pattern that is being cancelled.

NOTE: , placeholder = Just <| Input.placeholder [] (Element.text "Password") 
fixed by looking up placeholder in docs (to get Input.placeholder), hover over placeholder (to get []) and realize
you just then need an Element msg

NOTE: Use git log and then e.g.-- REF: Old http functions: commit d8c05b94d8d304d030194ea270519b356cfc9cc6
If think might want to refer back to some old code

NOTE: Filter query for mongo {nickname: 'Anon'}

NOTE: Follow Failure msgs in Elm debugger, not onscreen in app UI

TODO: create restriction on owning rankings owned by another

TODO: create a datestamp, updatetext for rankings

TODO: User registration  - panel should appear with mobile input err.

REVIEW: Opaque types: Do you need to expose a type constructor (..) to get something done? 
The type should then be opaque and the 
operation should be done through exposed functions that work on the type.

REVIEW: LastModified (type Date) on a ranking currently removed from v.1.New feature?

NOTE: There's only now going to be one User at a time. Downloaded 'Users' from the db will be 'players'. You may have an EverySet of players, but not users.

NOTE: if you're matching a lot of irrelevant patterns, go back to the model and review.

REF: Old http functions: commit d8c05b94d8d304d030194ea270519b356cfc9cc6

Other tags (edit in Setting.json and add to TodoTree: General: Tags setting):
RF - re-factor
BUG,
HACK,
FIX,
XXX, Do NOT do this
NAV,
WARN,
REVIEW,
REF - https://rchavesferna.medium.com/elm-how-to-use-decoders-for-ports-how-to-not-use-decoders-for-json-a4f95b51473a

pword use default or in keyfile

{nickname: 'Anon'}

Current/next issues:
user level and comment validation
use getTime in header


sort logic in rankingDetailsConfirmPanel

nb. redundant patterns - just lift above more generic ones.

unable to put off the issue of working with the user token for new ranking create (probably other ops as well).
you are already logged in when come to do this.
it is not tenable to have 'password' in userInfo once the field has been used for initial registration.

How does mongo expect me to use a refreshToken etc.?

parse new ranking message and send to mongo -> handle response in Recv
the model before sending is at:
AppOps (Loading (Global (R.Ladder R.Both R.View)))



E.g. App not like (get from debugger):


Likes (what works to get view you want, if available):

Should implement ladder description - db + elm

inputNewLadderview bottom of might be useful

Creating a ranking will be same as registering.

Model when click Create as new registered user:
Currently this takes us to a Challenge

Start more comms with db:
Create new ranking
Delete rankings and user
NewChallenge - if current challenger is not 6353e8b6aedf80653eb34191
Record match results
Join rankings
Update user profile
Anon will have to be given Anon ++ first 5 digits of id

rm SR.Types (keep Colors)
Decide what to do with Legacy etc. - n.b. it's all still in Git repo.


The only diff re: Global and Selected rankings is the ranking list is filled
for selected.

The ranking itself doesn't need to know if it's Global or Selected (that's
already determined in DataKind)

Rely on the model to bring clarity, not names and comments, if possible.

The question is can every part of e.g. Register be modelled separately?
e.g. view, create, update, delete? If so then the Msg can be generic
(and perhaps this approach helps the data modelling?)


Already distinguishes w/o a list!

Does a Spectator need UserInfo? - yes, to create a user.


Could RegisterNew simply become Create, like doing with NewLadder?
Yes, it is more 'esoteric' but it puts the emphasis on the model.
Then, what you create, depends on the model, not passing data around etc.
    

Old:
type User
    = Spectator UserInfo SpectatorOps
    | Registered UserInfo RegisteredOps

    nb. these ops relate to being a User only
    eg. View here, has nothing to do with viewing rankings
Essentially just for Registering a new user:
SpectatorOps = 
    Create
    | Confirm

Why have Confirm again? Cos Confirm for Registered user can relate
to very different functionality to what it means for Spectator. But
we can still use the generic Msg.

RegisteredOps =
    View [only regis can do this, spec nothing to view]
    | Confirm [e.g. profile update]
    | Delete [only regis can do]




Consider if some Elements Msgs can be rf out to Elements when do validation etc.
Others (so I can delete):
confirmChallengebutton (some commented code will be useful)
ClickedDeleteRankingConfirmed
and (note use of enableButton)
Input.button (Button.simple ++ enableButton (isValidatedForAllLadderDetailsInput appInfo.selectedRanking (G.asList sGlobal))) <|
--                                     --     { onPress = Just <| ClickedConfirmCreateNewRanking
--                                     --     , label = Element.text "Confirm"
--                                     --     }
Color.simple

Cancel (Msg) will be same Msg for all with a handleCancel that will just 'lift' the 
model to the higher level than current.

Other msgs more descriptive variants cos the model alone (although correctly recording state)
isn't clear enough to work with, it seems currently.

The currently heavily commented buttons should be appearing when dictated by the model, not passed the model and then
loads of pattern matching. We're keeping it for now for the UI code.

Nb. have to think how model will be modified to handle won, lost, undecided. They will be 'sub' types of Selected Ops, so
they won't need to be matched on by the rest of the app.



-- RF: Keep code in update to 1 line if possible - can handle complexity elsewhere (but not by passing the whole model!)
Add another variant to AdminOps or just use Info?
Check we can get all the views we need (by working the DATA) - think of CRUD
Can probably get rid of a lot of comments ...

NOTE: 


Add member player view
Review how Elements are working. Can more be move out there? What are the circular reference issues?
Try other users and give them some owned rankings etc.

Change Data.Rankings.Ranking to GlobalRanking
before moving other?

REVIEW: Model - what can be streamlined? Current overuse of user. Should there be more branching to get at the user or leave at top level?
Think about this before moving on to obtaining a selected ranking.
Conclusion: we only need user in fetched. user can come out of global cos already have in fetched. Rankings can also come out of global cos they're in User.
Global data is also going to be unnecessary (it's in the userInfo). Then S.Selected is just going to be a Ranking - Datakind won't be necessary,
just changes in UI then? But UI should be driven by data?
Go by the data and maybe rm some UIs ... ideally we would rm UIState (but unlikely)
First part of rf datakind will be to rm the extra user

The model context 'knows' what the UI should be and it's current state.
e.g. fetching a ranking will be done in the context of either owned or member
and the UI can then reflect that.

Don't write separate code for eg. owned and selected ranking so you can return an appropriate model.
The model should already know where you are and you can therefore just decodeRanking.

and this should be the basis for the UI.

Changes to 'Global' etc. will now just be db changes (done via the User)

Next: display ranking


Validation
Register

Think about more tags less branch naming. Stick to just DEV_WIP and use tags, unless good reason for a new branch - bigger, riskier change.




NOTE: Git branch labelling:
WIP_<wip type e.g. refactorDataModel> - Work in progress - means partially completed - waiting to be merged into higher branch.

Temporary (use short category words):
Standalone - SA - indirect relation to the project that is not part of main development pipeline. e.g. tutorials, faunadb etc.
Review - RV - branch created just so can review without disturbing a higher branch. Temporary and should be deleted once the review is over.

Bug Fix - BF - known bug that might be listed in a tracker
Hot Fix - HF - Urgent
Feature - F_<feature name> - adding something extra that didn't exist before
Backend - BE_

Old - discarded, but kept for reference, prosterity - no, use tags before branching, as above, instead

Old functions that might prompt for functionality todos (deleted from code):
updateWithReceivedPlayersByRankingId

Orginal bits for handy ref. Just return to tag RemoveFUser to see old code

updateWithReceivedRankings model response =
    case ( model, response ) of
        -- Login, so fill the Ranking set
        (  Login user uiState, Ok lrankings ) ->
            let
                filteredFRankingList =
                    Utils.MyUtils.removeNothingFromList (Maybe.withDefault [] lrankings)

From Bridge.elm

import Data.Players
import Data.Rankings
import U
import Element exposing (Option)

type alias LoginResult =
    { token : Maybe String, user : Maybe U.User }


requestLoginUser : U.UserName -> U.Password -> Http.Request LoginResult
requestLoginUser user_name password =
    let
        requiredArgs =
            { username = user_name, password = password }
    in
    Http.mutationRequest SR.Constants.endpointURL (mutationLoginUser requiredArgs loginResultSelectionSet)
        |> Http.withHeader "authorization" SR.Constants.customKeyBearerToken

registerUser : U.UserInfo -> Cmd Msg
registerUser userInfo =
    GQLHttp.send RegisteredNewUser (Bridge.requestCreateNewUser userInfo)

Another nice snippet:
convertedValidatedPlayerList =
            List.map (\x -> Maybe.withDefault Data.Players.empty x) filteredValidatedMaybePlayerLst

Another:
Utils.MyUtils.removeNothingFromList (Maybe.withDefault [] lplayers)

Another:
existingRanking =
            List.head <|
                List.filter (\r -> r.id_ == String.toLower rnkid)
                    rankingList

Another:
userJoinRankings =
            List.Unique.filterDuplicates (List.filterMap removedInvalidRankingId [ "" ])

        
        validatedRankingAdded =
            if V.isValidRankingId rankingId then
                rankingId :: userJoinRankings
Another:
let
           esUser =
               EverySet.filter (\user -> gotId user == userId) susers
       in
       List.head (EverySet.toList esUser)

-->

<body>
  <div id="loginDiv" style="color:rgb(225, 22, 11); text-align: center"></div>
</body>
</html>

<!--REF: links for solved issues in Elm Slack 

  Json decode from js:
  https://elmlang.slack.com/archives/C192T0Q1E/p1665141634964769

XXX: Famous erros:
rankingData[0] is not defined - nothing came back from the db cos e.g. there was
no userid match (e.g. ranking trying to join with a user that doesn't exist)
n.b. last time fixed used 'await' before key functions!


Temp:





-->