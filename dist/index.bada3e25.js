// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"gDk1O":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "be68dc86bada3e25";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && ![
        "localhost",
        "127.0.0.1",
        "0.0.0.0"
    ].includes(hostname) ? "wss" : "ws";
    var ws;
    if (HMR_USE_SSE) ws = new EventSource("/__parcel_hmr");
    else try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    if (ws instanceof WebSocket) {
        ws.onerror = function(e) {
            if (e.message) console.error(e.message);
        };
        ws.onclose = function() {
            console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
        };
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"8NmNK":[function(require,module,exports) {
var _mainElm = require("../src/Main.elm");
var _handleElmMessagesJs = require("./handleElmMessages.js");
var _scrollTopLinksMenuJs = require("./scrollTopLinksMenu.js");
document.addEventListener("DOMContentLoaded", ()=>{
    const eapp = (0, _mainElm.Elm).Main.init({
        node: document.getElementById("elm"),
        flags: "flags"
    });
    var detectEnvironment = function() {
        var protocol = window.location.protocol;
        var hostname = window.location.hostname;
        var port = window.location.port;
        var defaultPort = protocol === "https:" ? 443 : 80;
        var parsedPort = port ? parseInt(port, 10) : defaultPort;
        return {
            protocol: protocol,
            hostname: hostname,
            port: parsedPort
        };
    };
    var environmentInfo = detectEnvironment();
    console.log("Protocol:", environmentInfo.protocol);
    console.log("Hostname:", environmentInfo.hostname);
    console.log("Port:", environmentInfo.port);
    const protocol = environmentInfo.protocol;
    const hostnm = environmentInfo.hostname;
    const prt = environmentInfo.port;
    var jsonUrl = JSON.stringify(protocol + "//" + hostnm + ":" + prt);
    console.log("jsonUrl:", jsonUrl);
    eapp.ports.sendMessageToJs.subscribe(function(message) {
        console.log("Message sent to js ", message);
        (0, _handleElmMessagesJs.handleMessageFromElm)(message, eapp);
    });
    //burger animation
    const menubtn = document.querySelector(".menu-btn");
    let menuOpen = false;
    menubtn.addEventListener("click", ()=>{
        if (!menuOpen) {
            menubtn.classList.add("open");
            menuOpen = true;
        } else {
            menubtn.classList.remove("open");
            menuOpen = false;
        }
    });
});

},{"../src/Main.elm":"4XkAe","./handleElmMessages.js":"2AsAh","./scrollTopLinksMenu.js":"X1LcC"}],"4XkAe":[function(require,module,exports) {
(function(scope) {
    "use strict";
    function F(arity, fun, wrapper) {
        wrapper.a = arity;
        wrapper.f = fun;
        return wrapper;
    }
    function F2(fun) {
        return F(2, fun, function(a) {
            return function(b) {
                return fun(a, b);
            };
        });
    }
    function F3(fun) {
        return F(3, fun, function(a) {
            return function(b) {
                return function(c) {
                    return fun(a, b, c);
                };
            };
        });
    }
    function F4(fun) {
        return F(4, fun, function(a) {
            return function(b) {
                return function(c) {
                    return function(d) {
                        return fun(a, b, c, d);
                    };
                };
            };
        });
    }
    function F5(fun) {
        return F(5, fun, function(a) {
            return function(b) {
                return function(c) {
                    return function(d) {
                        return function(e) {
                            return fun(a, b, c, d, e);
                        };
                    };
                };
            };
        });
    }
    function F6(fun) {
        return F(6, fun, function(a) {
            return function(b) {
                return function(c) {
                    return function(d) {
                        return function(e) {
                            return function(f) {
                                return fun(a, b, c, d, e, f);
                            };
                        };
                    };
                };
            };
        });
    }
    function F7(fun) {
        return F(7, fun, function(a) {
            return function(b) {
                return function(c) {
                    return function(d) {
                        return function(e) {
                            return function(f) {
                                return function(g) {
                                    return fun(a, b, c, d, e, f, g);
                                };
                            };
                        };
                    };
                };
            };
        });
    }
    function F8(fun) {
        return F(8, fun, function(a) {
            return function(b) {
                return function(c) {
                    return function(d) {
                        return function(e) {
                            return function(f) {
                                return function(g) {
                                    return function(h) {
                                        return fun(a, b, c, d, e, f, g, h);
                                    };
                                };
                            };
                        };
                    };
                };
            };
        });
    }
    function F9(fun) {
        return F(9, fun, function(a) {
            return function(b) {
                return function(c) {
                    return function(d) {
                        return function(e) {
                            return function(f) {
                                return function(g) {
                                    return function(h) {
                                        return function(i) {
                                            return fun(a, b, c, d, e, f, g, h, i);
                                        };
                                    };
                                };
                            };
                        };
                    };
                };
            };
        });
    }
    function A2(fun, a, b) {
        return fun.a === 2 ? fun.f(a, b) : fun(a)(b);
    }
    function A3(fun, a, b, c) {
        return fun.a === 3 ? fun.f(a, b, c) : fun(a)(b)(c);
    }
    function A4(fun, a, b, c, d) {
        return fun.a === 4 ? fun.f(a, b, c, d) : fun(a)(b)(c)(d);
    }
    function A5(fun, a, b, c, d, e) {
        return fun.a === 5 ? fun.f(a, b, c, d, e) : fun(a)(b)(c)(d)(e);
    }
    function A6(fun, a, b, c, d, e, f) {
        return fun.a === 6 ? fun.f(a, b, c, d, e, f) : fun(a)(b)(c)(d)(e)(f);
    }
    function A7(fun, a, b, c, d, e, f, g) {
        return fun.a === 7 ? fun.f(a, b, c, d, e, f, g) : fun(a)(b)(c)(d)(e)(f)(g);
    }
    function A8(fun, a, b, c, d, e, f, g, h) {
        return fun.a === 8 ? fun.f(a, b, c, d, e, f, g, h) : fun(a)(b)(c)(d)(e)(f)(g)(h);
    }
    function A9(fun, a, b, c, d, e, f, g, h, i) {
        return fun.a === 9 ? fun.f(a, b, c, d, e, f, g, h, i) : fun(a)(b)(c)(d)(e)(f)(g)(h)(i);
    }
    console.warn("Compiled in DEBUG mode. Follow the advice at https://elm-lang.org/0.19.1/optimize for better performance and smaller assets.");
    // EQUALITY
    function _Utils_eq(x, y) {
        for(var pair, stack = [], isEqual = _Utils_eqHelp(x, y, 0, stack); isEqual && (pair = stack.pop()); isEqual = _Utils_eqHelp(pair.a, pair.b, 0, stack));
        return isEqual;
    }
    function _Utils_eqHelp(x, y, depth, stack) {
        if (x === y) return true;
        if (typeof x !== "object" || x === null || y === null) {
            typeof x === "function" && _Debug_crash(5);
            return false;
        }
        if (depth > 100) {
            stack.push(_Utils_Tuple2(x, y));
            return true;
        }
        /**/ if (x.$ === "Set_elm_builtin") {
            x = $elm$core$Set$toList(x);
            y = $elm$core$Set$toList(y);
        }
        if (x.$ === "RBNode_elm_builtin" || x.$ === "RBEmpty_elm_builtin") {
            x = $elm$core$Dict$toList(x);
            y = $elm$core$Dict$toList(y);
        }
        //*/
        /**_UNUSED/
	if (x.$ < 0)
	{
		x = $elm$core$Dict$toList(x);
		y = $elm$core$Dict$toList(y);
	}
	//*/ for(var key in x){
            if (!_Utils_eqHelp(x[key], y[key], depth + 1, stack)) return false;
        }
        return true;
    }
    var _Utils_equal = F2(_Utils_eq);
    var _Utils_notEqual = F2(function(a, b) {
        return !_Utils_eq(a, b);
    });
    // COMPARISONS
    // Code in Generate/JavaScript.hs, Basics.js, and List.js depends on
    // the particular integer values assigned to LT, EQ, and GT.
    function _Utils_cmp(x, y, ord) {
        if (typeof x !== "object") return x === y ? /*EQ*/ 0 : x < y ? /*LT*/ -1 : /*GT*/ 1;
        /**/ if (x instanceof String) {
            var a = x.valueOf();
            var b = y.valueOf();
            return a === b ? 0 : a < b ? -1 : 1;
        }
        //*/
        /**_UNUSED/
	if (typeof x.$ === 'undefined')
	//*/ /**/ if (x.$[0] === "#") return (ord = _Utils_cmp(x.a, y.a)) ? ord : (ord = _Utils_cmp(x.b, y.b)) ? ord : _Utils_cmp(x.c, y.c);
        // traverse conses until end of a list or a mismatch
        for(; x.b && y.b && !(ord = _Utils_cmp(x.a, y.a)); x = x.b, y = y.b); // WHILE_CONSES
        return ord || (x.b ? /*GT*/ 1 : y.b ? /*LT*/ -1 : /*EQ*/ 0);
    }
    var _Utils_lt = F2(function(a, b) {
        return _Utils_cmp(a, b) < 0;
    });
    var _Utils_le = F2(function(a, b) {
        return _Utils_cmp(a, b) < 1;
    });
    var _Utils_gt = F2(function(a, b) {
        return _Utils_cmp(a, b) > 0;
    });
    var _Utils_ge = F2(function(a, b) {
        return _Utils_cmp(a, b) >= 0;
    });
    var _Utils_compare = F2(function(x, y) {
        var n = _Utils_cmp(x, y);
        return n < 0 ? $elm$core$Basics$LT : n ? $elm$core$Basics$GT : $elm$core$Basics$EQ;
    });
    // COMMON VALUES
    var _Utils_Tuple0_UNUSED = 0;
    var _Utils_Tuple0 = {
        $: "#0"
    };
    function _Utils_Tuple2_UNUSED(a, b) {
        return {
            a: a,
            b: b
        };
    }
    function _Utils_Tuple2(a, b) {
        return {
            $: "#2",
            a: a,
            b: b
        };
    }
    function _Utils_Tuple3_UNUSED(a, b, c) {
        return {
            a: a,
            b: b,
            c: c
        };
    }
    function _Utils_Tuple3(a, b, c) {
        return {
            $: "#3",
            a: a,
            b: b,
            c: c
        };
    }
    function _Utils_chr_UNUSED(c) {
        return c;
    }
    function _Utils_chr(c) {
        return new String(c);
    }
    // RECORDS
    function _Utils_update(oldRecord, updatedFields) {
        var newRecord = {};
        for(var key in oldRecord)newRecord[key] = oldRecord[key];
        for(var key in updatedFields)newRecord[key] = updatedFields[key];
        return newRecord;
    }
    // APPEND
    var _Utils_append = F2(_Utils_ap);
    function _Utils_ap(xs, ys) {
        // append Strings
        if (typeof xs === "string") return xs + ys;
        // append Lists
        if (!xs.b) return ys;
        var root = _List_Cons(xs.a, ys);
        xs = xs.b;
        for(var curr = root; xs.b; xs = xs.b)curr = curr.b = _List_Cons(xs.a, ys);
        return root;
    }
    var _List_Nil_UNUSED = {
        $: 0
    };
    var _List_Nil = {
        $: "[]"
    };
    function _List_Cons_UNUSED(hd, tl) {
        return {
            $: 1,
            a: hd,
            b: tl
        };
    }
    function _List_Cons(hd, tl) {
        return {
            $: "::",
            a: hd,
            b: tl
        };
    }
    var _List_cons = F2(_List_Cons);
    function _List_fromArray(arr) {
        var out = _List_Nil;
        for(var i = arr.length; i--;)out = _List_Cons(arr[i], out);
        return out;
    }
    function _List_toArray(xs) {
        for(var out = []; xs.b; xs = xs.b)out.push(xs.a);
        return out;
    }
    var _List_map2 = F3(function(f, xs, ys) {
        for(var arr = []; xs.b && ys.b; xs = xs.b, ys = ys.b)arr.push(A2(f, xs.a, ys.a));
        return _List_fromArray(arr);
    });
    var _List_map3 = F4(function(f, xs, ys, zs) {
        for(var arr = []; xs.b && ys.b && zs.b; xs = xs.b, ys = ys.b, zs = zs.b)arr.push(A3(f, xs.a, ys.a, zs.a));
        return _List_fromArray(arr);
    });
    var _List_map4 = F5(function(f, ws, xs, ys, zs) {
        for(var arr = []; ws.b && xs.b && ys.b && zs.b; ws = ws.b, xs = xs.b, ys = ys.b, zs = zs.b)arr.push(A4(f, ws.a, xs.a, ys.a, zs.a));
        return _List_fromArray(arr);
    });
    var _List_map5 = F6(function(f, vs, ws, xs, ys, zs) {
        for(var arr = []; vs.b && ws.b && xs.b && ys.b && zs.b; vs = vs.b, ws = ws.b, xs = xs.b, ys = ys.b, zs = zs.b)arr.push(A5(f, vs.a, ws.a, xs.a, ys.a, zs.a));
        return _List_fromArray(arr);
    });
    var _List_sortBy = F2(function(f, xs) {
        return _List_fromArray(_List_toArray(xs).sort(function(a, b) {
            return _Utils_cmp(f(a), f(b));
        }));
    });
    var _List_sortWith = F2(function(f, xs) {
        return _List_fromArray(_List_toArray(xs).sort(function(a, b) {
            var ord = A2(f, a, b);
            return ord === $elm$core$Basics$EQ ? 0 : ord === $elm$core$Basics$LT ? -1 : 1;
        }));
    });
    var _JsArray_empty = [];
    function _JsArray_singleton(value) {
        return [
            value
        ];
    }
    function _JsArray_length(array) {
        return array.length;
    }
    var _JsArray_initialize = F3(function(size, offset, func) {
        var result = new Array(size);
        for(var i = 0; i < size; i++)result[i] = func(offset + i);
        return result;
    });
    var _JsArray_initializeFromList = F2(function(max, ls) {
        var result = new Array(max);
        for(var i = 0; i < max && ls.b; i++){
            result[i] = ls.a;
            ls = ls.b;
        }
        result.length = i;
        return _Utils_Tuple2(result, ls);
    });
    var _JsArray_unsafeGet = F2(function(index, array) {
        return array[index];
    });
    var _JsArray_unsafeSet = F3(function(index, value, array) {
        var length = array.length;
        var result = new Array(length);
        for(var i = 0; i < length; i++)result[i] = array[i];
        result[index] = value;
        return result;
    });
    var _JsArray_push = F2(function(value, array) {
        var length = array.length;
        var result = new Array(length + 1);
        for(var i = 0; i < length; i++)result[i] = array[i];
        result[length] = value;
        return result;
    });
    var _JsArray_foldl = F3(function(func, acc, array) {
        var length = array.length;
        for(var i = 0; i < length; i++)acc = A2(func, array[i], acc);
        return acc;
    });
    var _JsArray_foldr = F3(function(func, acc, array) {
        for(var i = array.length - 1; i >= 0; i--)acc = A2(func, array[i], acc);
        return acc;
    });
    var _JsArray_map = F2(function(func, array) {
        var length = array.length;
        var result = new Array(length);
        for(var i = 0; i < length; i++)result[i] = func(array[i]);
        return result;
    });
    var _JsArray_indexedMap = F3(function(func, offset, array) {
        var length = array.length;
        var result = new Array(length);
        for(var i = 0; i < length; i++)result[i] = A2(func, offset + i, array[i]);
        return result;
    });
    var _JsArray_slice = F3(function(from, to, array) {
        return array.slice(from, to);
    });
    var _JsArray_appendN = F3(function(n, dest, source) {
        var destLen = dest.length;
        var itemsToCopy = n - destLen;
        if (itemsToCopy > source.length) itemsToCopy = source.length;
        var size = destLen + itemsToCopy;
        var result = new Array(size);
        for(var i = 0; i < destLen; i++)result[i] = dest[i];
        for(var i = 0; i < itemsToCopy; i++)result[i + destLen] = source[i];
        return result;
    });
    // LOG
    var _Debug_log_UNUSED = F2(function(tag, value) {
        return value;
    });
    var _Debug_log = F2(function(tag, value) {
        console.log(tag + ": " + _Debug_toString(value));
        return value;
    });
    // TODOS
    function _Debug_todo(moduleName, region) {
        return function(message) {
            _Debug_crash(8, moduleName, region, message);
        };
    }
    function _Debug_todoCase(moduleName, region, value) {
        return function(message) {
            _Debug_crash(9, moduleName, region, value, message);
        };
    }
    // TO STRING
    function _Debug_toString_UNUSED(value) {
        return "<internals>";
    }
    function _Debug_toString(value) {
        return _Debug_toAnsiString(false, value);
    }
    function _Debug_toAnsiString(ansi, value) {
        if (typeof value === "function") return _Debug_internalColor(ansi, "<function>");
        if (typeof value === "boolean") return _Debug_ctorColor(ansi, value ? "True" : "False");
        if (typeof value === "number") return _Debug_numberColor(ansi, value + "");
        if (value instanceof String) return _Debug_charColor(ansi, "'" + _Debug_addSlashes(value, true) + "'");
        if (typeof value === "string") return _Debug_stringColor(ansi, '"' + _Debug_addSlashes(value, false) + '"');
        if (typeof value === "object" && "$" in value) {
            var tag = value.$;
            if (typeof tag === "number") return _Debug_internalColor(ansi, "<internals>");
            if (tag[0] === "#") {
                var output = [];
                for(var k in value){
                    if (k === "$") continue;
                    output.push(_Debug_toAnsiString(ansi, value[k]));
                }
                return "(" + output.join(",") + ")";
            }
            if (tag === "Set_elm_builtin") return _Debug_ctorColor(ansi, "Set") + _Debug_fadeColor(ansi, ".fromList") + " " + _Debug_toAnsiString(ansi, $elm$core$Set$toList(value));
            if (tag === "RBNode_elm_builtin" || tag === "RBEmpty_elm_builtin") return _Debug_ctorColor(ansi, "Dict") + _Debug_fadeColor(ansi, ".fromList") + " " + _Debug_toAnsiString(ansi, $elm$core$Dict$toList(value));
            if (tag === "Array_elm_builtin") return _Debug_ctorColor(ansi, "Array") + _Debug_fadeColor(ansi, ".fromList") + " " + _Debug_toAnsiString(ansi, $elm$core$Array$toList(value));
            if (tag === "::" || tag === "[]") {
                var output = "[";
                value.b && (output += _Debug_toAnsiString(ansi, value.a), value = value.b);
                for(; value.b; value = value.b)output += "," + _Debug_toAnsiString(ansi, value.a);
                return output + "]";
            }
            var output = "";
            for(var i in value){
                if (i === "$") continue;
                var str = _Debug_toAnsiString(ansi, value[i]);
                var c0 = str[0];
                var parenless = c0 === "{" || c0 === "(" || c0 === "[" || c0 === "<" || c0 === '"' || str.indexOf(" ") < 0;
                output += " " + (parenless ? str : "(" + str + ")");
            }
            return _Debug_ctorColor(ansi, tag) + output;
        }
        if (typeof DataView === "function" && value instanceof DataView) return _Debug_stringColor(ansi, "<" + value.byteLength + " bytes>");
        if (typeof File !== "undefined" && value instanceof File) return _Debug_internalColor(ansi, "<" + value.name + ">");
        if (typeof value === "object") {
            var output = [];
            for(var key in value){
                var field = key[0] === "_" ? key.slice(1) : key;
                output.push(_Debug_fadeColor(ansi, field) + " = " + _Debug_toAnsiString(ansi, value[key]));
            }
            if (output.length === 0) return "{}";
            return "{ " + output.join(", ") + " }";
        }
        return _Debug_internalColor(ansi, "<internals>");
    }
    function _Debug_addSlashes(str, isChar) {
        var s = str.replace(/\\/g, "\\\\").replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r").replace(/\v/g, "\\v").replace(/\0/g, "\\0");
        if (isChar) return s.replace(/\'/g, "\\'");
        else return s.replace(/\"/g, '\\"');
    }
    function _Debug_ctorColor(ansi, string) {
        return ansi ? "\x1b[96m" + string + "\x1b[0m" : string;
    }
    function _Debug_numberColor(ansi, string) {
        return ansi ? "\x1b[95m" + string + "\x1b[0m" : string;
    }
    function _Debug_stringColor(ansi, string) {
        return ansi ? "\x1b[93m" + string + "\x1b[0m" : string;
    }
    function _Debug_charColor(ansi, string) {
        return ansi ? "\x1b[92m" + string + "\x1b[0m" : string;
    }
    function _Debug_fadeColor(ansi, string) {
        return ansi ? "\x1b[37m" + string + "\x1b[0m" : string;
    }
    function _Debug_internalColor(ansi, string) {
        return ansi ? "\x1b[36m" + string + "\x1b[0m" : string;
    }
    function _Debug_toHexDigit(n) {
        return String.fromCharCode(n < 10 ? 48 + n : 55 + n);
    }
    // CRASH
    function _Debug_crash_UNUSED(identifier) {
        throw new Error("https://github.com/elm/core/blob/1.0.0/hints/" + identifier + ".md");
    }
    function _Debug_crash(identifier, fact1, fact2, fact3, fact4) {
        switch(identifier){
            case 0:
                throw new Error('What node should I take over? In JavaScript I need something like:\n\n    Elm.Main.init({\n        node: document.getElementById("elm-node")\n    })\n\nYou need to do this with any Browser.sandbox or Browser.element program.');
            case 1:
                throw new Error("Browser.application programs cannot handle URLs like this:\n\n    " + document.location.href + "\n\nWhat is the root? The root of your file system? Try looking at this program with `elm reactor` or some other server.");
            case 2:
                var jsonErrorString = fact1;
                throw new Error("Problem with the flags given to your Elm program on initialization.\n\n" + jsonErrorString);
            case 3:
                var portName = fact1;
                throw new Error("There can only be one port named `" + portName + "`, but your program has multiple.");
            case 4:
                var portName = fact1;
                var problem = fact2;
                throw new Error("Trying to send an unexpected type of value through port `" + portName + "`:\n" + problem);
            case 5:
                throw new Error('Trying to use `(==)` on functions.\nThere is no way to know if functions are "the same" in the Elm sense.\nRead more about this at https://package.elm-lang.org/packages/elm/core/latest/Basics#== which describes why it is this way and what the better version will look like.');
            case 6:
                var moduleName = fact1;
                throw new Error("Your page is loading multiple Elm scripts with a module named " + moduleName + ". Maybe a duplicate script is getting loaded accidentally? If not, rename one of them so I know which is which!");
            case 8:
                var moduleName = fact1;
                var region = fact2;
                var message = fact3;
                throw new Error("TODO in module `" + moduleName + "` " + _Debug_regionToString(region) + "\n\n" + message);
            case 9:
                var moduleName = fact1;
                var region = fact2;
                var value = fact3;
                var message = fact4;
                throw new Error("TODO in module `" + moduleName + "` from the `case` expression " + _Debug_regionToString(region) + "\n\nIt received the following value:\n\n    " + _Debug_toString(value).replace("\n", "\n    ") + "\n\nBut the branch that handles it says:\n\n    " + message.replace("\n", "\n    "));
            case 10:
                throw new Error("Bug in https://github.com/elm/virtual-dom/issues");
            case 11:
                throw new Error("Cannot perform mod 0. Division by zero error.");
        }
    }
    function _Debug_regionToString(region) {
        if (region.start.line === region.end.line) return "on line " + region.start.line;
        return "on lines " + region.start.line + " through " + region.end.line;
    }
    // MATH
    var _Basics_add = F2(function(a, b) {
        return a + b;
    });
    var _Basics_sub = F2(function(a, b) {
        return a - b;
    });
    var _Basics_mul = F2(function(a, b) {
        return a * b;
    });
    var _Basics_fdiv = F2(function(a, b) {
        return a / b;
    });
    var _Basics_idiv = F2(function(a, b) {
        return a / b | 0;
    });
    var _Basics_pow = F2(Math.pow);
    var _Basics_remainderBy = F2(function(b, a) {
        return a % b;
    });
    // https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf
    var _Basics_modBy = F2(function(modulus, x) {
        var answer = x % modulus;
        return modulus === 0 ? _Debug_crash(11) : answer > 0 && modulus < 0 || answer < 0 && modulus > 0 ? answer + modulus : answer;
    });
    // TRIGONOMETRY
    var _Basics_pi = Math.PI;
    var _Basics_e = Math.E;
    var _Basics_cos = Math.cos;
    var _Basics_sin = Math.sin;
    var _Basics_tan = Math.tan;
    var _Basics_acos = Math.acos;
    var _Basics_asin = Math.asin;
    var _Basics_atan = Math.atan;
    var _Basics_atan2 = F2(Math.atan2);
    // MORE MATH
    function _Basics_toFloat(x) {
        return x;
    }
    function _Basics_truncate(n) {
        return n | 0;
    }
    function _Basics_isInfinite(n) {
        return n === Infinity || n === -Infinity;
    }
    var _Basics_ceiling = Math.ceil;
    var _Basics_floor = Math.floor;
    var _Basics_round = Math.round;
    var _Basics_sqrt = Math.sqrt;
    var _Basics_log = Math.log;
    var _Basics_isNaN = isNaN;
    // BOOLEANS
    function _Basics_not(bool) {
        return !bool;
    }
    var _Basics_and = F2(function(a, b) {
        return a && b;
    });
    var _Basics_or = F2(function(a, b) {
        return a || b;
    });
    var _Basics_xor = F2(function(a, b) {
        return a !== b;
    });
    var _String_cons = F2(function(chr, str) {
        return chr + str;
    });
    function _String_uncons(string) {
        var word = string.charCodeAt(0);
        return !isNaN(word) ? $elm$core$Maybe$Just(0xD800 <= word && word <= 0xDBFF ? _Utils_Tuple2(_Utils_chr(string[0] + string[1]), string.slice(2)) : _Utils_Tuple2(_Utils_chr(string[0]), string.slice(1))) : $elm$core$Maybe$Nothing;
    }
    var _String_append = F2(function(a, b) {
        return a + b;
    });
    function _String_length(str) {
        return str.length;
    }
    var _String_map = F2(function(func, string) {
        var len = string.length;
        var array = new Array(len);
        var i = 0;
        while(i < len){
            var word = string.charCodeAt(i);
            if (0xD800 <= word && word <= 0xDBFF) {
                array[i] = func(_Utils_chr(string[i] + string[i + 1]));
                i += 2;
                continue;
            }
            array[i] = func(_Utils_chr(string[i]));
            i++;
        }
        return array.join("");
    });
    var _String_filter = F2(function(isGood, str) {
        var arr = [];
        var len = str.length;
        var i = 0;
        while(i < len){
            var char = str[i];
            var word = str.charCodeAt(i);
            i++;
            if (0xD800 <= word && word <= 0xDBFF) {
                char += str[i];
                i++;
            }
            if (isGood(_Utils_chr(char))) arr.push(char);
        }
        return arr.join("");
    });
    function _String_reverse(str) {
        var len = str.length;
        var arr = new Array(len);
        var i = 0;
        while(i < len){
            var word = str.charCodeAt(i);
            if (0xD800 <= word && word <= 0xDBFF) {
                arr[len - i] = str[i + 1];
                i++;
                arr[len - i] = str[i - 1];
                i++;
            } else {
                arr[len - i] = str[i];
                i++;
            }
        }
        return arr.join("");
    }
    var _String_foldl = F3(function(func, state, string) {
        var len = string.length;
        var i = 0;
        while(i < len){
            var char = string[i];
            var word = string.charCodeAt(i);
            i++;
            if (0xD800 <= word && word <= 0xDBFF) {
                char += string[i];
                i++;
            }
            state = A2(func, _Utils_chr(char), state);
        }
        return state;
    });
    var _String_foldr = F3(function(func, state, string) {
        var i = string.length;
        while(i--){
            var char = string[i];
            var word = string.charCodeAt(i);
            if (0xDC00 <= word && word <= 0xDFFF) {
                i--;
                char = string[i] + char;
            }
            state = A2(func, _Utils_chr(char), state);
        }
        return state;
    });
    var _String_split = F2(function(sep, str) {
        return str.split(sep);
    });
    var _String_join = F2(function(sep, strs) {
        return strs.join(sep);
    });
    var _String_slice = F3(function(start, end, str) {
        return str.slice(start, end);
    });
    function _String_trim(str) {
        return str.trim();
    }
    function _String_trimLeft(str) {
        return str.replace(/^\s+/, "");
    }
    function _String_trimRight(str) {
        return str.replace(/\s+$/, "");
    }
    function _String_words(str) {
        return _List_fromArray(str.trim().split(/\s+/g));
    }
    function _String_lines(str) {
        return _List_fromArray(str.split(/\r\n|\r|\n/g));
    }
    function _String_toUpper(str) {
        return str.toUpperCase();
    }
    function _String_toLower(str) {
        return str.toLowerCase();
    }
    var _String_any = F2(function(isGood, string) {
        var i = string.length;
        while(i--){
            var char = string[i];
            var word = string.charCodeAt(i);
            if (0xDC00 <= word && word <= 0xDFFF) {
                i--;
                char = string[i] + char;
            }
            if (isGood(_Utils_chr(char))) return true;
        }
        return false;
    });
    var _String_all = F2(function(isGood, string) {
        var i = string.length;
        while(i--){
            var char = string[i];
            var word = string.charCodeAt(i);
            if (0xDC00 <= word && word <= 0xDFFF) {
                i--;
                char = string[i] + char;
            }
            if (!isGood(_Utils_chr(char))) return false;
        }
        return true;
    });
    var _String_contains = F2(function(sub, str) {
        return str.indexOf(sub) > -1;
    });
    var _String_startsWith = F2(function(sub, str) {
        return str.indexOf(sub) === 0;
    });
    var _String_endsWith = F2(function(sub, str) {
        return str.length >= sub.length && str.lastIndexOf(sub) === str.length - sub.length;
    });
    var _String_indexes = F2(function(sub, str) {
        var subLen = sub.length;
        if (subLen < 1) return _List_Nil;
        var i = 0;
        var is = [];
        while((i = str.indexOf(sub, i)) > -1){
            is.push(i);
            i = i + subLen;
        }
        return _List_fromArray(is);
    });
    // TO STRING
    function _String_fromNumber(number) {
        return number + "";
    }
    // INT CONVERSIONS
    function _String_toInt(str) {
        var total = 0;
        var code0 = str.charCodeAt(0);
        var start = code0 == 0x2B /* + */  || code0 == 0x2D /* - */  ? 1 : 0;
        for(var i = start; i < str.length; ++i){
            var code = str.charCodeAt(i);
            if (code < 0x30 || 0x39 < code) return $elm$core$Maybe$Nothing;
            total = 10 * total + code - 0x30;
        }
        return i == start ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(code0 == 0x2D ? -total : total);
    }
    // FLOAT CONVERSIONS
    function _String_toFloat(s) {
        // check if it is a hex, octal, or binary number
        if (s.length === 0 || /[\sxbo]/.test(s)) return $elm$core$Maybe$Nothing;
        var n = +s;
        // faster isNaN check
        return n === n ? $elm$core$Maybe$Just(n) : $elm$core$Maybe$Nothing;
    }
    function _String_fromList(chars) {
        return _List_toArray(chars).join("");
    }
    function _Char_toCode(char) {
        var code = char.charCodeAt(0);
        if (0xD800 <= code && code <= 0xDBFF) return (code - 0xD800) * 0x400 + char.charCodeAt(1) - 0xDC00 + 0x10000;
        return code;
    }
    function _Char_fromCode(code) {
        return _Utils_chr(code < 0 || 0x10FFFF < code ? "\uFFFD" : code <= 0xFFFF ? String.fromCharCode(code) : (code -= 0x10000, String.fromCharCode(Math.floor(code / 0x400) + 0xD800, code % 0x400 + 0xDC00)));
    }
    function _Char_toUpper(char) {
        return _Utils_chr(char.toUpperCase());
    }
    function _Char_toLower(char) {
        return _Utils_chr(char.toLowerCase());
    }
    function _Char_toLocaleUpper(char) {
        return _Utils_chr(char.toLocaleUpperCase());
    }
    function _Char_toLocaleLower(char) {
        return _Utils_chr(char.toLocaleLowerCase());
    }
    /**/ function _Json_errorToString(error) {
        return $elm$json$Json$Decode$errorToString(error);
    }
    //*/
    // CORE DECODERS
    function _Json_succeed(msg) {
        return {
            $: 0,
            a: msg
        };
    }
    function _Json_fail(msg) {
        return {
            $: 1,
            a: msg
        };
    }
    function _Json_decodePrim(decoder) {
        return {
            $: 2,
            b: decoder
        };
    }
    var _Json_decodeInt = _Json_decodePrim(function(value) {
        return typeof value !== "number" ? _Json_expecting("an INT", value) : -2147483647 < value && value < 2147483647 && (value | 0) === value ? $elm$core$Result$Ok(value) : isFinite(value) && !(value % 1) ? $elm$core$Result$Ok(value) : _Json_expecting("an INT", value);
    });
    var _Json_decodeBool = _Json_decodePrim(function(value) {
        return typeof value === "boolean" ? $elm$core$Result$Ok(value) : _Json_expecting("a BOOL", value);
    });
    var _Json_decodeFloat = _Json_decodePrim(function(value) {
        return typeof value === "number" ? $elm$core$Result$Ok(value) : _Json_expecting("a FLOAT", value);
    });
    var _Json_decodeValue = _Json_decodePrim(function(value) {
        return $elm$core$Result$Ok(_Json_wrap(value));
    });
    var _Json_decodeString = _Json_decodePrim(function(value) {
        return typeof value === "string" ? $elm$core$Result$Ok(value) : value instanceof String ? $elm$core$Result$Ok(value + "") : _Json_expecting("a STRING", value);
    });
    function _Json_decodeList(decoder) {
        return {
            $: 3,
            b: decoder
        };
    }
    function _Json_decodeArray(decoder) {
        return {
            $: 4,
            b: decoder
        };
    }
    function _Json_decodeNull(value) {
        return {
            $: 5,
            c: value
        };
    }
    var _Json_decodeField = F2(function(field, decoder) {
        return {
            $: 6,
            d: field,
            b: decoder
        };
    });
    var _Json_decodeIndex = F2(function(index, decoder) {
        return {
            $: 7,
            e: index,
            b: decoder
        };
    });
    function _Json_decodeKeyValuePairs(decoder) {
        return {
            $: 8,
            b: decoder
        };
    }
    function _Json_mapMany(f, decoders) {
        return {
            $: 9,
            f: f,
            g: decoders
        };
    }
    var _Json_andThen = F2(function(callback, decoder) {
        return {
            $: 10,
            b: decoder,
            h: callback
        };
    });
    function _Json_oneOf(decoders) {
        return {
            $: 11,
            g: decoders
        };
    }
    // DECODING OBJECTS
    var _Json_map1 = F2(function(f, d1) {
        return _Json_mapMany(f, [
            d1
        ]);
    });
    var _Json_map2 = F3(function(f, d1, d2) {
        return _Json_mapMany(f, [
            d1,
            d2
        ]);
    });
    var _Json_map3 = F4(function(f, d1, d2, d3) {
        return _Json_mapMany(f, [
            d1,
            d2,
            d3
        ]);
    });
    var _Json_map4 = F5(function(f, d1, d2, d3, d4) {
        return _Json_mapMany(f, [
            d1,
            d2,
            d3,
            d4
        ]);
    });
    var _Json_map5 = F6(function(f, d1, d2, d3, d4, d5) {
        return _Json_mapMany(f, [
            d1,
            d2,
            d3,
            d4,
            d5
        ]);
    });
    var _Json_map6 = F7(function(f, d1, d2, d3, d4, d5, d6) {
        return _Json_mapMany(f, [
            d1,
            d2,
            d3,
            d4,
            d5,
            d6
        ]);
    });
    var _Json_map7 = F8(function(f, d1, d2, d3, d4, d5, d6, d7) {
        return _Json_mapMany(f, [
            d1,
            d2,
            d3,
            d4,
            d5,
            d6,
            d7
        ]);
    });
    var _Json_map8 = F9(function(f, d1, d2, d3, d4, d5, d6, d7, d8) {
        return _Json_mapMany(f, [
            d1,
            d2,
            d3,
            d4,
            d5,
            d6,
            d7,
            d8
        ]);
    });
    // DECODE
    var _Json_runOnString = F2(function(decoder, string) {
        try {
            var value = JSON.parse(string);
            return _Json_runHelp(decoder, value);
        } catch (e) {
            return $elm$core$Result$Err(A2($elm$json$Json$Decode$Failure, "This is not valid JSON! " + e.message, _Json_wrap(string)));
        }
    });
    var _Json_run = F2(function(decoder, value) {
        return _Json_runHelp(decoder, _Json_unwrap(value));
    });
    function _Json_runHelp(decoder, value) {
        switch(decoder.$){
            case 2:
                return decoder.b(value);
            case 5:
                return value === null ? $elm$core$Result$Ok(decoder.c) : _Json_expecting("null", value);
            case 3:
                if (!_Json_isArray(value)) return _Json_expecting("a LIST", value);
                return _Json_runArrayDecoder(decoder.b, value, _List_fromArray);
            case 4:
                if (!_Json_isArray(value)) return _Json_expecting("an ARRAY", value);
                return _Json_runArrayDecoder(decoder.b, value, _Json_toElmArray);
            case 6:
                var field = decoder.d;
                if (typeof value !== "object" || value === null || !(field in value)) return _Json_expecting("an OBJECT with a field named `" + field + "`", value);
                var result = _Json_runHelp(decoder.b, value[field]);
                return $elm$core$Result$isOk(result) ? result : $elm$core$Result$Err(A2($elm$json$Json$Decode$Field, field, result.a));
            case 7:
                var index = decoder.e;
                if (!_Json_isArray(value)) return _Json_expecting("an ARRAY", value);
                if (index >= value.length) return _Json_expecting("a LONGER array. Need index " + index + " but only see " + value.length + " entries", value);
                var result = _Json_runHelp(decoder.b, value[index]);
                return $elm$core$Result$isOk(result) ? result : $elm$core$Result$Err(A2($elm$json$Json$Decode$Index, index, result.a));
            case 8:
                if (typeof value !== "object" || value === null || _Json_isArray(value)) return _Json_expecting("an OBJECT", value);
                var keyValuePairs = _List_Nil;
                // TODO test perf of Object.keys and switch when support is good enough
                for(var key in value)if (value.hasOwnProperty(key)) {
                    var result = _Json_runHelp(decoder.b, value[key]);
                    if (!$elm$core$Result$isOk(result)) return $elm$core$Result$Err(A2($elm$json$Json$Decode$Field, key, result.a));
                    keyValuePairs = _List_Cons(_Utils_Tuple2(key, result.a), keyValuePairs);
                }
                return $elm$core$Result$Ok($elm$core$List$reverse(keyValuePairs));
            case 9:
                var answer = decoder.f;
                var decoders = decoder.g;
                for(var i = 0; i < decoders.length; i++){
                    var result = _Json_runHelp(decoders[i], value);
                    if (!$elm$core$Result$isOk(result)) return result;
                    answer = answer(result.a);
                }
                return $elm$core$Result$Ok(answer);
            case 10:
                var result = _Json_runHelp(decoder.b, value);
                return !$elm$core$Result$isOk(result) ? result : _Json_runHelp(decoder.h(result.a), value);
            case 11:
                var errors = _List_Nil;
                for(var temp = decoder.g; temp.b; temp = temp.b){
                    var result = _Json_runHelp(temp.a, value);
                    if ($elm$core$Result$isOk(result)) return result;
                    errors = _List_Cons(result.a, errors);
                }
                return $elm$core$Result$Err($elm$json$Json$Decode$OneOf($elm$core$List$reverse(errors)));
            case 1:
                return $elm$core$Result$Err(A2($elm$json$Json$Decode$Failure, decoder.a, _Json_wrap(value)));
            case 0:
                return $elm$core$Result$Ok(decoder.a);
        }
    }
    function _Json_runArrayDecoder(decoder, value, toElmValue) {
        var len = value.length;
        var array = new Array(len);
        for(var i = 0; i < len; i++){
            var result = _Json_runHelp(decoder, value[i]);
            if (!$elm$core$Result$isOk(result)) return $elm$core$Result$Err(A2($elm$json$Json$Decode$Index, i, result.a));
            array[i] = result.a;
        }
        return $elm$core$Result$Ok(toElmValue(array));
    }
    function _Json_isArray(value) {
        return Array.isArray(value) || typeof FileList !== "undefined" && value instanceof FileList;
    }
    function _Json_toElmArray(array) {
        return A2($elm$core$Array$initialize, array.length, function(i) {
            return array[i];
        });
    }
    function _Json_expecting(type, value) {
        return $elm$core$Result$Err(A2($elm$json$Json$Decode$Failure, "Expecting " + type, _Json_wrap(value)));
    }
    // EQUALITY
    function _Json_equality(x, y) {
        if (x === y) return true;
        if (x.$ !== y.$) return false;
        switch(x.$){
            case 0:
            case 1:
                return x.a === y.a;
            case 2:
                return x.b === y.b;
            case 5:
                return x.c === y.c;
            case 3:
            case 4:
            case 8:
                return _Json_equality(x.b, y.b);
            case 6:
                return x.d === y.d && _Json_equality(x.b, y.b);
            case 7:
                return x.e === y.e && _Json_equality(x.b, y.b);
            case 9:
                return x.f === y.f && _Json_listEquality(x.g, y.g);
            case 10:
                return x.h === y.h && _Json_equality(x.b, y.b);
            case 11:
                return _Json_listEquality(x.g, y.g);
        }
    }
    function _Json_listEquality(aDecoders, bDecoders) {
        var len = aDecoders.length;
        if (len !== bDecoders.length) return false;
        for(var i = 0; i < len; i++){
            if (!_Json_equality(aDecoders[i], bDecoders[i])) return false;
        }
        return true;
    }
    // ENCODE
    var _Json_encode = F2(function(indentLevel, value) {
        return JSON.stringify(_Json_unwrap(value), null, indentLevel) + "";
    });
    function _Json_wrap(value) {
        return {
            $: 0,
            a: value
        };
    }
    function _Json_unwrap(value) {
        return value.a;
    }
    function _Json_wrap_UNUSED(value) {
        return value;
    }
    function _Json_unwrap_UNUSED(value) {
        return value;
    }
    function _Json_emptyArray() {
        return [];
    }
    function _Json_emptyObject() {
        return {};
    }
    var _Json_addField = F3(function(key, value, object) {
        object[key] = _Json_unwrap(value);
        return object;
    });
    function _Json_addEntry(func) {
        return F2(function(entry, array) {
            array.push(_Json_unwrap(func(entry)));
            return array;
        });
    }
    var _Json_encodeNull = _Json_wrap(null);
    // TASKS
    function _Scheduler_succeed(value) {
        return {
            $: 0,
            a: value
        };
    }
    function _Scheduler_fail(error) {
        return {
            $: 1,
            a: error
        };
    }
    function _Scheduler_binding(callback) {
        return {
            $: 2,
            b: callback,
            c: null
        };
    }
    var _Scheduler_andThen = F2(function(callback, task) {
        return {
            $: 3,
            b: callback,
            d: task
        };
    });
    var _Scheduler_onError = F2(function(callback, task) {
        return {
            $: 4,
            b: callback,
            d: task
        };
    });
    function _Scheduler_receive(callback) {
        return {
            $: 5,
            b: callback
        };
    }
    // PROCESSES
    var _Scheduler_guid = 0;
    function _Scheduler_rawSpawn(task) {
        var proc = {
            $: 0,
            e: _Scheduler_guid++,
            f: task,
            g: null,
            h: []
        };
        _Scheduler_enqueue(proc);
        return proc;
    }
    function _Scheduler_spawn(task) {
        return _Scheduler_binding(function(callback) {
            callback(_Scheduler_succeed(_Scheduler_rawSpawn(task)));
        });
    }
    function _Scheduler_rawSend(proc, msg) {
        proc.h.push(msg);
        _Scheduler_enqueue(proc);
    }
    var _Scheduler_send = F2(function(proc, msg) {
        return _Scheduler_binding(function(callback) {
            _Scheduler_rawSend(proc, msg);
            callback(_Scheduler_succeed(_Utils_Tuple0));
        });
    });
    function _Scheduler_kill(proc) {
        return _Scheduler_binding(function(callback) {
            var task = proc.f;
            if (task.$ === 2 && task.c) task.c();
            proc.f = null;
            callback(_Scheduler_succeed(_Utils_Tuple0));
        });
    }
    /* STEP PROCESSES

type alias Process =
  { $ : tag
  , id : unique_id
  , root : Task
  , stack : null | { $: SUCCEED | FAIL, a: callback, b: stack }
  , mailbox : [msg]
  }

*/ var _Scheduler_working = false;
    var _Scheduler_queue = [];
    function _Scheduler_enqueue(proc) {
        _Scheduler_queue.push(proc);
        if (_Scheduler_working) return;
        _Scheduler_working = true;
        while(proc = _Scheduler_queue.shift())_Scheduler_step(proc);
        _Scheduler_working = false;
    }
    function _Scheduler_step(proc) {
        while(proc.f){
            var rootTag = proc.f.$;
            if (rootTag === 0 || rootTag === 1) {
                while(proc.g && proc.g.$ !== rootTag)proc.g = proc.g.i;
                if (!proc.g) return;
                proc.f = proc.g.b(proc.f.a);
                proc.g = proc.g.i;
            } else if (rootTag === 2) {
                proc.f.c = proc.f.b(function(newRoot) {
                    proc.f = newRoot;
                    _Scheduler_enqueue(proc);
                });
                return;
            } else if (rootTag === 5) {
                if (proc.h.length === 0) return;
                proc.f = proc.f.b(proc.h.shift());
            } else {
                proc.g = {
                    $: rootTag === 3 ? 0 : 1,
                    b: proc.f.b,
                    i: proc.g
                };
                proc.f = proc.f.d;
            }
        }
    }
    function _Process_sleep(time) {
        return _Scheduler_binding(function(callback) {
            var id = setTimeout(function() {
                callback(_Scheduler_succeed(_Utils_Tuple0));
            }, time);
            return function() {
                clearTimeout(id);
            };
        });
    }
    // PROGRAMS
    var _Platform_worker = F4(function(impl, flagDecoder, debugMetadata, args) {
        return _Platform_initialize(flagDecoder, args, impl.init, impl.update, impl.subscriptions, function() {
            return function() {};
        });
    });
    // INITIALIZE A PROGRAM
    function _Platform_initialize(flagDecoder, args, init, update, subscriptions, stepperBuilder) {
        var result = A2(_Json_run, flagDecoder, _Json_wrap(args ? args["flags"] : undefined));
        $elm$core$Result$isOk(result) || _Debug_crash(2 /**/ , _Json_errorToString(result.a));
        var managers = {};
        var initPair = init(result.a);
        var model = initPair.a;
        var stepper = stepperBuilder(sendToApp, model);
        var ports = _Platform_setupEffects(managers, sendToApp);
        function sendToApp(msg, viewMetadata) {
            var pair = A2(update, msg, model);
            stepper(model = pair.a, viewMetadata);
            _Platform_enqueueEffects(managers, pair.b, subscriptions(model));
        }
        _Platform_enqueueEffects(managers, initPair.b, subscriptions(model));
        return ports ? {
            ports: ports
        } : {};
    }
    // TRACK PRELOADS
    //
    // This is used by code in elm/browser and elm/http
    // to register any HTTP requests that are triggered by init.
    //
    var _Platform_preload;
    function _Platform_registerPreload(url) {
        _Platform_preload.add(url);
    }
    // EFFECT MANAGERS
    var _Platform_effectManagers = {};
    function _Platform_setupEffects(managers, sendToApp) {
        var ports;
        // setup all necessary effect managers
        for(var key in _Platform_effectManagers){
            var manager = _Platform_effectManagers[key];
            if (manager.a) {
                ports = ports || {};
                ports[key] = manager.a(key, sendToApp);
            }
            managers[key] = _Platform_instantiateManager(manager, sendToApp);
        }
        return ports;
    }
    function _Platform_createManager(init, onEffects, onSelfMsg, cmdMap, subMap) {
        return {
            b: init,
            c: onEffects,
            d: onSelfMsg,
            e: cmdMap,
            f: subMap
        };
    }
    function _Platform_instantiateManager(info, sendToApp) {
        var router = {
            g: sendToApp,
            h: undefined
        };
        var onEffects = info.c;
        var onSelfMsg = info.d;
        var cmdMap = info.e;
        var subMap = info.f;
        function loop(state) {
            return A2(_Scheduler_andThen, loop, _Scheduler_receive(function(msg) {
                var value = msg.a;
                if (msg.$ === 0) return A3(onSelfMsg, router, value, state);
                return cmdMap && subMap ? A4(onEffects, router, value.i, value.j, state) : A3(onEffects, router, cmdMap ? value.i : value.j, state);
            }));
        }
        return router.h = _Scheduler_rawSpawn(A2(_Scheduler_andThen, loop, info.b));
    }
    // ROUTING
    var _Platform_sendToApp = F2(function(router, msg) {
        return _Scheduler_binding(function(callback) {
            router.g(msg);
            callback(_Scheduler_succeed(_Utils_Tuple0));
        });
    });
    var _Platform_sendToSelf = F2(function(router, msg) {
        return A2(_Scheduler_send, router.h, {
            $: 0,
            a: msg
        });
    });
    // BAGS
    function _Platform_leaf(home) {
        return function(value) {
            return {
                $: 1,
                k: home,
                l: value
            };
        };
    }
    function _Platform_batch(list) {
        return {
            $: 2,
            m: list
        };
    }
    var _Platform_map = F2(function(tagger, bag) {
        return {
            $: 3,
            n: tagger,
            o: bag
        };
    });
    // PIPE BAGS INTO EFFECT MANAGERS
    //
    // Effects must be queued!
    //
    // Say your init contains a synchronous command, like Time.now or Time.here
    //
    //   - This will produce a batch of effects (FX_1)
    //   - The synchronous task triggers the subsequent `update` call
    //   - This will produce a batch of effects (FX_2)
    //
    // If we just start dispatching FX_2, subscriptions from FX_2 can be processed
    // before subscriptions from FX_1. No good! Earlier versions of this code had
    // this problem, leading to these reports:
    //
    //   https://github.com/elm/core/issues/980
    //   https://github.com/elm/core/pull/981
    //   https://github.com/elm/compiler/issues/1776
    //
    // The queue is necessary to avoid ordering issues for synchronous commands.
    // Why use true/false here? Why not just check the length of the queue?
    // The goal is to detect "are we currently dispatching effects?" If we
    // are, we need to bail and let the ongoing while loop handle things.
    //
    // Now say the queue has 1 element. When we dequeue the final element,
    // the queue will be empty, but we are still actively dispatching effects.
    // So you could get queue jumping in a really tricky category of cases.
    //
    var _Platform_effectsQueue = [];
    var _Platform_effectsActive = false;
    function _Platform_enqueueEffects(managers, cmdBag, subBag) {
        _Platform_effectsQueue.push({
            p: managers,
            q: cmdBag,
            r: subBag
        });
        if (_Platform_effectsActive) return;
        _Platform_effectsActive = true;
        for(var fx; fx = _Platform_effectsQueue.shift();)_Platform_dispatchEffects(fx.p, fx.q, fx.r);
        _Platform_effectsActive = false;
    }
    function _Platform_dispatchEffects(managers, cmdBag, subBag) {
        var effectsDict = {};
        _Platform_gatherEffects(true, cmdBag, effectsDict, null);
        _Platform_gatherEffects(false, subBag, effectsDict, null);
        for(var home in managers)_Scheduler_rawSend(managers[home], {
            $: "fx",
            a: effectsDict[home] || {
                i: _List_Nil,
                j: _List_Nil
            }
        });
    }
    function _Platform_gatherEffects(isCmd, bag, effectsDict, taggers) {
        switch(bag.$){
            case 1:
                var home = bag.k;
                var effect = _Platform_toEffect(isCmd, home, taggers, bag.l);
                effectsDict[home] = _Platform_insert(isCmd, effect, effectsDict[home]);
                return;
            case 2:
                for(var list = bag.m; list.b; list = list.b)_Platform_gatherEffects(isCmd, list.a, effectsDict, taggers);
                return;
            case 3:
                _Platform_gatherEffects(isCmd, bag.o, effectsDict, {
                    s: bag.n,
                    t: taggers
                });
                return;
        }
    }
    function _Platform_toEffect(isCmd, home, taggers, value) {
        function applyTaggers(x) {
            for(var temp = taggers; temp; temp = temp.t)x = temp.s(x);
            return x;
        }
        var map = isCmd ? _Platform_effectManagers[home].e : _Platform_effectManagers[home].f;
        return A2(map, applyTaggers, value);
    }
    function _Platform_insert(isCmd, newEffect, effects) {
        effects = effects || {
            i: _List_Nil,
            j: _List_Nil
        };
        isCmd ? effects.i = _List_Cons(newEffect, effects.i) : effects.j = _List_Cons(newEffect, effects.j);
        return effects;
    }
    // PORTS
    function _Platform_checkPortName(name) {
        if (_Platform_effectManagers[name]) _Debug_crash(3, name);
    }
    // OUTGOING PORTS
    function _Platform_outgoingPort(name, converter) {
        _Platform_checkPortName(name);
        _Platform_effectManagers[name] = {
            e: _Platform_outgoingPortMap,
            u: converter,
            a: _Platform_setupOutgoingPort
        };
        return _Platform_leaf(name);
    }
    var _Platform_outgoingPortMap = F2(function(tagger, value) {
        return value;
    });
    function _Platform_setupOutgoingPort(name) {
        var subs = [];
        var converter = _Platform_effectManagers[name].u;
        // CREATE MANAGER
        var init = _Process_sleep(0);
        _Platform_effectManagers[name].b = init;
        _Platform_effectManagers[name].c = F3(function(router, cmdList, state) {
            for(; cmdList.b; cmdList = cmdList.b){
                // grab a separate reference to subs in case unsubscribe is called
                var currentSubs = subs;
                var value = _Json_unwrap(converter(cmdList.a));
                for(var i = 0; i < currentSubs.length; i++)currentSubs[i](value);
            }
            return init;
        });
        // PUBLIC API
        function subscribe(callback) {
            subs.push(callback);
        }
        function unsubscribe(callback) {
            // copy subs into a new array in case unsubscribe is called within a
            // subscribed callback
            subs = subs.slice();
            var index = subs.indexOf(callback);
            if (index >= 0) subs.splice(index, 1);
        }
        return {
            subscribe: subscribe,
            unsubscribe: unsubscribe
        };
    }
    // INCOMING PORTS
    function _Platform_incomingPort(name, converter) {
        _Platform_checkPortName(name);
        _Platform_effectManagers[name] = {
            f: _Platform_incomingPortMap,
            u: converter,
            a: _Platform_setupIncomingPort
        };
        return _Platform_leaf(name);
    }
    var _Platform_incomingPortMap = F2(function(tagger, finalTagger) {
        return function(value) {
            return tagger(finalTagger(value));
        };
    });
    function _Platform_setupIncomingPort(name, sendToApp) {
        var subs = _List_Nil;
        var converter = _Platform_effectManagers[name].u;
        // CREATE MANAGER
        var init = _Scheduler_succeed(null);
        _Platform_effectManagers[name].b = init;
        _Platform_effectManagers[name].c = F3(function(router, subList, state) {
            subs = subList;
            return init;
        });
        // PUBLIC API
        function send(incomingValue) {
            var result = A2(_Json_run, converter, _Json_wrap(incomingValue));
            $elm$core$Result$isOk(result) || _Debug_crash(4, name, result.a);
            var value = result.a;
            for(var temp = subs; temp.b; temp = temp.b)sendToApp(temp.a(value));
        }
        return {
            send: send
        };
    }
    // EXPORT ELM MODULES
    //
    // Have DEBUG and PROD versions so that we can (1) give nicer errors in
    // debug mode and (2) not pay for the bits needed for that in prod mode.
    //
    function _Platform_export_UNUSED(exports) {
        scope["Elm"] ? _Platform_mergeExportsProd(scope["Elm"], exports) : scope["Elm"] = exports;
    }
    function _Platform_mergeExportsProd(obj, exports) {
        for(var name in exports)name in obj ? name == "init" ? _Debug_crash(6) : _Platform_mergeExportsProd(obj[name], exports[name]) : obj[name] = exports[name];
    }
    function _Platform_export(exports) {
        scope["Elm"] ? _Platform_mergeExportsDebug("Elm", scope["Elm"], exports) : scope["Elm"] = exports;
    }
    function _Platform_mergeExportsDebug(moduleName, obj, exports) {
        for(var name in exports)name in obj ? name == "init" ? _Debug_crash(6, moduleName) : _Platform_mergeExportsDebug(moduleName + "." + name, obj[name], exports[name]) : obj[name] = exports[name];
    }
    // HELPERS
    var _VirtualDom_divertHrefToApp;
    var _VirtualDom_doc = typeof document !== "undefined" ? document : {};
    function _VirtualDom_appendChild(parent, child) {
        parent.appendChild(child);
    }
    var _VirtualDom_init = F4(function(virtualNode, flagDecoder, debugMetadata, args) {
        // NOTE: this function needs _Platform_export available to work
        /**_UNUSED/
	var node = args['node'];
	//*/ /**/ var node = args && args["node"] ? args["node"] : _Debug_crash(0);
        //*/
        node.parentNode.replaceChild(_VirtualDom_render(virtualNode, function() {}), node);
        return {};
    });
    // TEXT
    function _VirtualDom_text(string) {
        return {
            $: 0,
            a: string
        };
    }
    // NODE
    var _VirtualDom_nodeNS = F2(function(namespace, tag) {
        return F2(function(factList, kidList) {
            for(var kids = [], descendantsCount = 0; kidList.b; kidList = kidList.b){
                var kid = kidList.a;
                descendantsCount += kid.b || 0;
                kids.push(kid);
            }
            descendantsCount += kids.length;
            return {
                $: 1,
                c: tag,
                d: _VirtualDom_organizeFacts(factList),
                e: kids,
                f: namespace,
                b: descendantsCount
            };
        });
    });
    var _VirtualDom_node = _VirtualDom_nodeNS(undefined);
    // KEYED NODE
    var _VirtualDom_keyedNodeNS = F2(function(namespace, tag) {
        return F2(function(factList, kidList) {
            for(var kids = [], descendantsCount = 0; kidList.b; kidList = kidList.b){
                var kid = kidList.a;
                descendantsCount += kid.b.b || 0;
                kids.push(kid);
            }
            descendantsCount += kids.length;
            return {
                $: 2,
                c: tag,
                d: _VirtualDom_organizeFacts(factList),
                e: kids,
                f: namespace,
                b: descendantsCount
            };
        });
    });
    var _VirtualDom_keyedNode = _VirtualDom_keyedNodeNS(undefined);
    // CUSTOM
    function _VirtualDom_custom(factList, model, render, diff) {
        return {
            $: 3,
            d: _VirtualDom_organizeFacts(factList),
            g: model,
            h: render,
            i: diff
        };
    }
    // MAP
    var _VirtualDom_map = F2(function(tagger, node) {
        return {
            $: 4,
            j: tagger,
            k: node,
            b: 1 + (node.b || 0)
        };
    });
    // LAZY
    function _VirtualDom_thunk(refs, thunk) {
        return {
            $: 5,
            l: refs,
            m: thunk,
            k: undefined
        };
    }
    var _VirtualDom_lazy = F2(function(func, a) {
        return _VirtualDom_thunk([
            func,
            a
        ], function() {
            return func(a);
        });
    });
    var _VirtualDom_lazy2 = F3(function(func, a, b) {
        return _VirtualDom_thunk([
            func,
            a,
            b
        ], function() {
            return A2(func, a, b);
        });
    });
    var _VirtualDom_lazy3 = F4(function(func, a, b, c) {
        return _VirtualDom_thunk([
            func,
            a,
            b,
            c
        ], function() {
            return A3(func, a, b, c);
        });
    });
    var _VirtualDom_lazy4 = F5(function(func, a, b, c, d) {
        return _VirtualDom_thunk([
            func,
            a,
            b,
            c,
            d
        ], function() {
            return A4(func, a, b, c, d);
        });
    });
    var _VirtualDom_lazy5 = F6(function(func, a, b, c, d, e) {
        return _VirtualDom_thunk([
            func,
            a,
            b,
            c,
            d,
            e
        ], function() {
            return A5(func, a, b, c, d, e);
        });
    });
    var _VirtualDom_lazy6 = F7(function(func, a, b, c, d, e, f) {
        return _VirtualDom_thunk([
            func,
            a,
            b,
            c,
            d,
            e,
            f
        ], function() {
            return A6(func, a, b, c, d, e, f);
        });
    });
    var _VirtualDom_lazy7 = F8(function(func, a, b, c, d, e, f, g) {
        return _VirtualDom_thunk([
            func,
            a,
            b,
            c,
            d,
            e,
            f,
            g
        ], function() {
            return A7(func, a, b, c, d, e, f, g);
        });
    });
    var _VirtualDom_lazy8 = F9(function(func, a, b, c, d, e, f, g, h) {
        return _VirtualDom_thunk([
            func,
            a,
            b,
            c,
            d,
            e,
            f,
            g,
            h
        ], function() {
            return A8(func, a, b, c, d, e, f, g, h);
        });
    });
    // FACTS
    var _VirtualDom_on = F2(function(key, handler) {
        return {
            $: "a0",
            n: key,
            o: handler
        };
    });
    var _VirtualDom_style = F2(function(key, value) {
        return {
            $: "a1",
            n: key,
            o: value
        };
    });
    var _VirtualDom_property = F2(function(key, value) {
        return {
            $: "a2",
            n: key,
            o: value
        };
    });
    var _VirtualDom_attribute = F2(function(key, value) {
        return {
            $: "a3",
            n: key,
            o: value
        };
    });
    var _VirtualDom_attributeNS = F3(function(namespace, key, value) {
        return {
            $: "a4",
            n: key,
            o: {
                f: namespace,
                o: value
            }
        };
    });
    // XSS ATTACK VECTOR CHECKS
    //
    // For some reason, tabs can appear in href protocols and it still works.
    // So '\tjava\tSCRIPT:alert("!!!")' and 'javascript:alert("!!!")' are the same
    // in practice. That is why _VirtualDom_RE_js and _VirtualDom_RE_js_html look
    // so freaky.
    //
    // Pulling the regular expressions out to the top level gives a slight speed
    // boost in small benchmarks (4-10%) but hoisting values to reduce allocation
    // can be unpredictable in large programs where JIT may have a harder time with
    // functions are not fully self-contained. The benefit is more that the js and
    // js_html ones are so weird that I prefer to see them near each other.
    var _VirtualDom_RE_script = /^script$/i;
    var _VirtualDom_RE_on_formAction = /^(on|formAction$)/i;
    var _VirtualDom_RE_js = /^\s*j\s*a\s*v\s*a\s*s\s*c\s*r\s*i\s*p\s*t\s*:/i;
    var _VirtualDom_RE_js_html = /^\s*(j\s*a\s*v\s*a\s*s\s*c\s*r\s*i\s*p\s*t\s*:|d\s*a\s*t\s*a\s*:\s*t\s*e\s*x\s*t\s*\/\s*h\s*t\s*m\s*l\s*(,|;))/i;
    function _VirtualDom_noScript(tag) {
        return _VirtualDom_RE_script.test(tag) ? "p" : tag;
    }
    function _VirtualDom_noOnOrFormAction(key) {
        return _VirtualDom_RE_on_formAction.test(key) ? "data-" + key : key;
    }
    function _VirtualDom_noInnerHtmlOrFormAction(key) {
        return key == "innerHTML" || key == "formAction" ? "data-" + key : key;
    }
    function _VirtualDom_noJavaScriptUri(value) {
        return _VirtualDom_RE_js.test(value) ? /**_UNUSED/''//*/ /**/ 'javascript:alert("This is an XSS vector. Please use ports or web components instead.")' //*/
         : value;
    }
    function _VirtualDom_noJavaScriptOrHtmlUri(value) {
        return _VirtualDom_RE_js_html.test(value) ? /**_UNUSED/''//*/ /**/ 'javascript:alert("This is an XSS vector. Please use ports or web components instead.")' //*/
         : value;
    }
    function _VirtualDom_noJavaScriptOrHtmlJson(value) {
        return typeof _Json_unwrap(value) === "string" && _VirtualDom_RE_js_html.test(_Json_unwrap(value)) ? _Json_wrap(/**_UNUSED/''//*/ /**/ 'javascript:alert("This is an XSS vector. Please use ports or web components instead.")' //*/
        ) : value;
    }
    // MAP FACTS
    var _VirtualDom_mapAttribute = F2(function(func, attr) {
        return attr.$ === "a0" ? A2(_VirtualDom_on, attr.n, _VirtualDom_mapHandler(func, attr.o)) : attr;
    });
    function _VirtualDom_mapHandler(func, handler) {
        var tag = $elm$virtual_dom$VirtualDom$toHandlerInt(handler);
        // 0 = Normal
        // 1 = MayStopPropagation
        // 2 = MayPreventDefault
        // 3 = Custom
        return {
            $: handler.$,
            a: !tag ? A2($elm$json$Json$Decode$map, func, handler.a) : A3($elm$json$Json$Decode$map2, tag < 3 ? _VirtualDom_mapEventTuple : _VirtualDom_mapEventRecord, $elm$json$Json$Decode$succeed(func), handler.a)
        };
    }
    var _VirtualDom_mapEventTuple = F2(function(func, tuple) {
        return _Utils_Tuple2(func(tuple.a), tuple.b);
    });
    var _VirtualDom_mapEventRecord = F2(function(func, record) {
        return {
            message: func(record.message),
            stopPropagation: record.stopPropagation,
            preventDefault: record.preventDefault
        };
    });
    // ORGANIZE FACTS
    function _VirtualDom_organizeFacts(factList) {
        for(var facts = {}; factList.b; factList = factList.b){
            var entry = factList.a;
            var tag = entry.$;
            var key = entry.n;
            var value = entry.o;
            if (tag === "a2") {
                key === "className" ? _VirtualDom_addClass(facts, key, _Json_unwrap(value)) : facts[key] = _Json_unwrap(value);
                continue;
            }
            var subFacts = facts[tag] || (facts[tag] = {});
            tag === "a3" && key === "class" ? _VirtualDom_addClass(subFacts, key, value) : subFacts[key] = value;
        }
        return facts;
    }
    function _VirtualDom_addClass(object, key, newClass) {
        var classes = object[key];
        object[key] = classes ? classes + " " + newClass : newClass;
    }
    // RENDER
    function _VirtualDom_render(vNode, eventNode) {
        var tag = vNode.$;
        if (tag === 5) return _VirtualDom_render(vNode.k || (vNode.k = vNode.m()), eventNode);
        if (tag === 0) return _VirtualDom_doc.createTextNode(vNode.a);
        if (tag === 4) {
            var subNode = vNode.k;
            var tagger = vNode.j;
            while(subNode.$ === 4){
                typeof tagger !== "object" ? tagger = [
                    tagger,
                    subNode.j
                ] : tagger.push(subNode.j);
                subNode = subNode.k;
            }
            var subEventRoot = {
                j: tagger,
                p: eventNode
            };
            var domNode = _VirtualDom_render(subNode, subEventRoot);
            domNode.elm_event_node_ref = subEventRoot;
            return domNode;
        }
        if (tag === 3) {
            var domNode = vNode.h(vNode.g);
            _VirtualDom_applyFacts(domNode, eventNode, vNode.d);
            return domNode;
        }
        // at this point `tag` must be 1 or 2
        var domNode = vNode.f ? _VirtualDom_doc.createElementNS(vNode.f, vNode.c) : _VirtualDom_doc.createElement(vNode.c);
        if (_VirtualDom_divertHrefToApp && vNode.c == "a") domNode.addEventListener("click", _VirtualDom_divertHrefToApp(domNode));
        _VirtualDom_applyFacts(domNode, eventNode, vNode.d);
        for(var kids = vNode.e, i = 0; i < kids.length; i++)_VirtualDom_appendChild(domNode, _VirtualDom_render(tag === 1 ? kids[i] : kids[i].b, eventNode));
        return domNode;
    }
    // APPLY FACTS
    function _VirtualDom_applyFacts(domNode, eventNode, facts) {
        for(var key in facts){
            var value = facts[key];
            key === "a1" ? _VirtualDom_applyStyles(domNode, value) : key === "a0" ? _VirtualDom_applyEvents(domNode, eventNode, value) : key === "a3" ? _VirtualDom_applyAttrs(domNode, value) : key === "a4" ? _VirtualDom_applyAttrsNS(domNode, value) : (key !== "value" && key !== "checked" || domNode[key] !== value) && (domNode[key] = value);
        }
    }
    // APPLY STYLES
    function _VirtualDom_applyStyles(domNode, styles) {
        var domNodeStyle = domNode.style;
        for(var key in styles)domNodeStyle[key] = styles[key];
    }
    // APPLY ATTRS
    function _VirtualDom_applyAttrs(domNode, attrs) {
        for(var key in attrs){
            var value = attrs[key];
            typeof value !== "undefined" ? domNode.setAttribute(key, value) : domNode.removeAttribute(key);
        }
    }
    // APPLY NAMESPACED ATTRS
    function _VirtualDom_applyAttrsNS(domNode, nsAttrs) {
        for(var key in nsAttrs){
            var pair = nsAttrs[key];
            var namespace = pair.f;
            var value = pair.o;
            typeof value !== "undefined" ? domNode.setAttributeNS(namespace, key, value) : domNode.removeAttributeNS(namespace, key);
        }
    }
    // APPLY EVENTS
    function _VirtualDom_applyEvents(domNode, eventNode, events) {
        var allCallbacks = domNode.elmFs || (domNode.elmFs = {});
        for(var key in events){
            var newHandler = events[key];
            var oldCallback = allCallbacks[key];
            if (!newHandler) {
                domNode.removeEventListener(key, oldCallback);
                allCallbacks[key] = undefined;
                continue;
            }
            if (oldCallback) {
                var oldHandler = oldCallback.q;
                if (oldHandler.$ === newHandler.$) {
                    oldCallback.q = newHandler;
                    continue;
                }
                domNode.removeEventListener(key, oldCallback);
            }
            oldCallback = _VirtualDom_makeCallback(eventNode, newHandler);
            domNode.addEventListener(key, oldCallback, _VirtualDom_passiveSupported && {
                passive: $elm$virtual_dom$VirtualDom$toHandlerInt(newHandler) < 2
            });
            allCallbacks[key] = oldCallback;
        }
    }
    // PASSIVE EVENTS
    var _VirtualDom_passiveSupported;
    try {
        window.addEventListener("t", null, Object.defineProperty({}, "passive", {
            get: function() {
                _VirtualDom_passiveSupported = true;
            }
        }));
    } catch (e) {}
    // EVENT HANDLERS
    function _VirtualDom_makeCallback(eventNode, initialHandler) {
        function callback(event) {
            var handler = callback.q;
            var result = _Json_runHelp(handler.a, event);
            if (!$elm$core$Result$isOk(result)) return;
            var tag = $elm$virtual_dom$VirtualDom$toHandlerInt(handler);
            // 0 = Normal
            // 1 = MayStopPropagation
            // 2 = MayPreventDefault
            // 3 = Custom
            var value = result.a;
            var message = !tag ? value : tag < 3 ? value.a : value.message;
            var stopPropagation = tag == 1 ? value.b : tag == 3 && value.stopPropagation;
            var currentEventNode = (stopPropagation && event.stopPropagation(), (tag == 2 ? value.b : tag == 3 && value.preventDefault) && event.preventDefault(), eventNode);
            var tagger;
            var i;
            while(tagger = currentEventNode.j){
                if (typeof tagger == "function") message = tagger(message);
                else for(var i = tagger.length; i--;)message = tagger[i](message);
                currentEventNode = currentEventNode.p;
            }
            currentEventNode(message, stopPropagation); // stopPropagation implies isSync
        }
        callback.q = initialHandler;
        return callback;
    }
    function _VirtualDom_equalEvents(x, y) {
        return x.$ == y.$ && _Json_equality(x.a, y.a);
    }
    // DIFF
    // TODO: Should we do patches like in iOS?
    //
    // type Patch
    //   = At Int Patch
    //   | Batch (List Patch)
    //   | Change ...
    //
    // How could it not be better?
    //
    function _VirtualDom_diff(x, y) {
        var patches = [];
        _VirtualDom_diffHelp(x, y, patches, 0);
        return patches;
    }
    function _VirtualDom_pushPatch(patches, type, index, data) {
        var patch = {
            $: type,
            r: index,
            s: data,
            t: undefined,
            u: undefined
        };
        patches.push(patch);
        return patch;
    }
    function _VirtualDom_diffHelp(x, y, patches, index) {
        if (x === y) return;
        var xType = x.$;
        var yType = y.$;
        // Bail if you run into different types of nodes. Implies that the
        // structure has changed significantly and it's not worth a diff.
        if (xType !== yType) {
            if (xType === 1 && yType === 2) {
                y = _VirtualDom_dekey(y);
                yType = 1;
            } else {
                _VirtualDom_pushPatch(patches, 0, index, y);
                return;
            }
        }
        // Now we know that both nodes are the same $.
        switch(yType){
            case 5:
                var xRefs = x.l;
                var yRefs = y.l;
                var i = xRefs.length;
                var same = i === yRefs.length;
                while(same && i--)same = xRefs[i] === yRefs[i];
                if (same) {
                    y.k = x.k;
                    return;
                }
                y.k = y.m();
                var subPatches = [];
                _VirtualDom_diffHelp(x.k, y.k, subPatches, 0);
                subPatches.length > 0 && _VirtualDom_pushPatch(patches, 1, index, subPatches);
                return;
            case 4:
                // gather nested taggers
                var xTaggers = x.j;
                var yTaggers = y.j;
                var nesting = false;
                var xSubNode = x.k;
                while(xSubNode.$ === 4){
                    nesting = true;
                    typeof xTaggers !== "object" ? xTaggers = [
                        xTaggers,
                        xSubNode.j
                    ] : xTaggers.push(xSubNode.j);
                    xSubNode = xSubNode.k;
                }
                var ySubNode = y.k;
                while(ySubNode.$ === 4){
                    nesting = true;
                    typeof yTaggers !== "object" ? yTaggers = [
                        yTaggers,
                        ySubNode.j
                    ] : yTaggers.push(ySubNode.j);
                    ySubNode = ySubNode.k;
                }
                // Just bail if different numbers of taggers. This implies the
                // structure of the virtual DOM has changed.
                if (nesting && xTaggers.length !== yTaggers.length) {
                    _VirtualDom_pushPatch(patches, 0, index, y);
                    return;
                }
                // check if taggers are "the same"
                if (nesting ? !_VirtualDom_pairwiseRefEqual(xTaggers, yTaggers) : xTaggers !== yTaggers) _VirtualDom_pushPatch(patches, 2, index, yTaggers);
                // diff everything below the taggers
                _VirtualDom_diffHelp(xSubNode, ySubNode, patches, index + 1);
                return;
            case 0:
                if (x.a !== y.a) _VirtualDom_pushPatch(patches, 3, index, y.a);
                return;
            case 1:
                _VirtualDom_diffNodes(x, y, patches, index, _VirtualDom_diffKids);
                return;
            case 2:
                _VirtualDom_diffNodes(x, y, patches, index, _VirtualDom_diffKeyedKids);
                return;
            case 3:
                if (x.h !== y.h) {
                    _VirtualDom_pushPatch(patches, 0, index, y);
                    return;
                }
                var factsDiff = _VirtualDom_diffFacts(x.d, y.d);
                factsDiff && _VirtualDom_pushPatch(patches, 4, index, factsDiff);
                var patch = y.i(x.g, y.g);
                patch && _VirtualDom_pushPatch(patches, 5, index, patch);
                return;
        }
    }
    // assumes the incoming arrays are the same length
    function _VirtualDom_pairwiseRefEqual(as, bs) {
        for(var i = 0; i < as.length; i++){
            if (as[i] !== bs[i]) return false;
        }
        return true;
    }
    function _VirtualDom_diffNodes(x, y, patches, index, diffKids) {
        // Bail if obvious indicators have changed. Implies more serious
        // structural changes such that it's not worth it to diff.
        if (x.c !== y.c || x.f !== y.f) {
            _VirtualDom_pushPatch(patches, 0, index, y);
            return;
        }
        var factsDiff = _VirtualDom_diffFacts(x.d, y.d);
        factsDiff && _VirtualDom_pushPatch(patches, 4, index, factsDiff);
        diffKids(x, y, patches, index);
    }
    // DIFF FACTS
    // TODO Instead of creating a new diff object, it's possible to just test if
    // there *is* a diff. During the actual patch, do the diff again and make the
    // modifications directly. This way, there's no new allocations. Worth it?
    function _VirtualDom_diffFacts(x, y, category) {
        var diff;
        // look for changes and removals
        for(var xKey in x){
            if (xKey === "a1" || xKey === "a0" || xKey === "a3" || xKey === "a4") {
                var subDiff = _VirtualDom_diffFacts(x[xKey], y[xKey] || {}, xKey);
                if (subDiff) {
                    diff = diff || {};
                    diff[xKey] = subDiff;
                }
                continue;
            }
            // remove if not in the new facts
            if (!(xKey in y)) {
                diff = diff || {};
                diff[xKey] = !category ? typeof x[xKey] === "string" ? "" : null : category === "a1" ? "" : category === "a0" || category === "a3" ? undefined : {
                    f: x[xKey].f,
                    o: undefined
                };
                continue;
            }
            var xValue = x[xKey];
            var yValue = y[xKey];
            // reference equal, so don't worry about it
            if (xValue === yValue && xKey !== "value" && xKey !== "checked" || category === "a0" && _VirtualDom_equalEvents(xValue, yValue)) continue;
            diff = diff || {};
            diff[xKey] = yValue;
        }
        // add new stuff
        for(var yKey in y)if (!(yKey in x)) {
            diff = diff || {};
            diff[yKey] = y[yKey];
        }
        return diff;
    }
    // DIFF KIDS
    function _VirtualDom_diffKids(xParent, yParent, patches, index) {
        var xKids = xParent.e;
        var yKids = yParent.e;
        var xLen = xKids.length;
        var yLen = yKids.length;
        // FIGURE OUT IF THERE ARE INSERTS OR REMOVALS
        if (xLen > yLen) _VirtualDom_pushPatch(patches, 6, index, {
            v: yLen,
            i: xLen - yLen
        });
        else if (xLen < yLen) _VirtualDom_pushPatch(patches, 7, index, {
            v: xLen,
            e: yKids
        });
        // PAIRWISE DIFF EVERYTHING ELSE
        for(var minLen = xLen < yLen ? xLen : yLen, i = 0; i < minLen; i++){
            var xKid = xKids[i];
            _VirtualDom_diffHelp(xKid, yKids[i], patches, ++index);
            index += xKid.b || 0;
        }
    }
    // KEYED DIFF
    function _VirtualDom_diffKeyedKids(xParent, yParent, patches, rootIndex) {
        var localPatches = [];
        var changes = {}; // Dict String Entry
        var inserts = []; // Array { index : Int, entry : Entry }
        // type Entry = { tag : String, vnode : VNode, index : Int, data : _ }
        var xKids = xParent.e;
        var yKids = yParent.e;
        var xLen = xKids.length;
        var yLen = yKids.length;
        var xIndex = 0;
        var yIndex = 0;
        var index = rootIndex;
        while(xIndex < xLen && yIndex < yLen){
            var x = xKids[xIndex];
            var y = yKids[yIndex];
            var xKey = x.a;
            var yKey = y.a;
            var xNode = x.b;
            var yNode = y.b;
            var newMatch = undefined;
            var oldMatch = undefined;
            // check if keys match
            if (xKey === yKey) {
                index++;
                _VirtualDom_diffHelp(xNode, yNode, localPatches, index);
                index += xNode.b || 0;
                xIndex++;
                yIndex++;
                continue;
            }
            // look ahead 1 to detect insertions and removals.
            var xNext = xKids[xIndex + 1];
            var yNext = yKids[yIndex + 1];
            if (xNext) {
                var xNextKey = xNext.a;
                var xNextNode = xNext.b;
                oldMatch = yKey === xNextKey;
            }
            if (yNext) {
                var yNextKey = yNext.a;
                var yNextNode = yNext.b;
                newMatch = xKey === yNextKey;
            }
            // swap x and y
            if (newMatch && oldMatch) {
                index++;
                _VirtualDom_diffHelp(xNode, yNextNode, localPatches, index);
                _VirtualDom_insertNode(changes, localPatches, xKey, yNode, yIndex, inserts);
                index += xNode.b || 0;
                index++;
                _VirtualDom_removeNode(changes, localPatches, xKey, xNextNode, index);
                index += xNextNode.b || 0;
                xIndex += 2;
                yIndex += 2;
                continue;
            }
            // insert y
            if (newMatch) {
                index++;
                _VirtualDom_insertNode(changes, localPatches, yKey, yNode, yIndex, inserts);
                _VirtualDom_diffHelp(xNode, yNextNode, localPatches, index);
                index += xNode.b || 0;
                xIndex += 1;
                yIndex += 2;
                continue;
            }
            // remove x
            if (oldMatch) {
                index++;
                _VirtualDom_removeNode(changes, localPatches, xKey, xNode, index);
                index += xNode.b || 0;
                index++;
                _VirtualDom_diffHelp(xNextNode, yNode, localPatches, index);
                index += xNextNode.b || 0;
                xIndex += 2;
                yIndex += 1;
                continue;
            }
            // remove x, insert y
            if (xNext && xNextKey === yNextKey) {
                index++;
                _VirtualDom_removeNode(changes, localPatches, xKey, xNode, index);
                _VirtualDom_insertNode(changes, localPatches, yKey, yNode, yIndex, inserts);
                index += xNode.b || 0;
                index++;
                _VirtualDom_diffHelp(xNextNode, yNextNode, localPatches, index);
                index += xNextNode.b || 0;
                xIndex += 2;
                yIndex += 2;
                continue;
            }
            break;
        }
        // eat up any remaining nodes with removeNode and insertNode
        while(xIndex < xLen){
            index++;
            var x = xKids[xIndex];
            var xNode = x.b;
            _VirtualDom_removeNode(changes, localPatches, x.a, xNode, index);
            index += xNode.b || 0;
            xIndex++;
        }
        while(yIndex < yLen){
            var endInserts = endInserts || [];
            var y = yKids[yIndex];
            _VirtualDom_insertNode(changes, localPatches, y.a, y.b, undefined, endInserts);
            yIndex++;
        }
        if (localPatches.length > 0 || inserts.length > 0 || endInserts) _VirtualDom_pushPatch(patches, 8, rootIndex, {
            w: localPatches,
            x: inserts,
            y: endInserts
        });
    }
    // CHANGES FROM KEYED DIFF
    var _VirtualDom_POSTFIX = "_elmW6BL";
    function _VirtualDom_insertNode(changes, localPatches, key, vnode, yIndex, inserts) {
        var entry = changes[key];
        // never seen this key before
        if (!entry) {
            entry = {
                c: 0,
                z: vnode,
                r: yIndex,
                s: undefined
            };
            inserts.push({
                r: yIndex,
                A: entry
            });
            changes[key] = entry;
            return;
        }
        // this key was removed earlier, a match!
        if (entry.c === 1) {
            inserts.push({
                r: yIndex,
                A: entry
            });
            entry.c = 2;
            var subPatches = [];
            _VirtualDom_diffHelp(entry.z, vnode, subPatches, entry.r);
            entry.r = yIndex;
            entry.s.s = {
                w: subPatches,
                A: entry
            };
            return;
        }
        // this key has already been inserted or moved, a duplicate!
        _VirtualDom_insertNode(changes, localPatches, key + _VirtualDom_POSTFIX, vnode, yIndex, inserts);
    }
    function _VirtualDom_removeNode(changes, localPatches, key, vnode, index) {
        var entry = changes[key];
        // never seen this key before
        if (!entry) {
            var patch = _VirtualDom_pushPatch(localPatches, 9, index, undefined);
            changes[key] = {
                c: 1,
                z: vnode,
                r: index,
                s: patch
            };
            return;
        }
        // this key was inserted earlier, a match!
        if (entry.c === 0) {
            entry.c = 2;
            var subPatches = [];
            _VirtualDom_diffHelp(vnode, entry.z, subPatches, index);
            _VirtualDom_pushPatch(localPatches, 9, index, {
                w: subPatches,
                A: entry
            });
            return;
        }
        // this key has already been removed or moved, a duplicate!
        _VirtualDom_removeNode(changes, localPatches, key + _VirtualDom_POSTFIX, vnode, index);
    }
    // ADD DOM NODES
    //
    // Each DOM node has an "index" assigned in order of traversal. It is important
    // to minimize our crawl over the actual DOM, so these indexes (along with the
    // descendantsCount of virtual nodes) let us skip touching entire subtrees of
    // the DOM if we know there are no patches there.
    function _VirtualDom_addDomNodes(domNode, vNode, patches, eventNode) {
        _VirtualDom_addDomNodesHelp(domNode, vNode, patches, 0, 0, vNode.b, eventNode);
    }
    // assumes `patches` is non-empty and indexes increase monotonically.
    function _VirtualDom_addDomNodesHelp(domNode, vNode, patches, i, low, high, eventNode) {
        var patch = patches[i];
        var index = patch.r;
        while(index === low){
            var patchType = patch.$;
            if (patchType === 1) _VirtualDom_addDomNodes(domNode, vNode.k, patch.s, eventNode);
            else if (patchType === 8) {
                patch.t = domNode;
                patch.u = eventNode;
                var subPatches = patch.s.w;
                if (subPatches.length > 0) _VirtualDom_addDomNodesHelp(domNode, vNode, subPatches, 0, low, high, eventNode);
            } else if (patchType === 9) {
                patch.t = domNode;
                patch.u = eventNode;
                var data = patch.s;
                if (data) {
                    data.A.s = domNode;
                    var subPatches = data.w;
                    if (subPatches.length > 0) _VirtualDom_addDomNodesHelp(domNode, vNode, subPatches, 0, low, high, eventNode);
                }
            } else {
                patch.t = domNode;
                patch.u = eventNode;
            }
            i++;
            if (!(patch = patches[i]) || (index = patch.r) > high) return i;
        }
        var tag = vNode.$;
        if (tag === 4) {
            var subNode = vNode.k;
            while(subNode.$ === 4)subNode = subNode.k;
            return _VirtualDom_addDomNodesHelp(domNode, subNode, patches, i, low + 1, high, domNode.elm_event_node_ref);
        }
        // tag must be 1 or 2 at this point
        var vKids = vNode.e;
        var childNodes = domNode.childNodes;
        for(var j = 0; j < vKids.length; j++){
            low++;
            var vKid = tag === 1 ? vKids[j] : vKids[j].b;
            var nextLow = low + (vKid.b || 0);
            if (low <= index && index <= nextLow) {
                i = _VirtualDom_addDomNodesHelp(childNodes[j], vKid, patches, i, low, nextLow, eventNode);
                if (!(patch = patches[i]) || (index = patch.r) > high) return i;
            }
            low = nextLow;
        }
        return i;
    }
    // APPLY PATCHES
    function _VirtualDom_applyPatches(rootDomNode, oldVirtualNode, patches, eventNode) {
        if (patches.length === 0) return rootDomNode;
        _VirtualDom_addDomNodes(rootDomNode, oldVirtualNode, patches, eventNode);
        return _VirtualDom_applyPatchesHelp(rootDomNode, patches);
    }
    function _VirtualDom_applyPatchesHelp(rootDomNode, patches) {
        for(var i = 0; i < patches.length; i++){
            var patch = patches[i];
            var localDomNode = patch.t;
            var newNode = _VirtualDom_applyPatch(localDomNode, patch);
            if (localDomNode === rootDomNode) rootDomNode = newNode;
        }
        return rootDomNode;
    }
    function _VirtualDom_applyPatch(domNode, patch) {
        switch(patch.$){
            case 0:
                return _VirtualDom_applyPatchRedraw(domNode, patch.s, patch.u);
            case 4:
                _VirtualDom_applyFacts(domNode, patch.u, patch.s);
                return domNode;
            case 3:
                domNode.replaceData(0, domNode.length, patch.s);
                return domNode;
            case 1:
                return _VirtualDom_applyPatchesHelp(domNode, patch.s);
            case 2:
                if (domNode.elm_event_node_ref) domNode.elm_event_node_ref.j = patch.s;
                else domNode.elm_event_node_ref = {
                    j: patch.s,
                    p: patch.u
                };
                return domNode;
            case 6:
                var data = patch.s;
                for(var i = 0; i < data.i; i++)domNode.removeChild(domNode.childNodes[data.v]);
                return domNode;
            case 7:
                var data = patch.s;
                var kids = data.e;
                var i = data.v;
                var theEnd = domNode.childNodes[i];
                for(; i < kids.length; i++)domNode.insertBefore(_VirtualDom_render(kids[i], patch.u), theEnd);
                return domNode;
            case 9:
                var data = patch.s;
                if (!data) {
                    domNode.parentNode.removeChild(domNode);
                    return domNode;
                }
                var entry = data.A;
                if (typeof entry.r !== "undefined") domNode.parentNode.removeChild(domNode);
                entry.s = _VirtualDom_applyPatchesHelp(domNode, data.w);
                return domNode;
            case 8:
                return _VirtualDom_applyPatchReorder(domNode, patch);
            case 5:
                return patch.s(domNode);
            default:
                _Debug_crash(10); // 'Ran into an unknown patch!'
        }
    }
    function _VirtualDom_applyPatchRedraw(domNode, vNode, eventNode) {
        var parentNode = domNode.parentNode;
        var newNode = _VirtualDom_render(vNode, eventNode);
        if (!newNode.elm_event_node_ref) newNode.elm_event_node_ref = domNode.elm_event_node_ref;
        if (parentNode && newNode !== domNode) parentNode.replaceChild(newNode, domNode);
        return newNode;
    }
    function _VirtualDom_applyPatchReorder(domNode, patch) {
        var data = patch.s;
        // remove end inserts
        var frag = _VirtualDom_applyPatchReorderEndInsertsHelp(data.y, patch);
        // removals
        domNode = _VirtualDom_applyPatchesHelp(domNode, data.w);
        // inserts
        var inserts = data.x;
        for(var i = 0; i < inserts.length; i++){
            var insert = inserts[i];
            var entry = insert.A;
            var node = entry.c === 2 ? entry.s : _VirtualDom_render(entry.z, patch.u);
            domNode.insertBefore(node, domNode.childNodes[insert.r]);
        }
        // add end inserts
        if (frag) _VirtualDom_appendChild(domNode, frag);
        return domNode;
    }
    function _VirtualDom_applyPatchReorderEndInsertsHelp(endInserts, patch) {
        if (!endInserts) return;
        var frag = _VirtualDom_doc.createDocumentFragment();
        for(var i = 0; i < endInserts.length; i++){
            var insert = endInserts[i];
            var entry = insert.A;
            _VirtualDom_appendChild(frag, entry.c === 2 ? entry.s : _VirtualDom_render(entry.z, patch.u));
        }
        return frag;
    }
    function _VirtualDom_virtualize(node) {
        // TEXT NODES
        if (node.nodeType === 3) return _VirtualDom_text(node.textContent);
        // WEIRD NODES
        if (node.nodeType !== 1) return _VirtualDom_text("");
        // ELEMENT NODES
        var attrList = _List_Nil;
        var attrs = node.attributes;
        for(var i = attrs.length; i--;){
            var attr = attrs[i];
            var name = attr.name;
            var value = attr.value;
            attrList = _List_Cons(A2(_VirtualDom_attribute, name, value), attrList);
        }
        var tag = node.tagName.toLowerCase();
        var kidList = _List_Nil;
        var kids = node.childNodes;
        for(var i = kids.length; i--;)kidList = _List_Cons(_VirtualDom_virtualize(kids[i]), kidList);
        return A3(_VirtualDom_node, tag, attrList, kidList);
    }
    function _VirtualDom_dekey(keyedNode) {
        var keyedKids = keyedNode.e;
        var len = keyedKids.length;
        var kids = new Array(len);
        for(var i = 0; i < len; i++)kids[i] = keyedKids[i].b;
        return {
            $: 1,
            c: keyedNode.c,
            d: keyedNode.d,
            e: kids,
            f: keyedNode.f,
            b: keyedNode.b
        };
    }
    var _Bitwise_and = F2(function(a, b) {
        return a & b;
    });
    var _Bitwise_or = F2(function(a, b) {
        return a | b;
    });
    var _Bitwise_xor = F2(function(a, b) {
        return a ^ b;
    });
    function _Bitwise_complement(a) {
        return ~a;
    }
    var _Bitwise_shiftLeftBy = F2(function(offset, a) {
        return a << offset;
    });
    var _Bitwise_shiftRightBy = F2(function(offset, a) {
        return a >> offset;
    });
    var _Bitwise_shiftRightZfBy = F2(function(offset, a) {
        return a >>> offset;
    });
    // HELPERS
    function _Debugger_unsafeCoerce(value) {
        return value;
    }
    // PROGRAMS
    var _Debugger_element = F4(function(impl, flagDecoder, debugMetadata, args) {
        return _Platform_initialize(flagDecoder, args, A3($elm$browser$Debugger$Main$wrapInit, _Json_wrap(debugMetadata), _Debugger_popout(), impl.init), $elm$browser$Debugger$Main$wrapUpdate(impl.update), $elm$browser$Debugger$Main$wrapSubs(impl.subscriptions), function(sendToApp, initialModel) {
            var view = impl.view;
            var title = _VirtualDom_doc.title;
            var domNode = args && args["node"] ? args["node"] : _Debug_crash(0);
            var currNode = _VirtualDom_virtualize(domNode);
            var currBlocker = $elm$browser$Debugger$Main$toBlockerType(initialModel);
            var currPopout;
            var cornerNode = _VirtualDom_doc.createElement("div");
            domNode.parentNode.insertBefore(cornerNode, domNode.nextSibling);
            var cornerCurr = _VirtualDom_virtualize(cornerNode);
            initialModel.popout.a = sendToApp;
            return _Browser_makeAnimator(initialModel, function(model) {
                var nextNode = A2(_VirtualDom_map, $elm$browser$Debugger$Main$UserMsg, view($elm$browser$Debugger$Main$getUserModel(model)));
                var patches = _VirtualDom_diff(currNode, nextNode);
                domNode = _VirtualDom_applyPatches(domNode, currNode, patches, sendToApp);
                currNode = nextNode;
                // update blocker
                var nextBlocker = $elm$browser$Debugger$Main$toBlockerType(model);
                _Debugger_updateBlocker(currBlocker, nextBlocker);
                currBlocker = nextBlocker;
                // view corner
                var cornerNext = $elm$browser$Debugger$Main$cornerView(model);
                var cornerPatches = _VirtualDom_diff(cornerCurr, cornerNext);
                cornerNode = _VirtualDom_applyPatches(cornerNode, cornerCurr, cornerPatches, sendToApp);
                cornerCurr = cornerNext;
                if (!model.popout.b) {
                    currPopout = undefined;
                    return;
                }
                // view popout
                _VirtualDom_doc = model.popout.b; // SWITCH TO POPOUT DOC
                currPopout || (currPopout = _VirtualDom_virtualize(model.popout.b));
                var nextPopout = $elm$browser$Debugger$Main$popoutView(model);
                var popoutPatches = _VirtualDom_diff(currPopout, nextPopout);
                _VirtualDom_applyPatches(model.popout.b.body, currPopout, popoutPatches, sendToApp);
                currPopout = nextPopout;
                _VirtualDom_doc = document; // SWITCH BACK TO NORMAL DOC
            });
        });
    });
    var _Debugger_document = F4(function(impl, flagDecoder, debugMetadata, args) {
        return _Platform_initialize(flagDecoder, args, A3($elm$browser$Debugger$Main$wrapInit, _Json_wrap(debugMetadata), _Debugger_popout(), impl.init), $elm$browser$Debugger$Main$wrapUpdate(impl.update), $elm$browser$Debugger$Main$wrapSubs(impl.subscriptions), function(sendToApp, initialModel) {
            var divertHrefToApp = impl.setup && impl.setup(function(x) {
                return sendToApp($elm$browser$Debugger$Main$UserMsg(x));
            });
            var view = impl.view;
            var title = _VirtualDom_doc.title;
            var bodyNode = _VirtualDom_doc.body;
            var currNode = _VirtualDom_virtualize(bodyNode);
            var currBlocker = $elm$browser$Debugger$Main$toBlockerType(initialModel);
            var currPopout;
            initialModel.popout.a = sendToApp;
            return _Browser_makeAnimator(initialModel, function(model) {
                _VirtualDom_divertHrefToApp = divertHrefToApp;
                var doc = view($elm$browser$Debugger$Main$getUserModel(model));
                var nextNode = _VirtualDom_node("body")(_List_Nil)(_Utils_ap(A2($elm$core$List$map, _VirtualDom_map($elm$browser$Debugger$Main$UserMsg), doc.body), _List_Cons($elm$browser$Debugger$Main$cornerView(model), _List_Nil)));
                var patches = _VirtualDom_diff(currNode, nextNode);
                bodyNode = _VirtualDom_applyPatches(bodyNode, currNode, patches, sendToApp);
                currNode = nextNode;
                _VirtualDom_divertHrefToApp = 0;
                title !== doc.title && (_VirtualDom_doc.title = title = doc.title);
                // update blocker
                var nextBlocker = $elm$browser$Debugger$Main$toBlockerType(model);
                _Debugger_updateBlocker(currBlocker, nextBlocker);
                currBlocker = nextBlocker;
                // view popout
                if (!model.popout.b) {
                    currPopout = undefined;
                    return;
                }
                _VirtualDom_doc = model.popout.b; // SWITCH TO POPOUT DOC
                currPopout || (currPopout = _VirtualDom_virtualize(model.popout.b));
                var nextPopout = $elm$browser$Debugger$Main$popoutView(model);
                var popoutPatches = _VirtualDom_diff(currPopout, nextPopout);
                _VirtualDom_applyPatches(model.popout.b.body, currPopout, popoutPatches, sendToApp);
                currPopout = nextPopout;
                _VirtualDom_doc = document; // SWITCH BACK TO NORMAL DOC
            });
        });
    });
    function _Debugger_popout() {
        return {
            b: undefined,
            a: undefined
        };
    }
    function _Debugger_isOpen(popout) {
        return !!popout.b;
    }
    function _Debugger_open(popout) {
        return _Scheduler_binding(function(callback) {
            _Debugger_openWindow(popout);
            callback(_Scheduler_succeed(_Utils_Tuple0));
        });
    }
    function _Debugger_openWindow(popout) {
        var w = $elm$browser$Debugger$Main$initialWindowWidth, h = $elm$browser$Debugger$Main$initialWindowHeight, x = screen.width - w, y = screen.height - h;
        var debuggerWindow = window.open("", "", "width=" + w + ",height=" + h + ",left=" + x + ",top=" + y);
        var doc = debuggerWindow.document;
        doc.title = "Elm Debugger";
        // handle arrow keys
        doc.addEventListener("keydown", function(event) {
            event.metaKey && event.which === 82 && window.location.reload();
            event.key === "ArrowUp" && (popout.a($elm$browser$Debugger$Main$Up), event.preventDefault());
            event.key === "ArrowDown" && (popout.a($elm$browser$Debugger$Main$Down), event.preventDefault());
        });
        // handle window close
        window.addEventListener("unload", close);
        debuggerWindow.addEventListener("unload", function() {
            popout.b = undefined;
            popout.a($elm$browser$Debugger$Main$NoOp);
            window.removeEventListener("unload", close);
        });
        function close() {
            popout.b = undefined;
            popout.a($elm$browser$Debugger$Main$NoOp);
            debuggerWindow.close();
        }
        // register new window
        popout.b = doc;
    }
    // SCROLL
    function _Debugger_scroll(popout) {
        return _Scheduler_binding(function(callback) {
            if (popout.b) {
                var msgs = popout.b.getElementById("elm-debugger-sidebar");
                if (msgs && msgs.scrollTop !== 0) msgs.scrollTop = 0;
            }
            callback(_Scheduler_succeed(_Utils_Tuple0));
        });
    }
    var _Debugger_scrollTo = F2(function(id, popout) {
        return _Scheduler_binding(function(callback) {
            if (popout.b) {
                var msg = popout.b.getElementById(id);
                if (msg) msg.scrollIntoView(false);
            }
            callback(_Scheduler_succeed(_Utils_Tuple0));
        });
    });
    // UPLOAD
    function _Debugger_upload(popout) {
        return _Scheduler_binding(function(callback) {
            var doc = popout.b || document;
            var element = doc.createElement("input");
            element.setAttribute("type", "file");
            element.setAttribute("accept", "text/json");
            element.style.display = "none";
            element.addEventListener("change", function(event) {
                var fileReader = new FileReader();
                fileReader.onload = function(e) {
                    callback(_Scheduler_succeed(e.target.result));
                };
                fileReader.readAsText(event.target.files[0]);
                doc.body.removeChild(element);
            });
            doc.body.appendChild(element);
            element.click();
        });
    }
    // DOWNLOAD
    var _Debugger_download = F2(function(historyLength, json) {
        return _Scheduler_binding(function(callback) {
            var fileName = "history-" + historyLength + ".txt";
            var jsonString = JSON.stringify(json);
            var mime = "text/plain;charset=utf-8";
            var done = _Scheduler_succeed(_Utils_Tuple0);
            // for IE10+
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(new Blob([
                    jsonString
                ], {
                    type: mime
                }), fileName);
                return callback(done);
            }
            // for HTML5
            var element = document.createElement("a");
            element.setAttribute("href", "data:" + mime + "," + encodeURIComponent(jsonString));
            element.setAttribute("download", fileName);
            element.style.display = "none";
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
            callback(done);
        });
    });
    // POPOUT CONTENT
    function _Debugger_messageToString(value) {
        if (typeof value === "boolean") return value ? "True" : "False";
        if (typeof value === "number") return value + "";
        if (typeof value === "string") return '"' + _Debugger_addSlashes(value, false) + '"';
        if (value instanceof String) return "'" + _Debugger_addSlashes(value, true) + "'";
        if (typeof value !== "object" || value === null || !("$" in value)) return "\u2026";
        if (typeof value.$ === "number") return "\u2026";
        var code = value.$.charCodeAt(0);
        if (code === 0x23 /* # */  || /* a */ 0x61 <= code && code <= 0x7A /* z */ ) return "\u2026";
        if ([
            "Array_elm_builtin",
            "Set_elm_builtin",
            "RBNode_elm_builtin",
            "RBEmpty_elm_builtin"
        ].indexOf(value.$) >= 0) return "\u2026";
        var keys = Object.keys(value);
        switch(keys.length){
            case 1:
                return value.$;
            case 2:
                return value.$ + " " + _Debugger_messageToString(value.a);
            default:
                return value.$ + " \u2026 " + _Debugger_messageToString(value[keys[keys.length - 1]]);
        }
    }
    function _Debugger_init(value) {
        if (typeof value === "boolean") return A3($elm$browser$Debugger$Expando$Constructor, $elm$core$Maybe$Just(value ? "True" : "False"), true, _List_Nil);
        if (typeof value === "number") return $elm$browser$Debugger$Expando$Primitive(value + "");
        if (typeof value === "string") return $elm$browser$Debugger$Expando$S('"' + _Debugger_addSlashes(value, false) + '"');
        if (value instanceof String) return $elm$browser$Debugger$Expando$S("'" + _Debugger_addSlashes(value, true) + "'");
        if (typeof value === "object" && "$" in value) {
            var tag = value.$;
            if (tag === "::" || tag === "[]") return A3($elm$browser$Debugger$Expando$Sequence, $elm$browser$Debugger$Expando$ListSeq, true, A2($elm$core$List$map, _Debugger_init, value));
            if (tag === "Set_elm_builtin") return A3($elm$browser$Debugger$Expando$Sequence, $elm$browser$Debugger$Expando$SetSeq, true, A3($elm$core$Set$foldr, _Debugger_initCons, _List_Nil, value));
            if (tag === "RBNode_elm_builtin" || tag == "RBEmpty_elm_builtin") return A2($elm$browser$Debugger$Expando$Dictionary, true, A3($elm$core$Dict$foldr, _Debugger_initKeyValueCons, _List_Nil, value));
            if (tag === "Array_elm_builtin") return A3($elm$browser$Debugger$Expando$Sequence, $elm$browser$Debugger$Expando$ArraySeq, true, A3($elm$core$Array$foldr, _Debugger_initCons, _List_Nil, value));
            if (typeof tag === "number") return $elm$browser$Debugger$Expando$Primitive("<internals>");
            var char = tag.charCodeAt(0);
            if (char === 35 || 65 <= char && char <= 90) {
                var list = _List_Nil;
                for(var i in value){
                    if (i === "$") continue;
                    list = _List_Cons(_Debugger_init(value[i]), list);
                }
                return A3($elm$browser$Debugger$Expando$Constructor, char === 35 ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(tag), true, $elm$core$List$reverse(list));
            }
            return $elm$browser$Debugger$Expando$Primitive("<internals>");
        }
        if (typeof value === "object") {
            var dict = $elm$core$Dict$empty;
            for(var i in value)dict = A3($elm$core$Dict$insert, i, _Debugger_init(value[i]), dict);
            return A2($elm$browser$Debugger$Expando$Record, true, dict);
        }
        return $elm$browser$Debugger$Expando$Primitive("<internals>");
    }
    var _Debugger_initCons = F2(function initConsHelp(value, list) {
        return _List_Cons(_Debugger_init(value), list);
    });
    var _Debugger_initKeyValueCons = F3(function(key, value, list) {
        return _List_Cons(_Utils_Tuple2(_Debugger_init(key), _Debugger_init(value)), list);
    });
    function _Debugger_addSlashes(str, isChar) {
        var s = str.replace(/\\/g, "\\\\").replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r").replace(/\v/g, "\\v").replace(/\0/g, "\\0");
        if (isChar) return s.replace(/\'/g, "\\'");
        else return s.replace(/\"/g, '\\"');
    }
    // BLOCK EVENTS
    function _Debugger_updateBlocker(oldBlocker, newBlocker) {
        if (oldBlocker === newBlocker) return;
        var oldEvents = _Debugger_blockerToEvents(oldBlocker);
        var newEvents = _Debugger_blockerToEvents(newBlocker);
        // remove old blockers
        for(var i = 0; i < oldEvents.length; i++)document.removeEventListener(oldEvents[i], _Debugger_blocker, true);
        // add new blockers
        for(var i = 0; i < newEvents.length; i++)document.addEventListener(newEvents[i], _Debugger_blocker, true);
    }
    function _Debugger_blocker(event) {
        if (event.type === "keydown" && event.metaKey && event.which === 82) return;
        var isScroll = event.type === "scroll" || event.type === "wheel";
        for(var node = event.target; node; node = node.parentNode){
            if (isScroll ? node.id === "elm-debugger-details" : node.id === "elm-debugger-overlay") return;
        }
        event.stopPropagation();
        event.preventDefault();
    }
    function _Debugger_blockerToEvents(blocker) {
        return blocker === $elm$browser$Debugger$Overlay$BlockNone ? [] : blocker === $elm$browser$Debugger$Overlay$BlockMost ? _Debugger_mostEvents : _Debugger_allEvents;
    }
    var _Debugger_mostEvents = [
        "click",
        "dblclick",
        "mousemove",
        "mouseup",
        "mousedown",
        "mouseenter",
        "mouseleave",
        "touchstart",
        "touchend",
        "touchcancel",
        "touchmove",
        "pointerdown",
        "pointerup",
        "pointerover",
        "pointerout",
        "pointerenter",
        "pointerleave",
        "pointermove",
        "pointercancel",
        "dragstart",
        "drag",
        "dragend",
        "dragenter",
        "dragover",
        "dragleave",
        "drop",
        "keyup",
        "keydown",
        "keypress",
        "input",
        "change",
        "focus",
        "blur"
    ];
    var _Debugger_allEvents = _Debugger_mostEvents.concat("wheel", "scroll");
    // ELEMENT
    var _Debugger_element;
    var _Browser_element = _Debugger_element || F4(function(impl, flagDecoder, debugMetadata, args) {
        return _Platform_initialize(flagDecoder, args, impl.init, impl.update, impl.subscriptions, function(sendToApp, initialModel) {
            var view = impl.view;
            /**_UNUSED/
			var domNode = args['node'];
			//*/ /**/ var domNode = args && args["node"] ? args["node"] : _Debug_crash(0);
            //*/
            var currNode = _VirtualDom_virtualize(domNode);
            return _Browser_makeAnimator(initialModel, function(model) {
                var nextNode = view(model);
                var patches = _VirtualDom_diff(currNode, nextNode);
                domNode = _VirtualDom_applyPatches(domNode, currNode, patches, sendToApp);
                currNode = nextNode;
            });
        });
    });
    // DOCUMENT
    var _Debugger_document;
    var _Browser_document = _Debugger_document || F4(function(impl, flagDecoder, debugMetadata, args) {
        return _Platform_initialize(flagDecoder, args, impl.init, impl.update, impl.subscriptions, function(sendToApp, initialModel) {
            var divertHrefToApp = impl.setup && impl.setup(sendToApp);
            var view = impl.view;
            var title = _VirtualDom_doc.title;
            var bodyNode = _VirtualDom_doc.body;
            var currNode = _VirtualDom_virtualize(bodyNode);
            return _Browser_makeAnimator(initialModel, function(model) {
                _VirtualDom_divertHrefToApp = divertHrefToApp;
                var doc = view(model);
                var nextNode = _VirtualDom_node("body")(_List_Nil)(doc.body);
                var patches = _VirtualDom_diff(currNode, nextNode);
                bodyNode = _VirtualDom_applyPatches(bodyNode, currNode, patches, sendToApp);
                currNode = nextNode;
                _VirtualDom_divertHrefToApp = 0;
                title !== doc.title && (_VirtualDom_doc.title = title = doc.title);
            });
        });
    });
    // ANIMATION
    var _Browser_cancelAnimationFrame = typeof cancelAnimationFrame !== "undefined" ? cancelAnimationFrame : function(id) {
        clearTimeout(id);
    };
    var _Browser_requestAnimationFrame = typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : function(callback) {
        return setTimeout(callback, 1000 / 60);
    };
    function _Browser_makeAnimator(model, draw) {
        draw(model);
        var state = 0;
        function updateIfNeeded() {
            state = state === 1 ? 0 : (_Browser_requestAnimationFrame(updateIfNeeded), draw(model), 1);
        }
        return function(nextModel, isSync) {
            model = nextModel;
            isSync ? (draw(model), state === 2 && (state = 1)) : (state === 0 && _Browser_requestAnimationFrame(updateIfNeeded), state = 2);
        };
    }
    // APPLICATION
    function _Browser_application(impl) {
        var onUrlChange = impl.onUrlChange;
        var onUrlRequest = impl.onUrlRequest;
        var key = function() {
            key.a(onUrlChange(_Browser_getUrl()));
        };
        key["elm-hot-nav-key"] = true;
        return _Browser_document({
            setup: function(sendToApp) {
                key.a = sendToApp;
                _Browser_window.addEventListener("popstate", key);
                _Browser_window.navigator.userAgent.indexOf("Trident") < 0 || _Browser_window.addEventListener("hashchange", key);
                return F2(function(domNode, event) {
                    if (!event.ctrlKey && !event.metaKey && !event.shiftKey && event.button < 1 && !domNode.target && !domNode.hasAttribute("download")) {
                        event.preventDefault();
                        var href = domNode.href;
                        var curr = _Browser_getUrl();
                        var next = $elm$url$Url$fromString(href).a;
                        sendToApp(onUrlRequest(next && curr.protocol === next.protocol && curr.host === next.host && curr.port_.a === next.port_.a ? $elm$browser$Browser$Internal(next) : $elm$browser$Browser$External(href)));
                    }
                });
            },
            init: function(flags) {
                return A3(impl.init, flags, _Browser_getUrl(), key);
            },
            view: impl.view,
            update: impl.update,
            subscriptions: impl.subscriptions
        });
    }
    function _Browser_getUrl() {
        return $elm$url$Url$fromString(_VirtualDom_doc.location.href).a || _Debug_crash(1);
    }
    var _Browser_go = F2(function(key, n) {
        return A2($elm$core$Task$perform, $elm$core$Basics$never, _Scheduler_binding(function() {
            n && history.go(n);
            key();
        }));
    });
    var _Browser_pushUrl = F2(function(key, url) {
        return A2($elm$core$Task$perform, $elm$core$Basics$never, _Scheduler_binding(function() {
            history.pushState({}, "", url);
            key();
        }));
    });
    var _Browser_replaceUrl = F2(function(key, url) {
        return A2($elm$core$Task$perform, $elm$core$Basics$never, _Scheduler_binding(function() {
            history.replaceState({}, "", url);
            key();
        }));
    });
    // GLOBAL EVENTS
    var _Browser_fakeNode = {
        addEventListener: function() {},
        removeEventListener: function() {}
    };
    var _Browser_doc = typeof document !== "undefined" ? document : _Browser_fakeNode;
    var _Browser_window = typeof window !== "undefined" ? window : _Browser_fakeNode;
    var _Browser_on = F3(function(node, eventName, sendToSelf) {
        return _Scheduler_spawn(_Scheduler_binding(function(callback) {
            function handler(event) {
                _Scheduler_rawSpawn(sendToSelf(event));
            }
            node.addEventListener(eventName, handler, _VirtualDom_passiveSupported && {
                passive: true
            });
            return function() {
                node.removeEventListener(eventName, handler);
            };
        }));
    });
    var _Browser_decodeEvent = F2(function(decoder, event) {
        var result = _Json_runHelp(decoder, event);
        return $elm$core$Result$isOk(result) ? $elm$core$Maybe$Just(result.a) : $elm$core$Maybe$Nothing;
    });
    // PAGE VISIBILITY
    function _Browser_visibilityInfo() {
        return typeof _VirtualDom_doc.hidden !== "undefined" ? {
            hidden: "hidden",
            change: "visibilitychange"
        } : typeof _VirtualDom_doc.mozHidden !== "undefined" ? {
            hidden: "mozHidden",
            change: "mozvisibilitychange"
        } : typeof _VirtualDom_doc.msHidden !== "undefined" ? {
            hidden: "msHidden",
            change: "msvisibilitychange"
        } : typeof _VirtualDom_doc.webkitHidden !== "undefined" ? {
            hidden: "webkitHidden",
            change: "webkitvisibilitychange"
        } : {
            hidden: "hidden",
            change: "visibilitychange"
        };
    }
    // ANIMATION FRAMES
    function _Browser_rAF() {
        return _Scheduler_binding(function(callback) {
            var id = _Browser_requestAnimationFrame(function() {
                callback(_Scheduler_succeed(Date.now()));
            });
            return function() {
                _Browser_cancelAnimationFrame(id);
            };
        });
    }
    function _Browser_now() {
        return _Scheduler_binding(function(callback) {
            callback(_Scheduler_succeed(Date.now()));
        });
    }
    // DOM STUFF
    function _Browser_withNode(id, doStuff) {
        return _Scheduler_binding(function(callback) {
            _Browser_requestAnimationFrame(function() {
                var node = document.getElementById(id);
                callback(node ? _Scheduler_succeed(doStuff(node)) : _Scheduler_fail($elm$browser$Browser$Dom$NotFound(id)));
            });
        });
    }
    function _Browser_withWindow(doStuff) {
        return _Scheduler_binding(function(callback) {
            _Browser_requestAnimationFrame(function() {
                callback(_Scheduler_succeed(doStuff()));
            });
        });
    }
    // FOCUS and BLUR
    var _Browser_call = F2(function(functionName, id) {
        return _Browser_withNode(id, function(node) {
            node[functionName]();
            return _Utils_Tuple0;
        });
    });
    // WINDOW VIEWPORT
    function _Browser_getViewport() {
        return {
            scene: _Browser_getScene(),
            viewport: {
                x: _Browser_window.pageXOffset,
                y: _Browser_window.pageYOffset,
                width: _Browser_doc.documentElement.clientWidth,
                height: _Browser_doc.documentElement.clientHeight
            }
        };
    }
    function _Browser_getScene() {
        var body = _Browser_doc.body;
        var elem = _Browser_doc.documentElement;
        return {
            width: Math.max(body.scrollWidth, body.offsetWidth, elem.scrollWidth, elem.offsetWidth, elem.clientWidth),
            height: Math.max(body.scrollHeight, body.offsetHeight, elem.scrollHeight, elem.offsetHeight, elem.clientHeight)
        };
    }
    var _Browser_setViewport = F2(function(x, y) {
        return _Browser_withWindow(function() {
            _Browser_window.scroll(x, y);
            return _Utils_Tuple0;
        });
    });
    // ELEMENT VIEWPORT
    function _Browser_getViewportOf(id) {
        return _Browser_withNode(id, function(node) {
            return {
                scene: {
                    width: node.scrollWidth,
                    height: node.scrollHeight
                },
                viewport: {
                    x: node.scrollLeft,
                    y: node.scrollTop,
                    width: node.clientWidth,
                    height: node.clientHeight
                }
            };
        });
    }
    var _Browser_setViewportOf = F3(function(id, x, y) {
        return _Browser_withNode(id, function(node) {
            node.scrollLeft = x;
            node.scrollTop = y;
            return _Utils_Tuple0;
        });
    });
    // ELEMENT
    function _Browser_getElement(id) {
        return _Browser_withNode(id, function(node) {
            var rect = node.getBoundingClientRect();
            var x = _Browser_window.pageXOffset;
            var y = _Browser_window.pageYOffset;
            return {
                scene: _Browser_getScene(),
                viewport: {
                    x: x,
                    y: y,
                    width: _Browser_doc.documentElement.clientWidth,
                    height: _Browser_doc.documentElement.clientHeight
                },
                element: {
                    x: x + rect.left,
                    y: y + rect.top,
                    width: rect.width,
                    height: rect.height
                }
            };
        });
    }
    // LOAD and RELOAD
    function _Browser_reload(skipCache) {
        return A2($elm$core$Task$perform, $elm$core$Basics$never, _Scheduler_binding(function(callback) {
            _VirtualDom_doc.location.reload(skipCache);
        }));
    }
    function _Browser_load(url) {
        return A2($elm$core$Task$perform, $elm$core$Basics$never, _Scheduler_binding(function(callback) {
            try {
                _Browser_window.location = url;
            } catch (err) {
                // Only Firefox can throw a NS_ERROR_MALFORMED_URI exception here.
                // Other browsers reload the page, so let's be consistent about that.
                _VirtualDom_doc.location.reload(false);
            }
        }));
    }
    // CREATE
    var _Regex_never = /.^/;
    var _Regex_fromStringWith = F2(function(options, string) {
        var flags = "g";
        if (options.multiline) flags += "m";
        if (options.caseInsensitive) flags += "i";
        try {
            return $elm$core$Maybe$Just(new RegExp(string, flags));
        } catch (error) {
            return $elm$core$Maybe$Nothing;
        }
    });
    // USE
    var _Regex_contains = F2(function(re, string) {
        return string.match(re) !== null;
    });
    var _Regex_findAtMost = F3(function(n, re, str) {
        var out = [];
        var number = 0;
        var string = str;
        var lastIndex = re.lastIndex;
        var prevLastIndex = -1;
        var result;
        while(number++ < n && (result = re.exec(string))){
            if (prevLastIndex == re.lastIndex) break;
            var i = result.length - 1;
            var subs = new Array(i);
            while(i > 0){
                var submatch = result[i];
                subs[--i] = submatch ? $elm$core$Maybe$Just(submatch) : $elm$core$Maybe$Nothing;
            }
            out.push(A4($elm$regex$Regex$Match, result[0], result.index, number, _List_fromArray(subs)));
            prevLastIndex = re.lastIndex;
        }
        re.lastIndex = lastIndex;
        return _List_fromArray(out);
    });
    var _Regex_replaceAtMost = F4(function(n, re, replacer, string) {
        var count = 0;
        function jsReplacer(match) {
            if (count++ >= n) return match;
            var i = arguments.length - 3;
            var submatches = new Array(i);
            while(i > 0){
                var submatch = arguments[i];
                submatches[--i] = submatch ? $elm$core$Maybe$Just(submatch) : $elm$core$Maybe$Nothing;
            }
            return replacer(A4($elm$regex$Regex$Match, match, arguments[arguments.length - 2], count, _List_fromArray(submatches)));
        }
        return string.replace(re, jsReplacer);
    });
    var _Regex_splitAtMost = F3(function(n, re, str) {
        var string = str;
        var out = [];
        var start = re.lastIndex;
        var restoreLastIndex = re.lastIndex;
        while(n--){
            var result = re.exec(string);
            if (!result) break;
            out.push(string.slice(start, result.index));
            start = re.lastIndex;
        }
        out.push(string.slice(start));
        re.lastIndex = restoreLastIndex;
        return _List_fromArray(out);
    });
    var _Regex_infinity = Infinity;
    function _Url_percentEncode(string) {
        return encodeURIComponent(string);
    }
    function _Url_percentDecode(string) {
        try {
            return $elm$core$Maybe$Just(decodeURIComponent(string));
        } catch (e) {
            return $elm$core$Maybe$Nothing;
        }
    }
    // SEND REQUEST
    var _Http_toTask = F3(function(router, toTask, request) {
        return _Scheduler_binding(function(callback) {
            function done(response) {
                callback(toTask(request.expect.a(response)));
            }
            var xhr = new XMLHttpRequest();
            xhr.addEventListener("error", function() {
                done($elm$http$Http$NetworkError_);
            });
            xhr.addEventListener("timeout", function() {
                done($elm$http$Http$Timeout_);
            });
            xhr.addEventListener("load", function() {
                done(_Http_toResponse(request.expect.b, xhr));
            });
            $elm$core$Maybe$isJust(request.tracker) && _Http_track(router, xhr, request.tracker.a);
            try {
                xhr.open(request.method, request.url, true);
            } catch (e) {
                return done($elm$http$Http$BadUrl_(request.url));
            }
            _Http_configureRequest(xhr, request);
            request.body.a && xhr.setRequestHeader("Content-Type", request.body.a);
            xhr.send(request.body.b);
            return function() {
                xhr.c = true;
                xhr.abort();
            };
        });
    });
    // CONFIGURE
    function _Http_configureRequest(xhr, request) {
        for(var headers = request.headers; headers.b; headers = headers.b)xhr.setRequestHeader(headers.a.a, headers.a.b);
        xhr.timeout = request.timeout.a || 0;
        xhr.responseType = request.expect.d;
        xhr.withCredentials = request.allowCookiesFromOtherDomains;
    }
    // RESPONSES
    function _Http_toResponse(toBody, xhr) {
        return A2(200 <= xhr.status && xhr.status < 300 ? $elm$http$Http$GoodStatus_ : $elm$http$Http$BadStatus_, _Http_toMetadata(xhr), toBody(xhr.response));
    }
    // METADATA
    function _Http_toMetadata(xhr) {
        return {
            url: xhr.responseURL,
            statusCode: xhr.status,
            statusText: xhr.statusText,
            headers: _Http_parseHeaders(xhr.getAllResponseHeaders())
        };
    }
    // HEADERS
    function _Http_parseHeaders(rawHeaders) {
        if (!rawHeaders) return $elm$core$Dict$empty;
        var headers = $elm$core$Dict$empty;
        var headerPairs = rawHeaders.split("\r\n");
        for(var i = headerPairs.length; i--;){
            var headerPair = headerPairs[i];
            var index = headerPair.indexOf(": ");
            if (index > 0) {
                var key = headerPair.substring(0, index);
                var value = headerPair.substring(index + 2);
                headers = A3($elm$core$Dict$update, key, function(oldValue) {
                    return $elm$core$Maybe$Just($elm$core$Maybe$isJust(oldValue) ? value + ", " + oldValue.a : value);
                }, headers);
            }
        }
        return headers;
    }
    // EXPECT
    var _Http_expect = F3(function(type, toBody, toValue) {
        return {
            $: 0,
            d: type,
            b: toBody,
            a: toValue
        };
    });
    var _Http_mapExpect = F2(function(func, expect) {
        return {
            $: 0,
            d: expect.d,
            b: expect.b,
            a: function(x) {
                return func(expect.a(x));
            }
        };
    });
    function _Http_toDataView(arrayBuffer) {
        return new DataView(arrayBuffer);
    }
    // BODY and PARTS
    var _Http_emptyBody = {
        $: 0
    };
    var _Http_pair = F2(function(a, b) {
        return {
            $: 0,
            a: a,
            b: b
        };
    });
    function _Http_toFormData(parts) {
        for(var formData = new FormData(); parts.b; parts = parts.b){
            var part = parts.a;
            formData.append(part.a, part.b);
        }
        return formData;
    }
    var _Http_bytesToBlob = F2(function(mime, bytes) {
        return new Blob([
            bytes
        ], {
            type: mime
        });
    });
    // PROGRESS
    function _Http_track(router, xhr, tracker) {
        // TODO check out lengthComputable on loadstart event
        xhr.upload.addEventListener("progress", function(event) {
            if (xhr.c) return;
            _Scheduler_rawSpawn(A2($elm$core$Platform$sendToSelf, router, _Utils_Tuple2(tracker, $elm$http$Http$Sending({
                sent: event.loaded,
                size: event.total
            }))));
        });
        xhr.addEventListener("progress", function(event) {
            if (xhr.c) return;
            _Scheduler_rawSpawn(A2($elm$core$Platform$sendToSelf, router, _Utils_Tuple2(tracker, $elm$http$Http$Receiving({
                received: event.loaded,
                size: event.lengthComputable ? $elm$core$Maybe$Just(event.total) : $elm$core$Maybe$Nothing
            }))));
        });
    }
    // BYTES
    function _Bytes_width(bytes) {
        return bytes.byteLength;
    }
    var _Bytes_getHostEndianness = F2(function(le, be) {
        return _Scheduler_binding(function(callback) {
            callback(_Scheduler_succeed(new Uint8Array(new Uint32Array([
                1
            ]))[0] === 1 ? le : be));
        });
    });
    // ENCODERS
    function _Bytes_encode(encoder) {
        var mutableBytes = new DataView(new ArrayBuffer($elm$bytes$Bytes$Encode$getWidth(encoder)));
        $elm$bytes$Bytes$Encode$write(encoder)(mutableBytes)(0);
        return mutableBytes;
    }
    // SIGNED INTEGERS
    var _Bytes_write_i8 = F3(function(mb, i, n) {
        mb.setInt8(i, n);
        return i + 1;
    });
    var _Bytes_write_i16 = F4(function(mb, i, n, isLE) {
        mb.setInt16(i, n, isLE);
        return i + 2;
    });
    var _Bytes_write_i32 = F4(function(mb, i, n, isLE) {
        mb.setInt32(i, n, isLE);
        return i + 4;
    });
    // UNSIGNED INTEGERS
    var _Bytes_write_u8 = F3(function(mb, i, n) {
        mb.setUint8(i, n);
        return i + 1;
    });
    var _Bytes_write_u16 = F4(function(mb, i, n, isLE) {
        mb.setUint16(i, n, isLE);
        return i + 2;
    });
    var _Bytes_write_u32 = F4(function(mb, i, n, isLE) {
        mb.setUint32(i, n, isLE);
        return i + 4;
    });
    // FLOATS
    var _Bytes_write_f32 = F4(function(mb, i, n, isLE) {
        mb.setFloat32(i, n, isLE);
        return i + 4;
    });
    var _Bytes_write_f64 = F4(function(mb, i, n, isLE) {
        mb.setFloat64(i, n, isLE);
        return i + 8;
    });
    // BYTES
    var _Bytes_write_bytes = F3(function(mb, offset, bytes) {
        for(var i = 0, len = bytes.byteLength, limit = len - 4; i <= limit; i += 4)mb.setUint32(offset + i, bytes.getUint32(i));
        for(; i < len; i++)mb.setUint8(offset + i, bytes.getUint8(i));
        return offset + len;
    });
    // STRINGS
    function _Bytes_getStringWidth(string) {
        for(var width = 0, i = 0; i < string.length; i++){
            var code = string.charCodeAt(i);
            width += code < 0x80 ? 1 : code < 0x800 ? 2 : code < 0xD800 || 0xDBFF < code ? 3 : (i++, 4);
        }
        return width;
    }
    var _Bytes_write_string = F3(function(mb, offset, string) {
        for(var i = 0; i < string.length; i++){
            var code = string.charCodeAt(i);
            offset += code < 0x80 ? (mb.setUint8(offset, code), 1) : code < 0x800 ? (mb.setUint16(offset, 0xC080 /* 0b1100000010000000 */  | (code >>> 6 & 0x1F /* 0b00011111 */ ) << 8 | code & 0x3F /* 0b00111111 */ ), 2) : code < 0xD800 || 0xDBFF < code ? (mb.setUint16(offset, 0xE080 /* 0b1110000010000000 */  | (code >>> 12 & 0xF /* 0b00001111 */ ) << 8 | code >>> 6 & 0x3F /* 0b00111111 */ ), mb.setUint8(offset + 2, 0x80 /* 0b10000000 */  | code & 0x3F /* 0b00111111 */ ), 3) : (code = (code - 0xD800) * 0x400 + string.charCodeAt(++i) - 0xDC00 + 0x10000, mb.setUint32(offset, 0xF0808080 /* 0b11110000100000001000000010000000 */  | (code >>> 18 & 0x7 /* 0b00000111 */ ) << 24 | (code >>> 12 & 0x3F /* 0b00111111 */ ) << 16 | (code >>> 6 & 0x3F /* 0b00111111 */ ) << 8 | code & 0x3F /* 0b00111111 */ ), 4);
        }
        return offset;
    });
    // DECODER
    var _Bytes_decode = F2(function(decoder, bytes) {
        try {
            return $elm$core$Maybe$Just(A2(decoder, bytes, 0).b);
        } catch (e) {
            return $elm$core$Maybe$Nothing;
        }
    });
    var _Bytes_read_i8 = F2(function(bytes, offset) {
        return _Utils_Tuple2(offset + 1, bytes.getInt8(offset));
    });
    var _Bytes_read_i16 = F3(function(isLE, bytes, offset) {
        return _Utils_Tuple2(offset + 2, bytes.getInt16(offset, isLE));
    });
    var _Bytes_read_i32 = F3(function(isLE, bytes, offset) {
        return _Utils_Tuple2(offset + 4, bytes.getInt32(offset, isLE));
    });
    var _Bytes_read_u8 = F2(function(bytes, offset) {
        return _Utils_Tuple2(offset + 1, bytes.getUint8(offset));
    });
    var _Bytes_read_u16 = F3(function(isLE, bytes, offset) {
        return _Utils_Tuple2(offset + 2, bytes.getUint16(offset, isLE));
    });
    var _Bytes_read_u32 = F3(function(isLE, bytes, offset) {
        return _Utils_Tuple2(offset + 4, bytes.getUint32(offset, isLE));
    });
    var _Bytes_read_f32 = F3(function(isLE, bytes, offset) {
        return _Utils_Tuple2(offset + 4, bytes.getFloat32(offset, isLE));
    });
    var _Bytes_read_f64 = F3(function(isLE, bytes, offset) {
        return _Utils_Tuple2(offset + 8, bytes.getFloat64(offset, isLE));
    });
    var _Bytes_read_bytes = F3(function(len, bytes, offset) {
        return _Utils_Tuple2(offset + len, new DataView(bytes.buffer, bytes.byteOffset + offset, len));
    });
    var _Bytes_read_string = F3(function(len, bytes, offset) {
        var string = "";
        var end = offset + len;
        for(; offset < end;){
            var byte = bytes.getUint8(offset++);
            string += byte < 128 ? String.fromCharCode(byte) : (byte & 0xE0 /* 0b11100000 */ ) === 0xC0 /* 0b11000000 */  ? String.fromCharCode((byte & 0x1F /* 0b00011111 */ ) << 6 | bytes.getUint8(offset++) & 0x3F /* 0b00111111 */ ) : (byte & 0xF0 /* 0b11110000 */ ) === 0xE0 /* 0b11100000 */  ? String.fromCharCode((byte & 0xF /* 0b00001111 */ ) << 12 | (bytes.getUint8(offset++) & 0x3F /* 0b00111111 */ ) << 6 | bytes.getUint8(offset++) & 0x3F /* 0b00111111 */ ) : (byte = ((byte & 0x7 /* 0b00000111 */ ) << 18 | (bytes.getUint8(offset++) & 0x3F /* 0b00111111 */ ) << 12 | (bytes.getUint8(offset++) & 0x3F /* 0b00111111 */ ) << 6 | bytes.getUint8(offset++) & 0x3F /* 0b00111111 */ ) - 0x10000, String.fromCharCode(Math.floor(byte / 0x400) + 0xD800, byte % 0x400 + 0xDC00));
        }
        return _Utils_Tuple2(offset, string);
    });
    var _Bytes_decodeFailure = F2(function() {
        throw 0;
    });
    function _Time_now(millisToPosix) {
        return _Scheduler_binding(function(callback) {
            callback(_Scheduler_succeed(millisToPosix(Date.now())));
        });
    }
    var _Time_setInterval = F2(function(interval, task) {
        return _Scheduler_binding(function(callback) {
            var id = setInterval(function() {
                _Scheduler_rawSpawn(task);
            }, interval);
            return function() {
                clearInterval(id);
            };
        });
    });
    function _Time_here() {
        return _Scheduler_binding(function(callback) {
            callback(_Scheduler_succeed(A2($elm$time$Time$customZone, -new Date().getTimezoneOffset(), _List_Nil)));
        });
    }
    function _Time_getZoneName() {
        return _Scheduler_binding(function(callback) {
            try {
                var name = $elm$time$Time$Name(Intl.DateTimeFormat().resolvedOptions().timeZone);
            } catch (e) {
                var name = $elm$time$Time$Offset(new Date().getTimezoneOffset());
            }
            callback(_Scheduler_succeed(name));
        });
    }
    // STRINGS
    var _Parser_isSubString = F5(function(smallString, offset, row, col, bigString) {
        var smallLength = smallString.length;
        var isGood = offset + smallLength <= bigString.length;
        for(var i = 0; isGood && i < smallLength;){
            var code = bigString.charCodeAt(offset);
            isGood = smallString[i++] === bigString[offset++] && (code === 0x000A /* \n */  ? (row++, col = 1) : (col++, (code & 0xF800) === 0xD800 ? smallString[i++] === bigString[offset++] : 1));
        }
        return _Utils_Tuple3(isGood ? offset : -1, row, col);
    });
    // CHARS
    var _Parser_isSubChar = F3(function(predicate, offset, string) {
        return string.length <= offset ? -1 : (string.charCodeAt(offset) & 0xF800) === 0xD800 ? predicate(_Utils_chr(string.substr(offset, 2))) ? offset + 2 : -1 : predicate(_Utils_chr(string[offset])) ? string[offset] === "\n" ? -2 : offset + 1 : -1;
    });
    var _Parser_isAsciiCode = F3(function(code, offset, string) {
        return string.charCodeAt(offset) === code;
    });
    // NUMBERS
    var _Parser_chompBase10 = F2(function(offset, string) {
        for(; offset < string.length; offset++){
            var code = string.charCodeAt(offset);
            if (code < 0x30 || 0x39 < code) return offset;
        }
        return offset;
    });
    var _Parser_consumeBase = F3(function(base, offset, string) {
        for(var total = 0; offset < string.length; offset++){
            var digit = string.charCodeAt(offset) - 0x30;
            if (digit < 0 || base <= digit) break;
            total = base * total + digit;
        }
        return _Utils_Tuple2(offset, total);
    });
    var _Parser_consumeBase16 = F2(function(offset, string) {
        for(var total = 0; offset < string.length; offset++){
            var code = string.charCodeAt(offset);
            if (0x30 <= code && code <= 0x39) total = 16 * total + code - 0x30;
            else if (0x41 <= code && code <= 0x46) total = 16 * total + code - 55;
            else if (0x61 <= code && code <= 0x66) total = 16 * total + code - 87;
            else break;
        }
        return _Utils_Tuple2(offset, total);
    });
    // FIND STRING
    var _Parser_findSubString = F5(function(smallString, offset, row, col, bigString) {
        var newOffset = bigString.indexOf(smallString, offset);
        var target = newOffset < 0 ? bigString.length : newOffset + smallString.length;
        while(offset < target){
            var code = bigString.charCodeAt(offset++);
            code === 0x000A /* \n */  ? (col = 1, row++) : (col++, (code & 0xF800) === 0xD800 && offset++);
        }
        return _Utils_Tuple3(newOffset, row, col);
    });
    var $author$project$Main$ChangedUrl = function(a) {
        return {
            $: "ChangedUrl",
            a: a
        };
    };
    var $author$project$Main$ClickedLink = function(a) {
        return {
            $: "ClickedLink",
            a: a
        };
    };
    var $elm$core$Basics$EQ = {
        $: "EQ"
    };
    var $elm$core$Basics$GT = {
        $: "GT"
    };
    var $elm$core$Basics$LT = {
        $: "LT"
    };
    var $elm$core$List$cons = _List_cons;
    var $elm$core$Dict$foldr = F3(function(func, acc, t) {
        foldr: while(true){
            if (t.$ === "RBEmpty_elm_builtin") return acc;
            else {
                var key = t.b;
                var value = t.c;
                var left = t.d;
                var right = t.e;
                var $temp$func = func, $temp$acc = A3(func, key, value, A3($elm$core$Dict$foldr, func, acc, right)), $temp$t = left;
                func = $temp$func;
                acc = $temp$acc;
                t = $temp$t;
                continue foldr;
            }
        }
    });
    var $elm$core$Dict$toList = function(dict) {
        return A3($elm$core$Dict$foldr, F3(function(key, value, list) {
            return A2($elm$core$List$cons, _Utils_Tuple2(key, value), list);
        }), _List_Nil, dict);
    };
    var $elm$core$Dict$keys = function(dict) {
        return A3($elm$core$Dict$foldr, F3(function(key, value, keyList) {
            return A2($elm$core$List$cons, key, keyList);
        }), _List_Nil, dict);
    };
    var $elm$core$Set$toList = function(_v0) {
        var dict = _v0.a;
        return $elm$core$Dict$keys(dict);
    };
    var $elm$core$Elm$JsArray$foldr = _JsArray_foldr;
    var $elm$core$Array$foldr = F3(function(func, baseCase, _v0) {
        var tree = _v0.c;
        var tail = _v0.d;
        var helper = F2(function(node, acc) {
            if (node.$ === "SubTree") {
                var subTree = node.a;
                return A3($elm$core$Elm$JsArray$foldr, helper, acc, subTree);
            } else {
                var values = node.a;
                return A3($elm$core$Elm$JsArray$foldr, func, acc, values);
            }
        });
        return A3($elm$core$Elm$JsArray$foldr, helper, A3($elm$core$Elm$JsArray$foldr, func, baseCase, tail), tree);
    });
    var $elm$core$Array$toList = function(array) {
        return A3($elm$core$Array$foldr, $elm$core$List$cons, _List_Nil, array);
    };
    var $elm$core$Result$Err = function(a) {
        return {
            $: "Err",
            a: a
        };
    };
    var $elm$json$Json$Decode$Failure = F2(function(a, b) {
        return {
            $: "Failure",
            a: a,
            b: b
        };
    });
    var $elm$json$Json$Decode$Field = F2(function(a, b) {
        return {
            $: "Field",
            a: a,
            b: b
        };
    });
    var $elm$json$Json$Decode$Index = F2(function(a, b) {
        return {
            $: "Index",
            a: a,
            b: b
        };
    });
    var $elm$core$Result$Ok = function(a) {
        return {
            $: "Ok",
            a: a
        };
    };
    var $elm$json$Json$Decode$OneOf = function(a) {
        return {
            $: "OneOf",
            a: a
        };
    };
    var $elm$core$Basics$False = {
        $: "False"
    };
    var $elm$core$Basics$add = _Basics_add;
    var $elm$core$Maybe$Just = function(a) {
        return {
            $: "Just",
            a: a
        };
    };
    var $elm$core$Maybe$Nothing = {
        $: "Nothing"
    };
    var $elm$core$String$all = _String_all;
    var $elm$core$Basics$and = _Basics_and;
    var $elm$core$Basics$append = _Utils_append;
    var $elm$json$Json$Encode$encode = _Json_encode;
    var $elm$core$String$fromInt = _String_fromNumber;
    var $elm$core$String$join = F2(function(sep, chunks) {
        return A2(_String_join, sep, _List_toArray(chunks));
    });
    var $elm$core$String$split = F2(function(sep, string) {
        return _List_fromArray(A2(_String_split, sep, string));
    });
    var $elm$json$Json$Decode$indent = function(str) {
        return A2($elm$core$String$join, "\n    ", A2($elm$core$String$split, "\n", str));
    };
    var $elm$core$List$foldl = F3(function(func, acc, list) {
        foldl: while(true){
            if (!list.b) return acc;
            else {
                var x = list.a;
                var xs = list.b;
                var $temp$func = func, $temp$acc = A2(func, x, acc), $temp$list = xs;
                func = $temp$func;
                acc = $temp$acc;
                list = $temp$list;
                continue foldl;
            }
        }
    });
    var $elm$core$List$length = function(xs) {
        return A3($elm$core$List$foldl, F2(function(_v0, i) {
            return i + 1;
        }), 0, xs);
    };
    var $elm$core$List$map2 = _List_map2;
    var $elm$core$Basics$le = _Utils_le;
    var $elm$core$Basics$sub = _Basics_sub;
    var $elm$core$List$rangeHelp = F3(function(lo, hi, list) {
        rangeHelp: while(true){
            if (_Utils_cmp(lo, hi) < 1) {
                var $temp$lo = lo, $temp$hi = hi - 1, $temp$list = A2($elm$core$List$cons, hi, list);
                lo = $temp$lo;
                hi = $temp$hi;
                list = $temp$list;
                continue rangeHelp;
            } else return list;
        }
    });
    var $elm$core$List$range = F2(function(lo, hi) {
        return A3($elm$core$List$rangeHelp, lo, hi, _List_Nil);
    });
    var $elm$core$List$indexedMap = F2(function(f, xs) {
        return A3($elm$core$List$map2, f, A2($elm$core$List$range, 0, $elm$core$List$length(xs) - 1), xs);
    });
    var $elm$core$Char$toCode = _Char_toCode;
    var $elm$core$Char$isLower = function(_char) {
        var code = $elm$core$Char$toCode(_char);
        return 97 <= code && code <= 122;
    };
    var $elm$core$Char$isUpper = function(_char) {
        var code = $elm$core$Char$toCode(_char);
        return code <= 90 && 65 <= code;
    };
    var $elm$core$Basics$or = _Basics_or;
    var $elm$core$Char$isAlpha = function(_char) {
        return $elm$core$Char$isLower(_char) || $elm$core$Char$isUpper(_char);
    };
    var $elm$core$Char$isDigit = function(_char) {
        var code = $elm$core$Char$toCode(_char);
        return code <= 57 && 48 <= code;
    };
    var $elm$core$Char$isAlphaNum = function(_char) {
        return $elm$core$Char$isLower(_char) || $elm$core$Char$isUpper(_char) || $elm$core$Char$isDigit(_char);
    };
    var $elm$core$List$reverse = function(list) {
        return A3($elm$core$List$foldl, $elm$core$List$cons, _List_Nil, list);
    };
    var $elm$core$String$uncons = _String_uncons;
    var $elm$json$Json$Decode$errorOneOf = F2(function(i, error) {
        return "\n\n(" + ($elm$core$String$fromInt(i + 1) + (") " + $elm$json$Json$Decode$indent($elm$json$Json$Decode$errorToString(error))));
    });
    var $elm$json$Json$Decode$errorToString = function(error) {
        return A2($elm$json$Json$Decode$errorToStringHelp, error, _List_Nil);
    };
    var $elm$json$Json$Decode$errorToStringHelp = F2(function(error, context) {
        errorToStringHelp: while(true)switch(error.$){
            case "Field":
                var f = error.a;
                var err = error.b;
                var isSimple = function() {
                    var _v1 = $elm$core$String$uncons(f);
                    if (_v1.$ === "Nothing") return false;
                    else {
                        var _v2 = _v1.a;
                        var _char = _v2.a;
                        var rest = _v2.b;
                        return $elm$core$Char$isAlpha(_char) && A2($elm$core$String$all, $elm$core$Char$isAlphaNum, rest);
                    }
                }();
                var fieldName = isSimple ? "." + f : "['" + (f + "']");
                var $temp$error = err, $temp$context = A2($elm$core$List$cons, fieldName, context);
                error = $temp$error;
                context = $temp$context;
                continue errorToStringHelp;
            case "Index":
                var i = error.a;
                var err = error.b;
                var indexName = "[" + ($elm$core$String$fromInt(i) + "]");
                var $temp$error = err, $temp$context = A2($elm$core$List$cons, indexName, context);
                error = $temp$error;
                context = $temp$context;
                continue errorToStringHelp;
            case "OneOf":
                var errors = error.a;
                if (!errors.b) return "Ran into a Json.Decode.oneOf with no possibilities" + function() {
                    if (!context.b) return "!";
                    else return " at json" + A2($elm$core$String$join, "", $elm$core$List$reverse(context));
                }();
                else if (!errors.b.b) {
                    var err = errors.a;
                    var $temp$error = err, $temp$context = context;
                    error = $temp$error;
                    context = $temp$context;
                    continue errorToStringHelp;
                } else {
                    var starter = function() {
                        if (!context.b) return "Json.Decode.oneOf";
                        else return "The Json.Decode.oneOf at json" + A2($elm$core$String$join, "", $elm$core$List$reverse(context));
                    }();
                    var introduction = starter + (" failed in the following " + ($elm$core$String$fromInt($elm$core$List$length(errors)) + " ways:"));
                    return A2($elm$core$String$join, "\n\n", A2($elm$core$List$cons, introduction, A2($elm$core$List$indexedMap, $elm$json$Json$Decode$errorOneOf, errors)));
                }
            default:
                var msg = error.a;
                var json = error.b;
                var introduction = function() {
                    if (!context.b) return "Problem with the given value:\n\n";
                    else return "Problem with the value at json" + (A2($elm$core$String$join, "", $elm$core$List$reverse(context)) + ":\n\n    ");
                }();
                return introduction + ($elm$json$Json$Decode$indent(A2($elm$json$Json$Encode$encode, 4, json)) + ("\n\n" + msg));
        }
    });
    var $elm$core$Array$branchFactor = 32;
    var $elm$core$Array$Array_elm_builtin = F4(function(a, b, c, d) {
        return {
            $: "Array_elm_builtin",
            a: a,
            b: b,
            c: c,
            d: d
        };
    });
    var $elm$core$Elm$JsArray$empty = _JsArray_empty;
    var $elm$core$Basics$ceiling = _Basics_ceiling;
    var $elm$core$Basics$fdiv = _Basics_fdiv;
    var $elm$core$Basics$logBase = F2(function(base, number) {
        return _Basics_log(number) / _Basics_log(base);
    });
    var $elm$core$Basics$toFloat = _Basics_toFloat;
    var $elm$core$Array$shiftStep = $elm$core$Basics$ceiling(A2($elm$core$Basics$logBase, 2, $elm$core$Array$branchFactor));
    var $elm$core$Array$empty = A4($elm$core$Array$Array_elm_builtin, 0, $elm$core$Array$shiftStep, $elm$core$Elm$JsArray$empty, $elm$core$Elm$JsArray$empty);
    var $elm$core$Elm$JsArray$initialize = _JsArray_initialize;
    var $elm$core$Array$Leaf = function(a) {
        return {
            $: "Leaf",
            a: a
        };
    };
    var $elm$core$Basics$apL = F2(function(f, x) {
        return f(x);
    });
    var $elm$core$Basics$apR = F2(function(x, f) {
        return f(x);
    });
    var $elm$core$Basics$eq = _Utils_equal;
    var $elm$core$Basics$floor = _Basics_floor;
    var $elm$core$Elm$JsArray$length = _JsArray_length;
    var $elm$core$Basics$gt = _Utils_gt;
    var $elm$core$Basics$max = F2(function(x, y) {
        return _Utils_cmp(x, y) > 0 ? x : y;
    });
    var $elm$core$Basics$mul = _Basics_mul;
    var $elm$core$Array$SubTree = function(a) {
        return {
            $: "SubTree",
            a: a
        };
    };
    var $elm$core$Elm$JsArray$initializeFromList = _JsArray_initializeFromList;
    var $elm$core$Array$compressNodes = F2(function(nodes, acc) {
        compressNodes: while(true){
            var _v0 = A2($elm$core$Elm$JsArray$initializeFromList, $elm$core$Array$branchFactor, nodes);
            var node = _v0.a;
            var remainingNodes = _v0.b;
            var newAcc = A2($elm$core$List$cons, $elm$core$Array$SubTree(node), acc);
            if (!remainingNodes.b) return $elm$core$List$reverse(newAcc);
            else {
                var $temp$nodes = remainingNodes, $temp$acc = newAcc;
                nodes = $temp$nodes;
                acc = $temp$acc;
                continue compressNodes;
            }
        }
    });
    var $elm$core$Tuple$first = function(_v0) {
        var x = _v0.a;
        return x;
    };
    var $elm$core$Array$treeFromBuilder = F2(function(nodeList, nodeListSize) {
        treeFromBuilder: while(true){
            var newNodeSize = $elm$core$Basics$ceiling(nodeListSize / $elm$core$Array$branchFactor);
            if (newNodeSize === 1) return A2($elm$core$Elm$JsArray$initializeFromList, $elm$core$Array$branchFactor, nodeList).a;
            else {
                var $temp$nodeList = A2($elm$core$Array$compressNodes, nodeList, _List_Nil), $temp$nodeListSize = newNodeSize;
                nodeList = $temp$nodeList;
                nodeListSize = $temp$nodeListSize;
                continue treeFromBuilder;
            }
        }
    });
    var $elm$core$Array$builderToArray = F2(function(reverseNodeList, builder) {
        if (!builder.nodeListSize) return A4($elm$core$Array$Array_elm_builtin, $elm$core$Elm$JsArray$length(builder.tail), $elm$core$Array$shiftStep, $elm$core$Elm$JsArray$empty, builder.tail);
        else {
            var treeLen = builder.nodeListSize * $elm$core$Array$branchFactor;
            var depth = $elm$core$Basics$floor(A2($elm$core$Basics$logBase, $elm$core$Array$branchFactor, treeLen - 1));
            var correctNodeList = reverseNodeList ? $elm$core$List$reverse(builder.nodeList) : builder.nodeList;
            var tree = A2($elm$core$Array$treeFromBuilder, correctNodeList, builder.nodeListSize);
            return A4($elm$core$Array$Array_elm_builtin, $elm$core$Elm$JsArray$length(builder.tail) + treeLen, A2($elm$core$Basics$max, 5, depth * $elm$core$Array$shiftStep), tree, builder.tail);
        }
    });
    var $elm$core$Basics$idiv = _Basics_idiv;
    var $elm$core$Basics$lt = _Utils_lt;
    var $elm$core$Array$initializeHelp = F5(function(fn, fromIndex, len, nodeList, tail) {
        initializeHelp: while(true){
            if (fromIndex < 0) return A2($elm$core$Array$builderToArray, false, {
                nodeList: nodeList,
                nodeListSize: len / $elm$core$Array$branchFactor | 0,
                tail: tail
            });
            else {
                var leaf = $elm$core$Array$Leaf(A3($elm$core$Elm$JsArray$initialize, $elm$core$Array$branchFactor, fromIndex, fn));
                var $temp$fn = fn, $temp$fromIndex = fromIndex - $elm$core$Array$branchFactor, $temp$len = len, $temp$nodeList = A2($elm$core$List$cons, leaf, nodeList), $temp$tail = tail;
                fn = $temp$fn;
                fromIndex = $temp$fromIndex;
                len = $temp$len;
                nodeList = $temp$nodeList;
                tail = $temp$tail;
                continue initializeHelp;
            }
        }
    });
    var $elm$core$Basics$remainderBy = _Basics_remainderBy;
    var $elm$core$Array$initialize = F2(function(len, fn) {
        if (len <= 0) return $elm$core$Array$empty;
        else {
            var tailLen = len % $elm$core$Array$branchFactor;
            var tail = A3($elm$core$Elm$JsArray$initialize, tailLen, len - tailLen, fn);
            var initialFromIndex = len - tailLen - $elm$core$Array$branchFactor;
            return A5($elm$core$Array$initializeHelp, fn, initialFromIndex, len, _List_Nil, tail);
        }
    });
    var $elm$core$Basics$True = {
        $: "True"
    };
    var $elm$core$Result$isOk = function(result) {
        if (result.$ === "Ok") return true;
        else return false;
    };
    var $elm$json$Json$Decode$map = _Json_map1;
    var $elm$json$Json$Decode$map2 = _Json_map2;
    var $elm$json$Json$Decode$succeed = _Json_succeed;
    var $elm$virtual_dom$VirtualDom$toHandlerInt = function(handler) {
        switch(handler.$){
            case "Normal":
                return 0;
            case "MayStopPropagation":
                return 1;
            case "MayPreventDefault":
                return 2;
            default:
                return 3;
        }
    };
    var $elm$browser$Debugger$Expando$ArraySeq = {
        $: "ArraySeq"
    };
    var $elm$browser$Debugger$Overlay$BlockMost = {
        $: "BlockMost"
    };
    var $elm$browser$Debugger$Overlay$BlockNone = {
        $: "BlockNone"
    };
    var $elm$browser$Debugger$Expando$Constructor = F3(function(a, b, c) {
        return {
            $: "Constructor",
            a: a,
            b: b,
            c: c
        };
    });
    var $elm$browser$Debugger$Expando$Dictionary = F2(function(a, b) {
        return {
            $: "Dictionary",
            a: a,
            b: b
        };
    });
    var $elm$browser$Debugger$Main$Down = {
        $: "Down"
    };
    var $elm$browser$Debugger$Expando$ListSeq = {
        $: "ListSeq"
    };
    var $elm$browser$Debugger$Main$NoOp = {
        $: "NoOp"
    };
    var $elm$browser$Debugger$Expando$Primitive = function(a) {
        return {
            $: "Primitive",
            a: a
        };
    };
    var $elm$browser$Debugger$Expando$Record = F2(function(a, b) {
        return {
            $: "Record",
            a: a,
            b: b
        };
    });
    var $elm$browser$Debugger$Expando$S = function(a) {
        return {
            $: "S",
            a: a
        };
    };
    var $elm$browser$Debugger$Expando$Sequence = F3(function(a, b, c) {
        return {
            $: "Sequence",
            a: a,
            b: b,
            c: c
        };
    });
    var $elm$browser$Debugger$Expando$SetSeq = {
        $: "SetSeq"
    };
    var $elm$browser$Debugger$Main$Up = {
        $: "Up"
    };
    var $elm$browser$Debugger$Main$UserMsg = function(a) {
        return {
            $: "UserMsg",
            a: a
        };
    };
    var $elm$browser$Debugger$Main$Export = {
        $: "Export"
    };
    var $elm$browser$Debugger$Main$Import = {
        $: "Import"
    };
    var $elm$browser$Debugger$Main$Open = {
        $: "Open"
    };
    var $elm$browser$Debugger$Main$OverlayMsg = function(a) {
        return {
            $: "OverlayMsg",
            a: a
        };
    };
    var $elm$browser$Debugger$Main$Resume = {
        $: "Resume"
    };
    var $elm$browser$Debugger$Main$isPaused = function(state) {
        if (state.$ === "Running") return false;
        else return true;
    };
    var $elm$browser$Debugger$History$size = function(history1) {
        return history1.numMessages;
    };
    var $elm$browser$Debugger$Overlay$Accept = function(a) {
        return {
            $: "Accept",
            a: a
        };
    };
    var $elm$browser$Debugger$Overlay$Choose = F2(function(a, b) {
        return {
            $: "Choose",
            a: a,
            b: b
        };
    });
    var $elm$html$Html$div = _VirtualDom_node("div");
    var $elm$json$Json$Encode$string = _Json_wrap;
    var $elm$html$Html$Attributes$stringProperty = F2(function(key, string) {
        return A2(_VirtualDom_property, key, $elm$json$Json$Encode$string(string));
    });
    var $elm$html$Html$Attributes$id = $elm$html$Html$Attributes$stringProperty("id");
    var $elm$virtual_dom$VirtualDom$Normal = function(a) {
        return {
            $: "Normal",
            a: a
        };
    };
    var $elm$virtual_dom$VirtualDom$on = _VirtualDom_on;
    var $elm$html$Html$Events$on = F2(function(event, decoder) {
        return A2($elm$virtual_dom$VirtualDom$on, event, $elm$virtual_dom$VirtualDom$Normal(decoder));
    });
    var $elm$html$Html$Events$onClick = function(msg) {
        return A2($elm$html$Html$Events$on, "click", $elm$json$Json$Decode$succeed(msg));
    };
    var $elm$html$Html$span = _VirtualDom_node("span");
    var $elm$virtual_dom$VirtualDom$style = _VirtualDom_style;
    var $elm$html$Html$Attributes$style = $elm$virtual_dom$VirtualDom$style;
    var $elm$virtual_dom$VirtualDom$text = _VirtualDom_text;
    var $elm$html$Html$text = $elm$virtual_dom$VirtualDom$text;
    var $elm$html$Html$a = _VirtualDom_node("a");
    var $elm$browser$Debugger$Overlay$goodNews1 = "\nThe good news is that having values like this in your message type is not\nso great in the long run. You are better off using simpler data, like\n";
    var $elm$browser$Debugger$Overlay$goodNews2 = "\nfunction can pattern match on that data and call whatever functions, JSON\ndecoders, etc. you need. This makes the code much more explicit and easy to\nfollow for other readers (or you in a few months!)\n";
    var $elm$html$Html$Attributes$href = function(url) {
        return A2($elm$html$Html$Attributes$stringProperty, "href", _VirtualDom_noJavaScriptUri(url));
    };
    var $elm$core$List$foldrHelper = F4(function(fn, acc, ctr, ls) {
        if (!ls.b) return acc;
        else {
            var a = ls.a;
            var r1 = ls.b;
            if (!r1.b) return A2(fn, a, acc);
            else {
                var b = r1.a;
                var r2 = r1.b;
                if (!r2.b) return A2(fn, a, A2(fn, b, acc));
                else {
                    var c = r2.a;
                    var r3 = r2.b;
                    if (!r3.b) return A2(fn, a, A2(fn, b, A2(fn, c, acc)));
                    else {
                        var d = r3.a;
                        var r4 = r3.b;
                        var res = ctr > 500 ? A3($elm$core$List$foldl, fn, acc, $elm$core$List$reverse(r4)) : A4($elm$core$List$foldrHelper, fn, acc, ctr + 1, r4);
                        return A2(fn, a, A2(fn, b, A2(fn, c, A2(fn, d, res))));
                    }
                }
            }
        }
    });
    var $elm$core$List$foldr = F3(function(fn, acc, ls) {
        return A4($elm$core$List$foldrHelper, fn, acc, 0, ls);
    });
    var $elm$core$List$map = F2(function(f, xs) {
        return A3($elm$core$List$foldr, F2(function(x, acc) {
            return A2($elm$core$List$cons, f(x), acc);
        }), _List_Nil, xs);
    });
    var $elm$html$Html$p = _VirtualDom_node("p");
    var $elm$html$Html$ul = _VirtualDom_node("ul");
    var $elm$html$Html$code = _VirtualDom_node("code");
    var $elm$browser$Debugger$Overlay$viewCode = function(name) {
        return A2($elm$html$Html$code, _List_Nil, _List_fromArray([
            $elm$html$Html$text(name)
        ]));
    };
    var $elm$browser$Debugger$Overlay$addCommas = function(items) {
        if (!items.b) return "";
        else {
            if (!items.b.b) {
                var item = items.a;
                return item;
            } else if (!items.b.b.b) {
                var item1 = items.a;
                var _v1 = items.b;
                var item2 = _v1.a;
                return item1 + (" and " + item2);
            } else {
                var lastItem = items.a;
                var otherItems = items.b;
                return A2($elm$core$String$join, ", ", _Utils_ap(otherItems, _List_fromArray([
                    " and " + lastItem
                ])));
            }
        }
    };
    var $elm$html$Html$li = _VirtualDom_node("li");
    var $elm$browser$Debugger$Overlay$problemToString = function(problem) {
        switch(problem.$){
            case "Function":
                return "functions";
            case "Decoder":
                return "JSON decoders";
            case "Task":
                return "tasks";
            case "Process":
                return "processes";
            case "Socket":
                return "web sockets";
            case "Request":
                return "HTTP requests";
            case "Program":
                return "programs";
            default:
                return "virtual DOM values";
        }
    };
    var $elm$browser$Debugger$Overlay$viewProblemType = function(_v0) {
        var name = _v0.name;
        var problems = _v0.problems;
        return A2($elm$html$Html$li, _List_Nil, _List_fromArray([
            $elm$browser$Debugger$Overlay$viewCode(name),
            $elm$html$Html$text(" can contain " + ($elm$browser$Debugger$Overlay$addCommas(A2($elm$core$List$map, $elm$browser$Debugger$Overlay$problemToString, problems)) + "."))
        ]));
    };
    var $elm$browser$Debugger$Overlay$viewBadMetadata = function(_v0) {
        var message = _v0.message;
        var problems = _v0.problems;
        return _List_fromArray([
            A2($elm$html$Html$p, _List_Nil, _List_fromArray([
                $elm$html$Html$text("The "),
                $elm$browser$Debugger$Overlay$viewCode(message),
                $elm$html$Html$text(" type of your program cannot be reliably serialized for history files.")
            ])),
            A2($elm$html$Html$p, _List_Nil, _List_fromArray([
                $elm$html$Html$text("Functions cannot be serialized, nor can values that contain functions. This is a problem in these places:")
            ])),
            A2($elm$html$Html$ul, _List_Nil, A2($elm$core$List$map, $elm$browser$Debugger$Overlay$viewProblemType, problems)),
            A2($elm$html$Html$p, _List_Nil, _List_fromArray([
                $elm$html$Html$text($elm$browser$Debugger$Overlay$goodNews1),
                A2($elm$html$Html$a, _List_fromArray([
                    $elm$html$Html$Attributes$href("https://guide.elm-lang.org/types/custom_types.html")
                ]), _List_fromArray([
                    $elm$html$Html$text("custom types")
                ])),
                $elm$html$Html$text(", in your messages. From there, your "),
                $elm$browser$Debugger$Overlay$viewCode("update"),
                $elm$html$Html$text($elm$browser$Debugger$Overlay$goodNews2)
            ]))
        ]);
    };
    var $elm$virtual_dom$VirtualDom$map = _VirtualDom_map;
    var $elm$html$Html$map = $elm$virtual_dom$VirtualDom$map;
    var $elm$browser$Debugger$Overlay$Cancel = {
        $: "Cancel"
    };
    var $elm$browser$Debugger$Overlay$Proceed = {
        $: "Proceed"
    };
    var $elm$html$Html$button = _VirtualDom_node("button");
    var $elm$browser$Debugger$Overlay$viewButtons = function(buttons) {
        var btn = F2(function(msg, string) {
            return A2($elm$html$Html$button, _List_fromArray([
                A2($elm$html$Html$Attributes$style, "margin-right", "20px"),
                $elm$html$Html$Events$onClick(msg)
            ]), _List_fromArray([
                $elm$html$Html$text(string)
            ]));
        });
        var buttonNodes = function() {
            if (buttons.$ === "Accept") {
                var proceed = buttons.a;
                return _List_fromArray([
                    A2(btn, $elm$browser$Debugger$Overlay$Proceed, proceed)
                ]);
            } else {
                var cancel = buttons.a;
                var proceed = buttons.b;
                return _List_fromArray([
                    A2(btn, $elm$browser$Debugger$Overlay$Cancel, cancel),
                    A2(btn, $elm$browser$Debugger$Overlay$Proceed, proceed)
                ]);
            }
        }();
        return A2($elm$html$Html$div, _List_fromArray([
            A2($elm$html$Html$Attributes$style, "height", "60px"),
            A2($elm$html$Html$Attributes$style, "line-height", "60px"),
            A2($elm$html$Html$Attributes$style, "text-align", "right"),
            A2($elm$html$Html$Attributes$style, "background-color", "rgb(50, 50, 50)")
        ]), buttonNodes);
    };
    var $elm$browser$Debugger$Overlay$viewMessage = F4(function(config, title, details, buttons) {
        return A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$id("elm-debugger-overlay"),
            A2($elm$html$Html$Attributes$style, "position", "fixed"),
            A2($elm$html$Html$Attributes$style, "top", "0"),
            A2($elm$html$Html$Attributes$style, "left", "0"),
            A2($elm$html$Html$Attributes$style, "width", "100vw"),
            A2($elm$html$Html$Attributes$style, "height", "100vh"),
            A2($elm$html$Html$Attributes$style, "color", "white"),
            A2($elm$html$Html$Attributes$style, "pointer-events", "none"),
            A2($elm$html$Html$Attributes$style, "font-family", "'Trebuchet MS', 'Lucida Grande', 'Bitstream Vera Sans', 'Helvetica Neue', sans-serif"),
            A2($elm$html$Html$Attributes$style, "z-index", "2147483647")
        ]), _List_fromArray([
            A2($elm$html$Html$div, _List_fromArray([
                A2($elm$html$Html$Attributes$style, "position", "absolute"),
                A2($elm$html$Html$Attributes$style, "width", "600px"),
                A2($elm$html$Html$Attributes$style, "height", "100vh"),
                A2($elm$html$Html$Attributes$style, "padding-left", "calc(50% - 300px)"),
                A2($elm$html$Html$Attributes$style, "padding-right", "calc(50% - 300px)"),
                A2($elm$html$Html$Attributes$style, "background-color", "rgba(200, 200, 200, 0.7)"),
                A2($elm$html$Html$Attributes$style, "pointer-events", "auto")
            ]), _List_fromArray([
                A2($elm$html$Html$div, _List_fromArray([
                    A2($elm$html$Html$Attributes$style, "font-size", "36px"),
                    A2($elm$html$Html$Attributes$style, "height", "80px"),
                    A2($elm$html$Html$Attributes$style, "background-color", "rgb(50, 50, 50)"),
                    A2($elm$html$Html$Attributes$style, "padding-left", "22px"),
                    A2($elm$html$Html$Attributes$style, "vertical-align", "middle"),
                    A2($elm$html$Html$Attributes$style, "line-height", "80px")
                ]), _List_fromArray([
                    $elm$html$Html$text(title)
                ])),
                A2($elm$html$Html$div, _List_fromArray([
                    $elm$html$Html$Attributes$id("elm-debugger-details"),
                    A2($elm$html$Html$Attributes$style, "padding", " 8px 20px"),
                    A2($elm$html$Html$Attributes$style, "overflow-y", "auto"),
                    A2($elm$html$Html$Attributes$style, "max-height", "calc(100vh - 156px)"),
                    A2($elm$html$Html$Attributes$style, "background-color", "rgb(61, 61, 61)")
                ]), details),
                A2($elm$html$Html$map, config.wrap, $elm$browser$Debugger$Overlay$viewButtons(buttons))
            ]))
        ]));
    });
    var $elm$virtual_dom$VirtualDom$attribute = F2(function(key, value) {
        return A2(_VirtualDom_attribute, _VirtualDom_noOnOrFormAction(key), _VirtualDom_noJavaScriptOrHtmlUri(value));
    });
    var $elm$core$Basics$negate = function(n) {
        return -n;
    };
    var $elm$virtual_dom$VirtualDom$nodeNS = F2(function(namespace, tag) {
        return A2(_VirtualDom_nodeNS, namespace, _VirtualDom_noScript(tag));
    });
    var $elm$core$String$fromFloat = _String_fromNumber;
    var $elm$browser$Debugger$Overlay$viewShape = F4(function(x, y, angle, coordinates) {
        return A4($elm$virtual_dom$VirtualDom$nodeNS, "http://www.w3.org/2000/svg", "polygon", _List_fromArray([
            A2($elm$virtual_dom$VirtualDom$attribute, "points", coordinates),
            A2($elm$virtual_dom$VirtualDom$attribute, "transform", "translate(" + ($elm$core$String$fromFloat(x) + (" " + ($elm$core$String$fromFloat(y) + (") rotate(" + ($elm$core$String$fromFloat(-angle) + ")"))))))
        ]), _List_Nil);
    });
    var $elm$browser$Debugger$Overlay$elmLogo = A4($elm$virtual_dom$VirtualDom$nodeNS, "http://www.w3.org/2000/svg", "svg", _List_fromArray([
        A2($elm$virtual_dom$VirtualDom$attribute, "viewBox", "-300 -300 600 600"),
        A2($elm$virtual_dom$VirtualDom$attribute, "xmlns", "http://www.w3.org/2000/svg"),
        A2($elm$virtual_dom$VirtualDom$attribute, "fill", "currentColor"),
        A2($elm$virtual_dom$VirtualDom$attribute, "width", "24px"),
        A2($elm$virtual_dom$VirtualDom$attribute, "height", "24px")
    ]), _List_fromArray([
        A4($elm$virtual_dom$VirtualDom$nodeNS, "http://www.w3.org/2000/svg", "g", _List_fromArray([
            A2($elm$virtual_dom$VirtualDom$attribute, "transform", "scale(1 -1)")
        ]), _List_fromArray([
            A4($elm$browser$Debugger$Overlay$viewShape, 0, -210, 0, "-280,-90 0,190 280,-90"),
            A4($elm$browser$Debugger$Overlay$viewShape, -210, 0, 90, "-280,-90 0,190 280,-90"),
            A4($elm$browser$Debugger$Overlay$viewShape, 207, 207, 45, "-198,-66 0,132 198,-66"),
            A4($elm$browser$Debugger$Overlay$viewShape, 150, 0, 0, "-130,0 0,-130 130,0 0,130"),
            A4($elm$browser$Debugger$Overlay$viewShape, -89, 239, 0, "-191,61 69,61 191,-61 -69,-61"),
            A4($elm$browser$Debugger$Overlay$viewShape, 0, 106, 180, "-130,-44 0,86  130,-44"),
            A4($elm$browser$Debugger$Overlay$viewShape, 256, -150, 270, "-130,-44 0,86  130,-44")
        ]))
    ]));
    var $elm$core$String$length = _String_length;
    var $elm$browser$Debugger$Overlay$viewMiniControls = F2(function(config, numMsgs) {
        var string = $elm$core$String$fromInt(numMsgs);
        var width = $elm$core$String$fromInt(2 + $elm$core$String$length(string));
        return A2($elm$html$Html$div, _List_fromArray([
            A2($elm$html$Html$Attributes$style, "position", "fixed"),
            A2($elm$html$Html$Attributes$style, "bottom", "2em"),
            A2($elm$html$Html$Attributes$style, "right", "2em"),
            A2($elm$html$Html$Attributes$style, "width", "calc(42px + " + (width + "ch)")),
            A2($elm$html$Html$Attributes$style, "height", "36px"),
            A2($elm$html$Html$Attributes$style, "background-color", "#1293D8"),
            A2($elm$html$Html$Attributes$style, "color", "white"),
            A2($elm$html$Html$Attributes$style, "font-family", "monospace"),
            A2($elm$html$Html$Attributes$style, "pointer-events", "auto"),
            A2($elm$html$Html$Attributes$style, "z-index", "2147483647"),
            A2($elm$html$Html$Attributes$style, "display", "flex"),
            A2($elm$html$Html$Attributes$style, "justify-content", "center"),
            A2($elm$html$Html$Attributes$style, "align-items", "center"),
            A2($elm$html$Html$Attributes$style, "cursor", "pointer"),
            $elm$html$Html$Events$onClick(config.open)
        ]), _List_fromArray([
            $elm$browser$Debugger$Overlay$elmLogo,
            A2($elm$html$Html$span, _List_fromArray([
                A2($elm$html$Html$Attributes$style, "padding-left", "calc(1ch + 6px)"),
                A2($elm$html$Html$Attributes$style, "padding-right", "1ch")
            ]), _List_fromArray([
                $elm$html$Html$text(string)
            ]))
        ]));
    });
    var $elm$browser$Debugger$Overlay$explanationBad = "\nThe messages in this history do not match the messages handled by your\nprogram. I noticed changes in the following types:\n";
    var $elm$browser$Debugger$Overlay$explanationRisky = "\nThis history seems old. It will work with this program, but some\nmessages have been added since the history was created:\n";
    var $elm$core$List$intersperse = F2(function(sep, xs) {
        if (!xs.b) return _List_Nil;
        else {
            var hd = xs.a;
            var tl = xs.b;
            var step = F2(function(x, rest) {
                return A2($elm$core$List$cons, sep, A2($elm$core$List$cons, x, rest));
            });
            var spersed = A3($elm$core$List$foldr, step, _List_Nil, tl);
            return A2($elm$core$List$cons, hd, spersed);
        }
    });
    var $elm$browser$Debugger$Overlay$viewMention = F2(function(tags, verbed) {
        var _v0 = A2($elm$core$List$map, $elm$browser$Debugger$Overlay$viewCode, $elm$core$List$reverse(tags));
        if (!_v0.b) return $elm$html$Html$text("");
        else {
            if (!_v0.b.b) {
                var tag = _v0.a;
                return A2($elm$html$Html$li, _List_Nil, _List_fromArray([
                    $elm$html$Html$text(verbed),
                    tag,
                    $elm$html$Html$text(".")
                ]));
            } else if (!_v0.b.b.b) {
                var tag2 = _v0.a;
                var _v1 = _v0.b;
                var tag1 = _v1.a;
                return A2($elm$html$Html$li, _List_Nil, _List_fromArray([
                    $elm$html$Html$text(verbed),
                    tag1,
                    $elm$html$Html$text(" and "),
                    tag2,
                    $elm$html$Html$text(".")
                ]));
            } else {
                var lastTag = _v0.a;
                var otherTags = _v0.b;
                return A2($elm$html$Html$li, _List_Nil, A2($elm$core$List$cons, $elm$html$Html$text(verbed), _Utils_ap(A2($elm$core$List$intersperse, $elm$html$Html$text(", "), $elm$core$List$reverse(otherTags)), _List_fromArray([
                    $elm$html$Html$text(", and "),
                    lastTag,
                    $elm$html$Html$text(".")
                ]))));
            }
        }
    });
    var $elm$browser$Debugger$Overlay$viewChange = function(change) {
        return A2($elm$html$Html$li, _List_fromArray([
            A2($elm$html$Html$Attributes$style, "margin", "8px 0")
        ]), function() {
            if (change.$ === "AliasChange") {
                var name = change.a;
                return _List_fromArray([
                    A2($elm$html$Html$span, _List_fromArray([
                        A2($elm$html$Html$Attributes$style, "font-size", "1.5em")
                    ]), _List_fromArray([
                        $elm$browser$Debugger$Overlay$viewCode(name)
                    ]))
                ]);
            } else {
                var name = change.a;
                var removed = change.b.removed;
                var changed = change.b.changed;
                var added = change.b.added;
                var argsMatch = change.b.argsMatch;
                return _List_fromArray([
                    A2($elm$html$Html$span, _List_fromArray([
                        A2($elm$html$Html$Attributes$style, "font-size", "1.5em")
                    ]), _List_fromArray([
                        $elm$browser$Debugger$Overlay$viewCode(name)
                    ])),
                    A2($elm$html$Html$ul, _List_fromArray([
                        A2($elm$html$Html$Attributes$style, "list-style-type", "disc"),
                        A2($elm$html$Html$Attributes$style, "padding-left", "2em")
                    ]), _List_fromArray([
                        A2($elm$browser$Debugger$Overlay$viewMention, removed, "Removed "),
                        A2($elm$browser$Debugger$Overlay$viewMention, changed, "Changed "),
                        A2($elm$browser$Debugger$Overlay$viewMention, added, "Added ")
                    ])),
                    argsMatch ? $elm$html$Html$text("") : $elm$html$Html$text("This may be due to the fact that the type variable names changed.")
                ]);
            }
        }());
    };
    var $elm$browser$Debugger$Overlay$viewReport = F2(function(isBad, report) {
        switch(report.$){
            case "CorruptHistory":
                return _List_fromArray([
                    $elm$html$Html$text("Looks like this history file is corrupt. I cannot understand it.")
                ]);
            case "VersionChanged":
                var old = report.a;
                var _new = report.b;
                return _List_fromArray([
                    $elm$html$Html$text("This history was created with Elm " + (old + (", but you are using Elm " + (_new + " right now."))))
                ]);
            case "MessageChanged":
                var old = report.a;
                var _new = report.b;
                return _List_fromArray([
                    $elm$html$Html$text("To import some other history, the overall message type must be the same. The old history has "),
                    $elm$browser$Debugger$Overlay$viewCode(old),
                    $elm$html$Html$text(" messages, but the new program works with "),
                    $elm$browser$Debugger$Overlay$viewCode(_new),
                    $elm$html$Html$text(" messages.")
                ]);
            default:
                var changes = report.a;
                return _List_fromArray([
                    A2($elm$html$Html$p, _List_Nil, _List_fromArray([
                        $elm$html$Html$text(isBad ? $elm$browser$Debugger$Overlay$explanationBad : $elm$browser$Debugger$Overlay$explanationRisky)
                    ])),
                    A2($elm$html$Html$ul, _List_fromArray([
                        A2($elm$html$Html$Attributes$style, "list-style-type", "none"),
                        A2($elm$html$Html$Attributes$style, "padding-left", "20px")
                    ]), A2($elm$core$List$map, $elm$browser$Debugger$Overlay$viewChange, changes))
                ]);
        }
    });
    var $elm$browser$Debugger$Overlay$view = F5(function(config, isPaused, isOpen, numMsgs, state) {
        switch(state.$){
            case "None":
                return isOpen ? $elm$html$Html$text("") : isPaused ? A2($elm$html$Html$div, _List_fromArray([
                    $elm$html$Html$Attributes$id("elm-debugger-overlay"),
                    A2($elm$html$Html$Attributes$style, "position", "fixed"),
                    A2($elm$html$Html$Attributes$style, "top", "0"),
                    A2($elm$html$Html$Attributes$style, "left", "0"),
                    A2($elm$html$Html$Attributes$style, "width", "100vw"),
                    A2($elm$html$Html$Attributes$style, "height", "100vh"),
                    A2($elm$html$Html$Attributes$style, "cursor", "pointer"),
                    A2($elm$html$Html$Attributes$style, "display", "flex"),
                    A2($elm$html$Html$Attributes$style, "align-items", "center"),
                    A2($elm$html$Html$Attributes$style, "justify-content", "center"),
                    A2($elm$html$Html$Attributes$style, "pointer-events", "auto"),
                    A2($elm$html$Html$Attributes$style, "background-color", "rgba(200, 200, 200, 0.7)"),
                    A2($elm$html$Html$Attributes$style, "color", "white"),
                    A2($elm$html$Html$Attributes$style, "font-family", "'Trebuchet MS', 'Lucida Grande', 'Bitstream Vera Sans', 'Helvetica Neue', sans-serif"),
                    A2($elm$html$Html$Attributes$style, "z-index", "2147483646"),
                    $elm$html$Html$Events$onClick(config.resume)
                ]), _List_fromArray([
                    A2($elm$html$Html$span, _List_fromArray([
                        A2($elm$html$Html$Attributes$style, "font-size", "80px")
                    ]), _List_fromArray([
                        $elm$html$Html$text("Click to Resume")
                    ])),
                    A2($elm$browser$Debugger$Overlay$viewMiniControls, config, numMsgs)
                ])) : A2($elm$browser$Debugger$Overlay$viewMiniControls, config, numMsgs);
            case "BadMetadata":
                var badMetadata_ = state.a;
                return A4($elm$browser$Debugger$Overlay$viewMessage, config, "Cannot use Import or Export", $elm$browser$Debugger$Overlay$viewBadMetadata(badMetadata_), $elm$browser$Debugger$Overlay$Accept("Ok"));
            case "BadImport":
                var report = state.a;
                return A4($elm$browser$Debugger$Overlay$viewMessage, config, "Cannot Import History", A2($elm$browser$Debugger$Overlay$viewReport, true, report), $elm$browser$Debugger$Overlay$Accept("Ok"));
            default:
                var report = state.a;
                return A4($elm$browser$Debugger$Overlay$viewMessage, config, "Warning", A2($elm$browser$Debugger$Overlay$viewReport, false, report), A2($elm$browser$Debugger$Overlay$Choose, "Cancel", "Import Anyway"));
        }
    });
    var $elm$browser$Debugger$Main$cornerView = function(model) {
        return A5($elm$browser$Debugger$Overlay$view, {
            exportHistory: $elm$browser$Debugger$Main$Export,
            importHistory: $elm$browser$Debugger$Main$Import,
            open: $elm$browser$Debugger$Main$Open,
            resume: $elm$browser$Debugger$Main$Resume,
            wrap: $elm$browser$Debugger$Main$OverlayMsg
        }, $elm$browser$Debugger$Main$isPaused(model.state), _Debugger_isOpen(model.popout), $elm$browser$Debugger$History$size(model.history), model.overlay);
    };
    var $elm$core$Dict$RBEmpty_elm_builtin = {
        $: "RBEmpty_elm_builtin"
    };
    var $elm$core$Dict$empty = $elm$core$Dict$RBEmpty_elm_builtin;
    var $elm$core$Set$foldr = F3(function(func, initialState, _v0) {
        var dict = _v0.a;
        return A3($elm$core$Dict$foldr, F3(function(key, _v1, state) {
            return A2(func, key, state);
        }), initialState, dict);
    });
    var $elm$browser$Debugger$Main$getCurrentModel = function(state) {
        if (state.$ === "Running") {
            var model = state.a;
            return model;
        } else {
            var model = state.b;
            return model;
        }
    };
    var $elm$browser$Debugger$Main$getUserModel = function(model) {
        return $elm$browser$Debugger$Main$getCurrentModel(model.state);
    };
    var $elm$browser$Debugger$Main$initialWindowHeight = 420;
    var $elm$browser$Debugger$Main$initialWindowWidth = 900;
    var $elm$core$Dict$Black = {
        $: "Black"
    };
    var $elm$core$Dict$RBNode_elm_builtin = F5(function(a, b, c, d, e) {
        return {
            $: "RBNode_elm_builtin",
            a: a,
            b: b,
            c: c,
            d: d,
            e: e
        };
    });
    var $elm$core$Dict$Red = {
        $: "Red"
    };
    var $elm$core$Dict$balance = F5(function(color, key, value, left, right) {
        if (right.$ === "RBNode_elm_builtin" && right.a.$ === "Red") {
            var _v1 = right.a;
            var rK = right.b;
            var rV = right.c;
            var rLeft = right.d;
            var rRight = right.e;
            if (left.$ === "RBNode_elm_builtin" && left.a.$ === "Red") {
                var _v3 = left.a;
                var lK = left.b;
                var lV = left.c;
                var lLeft = left.d;
                var lRight = left.e;
                return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, key, value, A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, lK, lV, lLeft, lRight), A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, rK, rV, rLeft, rRight));
            } else return A5($elm$core$Dict$RBNode_elm_builtin, color, rK, rV, A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, key, value, left, rLeft), rRight);
        } else {
            if (left.$ === "RBNode_elm_builtin" && left.a.$ === "Red" && left.d.$ === "RBNode_elm_builtin" && left.d.a.$ === "Red") {
                var _v5 = left.a;
                var lK = left.b;
                var lV = left.c;
                var _v6 = left.d;
                var _v7 = _v6.a;
                var llK = _v6.b;
                var llV = _v6.c;
                var llLeft = _v6.d;
                var llRight = _v6.e;
                var lRight = left.e;
                return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, llK, llV, llLeft, llRight), A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, key, value, lRight, right));
            } else return A5($elm$core$Dict$RBNode_elm_builtin, color, key, value, left, right);
        }
    });
    var $elm$core$Basics$compare = _Utils_compare;
    var $elm$core$Dict$insertHelp = F3(function(key, value, dict) {
        if (dict.$ === "RBEmpty_elm_builtin") return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, key, value, $elm$core$Dict$RBEmpty_elm_builtin, $elm$core$Dict$RBEmpty_elm_builtin);
        else {
            var nColor = dict.a;
            var nKey = dict.b;
            var nValue = dict.c;
            var nLeft = dict.d;
            var nRight = dict.e;
            var _v1 = A2($elm$core$Basics$compare, key, nKey);
            switch(_v1.$){
                case "LT":
                    return A5($elm$core$Dict$balance, nColor, nKey, nValue, A3($elm$core$Dict$insertHelp, key, value, nLeft), nRight);
                case "EQ":
                    return A5($elm$core$Dict$RBNode_elm_builtin, nColor, nKey, value, nLeft, nRight);
                default:
                    return A5($elm$core$Dict$balance, nColor, nKey, nValue, nLeft, A3($elm$core$Dict$insertHelp, key, value, nRight));
            }
        }
    });
    var $elm$core$Dict$insert = F3(function(key, value, dict) {
        var _v0 = A3($elm$core$Dict$insertHelp, key, value, dict);
        if (_v0.$ === "RBNode_elm_builtin" && _v0.a.$ === "Red") {
            var _v1 = _v0.a;
            var k = _v0.b;
            var v = _v0.c;
            var l = _v0.d;
            var r = _v0.e;
            return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, k, v, l, r);
        } else {
            var x = _v0;
            return x;
        }
    });
    var $elm$browser$Debugger$Main$cachedHistory = function(model) {
        var _v0 = model.state;
        if (_v0.$ === "Running") return model.history;
        else {
            var history1 = _v0.e;
            return history1;
        }
    };
    var $elm$virtual_dom$VirtualDom$node = function(tag) {
        return _VirtualDom_node(_VirtualDom_noScript(tag));
    };
    var $elm$html$Html$node = $elm$virtual_dom$VirtualDom$node;
    var $elm$browser$Debugger$Main$DragEnd = {
        $: "DragEnd"
    };
    var $elm$browser$Debugger$Main$getDragStatus = function(layout) {
        if (layout.$ === "Horizontal") {
            var status = layout.a;
            return status;
        } else {
            var status = layout.a;
            return status;
        }
    };
    var $elm$browser$Debugger$Main$Drag = function(a) {
        return {
            $: "Drag",
            a: a
        };
    };
    var $elm$browser$Debugger$Main$DragInfo = F5(function(x, y, down, width, height) {
        return {
            down: down,
            height: height,
            width: width,
            x: x,
            y: y
        };
    });
    var $elm$json$Json$Decode$field = _Json_decodeField;
    var $elm$json$Json$Decode$at = F2(function(fields, decoder) {
        return A3($elm$core$List$foldr, $elm$json$Json$Decode$field, decoder, fields);
    });
    var $elm$json$Json$Decode$float = _Json_decodeFloat;
    var $elm$browser$Debugger$Main$decodeDimension = function(field) {
        return A2($elm$json$Json$Decode$at, _List_fromArray([
            "currentTarget",
            "ownerDocument",
            "defaultView",
            field
        ]), $elm$json$Json$Decode$float);
    };
    var $elm$json$Json$Decode$int = _Json_decodeInt;
    var $elm$json$Json$Decode$map5 = _Json_map5;
    var $elm$browser$Debugger$Main$onMouseMove = A2($elm$html$Html$Events$on, "mousemove", A2($elm$json$Json$Decode$map, $elm$browser$Debugger$Main$Drag, A6($elm$json$Json$Decode$map5, $elm$browser$Debugger$Main$DragInfo, A2($elm$json$Json$Decode$field, "pageX", $elm$json$Json$Decode$float), A2($elm$json$Json$Decode$field, "pageY", $elm$json$Json$Decode$float), A2($elm$json$Json$Decode$field, "buttons", A2($elm$json$Json$Decode$map, function(v) {
        return v === 1;
    }, $elm$json$Json$Decode$int)), $elm$browser$Debugger$Main$decodeDimension("innerWidth"), $elm$browser$Debugger$Main$decodeDimension("innerHeight"))));
    var $elm$html$Html$Events$onMouseUp = function(msg) {
        return A2($elm$html$Html$Events$on, "mouseup", $elm$json$Json$Decode$succeed(msg));
    };
    var $elm$browser$Debugger$Main$toDragListeners = function(layout) {
        var _v0 = $elm$browser$Debugger$Main$getDragStatus(layout);
        if (_v0.$ === "Static") return _List_Nil;
        else return _List_fromArray([
            $elm$browser$Debugger$Main$onMouseMove,
            $elm$html$Html$Events$onMouseUp($elm$browser$Debugger$Main$DragEnd)
        ]);
    };
    var $elm$browser$Debugger$Main$toFlexDirection = function(layout) {
        if (layout.$ === "Horizontal") return "row";
        else return "column-reverse";
    };
    var $elm$browser$Debugger$Main$DragStart = {
        $: "DragStart"
    };
    var $elm$html$Html$Events$onMouseDown = function(msg) {
        return A2($elm$html$Html$Events$on, "mousedown", $elm$json$Json$Decode$succeed(msg));
    };
    var $elm$browser$Debugger$Main$toPercent = function(fraction) {
        return $elm$core$String$fromFloat(100 * fraction) + "%";
    };
    var $elm$browser$Debugger$Main$viewDragZone = function(layout) {
        if (layout.$ === "Horizontal") {
            var x = layout.b;
            return A2($elm$html$Html$div, _List_fromArray([
                A2($elm$html$Html$Attributes$style, "position", "absolute"),
                A2($elm$html$Html$Attributes$style, "top", "0"),
                A2($elm$html$Html$Attributes$style, "left", $elm$browser$Debugger$Main$toPercent(x)),
                A2($elm$html$Html$Attributes$style, "margin-left", "-5px"),
                A2($elm$html$Html$Attributes$style, "width", "10px"),
                A2($elm$html$Html$Attributes$style, "height", "100%"),
                A2($elm$html$Html$Attributes$style, "cursor", "col-resize"),
                $elm$html$Html$Events$onMouseDown($elm$browser$Debugger$Main$DragStart)
            ]), _List_Nil);
        } else {
            var y = layout.c;
            return A2($elm$html$Html$div, _List_fromArray([
                A2($elm$html$Html$Attributes$style, "position", "absolute"),
                A2($elm$html$Html$Attributes$style, "top", $elm$browser$Debugger$Main$toPercent(y)),
                A2($elm$html$Html$Attributes$style, "left", "0"),
                A2($elm$html$Html$Attributes$style, "margin-top", "-5px"),
                A2($elm$html$Html$Attributes$style, "width", "100%"),
                A2($elm$html$Html$Attributes$style, "height", "10px"),
                A2($elm$html$Html$Attributes$style, "cursor", "row-resize"),
                $elm$html$Html$Events$onMouseDown($elm$browser$Debugger$Main$DragStart)
            ]), _List_Nil);
        }
    };
    var $elm$browser$Debugger$Main$TweakExpandoModel = function(a) {
        return {
            $: "TweakExpandoModel",
            a: a
        };
    };
    var $elm$browser$Debugger$Main$TweakExpandoMsg = function(a) {
        return {
            $: "TweakExpandoMsg",
            a: a
        };
    };
    var $elm$browser$Debugger$Main$toExpandoPercents = function(layout) {
        if (layout.$ === "Horizontal") {
            var x = layout.b;
            return _Utils_Tuple2($elm$browser$Debugger$Main$toPercent(1 - x), "100%");
        } else {
            var y = layout.c;
            return _Utils_Tuple2("100%", $elm$browser$Debugger$Main$toPercent(y));
        }
    };
    var $elm$browser$Debugger$Main$toMouseBlocker = function(layout) {
        var _v0 = $elm$browser$Debugger$Main$getDragStatus(layout);
        if (_v0.$ === "Static") return "auto";
        else return "none";
    };
    var $elm$browser$Debugger$Expando$Field = F2(function(a, b) {
        return {
            $: "Field",
            a: a,
            b: b
        };
    });
    var $elm$browser$Debugger$Expando$Index = F3(function(a, b, c) {
        return {
            $: "Index",
            a: a,
            b: b,
            c: c
        };
    });
    var $elm$browser$Debugger$Expando$Key = {
        $: "Key"
    };
    var $elm$browser$Debugger$Expando$None = {
        $: "None"
    };
    var $elm$browser$Debugger$Expando$Toggle = {
        $: "Toggle"
    };
    var $elm$browser$Debugger$Expando$Value = {
        $: "Value"
    };
    var $elm$browser$Debugger$Expando$blue = A2($elm$html$Html$Attributes$style, "color", "rgb(28, 0, 207)");
    var $elm$core$Basics$composeL = F3(function(g, f, x) {
        return g(f(x));
    });
    var $elm$browser$Debugger$Expando$leftPad = function(maybeKey) {
        if (maybeKey.$ === "Nothing") return _List_Nil;
        else return _List_fromArray([
            A2($elm$html$Html$Attributes$style, "padding-left", "4ch")
        ]);
    };
    var $elm$browser$Debugger$Expando$makeArrow = function(arrow) {
        return A2($elm$html$Html$span, _List_fromArray([
            A2($elm$html$Html$Attributes$style, "color", "#777"),
            A2($elm$html$Html$Attributes$style, "padding-left", "2ch"),
            A2($elm$html$Html$Attributes$style, "width", "2ch"),
            A2($elm$html$Html$Attributes$style, "display", "inline-block")
        ]), _List_fromArray([
            $elm$html$Html$text(arrow)
        ]));
    };
    var $elm$browser$Debugger$Expando$purple = A2($elm$html$Html$Attributes$style, "color", "rgb(136, 19, 145)");
    var $elm$browser$Debugger$Expando$lineStarter = F3(function(maybeKey, maybeIsClosed, description) {
        var arrow = function() {
            if (maybeIsClosed.$ === "Nothing") return $elm$browser$Debugger$Expando$makeArrow("");
            else {
                if (maybeIsClosed.a) return $elm$browser$Debugger$Expando$makeArrow("\u25B8");
                else return $elm$browser$Debugger$Expando$makeArrow("\u25BE");
            }
        }();
        if (maybeKey.$ === "Nothing") return A2($elm$core$List$cons, arrow, description);
        else {
            var key = maybeKey.a;
            return A2($elm$core$List$cons, arrow, A2($elm$core$List$cons, A2($elm$html$Html$span, _List_fromArray([
                $elm$browser$Debugger$Expando$purple
            ]), _List_fromArray([
                $elm$html$Html$text(key)
            ])), A2($elm$core$List$cons, $elm$html$Html$text(" = "), description)));
        }
    });
    var $elm$browser$Debugger$Expando$red = A2($elm$html$Html$Attributes$style, "color", "rgb(196, 26, 22)");
    var $elm$core$Tuple$second = function(_v0) {
        var y = _v0.b;
        return y;
    };
    var $elm$browser$Debugger$Expando$seqTypeToString = F2(function(n, seqType) {
        switch(seqType.$){
            case "ListSeq":
                return "List(" + ($elm$core$String$fromInt(n) + ")");
            case "SetSeq":
                return "Set(" + ($elm$core$String$fromInt(n) + ")");
            default:
                return "Array(" + ($elm$core$String$fromInt(n) + ")");
        }
    });
    var $elm$core$String$slice = _String_slice;
    var $elm$core$String$left = F2(function(n, string) {
        return n < 1 ? "" : A3($elm$core$String$slice, 0, n, string);
    });
    var $elm$core$String$right = F2(function(n, string) {
        return n < 1 ? "" : A3($elm$core$String$slice, -n, $elm$core$String$length(string), string);
    });
    var $elm$browser$Debugger$Expando$elideMiddle = function(str) {
        return $elm$core$String$length(str) <= 18 ? str : A2($elm$core$String$left, 8, str) + ("..." + A2($elm$core$String$right, 8, str));
    };
    var $elm$core$Dict$isEmpty = function(dict) {
        if (dict.$ === "RBEmpty_elm_builtin") return true;
        else return false;
    };
    var $elm$browser$Debugger$Expando$viewExtraTinyRecord = F3(function(length, starter, entries) {
        if (!entries.b) return _Utils_Tuple2(length + 1, _List_fromArray([
            $elm$html$Html$text("}")
        ]));
        else {
            var field = entries.a;
            var rest = entries.b;
            var nextLength = length + $elm$core$String$length(field) + 1;
            if (nextLength > 18) return _Utils_Tuple2(length + 2, _List_fromArray([
                $elm$html$Html$text("\u2026}")
            ]));
            else {
                var _v1 = A3($elm$browser$Debugger$Expando$viewExtraTinyRecord, nextLength, ",", rest);
                var finalLength = _v1.a;
                var otherHtmls = _v1.b;
                return _Utils_Tuple2(finalLength, A2($elm$core$List$cons, $elm$html$Html$text(starter), A2($elm$core$List$cons, A2($elm$html$Html$span, _List_fromArray([
                    $elm$browser$Debugger$Expando$purple
                ]), _List_fromArray([
                    $elm$html$Html$text(field)
                ])), otherHtmls)));
            }
        }
    });
    var $elm$browser$Debugger$Expando$viewTinyHelp = function(str) {
        return _Utils_Tuple2($elm$core$String$length(str), _List_fromArray([
            $elm$html$Html$text(str)
        ]));
    };
    var $elm$core$Maybe$withDefault = F2(function(_default, maybe) {
        if (maybe.$ === "Just") {
            var value = maybe.a;
            return value;
        } else return _default;
    });
    var $elm$browser$Debugger$Expando$viewExtraTiny = function(value) {
        if (value.$ === "Record") {
            var record = value.b;
            return A3($elm$browser$Debugger$Expando$viewExtraTinyRecord, 0, "{", $elm$core$Dict$keys(record));
        } else return $elm$browser$Debugger$Expando$viewTiny(value);
    };
    var $elm$browser$Debugger$Expando$viewTiny = function(value) {
        switch(value.$){
            case "S":
                var stringRep = value.a;
                var str = $elm$browser$Debugger$Expando$elideMiddle(stringRep);
                return _Utils_Tuple2($elm$core$String$length(str), _List_fromArray([
                    A2($elm$html$Html$span, _List_fromArray([
                        $elm$browser$Debugger$Expando$red
                    ]), _List_fromArray([
                        $elm$html$Html$text(str)
                    ]))
                ]));
            case "Primitive":
                var stringRep = value.a;
                return _Utils_Tuple2($elm$core$String$length(stringRep), _List_fromArray([
                    A2($elm$html$Html$span, _List_fromArray([
                        $elm$browser$Debugger$Expando$blue
                    ]), _List_fromArray([
                        $elm$html$Html$text(stringRep)
                    ]))
                ]));
            case "Sequence":
                var seqType = value.a;
                var valueList = value.c;
                return $elm$browser$Debugger$Expando$viewTinyHelp(A2($elm$browser$Debugger$Expando$seqTypeToString, $elm$core$List$length(valueList), seqType));
            case "Dictionary":
                var keyValuePairs = value.b;
                return $elm$browser$Debugger$Expando$viewTinyHelp("Dict(" + ($elm$core$String$fromInt($elm$core$List$length(keyValuePairs)) + ")"));
            case "Record":
                var record = value.b;
                return $elm$browser$Debugger$Expando$viewTinyRecord(record);
            default:
                if (!value.c.b) {
                    var maybeName = value.a;
                    return $elm$browser$Debugger$Expando$viewTinyHelp(A2($elm$core$Maybe$withDefault, "Unit", maybeName));
                } else {
                    var maybeName = value.a;
                    var valueList = value.c;
                    return $elm$browser$Debugger$Expando$viewTinyHelp(function() {
                        if (maybeName.$ === "Nothing") return "Tuple(" + ($elm$core$String$fromInt($elm$core$List$length(valueList)) + ")");
                        else {
                            var name = maybeName.a;
                            return name + " \u2026";
                        }
                    }());
                }
        }
    };
    var $elm$browser$Debugger$Expando$viewTinyRecord = function(record) {
        return $elm$core$Dict$isEmpty(record) ? _Utils_Tuple2(2, _List_fromArray([
            $elm$html$Html$text("{}")
        ])) : A3($elm$browser$Debugger$Expando$viewTinyRecordHelp, 0, "{ ", $elm$core$Dict$toList(record));
    };
    var $elm$browser$Debugger$Expando$viewTinyRecordHelp = F3(function(length, starter, entries) {
        if (!entries.b) return _Utils_Tuple2(length + 2, _List_fromArray([
            $elm$html$Html$text(" }")
        ]));
        else {
            var _v1 = entries.a;
            var field = _v1.a;
            var value = _v1.b;
            var rest = entries.b;
            var fieldLen = $elm$core$String$length(field);
            var _v2 = $elm$browser$Debugger$Expando$viewExtraTiny(value);
            var valueLen = _v2.a;
            var valueHtmls = _v2.b;
            var newLength = length + fieldLen + valueLen + 5;
            if (newLength > 60) return _Utils_Tuple2(length + 4, _List_fromArray([
                $elm$html$Html$text(", \u2026 }")
            ]));
            else {
                var _v3 = A3($elm$browser$Debugger$Expando$viewTinyRecordHelp, newLength, ", ", rest);
                var finalLength = _v3.a;
                var otherHtmls = _v3.b;
                return _Utils_Tuple2(finalLength, A2($elm$core$List$cons, $elm$html$Html$text(starter), A2($elm$core$List$cons, A2($elm$html$Html$span, _List_fromArray([
                    $elm$browser$Debugger$Expando$purple
                ]), _List_fromArray([
                    $elm$html$Html$text(field)
                ])), A2($elm$core$List$cons, $elm$html$Html$text(" = "), A2($elm$core$List$cons, A2($elm$html$Html$span, _List_Nil, valueHtmls), otherHtmls)))));
            }
        }
    });
    var $elm$browser$Debugger$Expando$view = F2(function(maybeKey, expando) {
        switch(expando.$){
            case "S":
                var stringRep = expando.a;
                return A2($elm$html$Html$div, $elm$browser$Debugger$Expando$leftPad(maybeKey), A3($elm$browser$Debugger$Expando$lineStarter, maybeKey, $elm$core$Maybe$Nothing, _List_fromArray([
                    A2($elm$html$Html$span, _List_fromArray([
                        $elm$browser$Debugger$Expando$red
                    ]), _List_fromArray([
                        $elm$html$Html$text(stringRep)
                    ]))
                ])));
            case "Primitive":
                var stringRep = expando.a;
                return A2($elm$html$Html$div, $elm$browser$Debugger$Expando$leftPad(maybeKey), A3($elm$browser$Debugger$Expando$lineStarter, maybeKey, $elm$core$Maybe$Nothing, _List_fromArray([
                    A2($elm$html$Html$span, _List_fromArray([
                        $elm$browser$Debugger$Expando$blue
                    ]), _List_fromArray([
                        $elm$html$Html$text(stringRep)
                    ]))
                ])));
            case "Sequence":
                var seqType = expando.a;
                var isClosed = expando.b;
                var valueList = expando.c;
                return A4($elm$browser$Debugger$Expando$viewSequence, maybeKey, seqType, isClosed, valueList);
            case "Dictionary":
                var isClosed = expando.a;
                var keyValuePairs = expando.b;
                return A3($elm$browser$Debugger$Expando$viewDictionary, maybeKey, isClosed, keyValuePairs);
            case "Record":
                var isClosed = expando.a;
                var valueDict = expando.b;
                return A3($elm$browser$Debugger$Expando$viewRecord, maybeKey, isClosed, valueDict);
            default:
                var maybeName = expando.a;
                var isClosed = expando.b;
                var valueList = expando.c;
                return A4($elm$browser$Debugger$Expando$viewConstructor, maybeKey, maybeName, isClosed, valueList);
        }
    });
    var $elm$browser$Debugger$Expando$viewConstructor = F4(function(maybeKey, maybeName, isClosed, valueList) {
        var tinyArgs = A2($elm$core$List$map, A2($elm$core$Basics$composeL, $elm$core$Tuple$second, $elm$browser$Debugger$Expando$viewExtraTiny), valueList);
        var description = function() {
            var _v7 = _Utils_Tuple2(maybeName, tinyArgs);
            if (_v7.a.$ === "Nothing") {
                if (!_v7.b.b) {
                    var _v8 = _v7.a;
                    return _List_fromArray([
                        $elm$html$Html$text("()")
                    ]);
                } else {
                    var _v9 = _v7.a;
                    var _v10 = _v7.b;
                    var x = _v10.a;
                    var xs = _v10.b;
                    return A2($elm$core$List$cons, $elm$html$Html$text("( "), A2($elm$core$List$cons, A2($elm$html$Html$span, _List_Nil, x), A3($elm$core$List$foldr, F2(function(args, rest) {
                        return A2($elm$core$List$cons, $elm$html$Html$text(", "), A2($elm$core$List$cons, A2($elm$html$Html$span, _List_Nil, args), rest));
                    }), _List_fromArray([
                        $elm$html$Html$text(" )")
                    ]), xs)));
                }
            } else if (!_v7.b.b) {
                var name = _v7.a.a;
                return _List_fromArray([
                    $elm$html$Html$text(name)
                ]);
            } else {
                var name = _v7.a.a;
                var _v11 = _v7.b;
                var x = _v11.a;
                var xs = _v11.b;
                return A2($elm$core$List$cons, $elm$html$Html$text(name + " "), A2($elm$core$List$cons, A2($elm$html$Html$span, _List_Nil, x), A3($elm$core$List$foldr, F2(function(args, rest) {
                    return A2($elm$core$List$cons, $elm$html$Html$text(" "), A2($elm$core$List$cons, A2($elm$html$Html$span, _List_Nil, args), rest));
                }), _List_Nil, xs)));
            }
        }();
        var _v4 = function() {
            if (!valueList.b) return _Utils_Tuple2($elm$core$Maybe$Nothing, A2($elm$html$Html$div, _List_Nil, _List_Nil));
            else {
                if (!valueList.b.b) {
                    var entry = valueList.a;
                    switch(entry.$){
                        case "S":
                            return _Utils_Tuple2($elm$core$Maybe$Nothing, A2($elm$html$Html$div, _List_Nil, _List_Nil));
                        case "Primitive":
                            return _Utils_Tuple2($elm$core$Maybe$Nothing, A2($elm$html$Html$div, _List_Nil, _List_Nil));
                        case "Sequence":
                            var subValueList = entry.c;
                            return _Utils_Tuple2($elm$core$Maybe$Just(isClosed), isClosed ? A2($elm$html$Html$div, _List_Nil, _List_Nil) : A2($elm$html$Html$map, A2($elm$browser$Debugger$Expando$Index, $elm$browser$Debugger$Expando$None, 0), $elm$browser$Debugger$Expando$viewSequenceOpen(subValueList)));
                        case "Dictionary":
                            var keyValuePairs = entry.b;
                            return _Utils_Tuple2($elm$core$Maybe$Just(isClosed), isClosed ? A2($elm$html$Html$div, _List_Nil, _List_Nil) : A2($elm$html$Html$map, A2($elm$browser$Debugger$Expando$Index, $elm$browser$Debugger$Expando$None, 0), $elm$browser$Debugger$Expando$viewDictionaryOpen(keyValuePairs)));
                        case "Record":
                            var record = entry.b;
                            return _Utils_Tuple2($elm$core$Maybe$Just(isClosed), isClosed ? A2($elm$html$Html$div, _List_Nil, _List_Nil) : A2($elm$html$Html$map, A2($elm$browser$Debugger$Expando$Index, $elm$browser$Debugger$Expando$None, 0), $elm$browser$Debugger$Expando$viewRecordOpen(record)));
                        default:
                            var subValueList = entry.c;
                            return _Utils_Tuple2($elm$core$Maybe$Just(isClosed), isClosed ? A2($elm$html$Html$div, _List_Nil, _List_Nil) : A2($elm$html$Html$map, A2($elm$browser$Debugger$Expando$Index, $elm$browser$Debugger$Expando$None, 0), $elm$browser$Debugger$Expando$viewConstructorOpen(subValueList)));
                    }
                } else return _Utils_Tuple2($elm$core$Maybe$Just(isClosed), isClosed ? A2($elm$html$Html$div, _List_Nil, _List_Nil) : $elm$browser$Debugger$Expando$viewConstructorOpen(valueList));
            }
        }();
        var maybeIsClosed = _v4.a;
        var openHtml = _v4.b;
        return A2($elm$html$Html$div, $elm$browser$Debugger$Expando$leftPad(maybeKey), _List_fromArray([
            A2($elm$html$Html$div, _List_fromArray([
                $elm$html$Html$Events$onClick($elm$browser$Debugger$Expando$Toggle)
            ]), A3($elm$browser$Debugger$Expando$lineStarter, maybeKey, maybeIsClosed, description)),
            openHtml
        ]));
    });
    var $elm$browser$Debugger$Expando$viewConstructorEntry = F2(function(index, value) {
        return A2($elm$html$Html$map, A2($elm$browser$Debugger$Expando$Index, $elm$browser$Debugger$Expando$None, index), A2($elm$browser$Debugger$Expando$view, $elm$core$Maybe$Just($elm$core$String$fromInt(index)), value));
    });
    var $elm$browser$Debugger$Expando$viewConstructorOpen = function(valueList) {
        return A2($elm$html$Html$div, _List_Nil, A2($elm$core$List$indexedMap, $elm$browser$Debugger$Expando$viewConstructorEntry, valueList));
    };
    var $elm$browser$Debugger$Expando$viewDictionary = F3(function(maybeKey, isClosed, keyValuePairs) {
        var starter = "Dict(" + ($elm$core$String$fromInt($elm$core$List$length(keyValuePairs)) + ")");
        return A2($elm$html$Html$div, $elm$browser$Debugger$Expando$leftPad(maybeKey), _List_fromArray([
            A2($elm$html$Html$div, _List_fromArray([
                $elm$html$Html$Events$onClick($elm$browser$Debugger$Expando$Toggle)
            ]), A3($elm$browser$Debugger$Expando$lineStarter, maybeKey, $elm$core$Maybe$Just(isClosed), _List_fromArray([
                $elm$html$Html$text(starter)
            ]))),
            isClosed ? $elm$html$Html$text("") : $elm$browser$Debugger$Expando$viewDictionaryOpen(keyValuePairs)
        ]));
    });
    var $elm$browser$Debugger$Expando$viewDictionaryEntry = F2(function(index, _v2) {
        var key = _v2.a;
        var value = _v2.b;
        switch(key.$){
            case "S":
                var stringRep = key.a;
                return A2($elm$html$Html$map, A2($elm$browser$Debugger$Expando$Index, $elm$browser$Debugger$Expando$Value, index), A2($elm$browser$Debugger$Expando$view, $elm$core$Maybe$Just(stringRep), value));
            case "Primitive":
                var stringRep = key.a;
                return A2($elm$html$Html$map, A2($elm$browser$Debugger$Expando$Index, $elm$browser$Debugger$Expando$Value, index), A2($elm$browser$Debugger$Expando$view, $elm$core$Maybe$Just(stringRep), value));
            default:
                return A2($elm$html$Html$div, _List_Nil, _List_fromArray([
                    A2($elm$html$Html$map, A2($elm$browser$Debugger$Expando$Index, $elm$browser$Debugger$Expando$Key, index), A2($elm$browser$Debugger$Expando$view, $elm$core$Maybe$Just("key"), key)),
                    A2($elm$html$Html$map, A2($elm$browser$Debugger$Expando$Index, $elm$browser$Debugger$Expando$Value, index), A2($elm$browser$Debugger$Expando$view, $elm$core$Maybe$Just("value"), value))
                ]));
        }
    });
    var $elm$browser$Debugger$Expando$viewDictionaryOpen = function(keyValuePairs) {
        return A2($elm$html$Html$div, _List_Nil, A2($elm$core$List$indexedMap, $elm$browser$Debugger$Expando$viewDictionaryEntry, keyValuePairs));
    };
    var $elm$browser$Debugger$Expando$viewRecord = F3(function(maybeKey, isClosed, record) {
        var _v1 = isClosed ? _Utils_Tuple3($elm$browser$Debugger$Expando$viewTinyRecord(record).b, $elm$html$Html$text(""), $elm$html$Html$text("")) : _Utils_Tuple3(_List_fromArray([
            $elm$html$Html$text("{")
        ]), $elm$browser$Debugger$Expando$viewRecordOpen(record), A2($elm$html$Html$div, $elm$browser$Debugger$Expando$leftPad($elm$core$Maybe$Just(_Utils_Tuple0)), _List_fromArray([
            $elm$html$Html$text("}")
        ])));
        var start = _v1.a;
        var middle = _v1.b;
        var end = _v1.c;
        return A2($elm$html$Html$div, $elm$browser$Debugger$Expando$leftPad(maybeKey), _List_fromArray([
            A2($elm$html$Html$div, _List_fromArray([
                $elm$html$Html$Events$onClick($elm$browser$Debugger$Expando$Toggle)
            ]), A3($elm$browser$Debugger$Expando$lineStarter, maybeKey, $elm$core$Maybe$Just(isClosed), start)),
            middle,
            end
        ]));
    });
    var $elm$browser$Debugger$Expando$viewRecordEntry = function(_v0) {
        var field = _v0.a;
        var value = _v0.b;
        return A2($elm$html$Html$map, $elm$browser$Debugger$Expando$Field(field), A2($elm$browser$Debugger$Expando$view, $elm$core$Maybe$Just(field), value));
    };
    var $elm$browser$Debugger$Expando$viewRecordOpen = function(record) {
        return A2($elm$html$Html$div, _List_Nil, A2($elm$core$List$map, $elm$browser$Debugger$Expando$viewRecordEntry, $elm$core$Dict$toList(record)));
    };
    var $elm$browser$Debugger$Expando$viewSequence = F4(function(maybeKey, seqType, isClosed, valueList) {
        var starter = A2($elm$browser$Debugger$Expando$seqTypeToString, $elm$core$List$length(valueList), seqType);
        return A2($elm$html$Html$div, $elm$browser$Debugger$Expando$leftPad(maybeKey), _List_fromArray([
            A2($elm$html$Html$div, _List_fromArray([
                $elm$html$Html$Events$onClick($elm$browser$Debugger$Expando$Toggle)
            ]), A3($elm$browser$Debugger$Expando$lineStarter, maybeKey, $elm$core$Maybe$Just(isClosed), _List_fromArray([
                $elm$html$Html$text(starter)
            ]))),
            isClosed ? $elm$html$Html$text("") : $elm$browser$Debugger$Expando$viewSequenceOpen(valueList)
        ]));
    });
    var $elm$browser$Debugger$Expando$viewSequenceOpen = function(values) {
        return A2($elm$html$Html$div, _List_Nil, A2($elm$core$List$indexedMap, $elm$browser$Debugger$Expando$viewConstructorEntry, values));
    };
    var $elm$browser$Debugger$Main$viewExpando = F3(function(expandoMsg, expandoModel, layout) {
        var block = $elm$browser$Debugger$Main$toMouseBlocker(layout);
        var _v0 = $elm$browser$Debugger$Main$toExpandoPercents(layout);
        var w = _v0.a;
        var h = _v0.b;
        return A2($elm$html$Html$div, _List_fromArray([
            A2($elm$html$Html$Attributes$style, "display", "block"),
            A2($elm$html$Html$Attributes$style, "width", "calc(" + (w + " - 4em)")),
            A2($elm$html$Html$Attributes$style, "height", "calc(" + (h + " - 4em)")),
            A2($elm$html$Html$Attributes$style, "padding", "2em"),
            A2($elm$html$Html$Attributes$style, "margin", "0"),
            A2($elm$html$Html$Attributes$style, "overflow", "auto"),
            A2($elm$html$Html$Attributes$style, "pointer-events", block),
            A2($elm$html$Html$Attributes$style, "-webkit-user-select", block),
            A2($elm$html$Html$Attributes$style, "-moz-user-select", block),
            A2($elm$html$Html$Attributes$style, "-ms-user-select", block),
            A2($elm$html$Html$Attributes$style, "user-select", block)
        ]), _List_fromArray([
            A2($elm$html$Html$div, _List_fromArray([
                A2($elm$html$Html$Attributes$style, "color", "#ccc"),
                A2($elm$html$Html$Attributes$style, "padding", "0 0 1em 0")
            ]), _List_fromArray([
                $elm$html$Html$text("-- MESSAGE")
            ])),
            A2($elm$html$Html$map, $elm$browser$Debugger$Main$TweakExpandoMsg, A2($elm$browser$Debugger$Expando$view, $elm$core$Maybe$Nothing, expandoMsg)),
            A2($elm$html$Html$div, _List_fromArray([
                A2($elm$html$Html$Attributes$style, "color", "#ccc"),
                A2($elm$html$Html$Attributes$style, "padding", "1em 0")
            ]), _List_fromArray([
                $elm$html$Html$text("-- MODEL")
            ])),
            A2($elm$html$Html$map, $elm$browser$Debugger$Main$TweakExpandoModel, A2($elm$browser$Debugger$Expando$view, $elm$core$Maybe$Nothing, expandoModel))
        ]));
    });
    var $elm$browser$Debugger$Main$Jump = function(a) {
        return {
            $: "Jump",
            a: a
        };
    };
    var $elm$virtual_dom$VirtualDom$lazy = _VirtualDom_lazy;
    var $elm$html$Html$Lazy$lazy = $elm$virtual_dom$VirtualDom$lazy;
    var $elm$browser$Debugger$Main$toHistoryPercents = function(layout) {
        if (layout.$ === "Horizontal") {
            var x = layout.b;
            return _Utils_Tuple2($elm$browser$Debugger$Main$toPercent(x), "100%");
        } else {
            var y = layout.c;
            return _Utils_Tuple2("100%", $elm$browser$Debugger$Main$toPercent(1 - y));
        }
    };
    var $elm$virtual_dom$VirtualDom$lazy3 = _VirtualDom_lazy3;
    var $elm$html$Html$Lazy$lazy3 = $elm$virtual_dom$VirtualDom$lazy3;
    var $elm$html$Html$Attributes$class = $elm$html$Html$Attributes$stringProperty("className");
    var $elm$browser$Debugger$History$idForMessageIndex = function(index) {
        return "msg-" + $elm$core$String$fromInt(index);
    };
    var $elm$html$Html$Attributes$title = $elm$html$Html$Attributes$stringProperty("title");
    var $elm$browser$Debugger$History$viewMessage = F3(function(currentIndex, index, msg) {
        var messageName = _Debugger_messageToString(msg);
        var className = _Utils_eq(currentIndex, index) ? "elm-debugger-entry elm-debugger-entry-selected" : "elm-debugger-entry";
        return A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$id($elm$browser$Debugger$History$idForMessageIndex(index)),
            $elm$html$Html$Attributes$class(className),
            $elm$html$Html$Events$onClick(index)
        ]), _List_fromArray([
            A2($elm$html$Html$span, _List_fromArray([
                $elm$html$Html$Attributes$title(messageName),
                $elm$html$Html$Attributes$class("elm-debugger-entry-content")
            ]), _List_fromArray([
                $elm$html$Html$text(messageName)
            ])),
            A2($elm$html$Html$span, _List_fromArray([
                $elm$html$Html$Attributes$class("elm-debugger-entry-index")
            ]), _List_fromArray([
                $elm$html$Html$text($elm$core$String$fromInt(index))
            ]))
        ]));
    });
    var $elm$browser$Debugger$History$consMsg = F3(function(currentIndex, msg, _v0) {
        var index = _v0.a;
        var rest = _v0.b;
        return _Utils_Tuple2(index + 1, A2($elm$core$List$cons, _Utils_Tuple2($elm$core$String$fromInt(index), A4($elm$html$Html$Lazy$lazy3, $elm$browser$Debugger$History$viewMessage, currentIndex, index, msg)), rest));
    });
    var $elm$core$Array$length = function(_v0) {
        var len = _v0.a;
        return len;
    };
    var $elm$core$Basics$neq = _Utils_notEqual;
    var $elm$virtual_dom$VirtualDom$keyedNode = function(tag) {
        return _VirtualDom_keyedNode(_VirtualDom_noScript(tag));
    };
    var $elm$html$Html$Keyed$node = $elm$virtual_dom$VirtualDom$keyedNode;
    var $elm$browser$Debugger$History$maxSnapshotSize = 31;
    var $elm$browser$Debugger$History$showMoreButton = function(numMessages) {
        var nextIndex = numMessages - 1 - $elm$browser$Debugger$History$maxSnapshotSize * 2;
        var labelText = "View more messages";
        return A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$class("elm-debugger-entry"),
            $elm$html$Html$Events$onClick(nextIndex)
        ]), _List_fromArray([
            A2($elm$html$Html$span, _List_fromArray([
                $elm$html$Html$Attributes$title(labelText),
                $elm$html$Html$Attributes$class("elm-debugger-entry-content")
            ]), _List_fromArray([
                $elm$html$Html$text(labelText)
            ])),
            A2($elm$html$Html$span, _List_fromArray([
                $elm$html$Html$Attributes$class("elm-debugger-entry-index")
            ]), _List_Nil)
        ]));
    };
    var $elm$browser$Debugger$History$styles = A3($elm$html$Html$node, "style", _List_Nil, _List_fromArray([
        $elm$html$Html$text("\n\n.elm-debugger-entry {\n  cursor: pointer;\n  width: 100%;\n  box-sizing: border-box;\n  padding: 8px;\n}\n\n.elm-debugger-entry:hover {\n  background-color: rgb(41, 41, 41);\n}\n\n.elm-debugger-entry-selected, .elm-debugger-entry-selected:hover {\n  background-color: rgb(10, 10, 10);\n}\n\n.elm-debugger-entry-content {\n  width: calc(100% - 40px);\n  padding: 0 5px;\n  box-sizing: border-box;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n  display: inline-block;\n}\n\n.elm-debugger-entry-index {\n  color: #666;\n  width: 40px;\n  text-align: right;\n  display: block;\n  float: right;\n}\n\n")
    ]));
    var $elm$core$Basics$ge = _Utils_ge;
    var $elm$browser$Debugger$History$viewSnapshot = F3(function(selectedIndex, index, _v0) {
        var messages = _v0.messages;
        return A3($elm$html$Html$Keyed$node, "div", _List_Nil, A3($elm$core$Array$foldr, $elm$browser$Debugger$History$consMsg(selectedIndex), _Utils_Tuple2(index, _List_Nil), messages).b);
    });
    var $elm$browser$Debugger$History$consSnapshot = F3(function(selectedIndex, snapshot, _v0) {
        var index = _v0.a;
        var rest = _v0.b;
        var nextIndex = index + $elm$core$Array$length(snapshot.messages);
        var selectedIndexHelp = _Utils_cmp(nextIndex, selectedIndex) > 0 && _Utils_cmp(selectedIndex, index) > -1 ? selectedIndex : -1;
        return _Utils_Tuple2(nextIndex, A2($elm$core$List$cons, A4($elm$html$Html$Lazy$lazy3, $elm$browser$Debugger$History$viewSnapshot, selectedIndexHelp, index, snapshot), rest));
    });
    var $elm$core$Elm$JsArray$foldl = _JsArray_foldl;
    var $elm$core$Array$foldl = F3(function(func, baseCase, _v0) {
        var tree = _v0.c;
        var tail = _v0.d;
        var helper = F2(function(node, acc) {
            if (node.$ === "SubTree") {
                var subTree = node.a;
                return A3($elm$core$Elm$JsArray$foldl, helper, acc, subTree);
            } else {
                var values = node.a;
                return A3($elm$core$Elm$JsArray$foldl, func, acc, values);
            }
        });
        return A3($elm$core$Elm$JsArray$foldl, func, A3($elm$core$Elm$JsArray$foldl, helper, baseCase, tree), tail);
    });
    var $elm$browser$Debugger$History$viewAllSnapshots = F3(function(selectedIndex, startIndex, snapshots) {
        return A2($elm$html$Html$div, _List_Nil, A3($elm$core$Array$foldl, $elm$browser$Debugger$History$consSnapshot(selectedIndex), _Utils_Tuple2(startIndex, _List_Nil), snapshots).b);
    });
    var $elm$core$Array$fromListHelp = F3(function(list, nodeList, nodeListSize) {
        fromListHelp: while(true){
            var _v0 = A2($elm$core$Elm$JsArray$initializeFromList, $elm$core$Array$branchFactor, list);
            var jsArray = _v0.a;
            var remainingItems = _v0.b;
            if (_Utils_cmp($elm$core$Elm$JsArray$length(jsArray), $elm$core$Array$branchFactor) < 0) return A2($elm$core$Array$builderToArray, true, {
                nodeList: nodeList,
                nodeListSize: nodeListSize,
                tail: jsArray
            });
            else {
                var $temp$list = remainingItems, $temp$nodeList = A2($elm$core$List$cons, $elm$core$Array$Leaf(jsArray), nodeList), $temp$nodeListSize = nodeListSize + 1;
                list = $temp$list;
                nodeList = $temp$nodeList;
                nodeListSize = $temp$nodeListSize;
                continue fromListHelp;
            }
        }
    });
    var $elm$core$Array$fromList = function(list) {
        if (!list.b) return $elm$core$Array$empty;
        else return A3($elm$core$Array$fromListHelp, list, _List_Nil, 0);
    };
    var $elm$core$Bitwise$and = _Bitwise_and;
    var $elm$core$Bitwise$shiftRightZfBy = _Bitwise_shiftRightZfBy;
    var $elm$core$Array$bitMask = 4294967295 >>> 32 - $elm$core$Array$shiftStep;
    var $elm$core$Elm$JsArray$unsafeGet = _JsArray_unsafeGet;
    var $elm$core$Array$getHelp = F3(function(shift, index, tree) {
        getHelp: while(true){
            var pos = $elm$core$Array$bitMask & index >>> shift;
            var _v0 = A2($elm$core$Elm$JsArray$unsafeGet, pos, tree);
            if (_v0.$ === "SubTree") {
                var subTree = _v0.a;
                var $temp$shift = shift - $elm$core$Array$shiftStep, $temp$index = index, $temp$tree = subTree;
                shift = $temp$shift;
                index = $temp$index;
                tree = $temp$tree;
                continue getHelp;
            } else {
                var values = _v0.a;
                return A2($elm$core$Elm$JsArray$unsafeGet, $elm$core$Array$bitMask & index, values);
            }
        }
    });
    var $elm$core$Bitwise$shiftLeftBy = _Bitwise_shiftLeftBy;
    var $elm$core$Array$tailIndex = function(len) {
        return len >>> 5 << 5;
    };
    var $elm$core$Array$get = F2(function(index, _v0) {
        var len = _v0.a;
        var startShift = _v0.b;
        var tree = _v0.c;
        var tail = _v0.d;
        return index < 0 || _Utils_cmp(index, len) > -1 ? $elm$core$Maybe$Nothing : _Utils_cmp(index, $elm$core$Array$tailIndex(len)) > -1 ? $elm$core$Maybe$Just(A2($elm$core$Elm$JsArray$unsafeGet, $elm$core$Array$bitMask & index, tail)) : $elm$core$Maybe$Just(A3($elm$core$Array$getHelp, startShift, index, tree));
    });
    var $elm$core$Elm$JsArray$appendN = _JsArray_appendN;
    var $elm$core$Elm$JsArray$slice = _JsArray_slice;
    var $elm$core$Array$appendHelpBuilder = F2(function(tail, builder) {
        var tailLen = $elm$core$Elm$JsArray$length(tail);
        var notAppended = $elm$core$Array$branchFactor - $elm$core$Elm$JsArray$length(builder.tail) - tailLen;
        var appended = A3($elm$core$Elm$JsArray$appendN, $elm$core$Array$branchFactor, builder.tail, tail);
        return notAppended < 0 ? {
            nodeList: A2($elm$core$List$cons, $elm$core$Array$Leaf(appended), builder.nodeList),
            nodeListSize: builder.nodeListSize + 1,
            tail: A3($elm$core$Elm$JsArray$slice, notAppended, tailLen, tail)
        } : !notAppended ? {
            nodeList: A2($elm$core$List$cons, $elm$core$Array$Leaf(appended), builder.nodeList),
            nodeListSize: builder.nodeListSize + 1,
            tail: $elm$core$Elm$JsArray$empty
        } : {
            nodeList: builder.nodeList,
            nodeListSize: builder.nodeListSize,
            tail: appended
        };
    });
    var $elm$core$List$drop = F2(function(n, list) {
        drop: while(true){
            if (n <= 0) return list;
            else {
                if (!list.b) return list;
                else {
                    var x = list.a;
                    var xs = list.b;
                    var $temp$n = n - 1, $temp$list = xs;
                    n = $temp$n;
                    list = $temp$list;
                    continue drop;
                }
            }
        }
    });
    var $elm$core$Array$sliceLeft = F2(function(from, array) {
        var len = array.a;
        var tree = array.c;
        var tail = array.d;
        if (!from) return array;
        else {
            if (_Utils_cmp(from, $elm$core$Array$tailIndex(len)) > -1) return A4($elm$core$Array$Array_elm_builtin, len - from, $elm$core$Array$shiftStep, $elm$core$Elm$JsArray$empty, A3($elm$core$Elm$JsArray$slice, from - $elm$core$Array$tailIndex(len), $elm$core$Elm$JsArray$length(tail), tail));
            else {
                var skipNodes = from / $elm$core$Array$branchFactor | 0;
                var helper = F2(function(node, acc) {
                    if (node.$ === "SubTree") {
                        var subTree = node.a;
                        return A3($elm$core$Elm$JsArray$foldr, helper, acc, subTree);
                    } else {
                        var leaf = node.a;
                        return A2($elm$core$List$cons, leaf, acc);
                    }
                });
                var leafNodes = A3($elm$core$Elm$JsArray$foldr, helper, _List_fromArray([
                    tail
                ]), tree);
                var nodesToInsert = A2($elm$core$List$drop, skipNodes, leafNodes);
                if (!nodesToInsert.b) return $elm$core$Array$empty;
                else {
                    var head = nodesToInsert.a;
                    var rest = nodesToInsert.b;
                    var firstSlice = from - skipNodes * $elm$core$Array$branchFactor;
                    var initialBuilder = {
                        nodeList: _List_Nil,
                        nodeListSize: 0,
                        tail: A3($elm$core$Elm$JsArray$slice, firstSlice, $elm$core$Elm$JsArray$length(head), head)
                    };
                    return A2($elm$core$Array$builderToArray, true, A3($elm$core$List$foldl, $elm$core$Array$appendHelpBuilder, initialBuilder, rest));
                }
            }
        }
    });
    var $elm$core$Array$fetchNewTail = F4(function(shift, end, treeEnd, tree) {
        fetchNewTail: while(true){
            var pos = $elm$core$Array$bitMask & treeEnd >>> shift;
            var _v0 = A2($elm$core$Elm$JsArray$unsafeGet, pos, tree);
            if (_v0.$ === "SubTree") {
                var sub = _v0.a;
                var $temp$shift = shift - $elm$core$Array$shiftStep, $temp$end = end, $temp$treeEnd = treeEnd, $temp$tree = sub;
                shift = $temp$shift;
                end = $temp$end;
                treeEnd = $temp$treeEnd;
                tree = $temp$tree;
                continue fetchNewTail;
            } else {
                var values = _v0.a;
                return A3($elm$core$Elm$JsArray$slice, 0, $elm$core$Array$bitMask & end, values);
            }
        }
    });
    var $elm$core$Array$hoistTree = F3(function(oldShift, newShift, tree) {
        hoistTree: while(true){
            if (_Utils_cmp(oldShift, newShift) < 1 || !$elm$core$Elm$JsArray$length(tree)) return tree;
            else {
                var _v0 = A2($elm$core$Elm$JsArray$unsafeGet, 0, tree);
                if (_v0.$ === "SubTree") {
                    var sub = _v0.a;
                    var $temp$oldShift = oldShift - $elm$core$Array$shiftStep, $temp$newShift = newShift, $temp$tree = sub;
                    oldShift = $temp$oldShift;
                    newShift = $temp$newShift;
                    tree = $temp$tree;
                    continue hoistTree;
                } else return tree;
            }
        }
    });
    var $elm$core$Elm$JsArray$unsafeSet = _JsArray_unsafeSet;
    var $elm$core$Array$sliceTree = F3(function(shift, endIdx, tree) {
        var lastPos = $elm$core$Array$bitMask & endIdx >>> shift;
        var _v0 = A2($elm$core$Elm$JsArray$unsafeGet, lastPos, tree);
        if (_v0.$ === "SubTree") {
            var sub = _v0.a;
            var newSub = A3($elm$core$Array$sliceTree, shift - $elm$core$Array$shiftStep, endIdx, sub);
            return !$elm$core$Elm$JsArray$length(newSub) ? A3($elm$core$Elm$JsArray$slice, 0, lastPos, tree) : A3($elm$core$Elm$JsArray$unsafeSet, lastPos, $elm$core$Array$SubTree(newSub), A3($elm$core$Elm$JsArray$slice, 0, lastPos + 1, tree));
        } else return A3($elm$core$Elm$JsArray$slice, 0, lastPos, tree);
    });
    var $elm$core$Array$sliceRight = F2(function(end, array) {
        var len = array.a;
        var startShift = array.b;
        var tree = array.c;
        var tail = array.d;
        if (_Utils_eq(end, len)) return array;
        else {
            if (_Utils_cmp(end, $elm$core$Array$tailIndex(len)) > -1) return A4($elm$core$Array$Array_elm_builtin, end, startShift, tree, A3($elm$core$Elm$JsArray$slice, 0, $elm$core$Array$bitMask & end, tail));
            else {
                var endIdx = $elm$core$Array$tailIndex(end);
                var depth = $elm$core$Basics$floor(A2($elm$core$Basics$logBase, $elm$core$Array$branchFactor, A2($elm$core$Basics$max, 1, endIdx - 1)));
                var newShift = A2($elm$core$Basics$max, 5, depth * $elm$core$Array$shiftStep);
                return A4($elm$core$Array$Array_elm_builtin, end, newShift, A3($elm$core$Array$hoistTree, startShift, newShift, A3($elm$core$Array$sliceTree, startShift, endIdx, tree)), A4($elm$core$Array$fetchNewTail, startShift, end, endIdx, tree));
            }
        }
    });
    var $elm$core$Array$translateIndex = F2(function(index, _v0) {
        var len = _v0.a;
        var posIndex = index < 0 ? len + index : index;
        return posIndex < 0 ? 0 : _Utils_cmp(posIndex, len) > 0 ? len : posIndex;
    });
    var $elm$core$Array$slice = F3(function(from, to, array) {
        var correctTo = A2($elm$core$Array$translateIndex, to, array);
        var correctFrom = A2($elm$core$Array$translateIndex, from, array);
        return _Utils_cmp(correctFrom, correctTo) > 0 ? $elm$core$Array$empty : A2($elm$core$Array$sliceLeft, correctFrom, A2($elm$core$Array$sliceRight, correctTo, array));
    });
    var $elm$browser$Debugger$History$viewRecentSnapshots = F3(function(selectedIndex, recentMessagesNum, snapshots) {
        var messagesToFill = $elm$browser$Debugger$History$maxSnapshotSize - recentMessagesNum;
        var arrayLength = $elm$core$Array$length(snapshots);
        var snapshotsToRender = function() {
            var _v0 = _Utils_Tuple2(A2($elm$core$Array$get, arrayLength - 2, snapshots), A2($elm$core$Array$get, arrayLength - 1, snapshots));
            if (_v0.a.$ === "Just" && _v0.b.$ === "Just") {
                var fillerSnapshot = _v0.a.a;
                var recentSnapshot = _v0.b.a;
                return $elm$core$Array$fromList(_List_fromArray([
                    {
                        messages: A3($elm$core$Array$slice, 0, messagesToFill, fillerSnapshot.messages),
                        model: fillerSnapshot.model
                    },
                    recentSnapshot
                ]));
            } else return snapshots;
        }();
        var startingIndex = arrayLength * $elm$browser$Debugger$History$maxSnapshotSize - $elm$browser$Debugger$History$maxSnapshotSize - messagesToFill;
        return A3($elm$browser$Debugger$History$viewAllSnapshots, selectedIndex, startingIndex, snapshotsToRender);
    });
    var $elm$browser$Debugger$History$view = F2(function(maybeIndex, _v0) {
        var snapshots = _v0.snapshots;
        var recent = _v0.recent;
        var numMessages = _v0.numMessages;
        var recentMessageStartIndex = numMessages - recent.numMessages;
        var index = A2($elm$core$Maybe$withDefault, -1, maybeIndex);
        var newStuff = A3($elm$html$Html$Keyed$node, "div", _List_Nil, A3($elm$core$List$foldr, $elm$browser$Debugger$History$consMsg(index), _Utils_Tuple2(recentMessageStartIndex, _List_Nil), recent.messages).b);
        var onlyRenderRecentMessages = !_Utils_eq(index, -1) || $elm$core$Array$length(snapshots) < 2;
        var oldStuff = onlyRenderRecentMessages ? A4($elm$html$Html$Lazy$lazy3, $elm$browser$Debugger$History$viewAllSnapshots, index, 0, snapshots) : A4($elm$html$Html$Lazy$lazy3, $elm$browser$Debugger$History$viewRecentSnapshots, index, recent.numMessages, snapshots);
        return A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$id("elm-debugger-sidebar"),
            A2($elm$html$Html$Attributes$style, "width", "100%"),
            A2($elm$html$Html$Attributes$style, "overflow-y", "auto"),
            A2($elm$html$Html$Attributes$style, "height", "calc(100% - 72px)")
        ]), A2($elm$core$List$cons, $elm$browser$Debugger$History$styles, A2($elm$core$List$cons, newStuff, A2($elm$core$List$cons, oldStuff, onlyRenderRecentMessages ? _List_Nil : _List_fromArray([
            $elm$browser$Debugger$History$showMoreButton(numMessages)
        ])))));
    });
    var $elm$browser$Debugger$Main$SwapLayout = {
        $: "SwapLayout"
    };
    var $elm$browser$Debugger$Main$toHistoryIcon = function(layout) {
        if (layout.$ === "Horizontal") return "M13 1a3 3 0 0 1 3 3v8a3 3 0 0 1-3 3h-10a3 3 0 0 1-3-3v-8a3 3 0 0 1 3-3z M13 3h-10a1 1 0 0 0-1 1v5h12v-5a1 1 0 0 0-1-1z M14 10h-12v2a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1z";
        else return "M0 4a3 3 0 0 1 3-3h10a3 3 0 0 1 3 3v8a3 3 0 0 1-3 3h-10a3 3 0 0 1-3-3z M2 4v8a1 1 0 0 0 1 1h2v-10h-2a1 1 0 0 0-1 1z M6 3v10h7a1 1 0 0 0 1-1v-8a1 1 0 0 0-1-1z";
    };
    var $elm$browser$Debugger$Main$icon = function(path) {
        return A4($elm$virtual_dom$VirtualDom$nodeNS, "http://www.w3.org/2000/svg", "svg", _List_fromArray([
            A2($elm$virtual_dom$VirtualDom$attribute, "viewBox", "0 0 16 16"),
            A2($elm$virtual_dom$VirtualDom$attribute, "xmlns", "http://www.w3.org/2000/svg"),
            A2($elm$virtual_dom$VirtualDom$attribute, "fill", "currentColor"),
            A2($elm$virtual_dom$VirtualDom$attribute, "width", "16px"),
            A2($elm$virtual_dom$VirtualDom$attribute, "height", "16px")
        ]), _List_fromArray([
            A4($elm$virtual_dom$VirtualDom$nodeNS, "http://www.w3.org/2000/svg", "path", _List_fromArray([
                A2($elm$virtual_dom$VirtualDom$attribute, "d", path)
            ]), _List_Nil)
        ]));
    };
    var $elm$browser$Debugger$Main$viewHistoryButton = F3(function(label, msg, path) {
        return A2($elm$html$Html$button, _List_fromArray([
            A2($elm$html$Html$Attributes$style, "display", "flex"),
            A2($elm$html$Html$Attributes$style, "flex-direction", "row"),
            A2($elm$html$Html$Attributes$style, "align-items", "center"),
            A2($elm$html$Html$Attributes$style, "background", "none"),
            A2($elm$html$Html$Attributes$style, "border", "none"),
            A2($elm$html$Html$Attributes$style, "color", "inherit"),
            A2($elm$html$Html$Attributes$style, "cursor", "pointer"),
            $elm$html$Html$Events$onClick(msg)
        ]), _List_fromArray([
            $elm$browser$Debugger$Main$icon(path),
            A2($elm$html$Html$span, _List_fromArray([
                A2($elm$html$Html$Attributes$style, "padding-left", "6px")
            ]), _List_fromArray([
                $elm$html$Html$text(label)
            ]))
        ]));
    });
    var $elm$browser$Debugger$Main$viewHistoryOptions = function(layout) {
        return A2($elm$html$Html$div, _List_fromArray([
            A2($elm$html$Html$Attributes$style, "width", "100%"),
            A2($elm$html$Html$Attributes$style, "height", "36px"),
            A2($elm$html$Html$Attributes$style, "display", "flex"),
            A2($elm$html$Html$Attributes$style, "flex-direction", "row"),
            A2($elm$html$Html$Attributes$style, "align-items", "center"),
            A2($elm$html$Html$Attributes$style, "justify-content", "space-between"),
            A2($elm$html$Html$Attributes$style, "background-color", "rgb(50, 50, 50)")
        ]), _List_fromArray([
            A3($elm$browser$Debugger$Main$viewHistoryButton, "Swap Layout", $elm$browser$Debugger$Main$SwapLayout, $elm$browser$Debugger$Main$toHistoryIcon(layout)),
            A2($elm$html$Html$div, _List_fromArray([
                A2($elm$html$Html$Attributes$style, "display", "flex"),
                A2($elm$html$Html$Attributes$style, "flex-direction", "row"),
                A2($elm$html$Html$Attributes$style, "align-items", "center"),
                A2($elm$html$Html$Attributes$style, "justify-content", "space-between")
            ]), _List_fromArray([
                A3($elm$browser$Debugger$Main$viewHistoryButton, "Import", $elm$browser$Debugger$Main$Import, "M5 1a1 1 0 0 1 0 2h-2a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1a1 1 0 0 1 2 0a3 3 0 0 1-3 3h-10a3 3 0 0 1-3-3v-8a3 3 0 0 1 3-3z M10 2a1 1 0 0 0 -2 0v6a1 1 0 0 0 1 1h6a1 1 0 0 0 0-2h-3.586l4.293-4.293a1 1 0 0 0-1.414-1.414l-4.293 4.293z"),
                A3($elm$browser$Debugger$Main$viewHistoryButton, "Export", $elm$browser$Debugger$Main$Export, "M5 1a1 1 0 0 1 0 2h-2a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1 a1 1 0 0 1 2 0a3 3 0 0 1-3 3h-10a3 3 0 0 1-3-3v-8a3 3 0 0 1 3-3z M9 3a1 1 0 1 1 0-2h6a1 1 0 0 1 1 1v6a1 1 0 1 1-2 0v-3.586l-5.293 5.293 a1 1 0 0 1-1.414-1.414l5.293 -5.293z")
            ]))
        ]));
    };
    var $elm$browser$Debugger$Main$SliderJump = function(a) {
        return {
            $: "SliderJump",
            a: a
        };
    };
    var $elm$core$Basics$composeR = F3(function(f, g, x) {
        return g(f(x));
    });
    var $elm$html$Html$input = _VirtualDom_node("input");
    var $elm$browser$Debugger$Main$isPlaying = function(maybeIndex) {
        if (maybeIndex.$ === "Nothing") return true;
        else return false;
    };
    var $elm$html$Html$Attributes$max = $elm$html$Html$Attributes$stringProperty("max");
    var $elm$html$Html$Attributes$min = $elm$html$Html$Attributes$stringProperty("min");
    var $elm$html$Html$Events$alwaysStop = function(x) {
        return _Utils_Tuple2(x, true);
    };
    var $elm$virtual_dom$VirtualDom$MayStopPropagation = function(a) {
        return {
            $: "MayStopPropagation",
            a: a
        };
    };
    var $elm$html$Html$Events$stopPropagationOn = F2(function(event, decoder) {
        return A2($elm$virtual_dom$VirtualDom$on, event, $elm$virtual_dom$VirtualDom$MayStopPropagation(decoder));
    });
    var $elm$json$Json$Decode$string = _Json_decodeString;
    var $elm$html$Html$Events$targetValue = A2($elm$json$Json$Decode$at, _List_fromArray([
        "target",
        "value"
    ]), $elm$json$Json$Decode$string);
    var $elm$html$Html$Events$onInput = function(tagger) {
        return A2($elm$html$Html$Events$stopPropagationOn, "input", A2($elm$json$Json$Decode$map, $elm$html$Html$Events$alwaysStop, A2($elm$json$Json$Decode$map, tagger, $elm$html$Html$Events$targetValue)));
    };
    var $elm$core$String$toInt = _String_toInt;
    var $elm$html$Html$Attributes$type_ = $elm$html$Html$Attributes$stringProperty("type");
    var $elm$html$Html$Attributes$value = $elm$html$Html$Attributes$stringProperty("value");
    var $elm$browser$Debugger$Main$viewPlayButton = function(playing) {
        return A2($elm$html$Html$button, _List_fromArray([
            A2($elm$html$Html$Attributes$style, "background", "#1293D8"),
            A2($elm$html$Html$Attributes$style, "border", "none"),
            A2($elm$html$Html$Attributes$style, "color", "white"),
            A2($elm$html$Html$Attributes$style, "cursor", "pointer"),
            A2($elm$html$Html$Attributes$style, "width", "36px"),
            A2($elm$html$Html$Attributes$style, "height", "36px"),
            $elm$html$Html$Events$onClick($elm$browser$Debugger$Main$Resume)
        ]), _List_fromArray([
            playing ? $elm$browser$Debugger$Main$icon("M2 2h4v12h-4v-12z M10 2h4v12h-4v-12z") : $elm$browser$Debugger$Main$icon("M2 2l12 7l-12 7z")
        ]));
    };
    var $elm$browser$Debugger$Main$viewHistorySlider = F2(function(history1, maybeIndex) {
        var lastIndex = $elm$browser$Debugger$History$size(history1) - 1;
        var selectedIndex = A2($elm$core$Maybe$withDefault, lastIndex, maybeIndex);
        return A2($elm$html$Html$div, _List_fromArray([
            A2($elm$html$Html$Attributes$style, "display", "flex"),
            A2($elm$html$Html$Attributes$style, "flex-direction", "row"),
            A2($elm$html$Html$Attributes$style, "align-items", "center"),
            A2($elm$html$Html$Attributes$style, "width", "100%"),
            A2($elm$html$Html$Attributes$style, "height", "36px"),
            A2($elm$html$Html$Attributes$style, "background-color", "rgb(50, 50, 50)")
        ]), _List_fromArray([
            A2($elm$html$Html$Lazy$lazy, $elm$browser$Debugger$Main$viewPlayButton, $elm$browser$Debugger$Main$isPlaying(maybeIndex)),
            A2($elm$html$Html$input, _List_fromArray([
                $elm$html$Html$Attributes$type_("range"),
                A2($elm$html$Html$Attributes$style, "width", "calc(100% - 56px)"),
                A2($elm$html$Html$Attributes$style, "height", "36px"),
                A2($elm$html$Html$Attributes$style, "margin", "0 10px"),
                $elm$html$Html$Attributes$min("0"),
                $elm$html$Html$Attributes$max($elm$core$String$fromInt(lastIndex)),
                $elm$html$Html$Attributes$value($elm$core$String$fromInt(selectedIndex)),
                $elm$html$Html$Events$onInput(A2($elm$core$Basics$composeR, $elm$core$String$toInt, A2($elm$core$Basics$composeR, $elm$core$Maybe$withDefault(lastIndex), $elm$browser$Debugger$Main$SliderJump)))
            ]), _List_Nil)
        ]));
    });
    var $elm$browser$Debugger$Main$viewHistory = F3(function(maybeIndex, history1, layout) {
        var block = $elm$browser$Debugger$Main$toMouseBlocker(layout);
        var _v0 = $elm$browser$Debugger$Main$toHistoryPercents(layout);
        var w = _v0.a;
        var h = _v0.b;
        return A2($elm$html$Html$div, _List_fromArray([
            A2($elm$html$Html$Attributes$style, "width", w),
            A2($elm$html$Html$Attributes$style, "height", h),
            A2($elm$html$Html$Attributes$style, "display", "flex"),
            A2($elm$html$Html$Attributes$style, "flex-direction", "column"),
            A2($elm$html$Html$Attributes$style, "color", "#DDDDDD"),
            A2($elm$html$Html$Attributes$style, "background-color", "rgb(61, 61, 61)"),
            A2($elm$html$Html$Attributes$style, "pointer-events", block),
            A2($elm$html$Html$Attributes$style, "user-select", block)
        ]), _List_fromArray([
            A2($elm$browser$Debugger$Main$viewHistorySlider, history1, maybeIndex),
            A2($elm$html$Html$map, $elm$browser$Debugger$Main$Jump, A2($elm$browser$Debugger$History$view, maybeIndex, history1)),
            A2($elm$html$Html$Lazy$lazy, $elm$browser$Debugger$Main$viewHistoryOptions, layout)
        ]));
    });
    var $elm$browser$Debugger$Main$popoutView = function(model) {
        var maybeIndex = function() {
            var _v0 = model.state;
            if (_v0.$ === "Running") return $elm$core$Maybe$Nothing;
            else {
                var index = _v0.a;
                return $elm$core$Maybe$Just(index);
            }
        }();
        var historyToRender = $elm$browser$Debugger$Main$cachedHistory(model);
        return A3($elm$html$Html$node, "body", _Utils_ap($elm$browser$Debugger$Main$toDragListeners(model.layout), _List_fromArray([
            A2($elm$html$Html$Attributes$style, "margin", "0"),
            A2($elm$html$Html$Attributes$style, "padding", "0"),
            A2($elm$html$Html$Attributes$style, "width", "100%"),
            A2($elm$html$Html$Attributes$style, "height", "100%"),
            A2($elm$html$Html$Attributes$style, "font-family", "monospace"),
            A2($elm$html$Html$Attributes$style, "display", "flex"),
            A2($elm$html$Html$Attributes$style, "flex-direction", $elm$browser$Debugger$Main$toFlexDirection(model.layout))
        ])), _List_fromArray([
            A3($elm$browser$Debugger$Main$viewHistory, maybeIndex, historyToRender, model.layout),
            $elm$browser$Debugger$Main$viewDragZone(model.layout),
            A3($elm$browser$Debugger$Main$viewExpando, model.expandoMsg, model.expandoModel, model.layout)
        ]));
    };
    var $elm$browser$Debugger$Overlay$BlockAll = {
        $: "BlockAll"
    };
    var $elm$browser$Debugger$Overlay$toBlockerType = F2(function(isPaused, state) {
        switch(state.$){
            case "None":
                return isPaused ? $elm$browser$Debugger$Overlay$BlockAll : $elm$browser$Debugger$Overlay$BlockNone;
            case "BadMetadata":
                return $elm$browser$Debugger$Overlay$BlockMost;
            case "BadImport":
                return $elm$browser$Debugger$Overlay$BlockMost;
            default:
                return $elm$browser$Debugger$Overlay$BlockMost;
        }
    });
    var $elm$browser$Debugger$Main$toBlockerType = function(model) {
        return A2($elm$browser$Debugger$Overlay$toBlockerType, $elm$browser$Debugger$Main$isPaused(model.state), model.overlay);
    };
    var $elm$browser$Debugger$Main$Horizontal = F3(function(a, b, c) {
        return {
            $: "Horizontal",
            a: a,
            b: b,
            c: c
        };
    });
    var $elm$browser$Debugger$Main$Running = function(a) {
        return {
            $: "Running",
            a: a
        };
    };
    var $elm$browser$Debugger$Main$Static = {
        $: "Static"
    };
    var $elm$browser$Debugger$Metadata$Error = F2(function(message, problems) {
        return {
            message: message,
            problems: problems
        };
    });
    var $elm$json$Json$Decode$decodeValue = _Json_run;
    var $elm$browser$Debugger$Metadata$Metadata = F2(function(versions, types) {
        return {
            types: types,
            versions: versions
        };
    });
    var $elm$browser$Debugger$Metadata$Types = F3(function(message, aliases, unions) {
        return {
            aliases: aliases,
            message: message,
            unions: unions
        };
    });
    var $elm$browser$Debugger$Metadata$Alias = F2(function(args, tipe) {
        return {
            args: args,
            tipe: tipe
        };
    });
    var $elm$json$Json$Decode$list = _Json_decodeList;
    var $elm$browser$Debugger$Metadata$decodeAlias = A3($elm$json$Json$Decode$map2, $elm$browser$Debugger$Metadata$Alias, A2($elm$json$Json$Decode$field, "args", $elm$json$Json$Decode$list($elm$json$Json$Decode$string)), A2($elm$json$Json$Decode$field, "type", $elm$json$Json$Decode$string));
    var $elm$browser$Debugger$Metadata$Union = F2(function(args, tags) {
        return {
            args: args,
            tags: tags
        };
    });
    var $elm$core$Dict$fromList = function(assocs) {
        return A3($elm$core$List$foldl, F2(function(_v0, dict) {
            var key = _v0.a;
            var value = _v0.b;
            return A3($elm$core$Dict$insert, key, value, dict);
        }), $elm$core$Dict$empty, assocs);
    };
    var $elm$json$Json$Decode$keyValuePairs = _Json_decodeKeyValuePairs;
    var $elm$json$Json$Decode$dict = function(decoder) {
        return A2($elm$json$Json$Decode$map, $elm$core$Dict$fromList, $elm$json$Json$Decode$keyValuePairs(decoder));
    };
    var $elm$browser$Debugger$Metadata$decodeUnion = A3($elm$json$Json$Decode$map2, $elm$browser$Debugger$Metadata$Union, A2($elm$json$Json$Decode$field, "args", $elm$json$Json$Decode$list($elm$json$Json$Decode$string)), A2($elm$json$Json$Decode$field, "tags", $elm$json$Json$Decode$dict($elm$json$Json$Decode$list($elm$json$Json$Decode$string))));
    var $elm$json$Json$Decode$map3 = _Json_map3;
    var $elm$browser$Debugger$Metadata$decodeTypes = A4($elm$json$Json$Decode$map3, $elm$browser$Debugger$Metadata$Types, A2($elm$json$Json$Decode$field, "message", $elm$json$Json$Decode$string), A2($elm$json$Json$Decode$field, "aliases", $elm$json$Json$Decode$dict($elm$browser$Debugger$Metadata$decodeAlias)), A2($elm$json$Json$Decode$field, "unions", $elm$json$Json$Decode$dict($elm$browser$Debugger$Metadata$decodeUnion)));
    var $elm$browser$Debugger$Metadata$Versions = function(elm) {
        return {
            elm: elm
        };
    };
    var $elm$browser$Debugger$Metadata$decodeVersions = A2($elm$json$Json$Decode$map, $elm$browser$Debugger$Metadata$Versions, A2($elm$json$Json$Decode$field, "elm", $elm$json$Json$Decode$string));
    var $elm$browser$Debugger$Metadata$decoder = A3($elm$json$Json$Decode$map2, $elm$browser$Debugger$Metadata$Metadata, A2($elm$json$Json$Decode$field, "versions", $elm$browser$Debugger$Metadata$decodeVersions), A2($elm$json$Json$Decode$field, "types", $elm$browser$Debugger$Metadata$decodeTypes));
    var $elm$browser$Debugger$Metadata$ProblemType = F2(function(name, problems) {
        return {
            name: name,
            problems: problems
        };
    });
    var $elm$core$List$maybeCons = F3(function(f, mx, xs) {
        var _v0 = f(mx);
        if (_v0.$ === "Just") {
            var x = _v0.a;
            return A2($elm$core$List$cons, x, xs);
        } else return xs;
    });
    var $elm$core$List$filterMap = F2(function(f, xs) {
        return A3($elm$core$List$foldr, $elm$core$List$maybeCons(f), _List_Nil, xs);
    });
    var $elm$core$String$contains = _String_contains;
    var $elm$browser$Debugger$Metadata$hasProblem = F2(function(tipe, _v0) {
        var problem = _v0.a;
        var token = _v0.b;
        return A2($elm$core$String$contains, token, tipe) ? $elm$core$Maybe$Just(problem) : $elm$core$Maybe$Nothing;
    });
    var $elm$browser$Debugger$Metadata$Decoder = {
        $: "Decoder"
    };
    var $elm$browser$Debugger$Metadata$Function = {
        $: "Function"
    };
    var $elm$browser$Debugger$Metadata$Process = {
        $: "Process"
    };
    var $elm$browser$Debugger$Metadata$Program = {
        $: "Program"
    };
    var $elm$browser$Debugger$Metadata$Request = {
        $: "Request"
    };
    var $elm$browser$Debugger$Metadata$Socket = {
        $: "Socket"
    };
    var $elm$browser$Debugger$Metadata$Task = {
        $: "Task"
    };
    var $elm$browser$Debugger$Metadata$VirtualDom = {
        $: "VirtualDom"
    };
    var $elm$browser$Debugger$Metadata$problemTable = _List_fromArray([
        _Utils_Tuple2($elm$browser$Debugger$Metadata$Function, "->"),
        _Utils_Tuple2($elm$browser$Debugger$Metadata$Decoder, "Json.Decode.Decoder"),
        _Utils_Tuple2($elm$browser$Debugger$Metadata$Task, "Task.Task"),
        _Utils_Tuple2($elm$browser$Debugger$Metadata$Process, "Process.Id"),
        _Utils_Tuple2($elm$browser$Debugger$Metadata$Socket, "WebSocket.LowLevel.WebSocket"),
        _Utils_Tuple2($elm$browser$Debugger$Metadata$Request, "Http.Request"),
        _Utils_Tuple2($elm$browser$Debugger$Metadata$Program, "Platform.Program"),
        _Utils_Tuple2($elm$browser$Debugger$Metadata$VirtualDom, "VirtualDom.Node"),
        _Utils_Tuple2($elm$browser$Debugger$Metadata$VirtualDom, "VirtualDom.Attribute")
    ]);
    var $elm$browser$Debugger$Metadata$findProblems = function(tipe) {
        return A2($elm$core$List$filterMap, $elm$browser$Debugger$Metadata$hasProblem(tipe), $elm$browser$Debugger$Metadata$problemTable);
    };
    var $elm$browser$Debugger$Metadata$collectBadAliases = F3(function(name, _v0, list) {
        var tipe = _v0.tipe;
        var _v1 = $elm$browser$Debugger$Metadata$findProblems(tipe);
        if (!_v1.b) return list;
        else {
            var problems = _v1;
            return A2($elm$core$List$cons, A2($elm$browser$Debugger$Metadata$ProblemType, name, problems), list);
        }
    });
    var $elm$core$List$append = F2(function(xs, ys) {
        if (!ys.b) return xs;
        else return A3($elm$core$List$foldr, $elm$core$List$cons, ys, xs);
    });
    var $elm$core$List$concat = function(lists) {
        return A3($elm$core$List$foldr, $elm$core$List$append, _List_Nil, lists);
    };
    var $elm$core$List$concatMap = F2(function(f, list) {
        return $elm$core$List$concat(A2($elm$core$List$map, f, list));
    });
    var $elm$core$Dict$values = function(dict) {
        return A3($elm$core$Dict$foldr, F3(function(key, value, valueList) {
            return A2($elm$core$List$cons, value, valueList);
        }), _List_Nil, dict);
    };
    var $elm$browser$Debugger$Metadata$collectBadUnions = F3(function(name, _v0, list) {
        var tags = _v0.tags;
        var _v1 = A2($elm$core$List$concatMap, $elm$browser$Debugger$Metadata$findProblems, $elm$core$List$concat($elm$core$Dict$values(tags)));
        if (!_v1.b) return list;
        else {
            var problems = _v1;
            return A2($elm$core$List$cons, A2($elm$browser$Debugger$Metadata$ProblemType, name, problems), list);
        }
    });
    var $elm$core$Dict$foldl = F3(function(func, acc, dict) {
        foldl: while(true){
            if (dict.$ === "RBEmpty_elm_builtin") return acc;
            else {
                var key = dict.b;
                var value = dict.c;
                var left = dict.d;
                var right = dict.e;
                var $temp$func = func, $temp$acc = A3(func, key, value, A3($elm$core$Dict$foldl, func, acc, left)), $temp$dict = right;
                func = $temp$func;
                acc = $temp$acc;
                dict = $temp$dict;
                continue foldl;
            }
        }
    });
    var $elm$browser$Debugger$Metadata$isPortable = function(_v0) {
        var types = _v0.types;
        var badAliases = A3($elm$core$Dict$foldl, $elm$browser$Debugger$Metadata$collectBadAliases, _List_Nil, types.aliases);
        var _v1 = A3($elm$core$Dict$foldl, $elm$browser$Debugger$Metadata$collectBadUnions, badAliases, types.unions);
        if (!_v1.b) return $elm$core$Maybe$Nothing;
        else {
            var problems = _v1;
            return $elm$core$Maybe$Just(A2($elm$browser$Debugger$Metadata$Error, types.message, problems));
        }
    };
    var $elm$browser$Debugger$Metadata$decode = function(value) {
        var _v0 = A2($elm$json$Json$Decode$decodeValue, $elm$browser$Debugger$Metadata$decoder, value);
        if (_v0.$ === "Err") return $elm$core$Result$Err(A2($elm$browser$Debugger$Metadata$Error, "The compiler is generating bad metadata. This is a compiler bug!", _List_Nil));
        else {
            var metadata = _v0.a;
            var _v1 = $elm$browser$Debugger$Metadata$isPortable(metadata);
            if (_v1.$ === "Nothing") return $elm$core$Result$Ok(metadata);
            else {
                var error = _v1.a;
                return $elm$core$Result$Err(error);
            }
        }
    };
    var $elm$browser$Debugger$History$History = F3(function(snapshots, recent, numMessages) {
        return {
            numMessages: numMessages,
            recent: recent,
            snapshots: snapshots
        };
    });
    var $elm$browser$Debugger$History$RecentHistory = F3(function(model, messages, numMessages) {
        return {
            messages: messages,
            model: model,
            numMessages: numMessages
        };
    });
    var $elm$browser$Debugger$History$empty = function(model) {
        return A3($elm$browser$Debugger$History$History, $elm$core$Array$empty, A3($elm$browser$Debugger$History$RecentHistory, model, _List_Nil, 0), 0);
    };
    var $elm$core$Dict$map = F2(function(func, dict) {
        if (dict.$ === "RBEmpty_elm_builtin") return $elm$core$Dict$RBEmpty_elm_builtin;
        else {
            var color = dict.a;
            var key = dict.b;
            var value = dict.c;
            var left = dict.d;
            var right = dict.e;
            return A5($elm$core$Dict$RBNode_elm_builtin, color, key, A2(func, key, value), A2($elm$core$Dict$map, func, left), A2($elm$core$Dict$map, func, right));
        }
    });
    var $elm$core$Dict$sizeHelp = F2(function(n, dict) {
        sizeHelp: while(true){
            if (dict.$ === "RBEmpty_elm_builtin") return n;
            else {
                var left = dict.d;
                var right = dict.e;
                var $temp$n = A2($elm$core$Dict$sizeHelp, n + 1, right), $temp$dict = left;
                n = $temp$n;
                dict = $temp$dict;
                continue sizeHelp;
            }
        }
    });
    var $elm$core$Dict$size = function(dict) {
        return A2($elm$core$Dict$sizeHelp, 0, dict);
    };
    var $elm$browser$Debugger$Expando$initHelp = F2(function(isOuter, expando) {
        switch(expando.$){
            case "S":
                return expando;
            case "Primitive":
                return expando;
            case "Sequence":
                var seqType = expando.a;
                var isClosed = expando.b;
                var items = expando.c;
                return isOuter ? A3($elm$browser$Debugger$Expando$Sequence, seqType, false, A2($elm$core$List$map, $elm$browser$Debugger$Expando$initHelp(false), items)) : $elm$core$List$length(items) <= 8 ? A3($elm$browser$Debugger$Expando$Sequence, seqType, false, items) : expando;
            case "Dictionary":
                var isClosed = expando.a;
                var keyValuePairs = expando.b;
                return isOuter ? A2($elm$browser$Debugger$Expando$Dictionary, false, A2($elm$core$List$map, function(_v1) {
                    var k = _v1.a;
                    var v = _v1.b;
                    return _Utils_Tuple2(k, A2($elm$browser$Debugger$Expando$initHelp, false, v));
                }, keyValuePairs)) : $elm$core$List$length(keyValuePairs) <= 8 ? A2($elm$browser$Debugger$Expando$Dictionary, false, keyValuePairs) : expando;
            case "Record":
                var isClosed = expando.a;
                var entries = expando.b;
                return isOuter ? A2($elm$browser$Debugger$Expando$Record, false, A2($elm$core$Dict$map, F2(function(_v2, v) {
                    return A2($elm$browser$Debugger$Expando$initHelp, false, v);
                }), entries)) : $elm$core$Dict$size(entries) <= 4 ? A2($elm$browser$Debugger$Expando$Record, false, entries) : expando;
            default:
                var maybeName = expando.a;
                var isClosed = expando.b;
                var args = expando.c;
                return isOuter ? A3($elm$browser$Debugger$Expando$Constructor, maybeName, false, A2($elm$core$List$map, $elm$browser$Debugger$Expando$initHelp(false), args)) : $elm$core$List$length(args) <= 4 ? A3($elm$browser$Debugger$Expando$Constructor, maybeName, false, args) : expando;
        }
    });
    var $elm$browser$Debugger$Expando$init = function(value) {
        return A2($elm$browser$Debugger$Expando$initHelp, true, _Debugger_init(value));
    };
    var $elm$core$Platform$Cmd$map = _Platform_map;
    var $elm$browser$Debugger$Overlay$None = {
        $: "None"
    };
    var $elm$browser$Debugger$Overlay$none = $elm$browser$Debugger$Overlay$None;
    var $elm$browser$Debugger$Main$wrapInit = F4(function(metadata, popout, init, flags) {
        var _v0 = init(flags);
        var userModel = _v0.a;
        var userCommands = _v0.b;
        return _Utils_Tuple2({
            expandoModel: $elm$browser$Debugger$Expando$init(userModel),
            expandoMsg: $elm$browser$Debugger$Expando$init(_Utils_Tuple0),
            history: $elm$browser$Debugger$History$empty(userModel),
            layout: A3($elm$browser$Debugger$Main$Horizontal, $elm$browser$Debugger$Main$Static, 0.3, 0.5),
            metadata: $elm$browser$Debugger$Metadata$decode(metadata),
            overlay: $elm$browser$Debugger$Overlay$none,
            popout: popout,
            state: $elm$browser$Debugger$Main$Running(userModel)
        }, A2($elm$core$Platform$Cmd$map, $elm$browser$Debugger$Main$UserMsg, userCommands));
    });
    var $elm$browser$Debugger$Main$getLatestModel = function(state) {
        if (state.$ === "Running") {
            var model = state.a;
            return model;
        } else {
            var model = state.c;
            return model;
        }
    };
    var $elm$core$Platform$Sub$map = _Platform_map;
    var $elm$browser$Debugger$Main$wrapSubs = F2(function(subscriptions, model) {
        return A2($elm$core$Platform$Sub$map, $elm$browser$Debugger$Main$UserMsg, subscriptions($elm$browser$Debugger$Main$getLatestModel(model.state)));
    });
    var $elm$browser$Debugger$Main$Moving = {
        $: "Moving"
    };
    var $elm$browser$Debugger$Main$Paused = F5(function(a, b, c, d, e) {
        return {
            $: "Paused",
            a: a,
            b: b,
            c: c,
            d: d,
            e: e
        };
    });
    var $elm$browser$Debugger$History$Snapshot = F2(function(model, messages) {
        return {
            messages: messages,
            model: model
        };
    });
    var $elm$browser$Debugger$History$addRecent = F3(function(msg, newModel, _v0) {
        var model = _v0.model;
        var messages = _v0.messages;
        var numMessages = _v0.numMessages;
        return _Utils_eq(numMessages, $elm$browser$Debugger$History$maxSnapshotSize) ? _Utils_Tuple2($elm$core$Maybe$Just(A2($elm$browser$Debugger$History$Snapshot, model, $elm$core$Array$fromList(messages))), A3($elm$browser$Debugger$History$RecentHistory, newModel, _List_fromArray([
            msg
        ]), 1)) : _Utils_Tuple2($elm$core$Maybe$Nothing, A3($elm$browser$Debugger$History$RecentHistory, model, A2($elm$core$List$cons, msg, messages), numMessages + 1));
    });
    var $elm$core$Elm$JsArray$push = _JsArray_push;
    var $elm$core$Elm$JsArray$singleton = _JsArray_singleton;
    var $elm$core$Array$insertTailInTree = F4(function(shift, index, tail, tree) {
        var pos = $elm$core$Array$bitMask & index >>> shift;
        if (_Utils_cmp(pos, $elm$core$Elm$JsArray$length(tree)) > -1) {
            if (shift === 5) return A2($elm$core$Elm$JsArray$push, $elm$core$Array$Leaf(tail), tree);
            else {
                var newSub = $elm$core$Array$SubTree(A4($elm$core$Array$insertTailInTree, shift - $elm$core$Array$shiftStep, index, tail, $elm$core$Elm$JsArray$empty));
                return A2($elm$core$Elm$JsArray$push, newSub, tree);
            }
        } else {
            var value = A2($elm$core$Elm$JsArray$unsafeGet, pos, tree);
            if (value.$ === "SubTree") {
                var subTree = value.a;
                var newSub = $elm$core$Array$SubTree(A4($elm$core$Array$insertTailInTree, shift - $elm$core$Array$shiftStep, index, tail, subTree));
                return A3($elm$core$Elm$JsArray$unsafeSet, pos, newSub, tree);
            } else {
                var newSub = $elm$core$Array$SubTree(A4($elm$core$Array$insertTailInTree, shift - $elm$core$Array$shiftStep, index, tail, $elm$core$Elm$JsArray$singleton(value)));
                return A3($elm$core$Elm$JsArray$unsafeSet, pos, newSub, tree);
            }
        }
    });
    var $elm$core$Array$unsafeReplaceTail = F2(function(newTail, _v0) {
        var len = _v0.a;
        var startShift = _v0.b;
        var tree = _v0.c;
        var tail = _v0.d;
        var originalTailLen = $elm$core$Elm$JsArray$length(tail);
        var newTailLen = $elm$core$Elm$JsArray$length(newTail);
        var newArrayLen = len + (newTailLen - originalTailLen);
        if (_Utils_eq(newTailLen, $elm$core$Array$branchFactor)) {
            var overflow = _Utils_cmp(newArrayLen >>> $elm$core$Array$shiftStep, 1 << startShift) > 0;
            if (overflow) {
                var newShift = startShift + $elm$core$Array$shiftStep;
                var newTree = A4($elm$core$Array$insertTailInTree, newShift, len, newTail, $elm$core$Elm$JsArray$singleton($elm$core$Array$SubTree(tree)));
                return A4($elm$core$Array$Array_elm_builtin, newArrayLen, newShift, newTree, $elm$core$Elm$JsArray$empty);
            } else return A4($elm$core$Array$Array_elm_builtin, newArrayLen, startShift, A4($elm$core$Array$insertTailInTree, startShift, len, newTail, tree), $elm$core$Elm$JsArray$empty);
        } else return A4($elm$core$Array$Array_elm_builtin, newArrayLen, startShift, tree, newTail);
    });
    var $elm$core$Array$push = F2(function(a, array) {
        var tail = array.d;
        return A2($elm$core$Array$unsafeReplaceTail, A2($elm$core$Elm$JsArray$push, a, tail), array);
    });
    var $elm$browser$Debugger$History$add = F3(function(msg, model, _v0) {
        var snapshots = _v0.snapshots;
        var recent = _v0.recent;
        var numMessages = _v0.numMessages;
        var _v1 = A3($elm$browser$Debugger$History$addRecent, msg, model, recent);
        if (_v1.a.$ === "Just") {
            var snapshot = _v1.a.a;
            var newRecent = _v1.b;
            return A3($elm$browser$Debugger$History$History, A2($elm$core$Array$push, snapshot, snapshots), newRecent, numMessages + 1);
        } else {
            var _v2 = _v1.a;
            var newRecent = _v1.b;
            return A3($elm$browser$Debugger$History$History, snapshots, newRecent, numMessages + 1);
        }
    });
    var $elm$core$Basics$always = F2(function(a, _v0) {
        return a;
    });
    var $elm$browser$Debugger$Overlay$BadImport = function(a) {
        return {
            $: "BadImport",
            a: a
        };
    };
    var $elm$browser$Debugger$Overlay$RiskyImport = F2(function(a, b) {
        return {
            $: "RiskyImport",
            a: a,
            b: b
        };
    });
    var $elm$browser$Debugger$Report$VersionChanged = F2(function(a, b) {
        return {
            $: "VersionChanged",
            a: a,
            b: b
        };
    });
    var $elm$browser$Debugger$Report$MessageChanged = F2(function(a, b) {
        return {
            $: "MessageChanged",
            a: a,
            b: b
        };
    });
    var $elm$browser$Debugger$Report$SomethingChanged = function(a) {
        return {
            $: "SomethingChanged",
            a: a
        };
    };
    var $elm$browser$Debugger$Report$AliasChange = function(a) {
        return {
            $: "AliasChange",
            a: a
        };
    };
    var $elm$browser$Debugger$Metadata$checkAlias = F4(function(name, old, _new, changes) {
        return _Utils_eq(old.tipe, _new.tipe) && _Utils_eq(old.args, _new.args) ? changes : A2($elm$core$List$cons, $elm$browser$Debugger$Report$AliasChange(name), changes);
    });
    var $elm$browser$Debugger$Report$UnionChange = F2(function(a, b) {
        return {
            $: "UnionChange",
            a: a,
            b: b
        };
    });
    var $elm$browser$Debugger$Metadata$addTag = F3(function(tag, _v0, changes) {
        return _Utils_update(changes, {
            added: A2($elm$core$List$cons, tag, changes.added)
        });
    });
    var $elm$browser$Debugger$Metadata$checkTag = F4(function(tag, old, _new, changes) {
        return _Utils_eq(old, _new) ? changes : _Utils_update(changes, {
            changed: A2($elm$core$List$cons, tag, changes.changed)
        });
    });
    var $elm$browser$Debugger$Report$TagChanges = F4(function(removed, changed, added, argsMatch) {
        return {
            added: added,
            argsMatch: argsMatch,
            changed: changed,
            removed: removed
        };
    });
    var $elm$browser$Debugger$Report$emptyTagChanges = function(argsMatch) {
        return A4($elm$browser$Debugger$Report$TagChanges, _List_Nil, _List_Nil, _List_Nil, argsMatch);
    };
    var $elm$browser$Debugger$Report$hasTagChanges = function(tagChanges) {
        return _Utils_eq(tagChanges, A4($elm$browser$Debugger$Report$TagChanges, _List_Nil, _List_Nil, _List_Nil, true));
    };
    var $elm$core$Dict$merge = F6(function(leftStep, bothStep, rightStep, leftDict, rightDict, initialResult) {
        var stepState = F3(function(rKey, rValue, _v0) {
            stepState: while(true){
                var list = _v0.a;
                var result = _v0.b;
                if (!list.b) return _Utils_Tuple2(list, A3(rightStep, rKey, rValue, result));
                else {
                    var _v2 = list.a;
                    var lKey = _v2.a;
                    var lValue = _v2.b;
                    var rest = list.b;
                    if (_Utils_cmp(lKey, rKey) < 0) {
                        var $temp$rKey = rKey, $temp$rValue = rValue, $temp$_v0 = _Utils_Tuple2(rest, A3(leftStep, lKey, lValue, result));
                        rKey = $temp$rKey;
                        rValue = $temp$rValue;
                        _v0 = $temp$_v0;
                        continue stepState;
                    } else {
                        if (_Utils_cmp(lKey, rKey) > 0) return _Utils_Tuple2(list, A3(rightStep, rKey, rValue, result));
                        else return _Utils_Tuple2(rest, A4(bothStep, lKey, lValue, rValue, result));
                    }
                }
            }
        });
        var _v3 = A3($elm$core$Dict$foldl, stepState, _Utils_Tuple2($elm$core$Dict$toList(leftDict), initialResult), rightDict);
        var leftovers = _v3.a;
        var intermediateResult = _v3.b;
        return A3($elm$core$List$foldl, F2(function(_v4, result) {
            var k = _v4.a;
            var v = _v4.b;
            return A3(leftStep, k, v, result);
        }), intermediateResult, leftovers);
    });
    var $elm$browser$Debugger$Metadata$removeTag = F3(function(tag, _v0, changes) {
        return _Utils_update(changes, {
            removed: A2($elm$core$List$cons, tag, changes.removed)
        });
    });
    var $elm$browser$Debugger$Metadata$checkUnion = F4(function(name, old, _new, changes) {
        var tagChanges = A6($elm$core$Dict$merge, $elm$browser$Debugger$Metadata$removeTag, $elm$browser$Debugger$Metadata$checkTag, $elm$browser$Debugger$Metadata$addTag, old.tags, _new.tags, $elm$browser$Debugger$Report$emptyTagChanges(_Utils_eq(old.args, _new.args)));
        return $elm$browser$Debugger$Report$hasTagChanges(tagChanges) ? changes : A2($elm$core$List$cons, A2($elm$browser$Debugger$Report$UnionChange, name, tagChanges), changes);
    });
    var $elm$browser$Debugger$Metadata$ignore = F3(function(key, value, report) {
        return report;
    });
    var $elm$browser$Debugger$Metadata$checkTypes = F2(function(old, _new) {
        return !_Utils_eq(old.message, _new.message) ? A2($elm$browser$Debugger$Report$MessageChanged, old.message, _new.message) : $elm$browser$Debugger$Report$SomethingChanged(A6($elm$core$Dict$merge, $elm$browser$Debugger$Metadata$ignore, $elm$browser$Debugger$Metadata$checkUnion, $elm$browser$Debugger$Metadata$ignore, old.unions, _new.unions, A6($elm$core$Dict$merge, $elm$browser$Debugger$Metadata$ignore, $elm$browser$Debugger$Metadata$checkAlias, $elm$browser$Debugger$Metadata$ignore, old.aliases, _new.aliases, _List_Nil)));
    });
    var $elm$browser$Debugger$Metadata$check = F2(function(old, _new) {
        return !_Utils_eq(old.versions.elm, _new.versions.elm) ? A2($elm$browser$Debugger$Report$VersionChanged, old.versions.elm, _new.versions.elm) : A2($elm$browser$Debugger$Metadata$checkTypes, old.types, _new.types);
    });
    var $elm$browser$Debugger$Report$CorruptHistory = {
        $: "CorruptHistory"
    };
    var $elm$browser$Debugger$Overlay$corruptImport = $elm$browser$Debugger$Overlay$BadImport($elm$browser$Debugger$Report$CorruptHistory);
    var $elm$json$Json$Decode$decodeString = _Json_runOnString;
    var $elm$browser$Debugger$Report$Fine = {
        $: "Fine"
    };
    var $elm$browser$Debugger$Report$Impossible = {
        $: "Impossible"
    };
    var $elm$browser$Debugger$Report$Risky = {
        $: "Risky"
    };
    var $elm$core$Basics$not = _Basics_not;
    var $elm$core$List$isEmpty = function(xs) {
        if (!xs.b) return true;
        else return false;
    };
    var $elm$browser$Debugger$Report$some = function(list) {
        return !$elm$core$List$isEmpty(list);
    };
    var $elm$browser$Debugger$Report$evaluateChange = function(change) {
        if (change.$ === "AliasChange") return $elm$browser$Debugger$Report$Impossible;
        else {
            var removed = change.b.removed;
            var changed = change.b.changed;
            var added = change.b.added;
            var argsMatch = change.b.argsMatch;
            return !argsMatch || $elm$browser$Debugger$Report$some(changed) || $elm$browser$Debugger$Report$some(removed) ? $elm$browser$Debugger$Report$Impossible : $elm$browser$Debugger$Report$some(added) ? $elm$browser$Debugger$Report$Risky : $elm$browser$Debugger$Report$Fine;
        }
    };
    var $elm$browser$Debugger$Report$worstCase = F2(function(status, statusList) {
        worstCase: while(true){
            if (!statusList.b) return status;
            else switch(statusList.a.$){
                case "Impossible":
                    var _v1 = statusList.a;
                    return $elm$browser$Debugger$Report$Impossible;
                case "Risky":
                    var _v2 = statusList.a;
                    var rest = statusList.b;
                    var $temp$status = $elm$browser$Debugger$Report$Risky, $temp$statusList = rest;
                    status = $temp$status;
                    statusList = $temp$statusList;
                    continue worstCase;
                default:
                    var _v3 = statusList.a;
                    var rest = statusList.b;
                    var $temp$status = status, $temp$statusList = rest;
                    status = $temp$status;
                    statusList = $temp$statusList;
                    continue worstCase;
            }
        }
    });
    var $elm$browser$Debugger$Report$evaluate = function(report) {
        switch(report.$){
            case "CorruptHistory":
                return $elm$browser$Debugger$Report$Impossible;
            case "VersionChanged":
                return $elm$browser$Debugger$Report$Impossible;
            case "MessageChanged":
                return $elm$browser$Debugger$Report$Impossible;
            default:
                var changes = report.a;
                return A2($elm$browser$Debugger$Report$worstCase, $elm$browser$Debugger$Report$Fine, A2($elm$core$List$map, $elm$browser$Debugger$Report$evaluateChange, changes));
        }
    };
    var $elm$json$Json$Decode$value = _Json_decodeValue;
    var $elm$browser$Debugger$Overlay$uploadDecoder = A3($elm$json$Json$Decode$map2, F2(function(x, y) {
        return _Utils_Tuple2(x, y);
    }), A2($elm$json$Json$Decode$field, "metadata", $elm$browser$Debugger$Metadata$decoder), A2($elm$json$Json$Decode$field, "history", $elm$json$Json$Decode$value));
    var $elm$browser$Debugger$Overlay$assessImport = F2(function(metadata, jsonString) {
        var _v0 = A2($elm$json$Json$Decode$decodeString, $elm$browser$Debugger$Overlay$uploadDecoder, jsonString);
        if (_v0.$ === "Err") return $elm$core$Result$Err($elm$browser$Debugger$Overlay$corruptImport);
        else {
            var _v1 = _v0.a;
            var foreignMetadata = _v1.a;
            var rawHistory = _v1.b;
            var report = A2($elm$browser$Debugger$Metadata$check, foreignMetadata, metadata);
            var _v2 = $elm$browser$Debugger$Report$evaluate(report);
            switch(_v2.$){
                case "Impossible":
                    return $elm$core$Result$Err($elm$browser$Debugger$Overlay$BadImport(report));
                case "Risky":
                    return $elm$core$Result$Err(A2($elm$browser$Debugger$Overlay$RiskyImport, report, rawHistory));
                default:
                    return $elm$core$Result$Ok(rawHistory);
            }
        }
    });
    var $elm$core$Platform$Cmd$batch = _Platform_batch;
    var $elm$browser$Debugger$Overlay$close = F2(function(msg, state) {
        switch(state.$){
            case "None":
                return $elm$core$Maybe$Nothing;
            case "BadMetadata":
                return $elm$core$Maybe$Nothing;
            case "BadImport":
                return $elm$core$Maybe$Nothing;
            default:
                var rawHistory = state.b;
                if (msg.$ === "Cancel") return $elm$core$Maybe$Nothing;
                else return $elm$core$Maybe$Just(rawHistory);
        }
    });
    var $elm$browser$Debugger$History$elmToJs = A2($elm$core$Basics$composeR, _Json_wrap, _Debugger_unsafeCoerce);
    var $elm$browser$Debugger$History$encodeHelp = F2(function(snapshot, allMessages) {
        return A3($elm$core$Array$foldl, $elm$core$List$cons, allMessages, snapshot.messages);
    });
    var $elm$json$Json$Encode$list = F2(function(func, entries) {
        return _Json_wrap(A3($elm$core$List$foldl, _Json_addEntry(func), _Json_emptyArray(_Utils_Tuple0), entries));
    });
    var $elm$browser$Debugger$History$encode = function(_v0) {
        var snapshots = _v0.snapshots;
        var recent = _v0.recent;
        return A2($elm$json$Json$Encode$list, $elm$browser$Debugger$History$elmToJs, A3($elm$core$Array$foldr, $elm$browser$Debugger$History$encodeHelp, $elm$core$List$reverse(recent.messages), snapshots));
    };
    var $elm$json$Json$Encode$object = function(pairs) {
        return _Json_wrap(A3($elm$core$List$foldl, F2(function(_v0, obj) {
            var k = _v0.a;
            var v = _v0.b;
            return A3(_Json_addField, k, v, obj);
        }), _Json_emptyObject(_Utils_Tuple0), pairs));
    };
    var $elm$browser$Debugger$Metadata$encodeAlias = function(_v0) {
        var args = _v0.args;
        var tipe = _v0.tipe;
        return $elm$json$Json$Encode$object(_List_fromArray([
            _Utils_Tuple2("args", A2($elm$json$Json$Encode$list, $elm$json$Json$Encode$string, args)),
            _Utils_Tuple2("type", $elm$json$Json$Encode$string(tipe))
        ]));
    };
    var $elm$browser$Debugger$Metadata$encodeDict = F2(function(f, dict) {
        return $elm$json$Json$Encode$object($elm$core$Dict$toList(A2($elm$core$Dict$map, F2(function(key, value) {
            return f(value);
        }), dict)));
    });
    var $elm$browser$Debugger$Metadata$encodeUnion = function(_v0) {
        var args = _v0.args;
        var tags = _v0.tags;
        return $elm$json$Json$Encode$object(_List_fromArray([
            _Utils_Tuple2("args", A2($elm$json$Json$Encode$list, $elm$json$Json$Encode$string, args)),
            _Utils_Tuple2("tags", A2($elm$browser$Debugger$Metadata$encodeDict, $elm$json$Json$Encode$list($elm$json$Json$Encode$string), tags))
        ]));
    };
    var $elm$browser$Debugger$Metadata$encodeTypes = function(_v0) {
        var message = _v0.message;
        var unions = _v0.unions;
        var aliases = _v0.aliases;
        return $elm$json$Json$Encode$object(_List_fromArray([
            _Utils_Tuple2("message", $elm$json$Json$Encode$string(message)),
            _Utils_Tuple2("aliases", A2($elm$browser$Debugger$Metadata$encodeDict, $elm$browser$Debugger$Metadata$encodeAlias, aliases)),
            _Utils_Tuple2("unions", A2($elm$browser$Debugger$Metadata$encodeDict, $elm$browser$Debugger$Metadata$encodeUnion, unions))
        ]));
    };
    var $elm$browser$Debugger$Metadata$encodeVersions = function(_v0) {
        var elm = _v0.elm;
        return $elm$json$Json$Encode$object(_List_fromArray([
            _Utils_Tuple2("elm", $elm$json$Json$Encode$string(elm))
        ]));
    };
    var $elm$browser$Debugger$Metadata$encode = function(_v0) {
        var versions = _v0.versions;
        var types = _v0.types;
        return $elm$json$Json$Encode$object(_List_fromArray([
            _Utils_Tuple2("versions", $elm$browser$Debugger$Metadata$encodeVersions(versions)),
            _Utils_Tuple2("types", $elm$browser$Debugger$Metadata$encodeTypes(types))
        ]));
    };
    var $elm$core$Basics$identity = function(x) {
        return x;
    };
    var $elm$core$Task$Perform = function(a) {
        return {
            $: "Perform",
            a: a
        };
    };
    var $elm$core$Task$succeed = _Scheduler_succeed;
    var $elm$core$Task$init = $elm$core$Task$succeed(_Utils_Tuple0);
    var $elm$core$Task$andThen = _Scheduler_andThen;
    var $elm$core$Task$map = F2(function(func, taskA) {
        return A2($elm$core$Task$andThen, function(a) {
            return $elm$core$Task$succeed(func(a));
        }, taskA);
    });
    var $elm$core$Task$map2 = F3(function(func, taskA, taskB) {
        return A2($elm$core$Task$andThen, function(a) {
            return A2($elm$core$Task$andThen, function(b) {
                return $elm$core$Task$succeed(A2(func, a, b));
            }, taskB);
        }, taskA);
    });
    var $elm$core$Task$sequence = function(tasks) {
        return A3($elm$core$List$foldr, $elm$core$Task$map2($elm$core$List$cons), $elm$core$Task$succeed(_List_Nil), tasks);
    };
    var $elm$core$Platform$sendToApp = _Platform_sendToApp;
    var $elm$core$Task$spawnCmd = F2(function(router, _v0) {
        var task = _v0.a;
        return _Scheduler_spawn(A2($elm$core$Task$andThen, $elm$core$Platform$sendToApp(router), task));
    });
    var $elm$core$Task$onEffects = F3(function(router, commands, state) {
        return A2($elm$core$Task$map, function(_v0) {
            return _Utils_Tuple0;
        }, $elm$core$Task$sequence(A2($elm$core$List$map, $elm$core$Task$spawnCmd(router), commands)));
    });
    var $elm$core$Task$onSelfMsg = F3(function(_v0, _v1, _v2) {
        return $elm$core$Task$succeed(_Utils_Tuple0);
    });
    var $elm$core$Task$cmdMap = F2(function(tagger, _v0) {
        var task = _v0.a;
        return $elm$core$Task$Perform(A2($elm$core$Task$map, tagger, task));
    });
    _Platform_effectManagers["Task"] = _Platform_createManager($elm$core$Task$init, $elm$core$Task$onEffects, $elm$core$Task$onSelfMsg, $elm$core$Task$cmdMap);
    var $elm$core$Task$command = _Platform_leaf("Task");
    var $elm$core$Task$perform = F2(function(toMessage, task) {
        return $elm$core$Task$command($elm$core$Task$Perform(A2($elm$core$Task$map, toMessage, task)));
    });
    var $elm$browser$Debugger$Main$download = F2(function(metadata, history1) {
        var historyLength = $elm$browser$Debugger$History$size(history1);
        return A2($elm$core$Task$perform, function(_v0) {
            return $elm$browser$Debugger$Main$NoOp;
        }, A2(_Debugger_download, historyLength, _Json_unwrap($elm$json$Json$Encode$object(_List_fromArray([
            _Utils_Tuple2("metadata", $elm$browser$Debugger$Metadata$encode(metadata)),
            _Utils_Tuple2("history", $elm$browser$Debugger$History$encode(history1))
        ])))));
    });
    var $elm$browser$Debugger$Main$Vertical = F3(function(a, b, c) {
        return {
            $: "Vertical",
            a: a,
            b: b,
            c: c
        };
    });
    var $elm$browser$Debugger$Main$drag = F2(function(info, layout) {
        if (layout.$ === "Horizontal") {
            var status = layout.a;
            var y = layout.c;
            return A3($elm$browser$Debugger$Main$Horizontal, status, info.x / info.width, y);
        } else {
            var status = layout.a;
            var x = layout.b;
            return A3($elm$browser$Debugger$Main$Vertical, status, x, info.y / info.height);
        }
    });
    var $elm$browser$Debugger$History$Stepping = F2(function(a, b) {
        return {
            $: "Stepping",
            a: a,
            b: b
        };
    });
    var $elm$browser$Debugger$History$Done = F2(function(a, b) {
        return {
            $: "Done",
            a: a,
            b: b
        };
    });
    var $elm$browser$Debugger$History$getHelp = F3(function(update, msg, getResult) {
        if (getResult.$ === "Done") return getResult;
        else {
            var n = getResult.a;
            var model = getResult.b;
            return !n ? A2($elm$browser$Debugger$History$Done, msg, A2(update, msg, model).a) : A2($elm$browser$Debugger$History$Stepping, n - 1, A2(update, msg, model).a);
        }
    });
    var $elm$browser$Debugger$History$undone = function(getResult) {
        undone: while(true)if (getResult.$ === "Done") {
            var msg = getResult.a;
            var model = getResult.b;
            return _Utils_Tuple2(model, msg);
        } else {
            var $temp$getResult = getResult;
            getResult = $temp$getResult;
            continue undone;
        }
    };
    var $elm$browser$Debugger$History$get = F3(function(update, index, history1) {
        get: while(true){
            var recent = history1.recent;
            var snapshotMax = history1.numMessages - recent.numMessages;
            if (_Utils_cmp(index, snapshotMax) > -1) return $elm$browser$Debugger$History$undone(A3($elm$core$List$foldr, $elm$browser$Debugger$History$getHelp(update), A2($elm$browser$Debugger$History$Stepping, index - snapshotMax, recent.model), recent.messages));
            else {
                var _v0 = A2($elm$core$Array$get, index / $elm$browser$Debugger$History$maxSnapshotSize | 0, history1.snapshots);
                if (_v0.$ === "Nothing") {
                    var $temp$update = update, $temp$index = index, $temp$history = history1;
                    update = $temp$update;
                    index = $temp$index;
                    history1 = $temp$history;
                    continue get;
                } else {
                    var model = _v0.a.model;
                    var messages = _v0.a.messages;
                    return $elm$browser$Debugger$History$undone(A3($elm$core$Array$foldr, $elm$browser$Debugger$History$getHelp(update), A2($elm$browser$Debugger$History$Stepping, index % $elm$browser$Debugger$History$maxSnapshotSize, model), messages));
                }
            }
        }
    });
    var $elm$browser$Debugger$History$getRecentMsg = function(history1) {
        getRecentMsg: while(true){
            var _v0 = history1.recent.messages;
            if (!_v0.b) {
                var $temp$history = history1;
                history1 = $temp$history;
                continue getRecentMsg;
            } else {
                var first = _v0.a;
                return first;
            }
        }
    };
    var $elm$core$Dict$get = F2(function(targetKey, dict) {
        get: while(true){
            if (dict.$ === "RBEmpty_elm_builtin") return $elm$core$Maybe$Nothing;
            else {
                var key = dict.b;
                var value = dict.c;
                var left = dict.d;
                var right = dict.e;
                var _v1 = A2($elm$core$Basics$compare, targetKey, key);
                switch(_v1.$){
                    case "LT":
                        var $temp$targetKey = targetKey, $temp$dict = left;
                        targetKey = $temp$targetKey;
                        dict = $temp$dict;
                        continue get;
                    case "EQ":
                        return $elm$core$Maybe$Just(value);
                    default:
                        var $temp$targetKey = targetKey, $temp$dict = right;
                        targetKey = $temp$targetKey;
                        dict = $temp$dict;
                        continue get;
                }
            }
        }
    });
    var $elm$browser$Debugger$Expando$mergeDictHelp = F3(function(oldDict, key, value) {
        var _v12 = A2($elm$core$Dict$get, key, oldDict);
        if (_v12.$ === "Nothing") return value;
        else {
            var oldValue = _v12.a;
            return A2($elm$browser$Debugger$Expando$mergeHelp, oldValue, value);
        }
    });
    var $elm$browser$Debugger$Expando$mergeHelp = F2(function(old, _new) {
        var _v3 = _Utils_Tuple2(old, _new);
        _v3$6: while(true)switch(_v3.b.$){
            case "S":
                return _new;
            case "Primitive":
                return _new;
            case "Sequence":
                if (_v3.a.$ === "Sequence") {
                    var _v4 = _v3.a;
                    var isClosed = _v4.b;
                    var oldValues = _v4.c;
                    var _v5 = _v3.b;
                    var seqType = _v5.a;
                    var newValues = _v5.c;
                    return A3($elm$browser$Debugger$Expando$Sequence, seqType, isClosed, A2($elm$browser$Debugger$Expando$mergeListHelp, oldValues, newValues));
                } else break _v3$6;
            case "Dictionary":
                if (_v3.a.$ === "Dictionary") {
                    var _v6 = _v3.a;
                    var isClosed = _v6.a;
                    var _v7 = _v3.b;
                    var keyValuePairs = _v7.b;
                    return A2($elm$browser$Debugger$Expando$Dictionary, isClosed, keyValuePairs);
                } else break _v3$6;
            case "Record":
                if (_v3.a.$ === "Record") {
                    var _v8 = _v3.a;
                    var isClosed = _v8.a;
                    var oldDict = _v8.b;
                    var _v9 = _v3.b;
                    var newDict = _v9.b;
                    return A2($elm$browser$Debugger$Expando$Record, isClosed, A2($elm$core$Dict$map, $elm$browser$Debugger$Expando$mergeDictHelp(oldDict), newDict));
                } else break _v3$6;
            default:
                if (_v3.a.$ === "Constructor") {
                    var _v10 = _v3.a;
                    var isClosed = _v10.b;
                    var oldValues = _v10.c;
                    var _v11 = _v3.b;
                    var maybeName = _v11.a;
                    var newValues = _v11.c;
                    return A3($elm$browser$Debugger$Expando$Constructor, maybeName, isClosed, A2($elm$browser$Debugger$Expando$mergeListHelp, oldValues, newValues));
                } else break _v3$6;
        }
        return _new;
    });
    var $elm$browser$Debugger$Expando$mergeListHelp = F2(function(olds, news) {
        var _v0 = _Utils_Tuple2(olds, news);
        if (!_v0.a.b) return news;
        else {
            if (!_v0.b.b) return news;
            else {
                var _v1 = _v0.a;
                var x = _v1.a;
                var xs = _v1.b;
                var _v2 = _v0.b;
                var y = _v2.a;
                var ys = _v2.b;
                return A2($elm$core$List$cons, A2($elm$browser$Debugger$Expando$mergeHelp, x, y), A2($elm$browser$Debugger$Expando$mergeListHelp, xs, ys));
            }
        }
    });
    var $elm$browser$Debugger$Expando$merge = F2(function(value, expando) {
        return A2($elm$browser$Debugger$Expando$mergeHelp, expando, _Debugger_init(value));
    });
    var $elm$browser$Debugger$Main$jumpUpdate = F3(function(update, index, model) {
        var history1 = $elm$browser$Debugger$Main$cachedHistory(model);
        var currentMsg = $elm$browser$Debugger$History$getRecentMsg(history1);
        var currentModel = $elm$browser$Debugger$Main$getLatestModel(model.state);
        var _v0 = A3($elm$browser$Debugger$History$get, update, index, history1);
        var indexModel = _v0.a;
        var indexMsg = _v0.b;
        return _Utils_update(model, {
            expandoModel: A2($elm$browser$Debugger$Expando$merge, indexModel, model.expandoModel),
            expandoMsg: A2($elm$browser$Debugger$Expando$merge, indexMsg, model.expandoMsg),
            state: A5($elm$browser$Debugger$Main$Paused, index, indexModel, currentModel, currentMsg, history1)
        });
    });
    var $elm$browser$Debugger$History$jsToElm = A2($elm$core$Basics$composeR, _Json_unwrap, _Debugger_unsafeCoerce);
    var $elm$browser$Debugger$History$decoder = F2(function(initialModel, update) {
        var addMessage = F2(function(rawMsg, _v0) {
            var model = _v0.a;
            var history1 = _v0.b;
            var msg = $elm$browser$Debugger$History$jsToElm(rawMsg);
            return _Utils_Tuple2(A2(update, msg, model), A3($elm$browser$Debugger$History$add, msg, model, history1));
        });
        var updateModel = function(rawMsgs) {
            return A3($elm$core$List$foldl, addMessage, _Utils_Tuple2(initialModel, $elm$browser$Debugger$History$empty(initialModel)), rawMsgs);
        };
        return A2($elm$json$Json$Decode$map, updateModel, $elm$json$Json$Decode$list($elm$json$Json$Decode$value));
    });
    var $elm$browser$Debugger$History$getInitialModel = function(_v0) {
        var snapshots = _v0.snapshots;
        var recent = _v0.recent;
        var _v1 = A2($elm$core$Array$get, 0, snapshots);
        if (_v1.$ === "Just") {
            var model = _v1.a.model;
            return model;
        } else return recent.model;
    };
    var $elm$core$Platform$Cmd$none = $elm$core$Platform$Cmd$batch(_List_Nil);
    var $elm$browser$Debugger$Main$loadNewHistory = F3(function(rawHistory, update, model) {
        var pureUserUpdate = F2(function(msg, userModel) {
            return A2(update, msg, userModel).a;
        });
        var initialUserModel = $elm$browser$Debugger$History$getInitialModel(model.history);
        var decoder = A2($elm$browser$Debugger$History$decoder, initialUserModel, pureUserUpdate);
        var _v0 = A2($elm$json$Json$Decode$decodeValue, decoder, rawHistory);
        if (_v0.$ === "Err") return _Utils_Tuple2(_Utils_update(model, {
            overlay: $elm$browser$Debugger$Overlay$corruptImport
        }), $elm$core$Platform$Cmd$none);
        else {
            var _v1 = _v0.a;
            var latestUserModel = _v1.a;
            var newHistory = _v1.b;
            return _Utils_Tuple2(_Utils_update(model, {
                expandoModel: $elm$browser$Debugger$Expando$init(latestUserModel),
                expandoMsg: $elm$browser$Debugger$Expando$init($elm$browser$Debugger$History$getRecentMsg(newHistory)),
                history: newHistory,
                overlay: $elm$browser$Debugger$Overlay$none,
                state: $elm$browser$Debugger$Main$Running(latestUserModel)
            }), $elm$core$Platform$Cmd$none);
        }
    });
    var $elm$browser$Debugger$Main$scroll = function(popout) {
        return A2($elm$core$Task$perform, $elm$core$Basics$always($elm$browser$Debugger$Main$NoOp), _Debugger_scroll(popout));
    };
    var $elm$browser$Debugger$Main$scrollTo = F2(function(id, popout) {
        return A2($elm$core$Task$perform, $elm$core$Basics$always($elm$browser$Debugger$Main$NoOp), A2(_Debugger_scrollTo, id, popout));
    });
    var $elm$browser$Debugger$Main$setDragStatus = F2(function(status, layout) {
        if (layout.$ === "Horizontal") {
            var x = layout.b;
            var y = layout.c;
            return A3($elm$browser$Debugger$Main$Horizontal, status, x, y);
        } else {
            var x = layout.b;
            var y = layout.c;
            return A3($elm$browser$Debugger$Main$Vertical, status, x, y);
        }
    });
    var $elm$browser$Debugger$Main$swapLayout = function(layout) {
        if (layout.$ === "Horizontal") {
            var s = layout.a;
            var x = layout.b;
            var y = layout.c;
            return A3($elm$browser$Debugger$Main$Vertical, s, x, y);
        } else {
            var s = layout.a;
            var x = layout.b;
            var y = layout.c;
            return A3($elm$browser$Debugger$Main$Horizontal, s, x, y);
        }
    };
    var $elm$core$Dict$getMin = function(dict) {
        getMin: while(true){
            if (dict.$ === "RBNode_elm_builtin" && dict.d.$ === "RBNode_elm_builtin") {
                var left = dict.d;
                var $temp$dict = left;
                dict = $temp$dict;
                continue getMin;
            } else return dict;
        }
    };
    var $elm$core$Dict$moveRedLeft = function(dict) {
        if (dict.$ === "RBNode_elm_builtin" && dict.d.$ === "RBNode_elm_builtin" && dict.e.$ === "RBNode_elm_builtin") {
            if (dict.e.d.$ === "RBNode_elm_builtin" && dict.e.d.a.$ === "Red") {
                var clr = dict.a;
                var k = dict.b;
                var v = dict.c;
                var _v1 = dict.d;
                var lClr = _v1.a;
                var lK = _v1.b;
                var lV = _v1.c;
                var lLeft = _v1.d;
                var lRight = _v1.e;
                var _v2 = dict.e;
                var rClr = _v2.a;
                var rK = _v2.b;
                var rV = _v2.c;
                var rLeft = _v2.d;
                var _v3 = rLeft.a;
                var rlK = rLeft.b;
                var rlV = rLeft.c;
                var rlL = rLeft.d;
                var rlR = rLeft.e;
                var rRight = _v2.e;
                return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rlK, rlV, A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, k, v, A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight), rlL), A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, rK, rV, rlR, rRight));
            } else {
                var clr = dict.a;
                var k = dict.b;
                var v = dict.c;
                var _v4 = dict.d;
                var lClr = _v4.a;
                var lK = _v4.b;
                var lV = _v4.c;
                var lLeft = _v4.d;
                var lRight = _v4.e;
                var _v5 = dict.e;
                var rClr = _v5.a;
                var rK = _v5.b;
                var rV = _v5.c;
                var rLeft = _v5.d;
                var rRight = _v5.e;
                if (clr.$ === "Black") return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, k, v, A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight), A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight));
                else return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, k, v, A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight), A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight));
            }
        } else return dict;
    };
    var $elm$core$Dict$moveRedRight = function(dict) {
        if (dict.$ === "RBNode_elm_builtin" && dict.d.$ === "RBNode_elm_builtin" && dict.e.$ === "RBNode_elm_builtin") {
            if (dict.d.d.$ === "RBNode_elm_builtin" && dict.d.d.a.$ === "Red") {
                var clr = dict.a;
                var k = dict.b;
                var v = dict.c;
                var _v1 = dict.d;
                var lClr = _v1.a;
                var lK = _v1.b;
                var lV = _v1.c;
                var _v2 = _v1.d;
                var _v3 = _v2.a;
                var llK = _v2.b;
                var llV = _v2.c;
                var llLeft = _v2.d;
                var llRight = _v2.e;
                var lRight = _v1.e;
                var _v4 = dict.e;
                var rClr = _v4.a;
                var rK = _v4.b;
                var rV = _v4.c;
                var rLeft = _v4.d;
                var rRight = _v4.e;
                return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, llK, llV, llLeft, llRight), A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, k, v, lRight, A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight)));
            } else {
                var clr = dict.a;
                var k = dict.b;
                var v = dict.c;
                var _v5 = dict.d;
                var lClr = _v5.a;
                var lK = _v5.b;
                var lV = _v5.c;
                var lLeft = _v5.d;
                var lRight = _v5.e;
                var _v6 = dict.e;
                var rClr = _v6.a;
                var rK = _v6.b;
                var rV = _v6.c;
                var rLeft = _v6.d;
                var rRight = _v6.e;
                if (clr.$ === "Black") return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, k, v, A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight), A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight));
                else return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, k, v, A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight), A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight));
            }
        } else return dict;
    };
    var $elm$core$Dict$removeHelpPrepEQGT = F7(function(targetKey, dict, color, key, value, left, right) {
        if (left.$ === "RBNode_elm_builtin" && left.a.$ === "Red") {
            var _v1 = left.a;
            var lK = left.b;
            var lV = left.c;
            var lLeft = left.d;
            var lRight = left.e;
            return A5($elm$core$Dict$RBNode_elm_builtin, color, lK, lV, lLeft, A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, key, value, lRight, right));
        } else {
            _v2$2: while(true){
                if (right.$ === "RBNode_elm_builtin" && right.a.$ === "Black") {
                    if (right.d.$ === "RBNode_elm_builtin") {
                        if (right.d.a.$ === "Black") {
                            var _v3 = right.a;
                            var _v4 = right.d;
                            var _v5 = _v4.a;
                            return $elm$core$Dict$moveRedRight(dict);
                        } else break _v2$2;
                    } else {
                        var _v6 = right.a;
                        var _v7 = right.d;
                        return $elm$core$Dict$moveRedRight(dict);
                    }
                } else break _v2$2;
            }
            return dict;
        }
    });
    var $elm$core$Dict$removeMin = function(dict) {
        if (dict.$ === "RBNode_elm_builtin" && dict.d.$ === "RBNode_elm_builtin") {
            var color = dict.a;
            var key = dict.b;
            var value = dict.c;
            var left = dict.d;
            var lColor = left.a;
            var lLeft = left.d;
            var right = dict.e;
            if (lColor.$ === "Black") {
                if (lLeft.$ === "RBNode_elm_builtin" && lLeft.a.$ === "Red") {
                    var _v3 = lLeft.a;
                    return A5($elm$core$Dict$RBNode_elm_builtin, color, key, value, $elm$core$Dict$removeMin(left), right);
                } else {
                    var _v4 = $elm$core$Dict$moveRedLeft(dict);
                    if (_v4.$ === "RBNode_elm_builtin") {
                        var nColor = _v4.a;
                        var nKey = _v4.b;
                        var nValue = _v4.c;
                        var nLeft = _v4.d;
                        var nRight = _v4.e;
                        return A5($elm$core$Dict$balance, nColor, nKey, nValue, $elm$core$Dict$removeMin(nLeft), nRight);
                    } else return $elm$core$Dict$RBEmpty_elm_builtin;
                }
            } else return A5($elm$core$Dict$RBNode_elm_builtin, color, key, value, $elm$core$Dict$removeMin(left), right);
        } else return $elm$core$Dict$RBEmpty_elm_builtin;
    };
    var $elm$core$Dict$removeHelp = F2(function(targetKey, dict) {
        if (dict.$ === "RBEmpty_elm_builtin") return $elm$core$Dict$RBEmpty_elm_builtin;
        else {
            var color = dict.a;
            var key = dict.b;
            var value = dict.c;
            var left = dict.d;
            var right = dict.e;
            if (_Utils_cmp(targetKey, key) < 0) {
                if (left.$ === "RBNode_elm_builtin" && left.a.$ === "Black") {
                    var _v4 = left.a;
                    var lLeft = left.d;
                    if (lLeft.$ === "RBNode_elm_builtin" && lLeft.a.$ === "Red") {
                        var _v6 = lLeft.a;
                        return A5($elm$core$Dict$RBNode_elm_builtin, color, key, value, A2($elm$core$Dict$removeHelp, targetKey, left), right);
                    } else {
                        var _v7 = $elm$core$Dict$moveRedLeft(dict);
                        if (_v7.$ === "RBNode_elm_builtin") {
                            var nColor = _v7.a;
                            var nKey = _v7.b;
                            var nValue = _v7.c;
                            var nLeft = _v7.d;
                            var nRight = _v7.e;
                            return A5($elm$core$Dict$balance, nColor, nKey, nValue, A2($elm$core$Dict$removeHelp, targetKey, nLeft), nRight);
                        } else return $elm$core$Dict$RBEmpty_elm_builtin;
                    }
                } else return A5($elm$core$Dict$RBNode_elm_builtin, color, key, value, A2($elm$core$Dict$removeHelp, targetKey, left), right);
            } else return A2($elm$core$Dict$removeHelpEQGT, targetKey, A7($elm$core$Dict$removeHelpPrepEQGT, targetKey, dict, color, key, value, left, right));
        }
    });
    var $elm$core$Dict$removeHelpEQGT = F2(function(targetKey, dict) {
        if (dict.$ === "RBNode_elm_builtin") {
            var color = dict.a;
            var key = dict.b;
            var value = dict.c;
            var left = dict.d;
            var right = dict.e;
            if (_Utils_eq(targetKey, key)) {
                var _v1 = $elm$core$Dict$getMin(right);
                if (_v1.$ === "RBNode_elm_builtin") {
                    var minKey = _v1.b;
                    var minValue = _v1.c;
                    return A5($elm$core$Dict$balance, color, minKey, minValue, left, $elm$core$Dict$removeMin(right));
                } else return $elm$core$Dict$RBEmpty_elm_builtin;
            } else return A5($elm$core$Dict$balance, color, key, value, left, A2($elm$core$Dict$removeHelp, targetKey, right));
        } else return $elm$core$Dict$RBEmpty_elm_builtin;
    });
    var $elm$core$Dict$remove = F2(function(key, dict) {
        var _v0 = A2($elm$core$Dict$removeHelp, key, dict);
        if (_v0.$ === "RBNode_elm_builtin" && _v0.a.$ === "Red") {
            var _v1 = _v0.a;
            var k = _v0.b;
            var v = _v0.c;
            var l = _v0.d;
            var r = _v0.e;
            return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, k, v, l, r);
        } else {
            var x = _v0;
            return x;
        }
    });
    var $elm$core$Dict$update = F3(function(targetKey, alter, dictionary) {
        var _v0 = alter(A2($elm$core$Dict$get, targetKey, dictionary));
        if (_v0.$ === "Just") {
            var value = _v0.a;
            return A3($elm$core$Dict$insert, targetKey, value, dictionary);
        } else return A2($elm$core$Dict$remove, targetKey, dictionary);
    });
    var $elm$browser$Debugger$Expando$updateIndex = F3(function(n, func, list) {
        if (!list.b) return _List_Nil;
        else {
            var x = list.a;
            var xs = list.b;
            return n <= 0 ? A2($elm$core$List$cons, func(x), xs) : A2($elm$core$List$cons, x, A3($elm$browser$Debugger$Expando$updateIndex, n - 1, func, xs));
        }
    });
    var $elm$browser$Debugger$Expando$update = F2(function(msg, value) {
        switch(value.$){
            case "S":
                return value;
            case "Primitive":
                return value;
            case "Sequence":
                var seqType = value.a;
                var isClosed = value.b;
                var valueList = value.c;
                switch(msg.$){
                    case "Toggle":
                        return A3($elm$browser$Debugger$Expando$Sequence, seqType, !isClosed, valueList);
                    case "Index":
                        if (msg.a.$ === "None") {
                            var _v3 = msg.a;
                            var index = msg.b;
                            var subMsg = msg.c;
                            return A3($elm$browser$Debugger$Expando$Sequence, seqType, isClosed, A3($elm$browser$Debugger$Expando$updateIndex, index, $elm$browser$Debugger$Expando$update(subMsg), valueList));
                        } else return value;
                    default:
                        return value;
                }
            case "Dictionary":
                var isClosed = value.a;
                var keyValuePairs = value.b;
                switch(msg.$){
                    case "Toggle":
                        return A2($elm$browser$Debugger$Expando$Dictionary, !isClosed, keyValuePairs);
                    case "Index":
                        var redirect = msg.a;
                        var index = msg.b;
                        var subMsg = msg.c;
                        switch(redirect.$){
                            case "None":
                                return value;
                            case "Key":
                                return A2($elm$browser$Debugger$Expando$Dictionary, isClosed, A3($elm$browser$Debugger$Expando$updateIndex, index, function(_v6) {
                                    var k = _v6.a;
                                    var v = _v6.b;
                                    return _Utils_Tuple2(A2($elm$browser$Debugger$Expando$update, subMsg, k), v);
                                }, keyValuePairs));
                            default:
                                return A2($elm$browser$Debugger$Expando$Dictionary, isClosed, A3($elm$browser$Debugger$Expando$updateIndex, index, function(_v7) {
                                    var k = _v7.a;
                                    var v = _v7.b;
                                    return _Utils_Tuple2(k, A2($elm$browser$Debugger$Expando$update, subMsg, v));
                                }, keyValuePairs));
                        }
                    default:
                        return value;
                }
            case "Record":
                var isClosed = value.a;
                var valueDict = value.b;
                switch(msg.$){
                    case "Toggle":
                        return A2($elm$browser$Debugger$Expando$Record, !isClosed, valueDict);
                    case "Index":
                        return value;
                    default:
                        var field = msg.a;
                        var subMsg = msg.b;
                        return A2($elm$browser$Debugger$Expando$Record, isClosed, A3($elm$core$Dict$update, field, $elm$browser$Debugger$Expando$updateField(subMsg), valueDict));
                }
            default:
                var maybeName = value.a;
                var isClosed = value.b;
                var valueList = value.c;
                switch(msg.$){
                    case "Toggle":
                        return A3($elm$browser$Debugger$Expando$Constructor, maybeName, !isClosed, valueList);
                    case "Index":
                        if (msg.a.$ === "None") {
                            var _v10 = msg.a;
                            var index = msg.b;
                            var subMsg = msg.c;
                            return A3($elm$browser$Debugger$Expando$Constructor, maybeName, isClosed, A3($elm$browser$Debugger$Expando$updateIndex, index, $elm$browser$Debugger$Expando$update(subMsg), valueList));
                        } else return value;
                    default:
                        return value;
                }
        }
    });
    var $elm$browser$Debugger$Expando$updateField = F2(function(msg, maybeExpando) {
        if (maybeExpando.$ === "Nothing") return maybeExpando;
        else {
            var expando = maybeExpando.a;
            return $elm$core$Maybe$Just(A2($elm$browser$Debugger$Expando$update, msg, expando));
        }
    });
    var $elm$browser$Debugger$Main$Upload = function(a) {
        return {
            $: "Upload",
            a: a
        };
    };
    var $elm$browser$Debugger$Main$upload = function(popout) {
        return A2($elm$core$Task$perform, $elm$browser$Debugger$Main$Upload, _Debugger_upload(popout));
    };
    var $elm$browser$Debugger$Overlay$BadMetadata = function(a) {
        return {
            $: "BadMetadata",
            a: a
        };
    };
    var $elm$browser$Debugger$Overlay$badMetadata = $elm$browser$Debugger$Overlay$BadMetadata;
    var $elm$browser$Debugger$Main$withGoodMetadata = F2(function(model, func) {
        var _v0 = model.metadata;
        if (_v0.$ === "Ok") {
            var metadata = _v0.a;
            return func(metadata);
        } else {
            var error = _v0.a;
            return _Utils_Tuple2(_Utils_update(model, {
                overlay: $elm$browser$Debugger$Overlay$badMetadata(error)
            }), $elm$core$Platform$Cmd$none);
        }
    });
    var $elm$browser$Debugger$Main$wrapUpdate = F3(function(update, msg, model) {
        wrapUpdate: while(true)switch(msg.$){
            case "NoOp":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "UserMsg":
                var userMsg = msg.a;
                var userModel = $elm$browser$Debugger$Main$getLatestModel(model.state);
                var newHistory = A3($elm$browser$Debugger$History$add, userMsg, userModel, model.history);
                var _v1 = A2(update, userMsg, userModel);
                var newUserModel = _v1.a;
                var userCmds = _v1.b;
                var commands = A2($elm$core$Platform$Cmd$map, $elm$browser$Debugger$Main$UserMsg, userCmds);
                var _v2 = model.state;
                if (_v2.$ === "Running") return _Utils_Tuple2(_Utils_update(model, {
                    expandoModel: A2($elm$browser$Debugger$Expando$merge, newUserModel, model.expandoModel),
                    expandoMsg: A2($elm$browser$Debugger$Expando$merge, userMsg, model.expandoMsg),
                    history: newHistory,
                    state: $elm$browser$Debugger$Main$Running(newUserModel)
                }), $elm$core$Platform$Cmd$batch(_List_fromArray([
                    commands,
                    $elm$browser$Debugger$Main$scroll(model.popout)
                ])));
                else {
                    var index = _v2.a;
                    var indexModel = _v2.b;
                    var history1 = _v2.e;
                    return _Utils_Tuple2(_Utils_update(model, {
                        history: newHistory,
                        state: A5($elm$browser$Debugger$Main$Paused, index, indexModel, newUserModel, userMsg, history1)
                    }), commands);
                }
            case "TweakExpandoMsg":
                var eMsg = msg.a;
                return _Utils_Tuple2(_Utils_update(model, {
                    expandoMsg: A2($elm$browser$Debugger$Expando$update, eMsg, model.expandoMsg)
                }), $elm$core$Platform$Cmd$none);
            case "TweakExpandoModel":
                var eMsg = msg.a;
                return _Utils_Tuple2(_Utils_update(model, {
                    expandoModel: A2($elm$browser$Debugger$Expando$update, eMsg, model.expandoModel)
                }), $elm$core$Platform$Cmd$none);
            case "Resume":
                var _v3 = model.state;
                if (_v3.$ === "Running") return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
                else {
                    var userModel = _v3.c;
                    var userMsg = _v3.d;
                    return _Utils_Tuple2(_Utils_update(model, {
                        expandoModel: A2($elm$browser$Debugger$Expando$merge, userModel, model.expandoModel),
                        expandoMsg: A2($elm$browser$Debugger$Expando$merge, userMsg, model.expandoMsg),
                        state: $elm$browser$Debugger$Main$Running(userModel)
                    }), $elm$browser$Debugger$Main$scroll(model.popout));
                }
            case "Jump":
                var index = msg.a;
                return _Utils_Tuple2(A3($elm$browser$Debugger$Main$jumpUpdate, update, index, model), $elm$core$Platform$Cmd$none);
            case "SliderJump":
                var index = msg.a;
                return _Utils_Tuple2(A3($elm$browser$Debugger$Main$jumpUpdate, update, index, model), A2($elm$browser$Debugger$Main$scrollTo, $elm$browser$Debugger$History$idForMessageIndex(index), model.popout));
            case "Open":
                return _Utils_Tuple2(model, A2($elm$core$Task$perform, $elm$core$Basics$always($elm$browser$Debugger$Main$NoOp), _Debugger_open(model.popout)));
            case "Up":
                var _v4 = model.state;
                if (_v4.$ === "Running") return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
                else {
                    var i = _v4.a;
                    var history1 = _v4.e;
                    var targetIndex = i + 1;
                    if (_Utils_cmp(targetIndex, $elm$browser$Debugger$History$size(history1)) < 0) {
                        var $temp$update = update, $temp$msg = $elm$browser$Debugger$Main$SliderJump(targetIndex), $temp$model = model;
                        update = $temp$update;
                        msg = $temp$msg;
                        model = $temp$model;
                        continue wrapUpdate;
                    } else {
                        var $temp$update = update, $temp$msg = $elm$browser$Debugger$Main$Resume, $temp$model = model;
                        update = $temp$update;
                        msg = $temp$msg;
                        model = $temp$model;
                        continue wrapUpdate;
                    }
                }
            case "Down":
                var _v5 = model.state;
                if (_v5.$ === "Running") {
                    var $temp$update = update, $temp$msg = $elm$browser$Debugger$Main$Jump($elm$browser$Debugger$History$size(model.history) - 1), $temp$model = model;
                    update = $temp$update;
                    msg = $temp$msg;
                    model = $temp$model;
                    continue wrapUpdate;
                } else {
                    var index = _v5.a;
                    if (index > 0) {
                        var $temp$update = update, $temp$msg = $elm$browser$Debugger$Main$SliderJump(index - 1), $temp$model = model;
                        update = $temp$update;
                        msg = $temp$msg;
                        model = $temp$model;
                        continue wrapUpdate;
                    } else return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
                }
            case "Import":
                return A2($elm$browser$Debugger$Main$withGoodMetadata, model, function(_v6) {
                    return _Utils_Tuple2(model, $elm$browser$Debugger$Main$upload(model.popout));
                });
            case "Export":
                return A2($elm$browser$Debugger$Main$withGoodMetadata, model, function(metadata) {
                    return _Utils_Tuple2(model, A2($elm$browser$Debugger$Main$download, metadata, model.history));
                });
            case "Upload":
                var jsonString = msg.a;
                return A2($elm$browser$Debugger$Main$withGoodMetadata, model, function(metadata) {
                    var _v7 = A2($elm$browser$Debugger$Overlay$assessImport, metadata, jsonString);
                    if (_v7.$ === "Err") {
                        var newOverlay = _v7.a;
                        return _Utils_Tuple2(_Utils_update(model, {
                            overlay: newOverlay
                        }), $elm$core$Platform$Cmd$none);
                    } else {
                        var rawHistory = _v7.a;
                        return A3($elm$browser$Debugger$Main$loadNewHistory, rawHistory, update, model);
                    }
                });
            case "OverlayMsg":
                var overlayMsg = msg.a;
                var _v8 = A2($elm$browser$Debugger$Overlay$close, overlayMsg, model.overlay);
                if (_v8.$ === "Nothing") return _Utils_Tuple2(_Utils_update(model, {
                    overlay: $elm$browser$Debugger$Overlay$none
                }), $elm$core$Platform$Cmd$none);
                else {
                    var rawHistory = _v8.a;
                    return A3($elm$browser$Debugger$Main$loadNewHistory, rawHistory, update, model);
                }
            case "SwapLayout":
                return _Utils_Tuple2(_Utils_update(model, {
                    layout: $elm$browser$Debugger$Main$swapLayout(model.layout)
                }), $elm$core$Platform$Cmd$none);
            case "DragStart":
                return _Utils_Tuple2(_Utils_update(model, {
                    layout: A2($elm$browser$Debugger$Main$setDragStatus, $elm$browser$Debugger$Main$Moving, model.layout)
                }), $elm$core$Platform$Cmd$none);
            case "Drag":
                var info = msg.a;
                return _Utils_Tuple2(_Utils_update(model, {
                    layout: A2($elm$browser$Debugger$Main$drag, info, model.layout)
                }), $elm$core$Platform$Cmd$none);
            default:
                return _Utils_Tuple2(_Utils_update(model, {
                    layout: A2($elm$browser$Debugger$Main$setDragStatus, $elm$browser$Debugger$Main$Static, model.layout)
                }), $elm$core$Platform$Cmd$none);
        }
    });
    var $elm$browser$Browser$External = function(a) {
        return {
            $: "External",
            a: a
        };
    };
    var $elm$browser$Browser$Internal = function(a) {
        return {
            $: "Internal",
            a: a
        };
    };
    var $elm$browser$Browser$Dom$NotFound = function(a) {
        return {
            $: "NotFound",
            a: a
        };
    };
    var $elm$url$Url$Http = {
        $: "Http"
    };
    var $elm$url$Url$Https = {
        $: "Https"
    };
    var $elm$url$Url$Url = F6(function(protocol, host, port_, path, query, fragment) {
        return {
            fragment: fragment,
            host: host,
            path: path,
            port_: port_,
            protocol: protocol,
            query: query
        };
    });
    var $elm$core$String$dropLeft = F2(function(n, string) {
        return n < 1 ? string : A3($elm$core$String$slice, n, $elm$core$String$length(string), string);
    });
    var $elm$core$String$indexes = _String_indexes;
    var $elm$core$String$isEmpty = function(string) {
        return string === "";
    };
    var $elm$url$Url$chompBeforePath = F5(function(protocol, path, params, frag, str) {
        if ($elm$core$String$isEmpty(str) || A2($elm$core$String$contains, "@", str)) return $elm$core$Maybe$Nothing;
        else {
            var _v0 = A2($elm$core$String$indexes, ":", str);
            if (!_v0.b) return $elm$core$Maybe$Just(A6($elm$url$Url$Url, protocol, str, $elm$core$Maybe$Nothing, path, params, frag));
            else {
                if (!_v0.b.b) {
                    var i = _v0.a;
                    var _v1 = $elm$core$String$toInt(A2($elm$core$String$dropLeft, i + 1, str));
                    if (_v1.$ === "Nothing") return $elm$core$Maybe$Nothing;
                    else {
                        var port_ = _v1;
                        return $elm$core$Maybe$Just(A6($elm$url$Url$Url, protocol, A2($elm$core$String$left, i, str), port_, path, params, frag));
                    }
                } else return $elm$core$Maybe$Nothing;
            }
        }
    });
    var $elm$url$Url$chompBeforeQuery = F4(function(protocol, params, frag, str) {
        if ($elm$core$String$isEmpty(str)) return $elm$core$Maybe$Nothing;
        else {
            var _v0 = A2($elm$core$String$indexes, "/", str);
            if (!_v0.b) return A5($elm$url$Url$chompBeforePath, protocol, "/", params, frag, str);
            else {
                var i = _v0.a;
                return A5($elm$url$Url$chompBeforePath, protocol, A2($elm$core$String$dropLeft, i, str), params, frag, A2($elm$core$String$left, i, str));
            }
        }
    });
    var $elm$url$Url$chompBeforeFragment = F3(function(protocol, frag, str) {
        if ($elm$core$String$isEmpty(str)) return $elm$core$Maybe$Nothing;
        else {
            var _v0 = A2($elm$core$String$indexes, "?", str);
            if (!_v0.b) return A4($elm$url$Url$chompBeforeQuery, protocol, $elm$core$Maybe$Nothing, frag, str);
            else {
                var i = _v0.a;
                return A4($elm$url$Url$chompBeforeQuery, protocol, $elm$core$Maybe$Just(A2($elm$core$String$dropLeft, i + 1, str)), frag, A2($elm$core$String$left, i, str));
            }
        }
    });
    var $elm$url$Url$chompAfterProtocol = F2(function(protocol, str) {
        if ($elm$core$String$isEmpty(str)) return $elm$core$Maybe$Nothing;
        else {
            var _v0 = A2($elm$core$String$indexes, "#", str);
            if (!_v0.b) return A3($elm$url$Url$chompBeforeFragment, protocol, $elm$core$Maybe$Nothing, str);
            else {
                var i = _v0.a;
                return A3($elm$url$Url$chompBeforeFragment, protocol, $elm$core$Maybe$Just(A2($elm$core$String$dropLeft, i + 1, str)), A2($elm$core$String$left, i, str));
            }
        }
    });
    var $elm$core$String$startsWith = _String_startsWith;
    var $elm$url$Url$fromString = function(str) {
        return A2($elm$core$String$startsWith, "http://", str) ? A2($elm$url$Url$chompAfterProtocol, $elm$url$Url$Http, A2($elm$core$String$dropLeft, 7, str)) : A2($elm$core$String$startsWith, "https://", str) ? A2($elm$url$Url$chompAfterProtocol, $elm$url$Url$Https, A2($elm$core$String$dropLeft, 8, str)) : $elm$core$Maybe$Nothing;
    };
    var $elm$core$Basics$never = function(_v0) {
        never: while(true){
            var nvr = _v0.a;
            var $temp$_v0 = nvr;
            _v0 = $temp$_v0;
            continue never;
        }
    };
    var $elm$browser$Browser$application = _Browser_application;
    var $author$project$Main$NotFound = {
        $: "NotFound"
    };
    var $elm$time$Time$Posix = function(a) {
        return {
            $: "Posix",
            a: a
        };
    };
    var $elm$time$Time$millisToPosix = $elm$time$Time$Posix;
    var $elm$browser$Browser$Navigation$pushUrl = _Browser_pushUrl;
    var $elm$url$Url$addPort = F2(function(maybePort, starter) {
        if (maybePort.$ === "Nothing") return starter;
        else {
            var port_ = maybePort.a;
            return starter + (":" + $elm$core$String$fromInt(port_));
        }
    });
    var $elm$url$Url$addPrefixed = F3(function(prefix, maybeSegment, starter) {
        if (maybeSegment.$ === "Nothing") return starter;
        else {
            var segment = maybeSegment.a;
            return _Utils_ap(starter, _Utils_ap(prefix, segment));
        }
    });
    var $elm$url$Url$toString = function(url) {
        var http = function() {
            var _v0 = url.protocol;
            if (_v0.$ === "Http") return "http://";
            else return "https://";
        }();
        return A3($elm$url$Url$addPrefixed, "#", url.fragment, A3($elm$url$Url$addPrefixed, "?", url.query, _Utils_ap(A2($elm$url$Url$addPort, url.port_, _Utils_ap(http, url.host)), url.path)));
    };
    var $elm$core$List$filter = F2(function(isGood, list) {
        return A3($elm$core$List$foldr, F2(function(x, xs) {
            return isGood(x) ? A2($elm$core$List$cons, x, xs) : xs;
        }), _List_Nil, list);
    });
    var $RomanErnst$erl$Erl$getQueryValuesForKey = F2(function(key, url) {
        return A2($elm$core$List$map, $elm$core$Tuple$second, A2($elm$core$List$filter, function(_v0) {
            var k = _v0.a;
            return _Utils_eq(k, key);
        }, url.query));
    });
    var $elm$core$List$head = function(list) {
        if (list.b) {
            var x = list.a;
            var xs = list.b;
            return $elm$core$Maybe$Just(x);
        } else return $elm$core$Maybe$Nothing;
    };
    var $RomanErnst$erl$Erl$extractProtocol = function(str) {
        var parts = A2($elm$core$String$split, "://", str);
        var _v0 = $elm$core$List$length(parts);
        if (_v0 === 1) return "";
        else return A2($elm$core$Maybe$withDefault, "", $elm$core$List$head(parts));
    };
    var $elm$regex$Regex$Match = F4(function(match, index, number, submatches) {
        return {
            index: index,
            match: match,
            number: number,
            submatches: submatches
        };
    });
    var $elm$regex$Regex$findAtMost = _Regex_findAtMost;
    var $elm$regex$Regex$fromStringWith = _Regex_fromStringWith;
    var $elm$regex$Regex$fromString = function(string) {
        return A2($elm$regex$Regex$fromStringWith, {
            caseInsensitive: false,
            multiline: false
        }, string);
    };
    var $elm$core$Maybe$map = F2(function(f, maybe) {
        if (maybe.$ === "Just") {
            var value = maybe.a;
            return $elm$core$Maybe$Just(f(value));
        } else return $elm$core$Maybe$Nothing;
    });
    var $RomanErnst$erl$Erl$extractPort = function(str) {
        var res = A2($elm$core$Maybe$withDefault, _List_Nil, A2($elm$core$Maybe$map, function(rx) {
            return A3($elm$regex$Regex$findAtMost, 1, rx, str);
        }, $elm$regex$Regex$fromString(":\\d+")));
        return function(result) {
            if (result.$ === "Just") {
                var port_ = result.a;
                return port_;
            } else {
                var _v1 = $RomanErnst$erl$Erl$extractProtocol(str);
                switch(_v1){
                    case "http":
                        return 80;
                    case "https":
                        return 443;
                    case "ftp":
                        return 21;
                    case "sftp":
                        return 22;
                    default:
                        return 0;
                }
            }
        }($elm$core$String$toInt(A2($elm$core$String$dropLeft, 1, A2($elm$core$Maybe$withDefault, "", $elm$core$List$head(A2($elm$core$List$map, function($) {
            return $.match;
        }, res))))));
    };
    var $elm$regex$Regex$contains = _Regex_contains;
    var $RomanErnst$erl$Erl$leftFromOrSame = F2(function(delimiter, str) {
        var parts = A2($elm$core$String$split, delimiter, str);
        return A2($elm$core$Maybe$withDefault, "", $elm$core$List$head(parts));
    });
    var $RomanErnst$erl$Erl$rightFromOrSame = F2(function(delimiter, str) {
        var parts = A2($elm$core$String$split, delimiter, str);
        return A2($elm$core$Maybe$withDefault, "", $elm$core$List$head($elm$core$List$reverse(parts)));
    });
    var $RomanErnst$erl$Erl$extractHost = function(str) {
        if (A2($elm$core$String$contains, "//", str)) return A2($RomanErnst$erl$Erl$leftFromOrSame, ":", A2($RomanErnst$erl$Erl$leftFromOrSame, "/", A2($RomanErnst$erl$Erl$rightFromOrSame, "//", str)));
        else {
            var matches = function(s) {
                return A2($elm$core$Maybe$withDefault, _List_Nil, A2($elm$core$Maybe$map, function(rx) {
                    return A3($elm$regex$Regex$findAtMost, 1, rx, s);
                }, $elm$regex$Regex$fromString("((\\w|-)+\\.)+(\\w|-)+")));
            };
            return A2($elm$core$Maybe$withDefault, "", A2($elm$core$Maybe$map, function($) {
                return $.match;
            }, $elm$core$List$head(matches(A2($RomanErnst$erl$Erl$leftFromOrSame, "/", A2($RomanErnst$erl$Erl$rightFromOrSame, "//", str))))));
        }
    };
    var $elm$regex$Regex$replaceAtMost = _Regex_replaceAtMost;
    var $RomanErnst$erl$Erl$extractPath = function(str) {
        var replace = F2(function(maybeRegex, s) {
            return A2($elm$core$Maybe$withDefault, s, A2($elm$core$Maybe$map, function(rx) {
                return A4($elm$regex$Regex$replaceAtMost, 1, rx, function(_v0) {
                    return "";
                }, s);
            }, maybeRegex));
        });
        var host_ = $RomanErnst$erl$Erl$extractHost(str);
        return A2(replace, $elm$regex$Regex$fromString(":\\d+"), A2(replace, $elm$regex$Regex$fromString(host_), A2($RomanErnst$erl$Erl$leftFromOrSame, "#", A2($RomanErnst$erl$Erl$leftFromOrSame, "?", A2($RomanErnst$erl$Erl$rightFromOrSame, "//", str)))));
    };
    var $RomanErnst$erl$Erl$hasLeadingSlashFromAll = function(str) {
        return A2($elm$core$Maybe$withDefault, false, A2($elm$core$Maybe$map, function(rx) {
            return A2($elm$regex$Regex$contains, rx, $RomanErnst$erl$Erl$extractPath(str));
        }, $elm$regex$Regex$fromString("^/")));
    };
    var $RomanErnst$erl$Erl$hasTrailingSlashFromAll = function(str) {
        return A2($elm$core$Maybe$withDefault, false, A2($elm$core$Maybe$map, function(rx) {
            return A2($elm$regex$Regex$contains, rx, $RomanErnst$erl$Erl$extractPath(str));
        }, $elm$regex$Regex$fromString("/$")));
    };
    var $RomanErnst$erl$Erl$extractHash = function(str) {
        return A2($elm$core$Maybe$withDefault, "", $elm$core$List$head(A2($elm$core$List$drop, 1, A2($elm$core$String$split, "#", str))));
    };
    var $RomanErnst$erl$Erl$hashFromAll = function(str) {
        return $RomanErnst$erl$Erl$extractHash(str);
    };
    var $RomanErnst$erl$Erl$parseHost = function(str) {
        return A2($elm$core$String$split, ".", str);
    };
    var $RomanErnst$erl$Erl$host = function(str) {
        return $RomanErnst$erl$Erl$parseHost($RomanErnst$erl$Erl$extractHost(str));
    };
    var $RomanErnst$erl$Erl$notEmpty = function(str) {
        return !$elm$core$String$isEmpty(str);
    };
    var $elm$url$Url$percentDecode = _Url_percentDecode;
    var $RomanErnst$erl$Erl$parsePath = function(str) {
        return A2($elm$core$List$map, $elm$core$Maybe$withDefault(""), A2($elm$core$List$map, $elm$url$Url$percentDecode, A2($elm$core$List$filter, $RomanErnst$erl$Erl$notEmpty, A2($elm$core$String$split, "/", str))));
    };
    var $RomanErnst$erl$Erl$pathFromAll = function(str) {
        return $RomanErnst$erl$Erl$parsePath($RomanErnst$erl$Erl$extractPath(str));
    };
    var $RomanErnst$erl$Erl$extractQuery = function(str) {
        return A2($elm$core$Maybe$withDefault, "", $elm$core$List$head(A2($elm$core$String$split, "#", A2($elm$core$Maybe$withDefault, "", $elm$core$List$head(A2($elm$core$List$drop, 1, A2($elm$core$String$split, "?", str)))))));
    };
    var $RomanErnst$erl$Erl$queryStringElementToTuple = function(element) {
        var splitted = A2($elm$core$String$split, "=", element);
        var second = A2($elm$core$Maybe$withDefault, "", $elm$core$List$head(A2($elm$core$List$drop, 1, splitted)));
        var secondDecoded = A2($elm$core$Maybe$withDefault, "", $elm$url$Url$percentDecode(second));
        var first = A2($elm$core$Maybe$withDefault, "", $elm$core$List$head(splitted));
        var firstDecoded = A2($elm$core$Maybe$withDefault, "", $elm$url$Url$percentDecode(first));
        return _Utils_Tuple2(firstDecoded, secondDecoded);
    };
    var $RomanErnst$erl$Erl$parseQuery = function(queryString) {
        var splitted = A2($elm$core$String$split, "&", queryString);
        return $elm$core$String$isEmpty(queryString) ? _List_Nil : A2($elm$core$List$map, $RomanErnst$erl$Erl$queryStringElementToTuple, splitted);
    };
    var $RomanErnst$erl$Erl$queryFromAll = function(all) {
        return $RomanErnst$erl$Erl$parseQuery($RomanErnst$erl$Erl$extractQuery(all));
    };
    var $RomanErnst$erl$Erl$parse = function(str) {
        return {
            hasLeadingSlash: $RomanErnst$erl$Erl$hasLeadingSlashFromAll(str),
            hasTrailingSlash: $RomanErnst$erl$Erl$hasTrailingSlashFromAll(str),
            hash: $RomanErnst$erl$Erl$hashFromAll(str),
            host: $RomanErnst$erl$Erl$host(str),
            password: "",
            path: $RomanErnst$erl$Erl$pathFromAll(str),
            port_: $RomanErnst$erl$Erl$extractPort(str),
            protocol: $RomanErnst$erl$Erl$extractProtocol(str),
            query: $RomanErnst$erl$Erl$queryFromAll(str),
            username: ""
        };
    };
    var $author$project$Main$gotCodeFromUrl = function(url) {
        return $elm$core$Maybe$Just(A2($elm$core$String$join, "", A2($RomanErnst$erl$Erl$getQueryValuesForKey, "code", $RomanErnst$erl$Erl$parse($elm$url$Url$toString(url)))));
    };
    var $author$project$Pages$Buy$Buy = function(a) {
        return {
            $: "Buy",
            a: a
        };
    };
    var $author$project$Pages$Buy$Loading = {
        $: "Loading"
    };
    var $author$project$Pages$Buy$initialModel = {
        root: $author$project$Pages$Buy$Buy({
            name: "Loading..."
        }),
        status: $author$project$Pages$Buy$Loading,
        title: "Buy"
    };
    var $author$project$Pages$Buy$init = function(_v0) {
        return _Utils_Tuple2(_Utils_update($author$project$Pages$Buy$initialModel, {
            title: "Haveno-Web Buy"
        }), $elm$core$Platform$Cmd$none);
    };
    var $author$project$Pages$Dashboard$Dashboard = function(a) {
        return {
            $: "Dashboard",
            a: a
        };
    };
    var $author$project$Pages$Dashboard$HavenoAPKHttpRequest = F6(function(method, headers, url, body, timeout, tracker) {
        return {
            body: body,
            headers: headers,
            method: method,
            timeout: timeout,
            tracker: tracker,
            url: url
        };
    });
    var $author$project$Pages$Dashboard$Loading = {
        $: "Loading"
    };
    var $author$project$Pages$Dashboard$Model = F8(function(status, title, root, balance, flagUrl, havenoAPKHttpRequest, version, errors) {
        return {
            balance: balance,
            errors: errors,
            flagUrl: flagUrl,
            havenoAPKHttpRequest: havenoAPKHttpRequest,
            root: root,
            status: status,
            title: title,
            version: version
        };
    });
    var $elm$http$Http$BadStatus_ = F2(function(a, b) {
        return {
            $: "BadStatus_",
            a: a,
            b: b
        };
    });
    var $elm$http$Http$BadUrl_ = function(a) {
        return {
            $: "BadUrl_",
            a: a
        };
    };
    var $elm$http$Http$GoodStatus_ = F2(function(a, b) {
        return {
            $: "GoodStatus_",
            a: a,
            b: b
        };
    });
    var $elm$http$Http$NetworkError_ = {
        $: "NetworkError_"
    };
    var $elm$http$Http$Receiving = function(a) {
        return {
            $: "Receiving",
            a: a
        };
    };
    var $elm$http$Http$Sending = function(a) {
        return {
            $: "Sending",
            a: a
        };
    };
    var $elm$http$Http$Timeout_ = {
        $: "Timeout_"
    };
    var $elm$core$Maybe$isJust = function(maybe) {
        if (maybe.$ === "Just") return true;
        else return false;
    };
    var $elm$core$Platform$sendToSelf = _Platform_sendToSelf;
    var $elm$http$Http$emptyBody = _Http_emptyBody;
    var $author$project$Extras$Constants$localorproductionServerAutoCheck = "haveno-web.squashpassion";
    var $author$project$Extras$Constants$middleWarePath = "/middleware";
    var $author$project$Extras$Constants$post = "POST";
    var $author$project$Extras$Constants$productionProxyConfig = "/proxy/";
    var $author$project$Pages$Dashboard$GotVersion = function(a) {
        return {
            $: "GotVersion",
            a: a
        };
    };
    var $anmolitor$elm_grpc$Grpc$InternalRpcRequest = function(a) {
        return {
            $: "InternalRpcRequest",
            a: a
        };
    };
    var $elm$http$Http$Header = F2(function(a, b) {
        return {
            $: "Header",
            a: a,
            b: b
        };
    });
    var $elm$http$Http$header = $elm$http$Http$Header;
    var $anmolitor$elm_grpc$Grpc$addHeader = F3(function(key, value, _v0) {
        var req = _v0.a;
        return $anmolitor$elm_grpc$Grpc$InternalRpcRequest(_Utils_update(req, {
            headers: A2($elm$core$List$cons, A2($elm$http$Http$header, key, value), req.headers)
        }));
    });
    var $anmolitor$elm_grpc$Grpc$Internal$Rpc = function(a) {
        return {
            $: "Rpc",
            a: a
        };
    };
    var $author$project$Proto$Io$Haveno$Protobuffer$Internals_$defaultProto__Io__Haveno__Protobuffer__GetVersionReply = {
        version: ""
    };
    var $eriktim$elm_protocol_buffers$Protobuf$Decode$Decoder = function(a) {
        return {
            $: "Decoder",
            a: a
        };
    };
    var $elm$bytes$Bytes$Encode$getWidth = function(builder) {
        switch(builder.$){
            case "I8":
                return 1;
            case "I16":
                return 2;
            case "I32":
                return 4;
            case "U8":
                return 1;
            case "U16":
                return 2;
            case "U32":
                return 4;
            case "F32":
                return 4;
            case "F64":
                return 8;
            case "Seq":
                var w = builder.a;
                return w;
            case "Utf8":
                var w = builder.a;
                return w;
            default:
                var bs = builder.a;
                return _Bytes_width(bs);
        }
    };
    var $elm$bytes$Bytes$LE = {
        $: "LE"
    };
    var $elm$bytes$Bytes$Encode$write = F3(function(builder, mb, offset) {
        switch(builder.$){
            case "I8":
                var n = builder.a;
                return A3(_Bytes_write_i8, mb, offset, n);
            case "I16":
                var e = builder.a;
                var n = builder.b;
                return A4(_Bytes_write_i16, mb, offset, n, _Utils_eq(e, $elm$bytes$Bytes$LE));
            case "I32":
                var e = builder.a;
                var n = builder.b;
                return A4(_Bytes_write_i32, mb, offset, n, _Utils_eq(e, $elm$bytes$Bytes$LE));
            case "U8":
                var n = builder.a;
                return A3(_Bytes_write_u8, mb, offset, n);
            case "U16":
                var e = builder.a;
                var n = builder.b;
                return A4(_Bytes_write_u16, mb, offset, n, _Utils_eq(e, $elm$bytes$Bytes$LE));
            case "U32":
                var e = builder.a;
                var n = builder.b;
                return A4(_Bytes_write_u32, mb, offset, n, _Utils_eq(e, $elm$bytes$Bytes$LE));
            case "F32":
                var e = builder.a;
                var n = builder.b;
                return A4(_Bytes_write_f32, mb, offset, n, _Utils_eq(e, $elm$bytes$Bytes$LE));
            case "F64":
                var e = builder.a;
                var n = builder.b;
                return A4(_Bytes_write_f64, mb, offset, n, _Utils_eq(e, $elm$bytes$Bytes$LE));
            case "Seq":
                var bs = builder.b;
                return A3($elm$bytes$Bytes$Encode$writeSequence, bs, mb, offset);
            case "Utf8":
                var s = builder.b;
                return A3(_Bytes_write_string, mb, offset, s);
            default:
                var bs = builder.a;
                return A3(_Bytes_write_bytes, mb, offset, bs);
        }
    });
    var $elm$bytes$Bytes$Encode$writeSequence = F3(function(builders, mb, offset) {
        writeSequence: while(true){
            if (!builders.b) return offset;
            else {
                var b = builders.a;
                var bs = builders.b;
                var $temp$builders = bs, $temp$mb = mb, $temp$offset = A3($elm$bytes$Bytes$Encode$write, b, mb, offset);
                builders = $temp$builders;
                mb = $temp$mb;
                offset = $temp$offset;
                continue writeSequence;
            }
        }
    });
    var $elm$bytes$Bytes$Decode$Decoder = function(a) {
        return {
            $: "Decoder",
            a: a
        };
    };
    var $elm$bytes$Bytes$Decode$fail = $elm$bytes$Bytes$Decode$Decoder(_Bytes_decodeFailure);
    var $elm$core$Set$Set_elm_builtin = function(a) {
        return {
            $: "Set_elm_builtin",
            a: a
        };
    };
    var $elm$core$Set$empty = $elm$core$Set$Set_elm_builtin($elm$core$Dict$empty);
    var $elm$core$Set$insert = F2(function(key, _v0) {
        var dict = _v0.a;
        return $elm$core$Set$Set_elm_builtin(A3($elm$core$Dict$insert, key, _Utils_Tuple0, dict));
    });
    var $elm$core$Set$fromList = function(list) {
        return A3($elm$core$List$foldl, $elm$core$Set$insert, $elm$core$Set$empty, list);
    };
    var $elm$bytes$Bytes$Decode$loopHelp = F4(function(state, callback, bites, offset) {
        loopHelp: while(true){
            var _v0 = callback(state);
            var decoder = _v0.a;
            var _v1 = A2(decoder, bites, offset);
            var newOffset = _v1.a;
            var step = _v1.b;
            if (step.$ === "Loop") {
                var newState = step.a;
                var $temp$state = newState, $temp$callback = callback, $temp$bites = bites, $temp$offset = newOffset;
                state = $temp$state;
                callback = $temp$callback;
                bites = $temp$bites;
                offset = $temp$offset;
                continue loopHelp;
            } else {
                var result = step.a;
                return _Utils_Tuple2(newOffset, result);
            }
        }
    });
    var $elm$bytes$Bytes$Decode$loop = F2(function(state, callback) {
        return $elm$bytes$Bytes$Decode$Decoder(A2($elm$bytes$Bytes$Decode$loopHelp, state, callback));
    });
    var $elm$core$Tuple$mapFirst = F2(function(func, _v0) {
        var x = _v0.a;
        var y = _v0.b;
        return _Utils_Tuple2(func(x), y);
    });
    var $elm$core$Tuple$mapSecond = F2(function(func, _v0) {
        var x = _v0.a;
        var y = _v0.b;
        return _Utils_Tuple2(x, func(y));
    });
    var $elm$bytes$Bytes$Decode$Done = function(a) {
        return {
            $: "Done",
            a: a
        };
    };
    var $elm$bytes$Bytes$Decode$Loop = function(a) {
        return {
            $: "Loop",
            a: a
        };
    };
    var $elm$bytes$Bytes$Decode$andThen = F2(function(callback, _v0) {
        var decodeA = _v0.a;
        return $elm$bytes$Bytes$Decode$Decoder(F2(function(bites, offset) {
            var _v1 = A2(decodeA, bites, offset);
            var newOffset = _v1.a;
            var a = _v1.b;
            var _v2 = callback(a);
            var decodeB = _v2.a;
            return A2(decodeB, bites, newOffset);
        }));
    });
    var $elm$core$Set$isEmpty = function(_v0) {
        var dict = _v0.a;
        return $elm$core$Dict$isEmpty(dict);
    };
    var $elm$bytes$Bytes$Decode$map = F2(function(func, _v0) {
        var decodeA = _v0.a;
        return $elm$bytes$Bytes$Decode$Decoder(F2(function(bites, offset) {
            var _v1 = A2(decodeA, bites, offset);
            var aOffset = _v1.a;
            var a = _v1.b;
            return _Utils_Tuple2(aOffset, func(a));
        }));
    });
    var $elm$core$Set$remove = F2(function(key, _v0) {
        var dict = _v0.a;
        return $elm$core$Set$Set_elm_builtin(A2($elm$core$Dict$remove, key, dict));
    });
    var $elm$bytes$Bytes$Decode$succeed = function(a) {
        return $elm$bytes$Bytes$Decode$Decoder(F2(function(_v0, offset) {
            return _Utils_Tuple2(offset, a);
        }));
    };
    var $eriktim$elm_protocol_buffers$Internal$Protobuf$Bit32 = {
        $: "Bit32"
    };
    var $eriktim$elm_protocol_buffers$Internal$Protobuf$Bit64 = {
        $: "Bit64"
    };
    var $eriktim$elm_protocol_buffers$Internal$Protobuf$EndGroup = {
        $: "EndGroup"
    };
    var $eriktim$elm_protocol_buffers$Internal$Protobuf$LengthDelimited = function(a) {
        return {
            $: "LengthDelimited",
            a: a
        };
    };
    var $eriktim$elm_protocol_buffers$Internal$Protobuf$StartGroup = {
        $: "StartGroup"
    };
    var $eriktim$elm_protocol_buffers$Internal$Protobuf$VarInt = {
        $: "VarInt"
    };
    var $elm$core$Basics$pow = _Basics_pow;
    var $eriktim$elm_protocol_buffers$Internal$Int32$fromSigned = function(value) {
        return value < 0 ? value + A2($elm$core$Basics$pow, 2, 32) : value;
    };
    var $elm$core$Bitwise$xor = _Bitwise_xor;
    var $eriktim$elm_protocol_buffers$Internal$Int32$fromZigZag = function(value) {
        return value >>> 1 ^ -1 * (1 & value);
    };
    var $eriktim$elm_protocol_buffers$Internal$Int32$popBase128 = function(value) {
        var higherBits = value >>> 7;
        var base128 = 127 & value;
        return _Utils_Tuple2(base128, higherBits);
    };
    var $eriktim$elm_protocol_buffers$Internal$Int32$pushBase128 = F2(function(base128, _int) {
        return base128 + (_int << 7);
    });
    var $eriktim$elm_protocol_buffers$Internal$Int32$toSigned = function(value) {
        return _Utils_cmp(value, A2($elm$core$Basics$pow, 2, 31)) > -1 ? value - A2($elm$core$Basics$pow, 2, 32) : value;
    };
    var $elm$core$Bitwise$shiftRightBy = _Bitwise_shiftRightBy;
    var $eriktim$elm_protocol_buffers$Internal$Int32$toZigZag = function(value) {
        return value >> 31 ^ value << 1;
    };
    var $eriktim$elm_protocol_buffers$Internal$Int32$operations = {
        fromBase128: $elm$core$Basics$identity,
        fromSigned: $eriktim$elm_protocol_buffers$Internal$Int32$fromSigned,
        fromZigZag: $eriktim$elm_protocol_buffers$Internal$Int32$fromZigZag,
        popBase128: $eriktim$elm_protocol_buffers$Internal$Int32$popBase128,
        pushBase128: $eriktim$elm_protocol_buffers$Internal$Int32$pushBase128,
        toSigned: $eriktim$elm_protocol_buffers$Internal$Int32$toSigned,
        toZigZag: $eriktim$elm_protocol_buffers$Internal$Int32$toZigZag
    };
    var $elm$bytes$Bytes$Decode$unsignedInt8 = $elm$bytes$Bytes$Decode$Decoder(_Bytes_read_u8);
    var $eriktim$elm_protocol_buffers$Protobuf$Decode$varIntDecoder = function(config) {
        return A2($elm$bytes$Bytes$Decode$andThen, function(octet) {
            return (128 & octet) === 128 ? A2($elm$bytes$Bytes$Decode$map, function(_v0) {
                var usedBytes = _v0.a;
                var value = _v0.b;
                return _Utils_Tuple2(usedBytes + 1, A2(config.pushBase128, 127 & octet, value));
            }, $eriktim$elm_protocol_buffers$Protobuf$Decode$varIntDecoder(config)) : $elm$bytes$Bytes$Decode$succeed(_Utils_Tuple2(1, config.fromBase128(octet)));
        }, $elm$bytes$Bytes$Decode$unsignedInt8);
    };
    var $eriktim$elm_protocol_buffers$Protobuf$Decode$tagDecoder = A2($elm$bytes$Bytes$Decode$andThen, function(_v0) {
        var usedBytes = _v0.a;
        var value = _v0.b;
        var fieldNumber = value >>> 3;
        return A2($elm$bytes$Bytes$Decode$map, function(_v1) {
            var n = _v1.a;
            var wireType = _v1.b;
            return _Utils_Tuple2(usedBytes + n, _Utils_Tuple2(fieldNumber, wireType));
        }, function() {
            var _v2 = 7 & value;
            switch(_v2){
                case 0:
                    return $elm$bytes$Bytes$Decode$succeed(_Utils_Tuple2(0, $eriktim$elm_protocol_buffers$Internal$Protobuf$VarInt));
                case 1:
                    return $elm$bytes$Bytes$Decode$succeed(_Utils_Tuple2(0, $eriktim$elm_protocol_buffers$Internal$Protobuf$Bit64));
                case 2:
                    return A2($elm$bytes$Bytes$Decode$map, $elm$core$Tuple$mapSecond($eriktim$elm_protocol_buffers$Internal$Protobuf$LengthDelimited), $eriktim$elm_protocol_buffers$Protobuf$Decode$varIntDecoder($eriktim$elm_protocol_buffers$Internal$Int32$operations));
                case 3:
                    return $elm$bytes$Bytes$Decode$succeed(_Utils_Tuple2(0, $eriktim$elm_protocol_buffers$Internal$Protobuf$StartGroup));
                case 4:
                    return $elm$bytes$Bytes$Decode$succeed(_Utils_Tuple2(0, $eriktim$elm_protocol_buffers$Internal$Protobuf$EndGroup));
                case 5:
                    return $elm$bytes$Bytes$Decode$succeed(_Utils_Tuple2(0, $eriktim$elm_protocol_buffers$Internal$Protobuf$Bit32));
                default:
                    return $elm$bytes$Bytes$Decode$fail;
            }
        }());
    }, $eriktim$elm_protocol_buffers$Protobuf$Decode$varIntDecoder($eriktim$elm_protocol_buffers$Internal$Int32$operations));
    var $elm$bytes$Bytes$Decode$bytes = function(n) {
        return $elm$bytes$Bytes$Decode$Decoder(_Bytes_read_bytes(n));
    };
    var $eriktim$elm_protocol_buffers$Protobuf$Decode$unknownFieldDecoder = function(wireType) {
        switch(wireType.$){
            case "VarInt":
                return A2($elm$bytes$Bytes$Decode$map, $elm$core$Tuple$first, $eriktim$elm_protocol_buffers$Protobuf$Decode$varIntDecoder($eriktim$elm_protocol_buffers$Internal$Int32$operations));
            case "Bit64":
                return A2($elm$bytes$Bytes$Decode$map, $elm$core$Basics$always(8), $elm$bytes$Bytes$Decode$bytes(8));
            case "LengthDelimited":
                var width = wireType.a;
                return A2($elm$bytes$Bytes$Decode$map, $elm$core$Basics$always(width), $elm$bytes$Bytes$Decode$bytes(width));
            case "StartGroup":
                return $elm$bytes$Bytes$Decode$fail;
            case "EndGroup":
                return $elm$bytes$Bytes$Decode$fail;
            default:
                return A2($elm$bytes$Bytes$Decode$map, $elm$core$Basics$always(4), $elm$bytes$Bytes$Decode$bytes(4));
        }
    };
    var $eriktim$elm_protocol_buffers$Protobuf$Decode$stepMessage = F2(function(width, state) {
        return state.width <= 0 ? $elm$core$Set$isEmpty(state.requiredFieldNumbers) ? $elm$bytes$Bytes$Decode$succeed($elm$bytes$Bytes$Decode$Done(_Utils_Tuple2(width, state.model))) : $elm$bytes$Bytes$Decode$fail : A2($elm$bytes$Bytes$Decode$andThen, function(_v0) {
            var usedBytes = _v0.a;
            var _v1 = _v0.b;
            var fieldNumber = _v1.a;
            var wireType = _v1.b;
            var _v2 = A2($elm$core$Dict$get, fieldNumber, state.dict);
            if (_v2.$ === "Just") {
                var decoder = _v2.a.a;
                return A2($elm$bytes$Bytes$Decode$map, function(_v3) {
                    var n = _v3.a;
                    var fn = _v3.b;
                    return $elm$bytes$Bytes$Decode$Loop(_Utils_update(state, {
                        model: fn(state.model),
                        requiredFieldNumbers: A2($elm$core$Set$remove, fieldNumber, state.requiredFieldNumbers),
                        width: state.width - usedBytes - n
                    }));
                }, decoder(wireType));
            } else return A2($elm$bytes$Bytes$Decode$map, function(n) {
                return $elm$bytes$Bytes$Decode$Loop(_Utils_update(state, {
                    width: state.width - usedBytes - n
                }));
            }, $eriktim$elm_protocol_buffers$Protobuf$Decode$unknownFieldDecoder(wireType));
        }, $eriktim$elm_protocol_buffers$Protobuf$Decode$tagDecoder);
    });
    var $eriktim$elm_protocol_buffers$Protobuf$Decode$message = F2(function(v, fieldDecoders) {
        var _v0 = A2($elm$core$Tuple$mapSecond, $elm$core$Dict$fromList, A2($elm$core$Tuple$mapFirst, $elm$core$Set$fromList, A3($elm$core$List$foldr, F2(function(_v1, _v2) {
            var isRequired = _v1.a;
            var items = _v1.b;
            var numbers = _v2.a;
            var decoders = _v2.b;
            var numbers_ = isRequired ? _Utils_ap(numbers, A2($elm$core$List$map, $elm$core$Tuple$first, items)) : numbers;
            return _Utils_Tuple2(numbers_, _Utils_ap(items, decoders));
        }), _Utils_Tuple2(_List_Nil, _List_Nil), fieldDecoders)));
        var requiredSet = _v0.a;
        var dict = _v0.b;
        return $eriktim$elm_protocol_buffers$Protobuf$Decode$Decoder(function(wireType) {
            if (wireType.$ === "LengthDelimited") {
                var width = wireType.a;
                return A2($elm$bytes$Bytes$Decode$loop, {
                    dict: dict,
                    model: v,
                    requiredFieldNumbers: requiredSet,
                    width: width
                }, $eriktim$elm_protocol_buffers$Protobuf$Decode$stepMessage(width));
            } else return $elm$bytes$Bytes$Decode$fail;
        });
    });
    var $eriktim$elm_protocol_buffers$Protobuf$Decode$FieldDecoder = F2(function(a, b) {
        return {
            $: "FieldDecoder",
            a: a,
            b: b
        };
    });
    var $eriktim$elm_protocol_buffers$Protobuf$Decode$map = F2(function(fn, _v0) {
        var decoder = _v0.a;
        return $eriktim$elm_protocol_buffers$Protobuf$Decode$Decoder(function(wireType) {
            return A2($elm$bytes$Bytes$Decode$map, $elm$core$Tuple$mapSecond(fn), decoder(wireType));
        });
    });
    var $eriktim$elm_protocol_buffers$Protobuf$Decode$optional = F3(function(fieldNumber, decoder, set) {
        return A2($eriktim$elm_protocol_buffers$Protobuf$Decode$FieldDecoder, false, _List_fromArray([
            _Utils_Tuple2(fieldNumber, A2($eriktim$elm_protocol_buffers$Protobuf$Decode$map, set, decoder))
        ]));
    });
    var $elm$core$Tuple$pair = F2(function(a, b) {
        return _Utils_Tuple2(a, b);
    });
    var $eriktim$elm_protocol_buffers$Protobuf$Decode$lengthDelimitedDecoder = function(decoder) {
        return $eriktim$elm_protocol_buffers$Protobuf$Decode$Decoder(function(wireType) {
            if (wireType.$ === "LengthDelimited") {
                var width = wireType.a;
                return A2($elm$bytes$Bytes$Decode$map, $elm$core$Tuple$pair(width), decoder(width));
            } else return $elm$bytes$Bytes$Decode$fail;
        });
    };
    var $elm$bytes$Bytes$Decode$string = function(n) {
        return $elm$bytes$Bytes$Decode$Decoder(_Bytes_read_string(n));
    };
    var $eriktim$elm_protocol_buffers$Protobuf$Decode$string = $eriktim$elm_protocol_buffers$Protobuf$Decode$lengthDelimitedDecoder($elm$bytes$Bytes$Decode$string);
    var $author$project$Proto$Io$Haveno$Protobuffer$Internals_$decodeProto__Io__Haveno__Protobuffer__GetVersionReply = A2($eriktim$elm_protocol_buffers$Protobuf$Decode$message, $author$project$Proto$Io$Haveno$Protobuffer$Internals_$defaultProto__Io__Haveno__Protobuffer__GetVersionReply, _List_fromArray([
        A3($eriktim$elm_protocol_buffers$Protobuf$Decode$optional, 1, $eriktim$elm_protocol_buffers$Protobuf$Decode$string, F2(function(a, r) {
            return _Utils_update(r, {
                version: a
            });
        }))
    ]));
    var $author$project$Proto$Io$Haveno$Protobuffer$decodeGetVersionReply = $author$project$Proto$Io$Haveno$Protobuffer$Internals_$decodeProto__Io__Haveno__Protobuffer__GetVersionReply;
    var $eriktim$elm_protocol_buffers$Protobuf$Encode$Encoder = F2(function(a, b) {
        return {
            $: "Encoder",
            a: a,
            b: b
        };
    });
    var $elm$bytes$Bytes$Encode$Seq = F2(function(a, b) {
        return {
            $: "Seq",
            a: a,
            b: b
        };
    });
    var $elm$bytes$Bytes$Encode$getWidths = F2(function(width, builders) {
        getWidths: while(true){
            if (!builders.b) return width;
            else {
                var b = builders.a;
                var bs = builders.b;
                var $temp$width = width + $elm$bytes$Bytes$Encode$getWidth(b), $temp$builders = bs;
                width = $temp$width;
                builders = $temp$builders;
                continue getWidths;
            }
        }
    });
    var $elm$bytes$Bytes$Encode$sequence = function(builders) {
        return A2($elm$bytes$Bytes$Encode$Seq, A2($elm$bytes$Bytes$Encode$getWidths, 0, builders), builders);
    };
    var $elm$core$List$sum = function(numbers) {
        return A3($elm$core$List$foldl, $elm$core$Basics$add, 0, numbers);
    };
    var $eriktim$elm_protocol_buffers$Protobuf$Encode$sequence = function(items) {
        var width = $elm$core$List$sum(A2($elm$core$List$map, $elm$core$Tuple$first, items));
        return _Utils_Tuple2(width, $elm$bytes$Bytes$Encode$sequence(A2($elm$core$List$map, $elm$core$Tuple$second, items)));
    };
    var $elm$core$List$sortBy = _List_sortBy;
    var $elm$core$Bitwise$or = _Bitwise_or;
    var $elm$bytes$Bytes$Encode$U8 = function(a) {
        return {
            $: "U8",
            a: a
        };
    };
    var $elm$bytes$Bytes$Encode$unsignedInt8 = $elm$bytes$Bytes$Encode$U8;
    var $eriktim$elm_protocol_buffers$Protobuf$Encode$toVarIntEncoders = F2(function(config, value) {
        var _v0 = config.popBase128(value);
        var base128 = _v0.a;
        var higherBits = _v0.b;
        return _Utils_eq(higherBits, config.fromBase128(0)) ? _List_fromArray([
            $elm$bytes$Bytes$Encode$unsignedInt8(base128)
        ]) : A2($elm$core$List$cons, $elm$bytes$Bytes$Encode$unsignedInt8(128 | base128), A2($eriktim$elm_protocol_buffers$Protobuf$Encode$toVarIntEncoders, config, higherBits));
    });
    var $eriktim$elm_protocol_buffers$Protobuf$Encode$varInt = F2(function(config, value) {
        var encoders = A2($eriktim$elm_protocol_buffers$Protobuf$Encode$toVarIntEncoders, config, value);
        return _Utils_Tuple2($elm$core$List$length(encoders), $elm$bytes$Bytes$Encode$sequence(encoders));
    });
    var $eriktim$elm_protocol_buffers$Protobuf$Encode$varInt32 = $eriktim$elm_protocol_buffers$Protobuf$Encode$varInt($eriktim$elm_protocol_buffers$Internal$Int32$operations);
    var $eriktim$elm_protocol_buffers$Protobuf$Encode$tag = F2(function(fieldNumber, wireType) {
        var encodeTag = function(base4) {
            return $eriktim$elm_protocol_buffers$Protobuf$Encode$varInt32(fieldNumber << 3 | base4);
        };
        switch(wireType.$){
            case "VarInt":
                return encodeTag(0);
            case "Bit64":
                return encodeTag(1);
            case "LengthDelimited":
                var width = wireType.a;
                return $eriktim$elm_protocol_buffers$Protobuf$Encode$sequence(_List_fromArray([
                    encodeTag(2),
                    $eriktim$elm_protocol_buffers$Protobuf$Encode$varInt32(width)
                ]));
            case "StartGroup":
                return encodeTag(3);
            case "EndGroup":
                return encodeTag(4);
            default:
                return encodeTag(5);
        }
    });
    var $eriktim$elm_protocol_buffers$Protobuf$Encode$unwrap = function(encoder) {
        if (encoder.$ === "Encoder") {
            var encoder_ = encoder.b;
            return $elm$core$Maybe$Just(encoder_);
        } else return $elm$core$Maybe$Nothing;
    };
    var $eriktim$elm_protocol_buffers$Protobuf$Encode$toPackedEncoder = function(encoders) {
        if (encoders.b && encoders.a.$ === "Encoder") {
            var _v1 = encoders.a;
            var wireType = _v1.a;
            var encoder = _v1.b;
            var others = encoders.b;
            if (wireType.$ === "LengthDelimited") return $elm$core$Maybe$Nothing;
            else return $elm$core$Maybe$Just($eriktim$elm_protocol_buffers$Protobuf$Encode$sequence(A2($elm$core$List$cons, encoder, A2($elm$core$List$filterMap, $eriktim$elm_protocol_buffers$Protobuf$Encode$unwrap, others))));
        } else return $elm$core$Maybe$Nothing;
    };
    var $eriktim$elm_protocol_buffers$Protobuf$Encode$toKeyValuePairEncoder = function(_v0) {
        var fieldNumber = _v0.a;
        var encoder = _v0.b;
        switch(encoder.$){
            case "Encoder":
                var wireType = encoder.a;
                var encoder_ = encoder.b;
                return $eriktim$elm_protocol_buffers$Protobuf$Encode$sequence(_List_fromArray([
                    A2($eriktim$elm_protocol_buffers$Protobuf$Encode$tag, fieldNumber, wireType),
                    encoder_
                ]));
            case "ListEncoder":
                var encoders = encoder.a;
                var _v2 = $eriktim$elm_protocol_buffers$Protobuf$Encode$toPackedEncoder(encoders);
                if (_v2.$ === "Just") {
                    var encoder_ = _v2.a;
                    return $eriktim$elm_protocol_buffers$Protobuf$Encode$sequence(_List_fromArray([
                        A2($eriktim$elm_protocol_buffers$Protobuf$Encode$tag, fieldNumber, $eriktim$elm_protocol_buffers$Internal$Protobuf$LengthDelimited(encoder_.a)),
                        encoder_
                    ]));
                } else return $eriktim$elm_protocol_buffers$Protobuf$Encode$sequence(A2($elm$core$List$map, A2($elm$core$Basics$composeL, $eriktim$elm_protocol_buffers$Protobuf$Encode$toKeyValuePairEncoder, $elm$core$Tuple$pair(fieldNumber)), encoders));
            default:
                return $eriktim$elm_protocol_buffers$Protobuf$Encode$sequence(_List_Nil);
        }
    };
    var $eriktim$elm_protocol_buffers$Protobuf$Encode$message = function(items) {
        return function(e) {
            return A2($eriktim$elm_protocol_buffers$Protobuf$Encode$Encoder, $eriktim$elm_protocol_buffers$Internal$Protobuf$LengthDelimited(e.a), e);
        }($eriktim$elm_protocol_buffers$Protobuf$Encode$sequence(A2($elm$core$List$map, $eriktim$elm_protocol_buffers$Protobuf$Encode$toKeyValuePairEncoder, A2($elm$core$List$sortBy, $elm$core$Tuple$first, items))));
    };
    var $author$project$Proto$Io$Haveno$Protobuffer$Internals_$encodeProto__Io__Haveno__Protobuffer__GetVersionRequest = function(_v0) {
        return $eriktim$elm_protocol_buffers$Protobuf$Encode$message(_List_Nil);
    };
    var $author$project$Proto$Io$Haveno$Protobuffer$encodeGetVersionRequest = $author$project$Proto$Io$Haveno$Protobuffer$Internals_$encodeProto__Io__Haveno__Protobuffer__GetVersionRequest;
    var $author$project$Proto$Io$Haveno$Protobuffer$GetVersion$getVersion = $anmolitor$elm_grpc$Grpc$Internal$Rpc({
        decoder: $author$project$Proto$Io$Haveno$Protobuffer$decodeGetVersionReply,
        encoder: $author$project$Proto$Io$Haveno$Protobuffer$encodeGetVersionRequest,
        _package: "io.haveno.protobuffer",
        rpcName: "GetVersion",
        service: "GetVersion"
    });
    var $anmolitor$elm_grpc$Grpc$grpcContentType = "application/grpc-web+proto";
    var $anmolitor$elm_grpc$Grpc$new = F2(function(rpc, req) {
        return $anmolitor$elm_grpc$Grpc$InternalRpcRequest({
            body: req,
            headers: _List_fromArray([
                A2($elm$http$Http$header, "accept", $anmolitor$elm_grpc$Grpc$grpcContentType)
            ]),
            host: "",
            risky: false,
            rpc: rpc,
            timeout: $elm$core$Maybe$Nothing,
            tracker: $elm$core$Maybe$Nothing
        });
    });
    var $anmolitor$elm_grpc$Grpc$setHost = F2(function(host, _v0) {
        var req = _v0.a;
        return $anmolitor$elm_grpc$Grpc$InternalRpcRequest(_Utils_update(req, {
            host: host
        }));
    });
    var $elm$http$Http$bytesBody = _Http_pair;
    var $elm$bytes$Bytes$Encode$Bytes = function(a) {
        return {
            $: "Bytes",
            a: a
        };
    };
    var $elm$bytes$Bytes$Encode$bytes = $elm$bytes$Bytes$Encode$Bytes;
    var $elm$bytes$Bytes$Encode$encode = _Bytes_encode;
    var $eriktim$elm_protocol_buffers$Protobuf$Encode$encode = function(encoder) {
        switch(encoder.$){
            case "Encoder":
                var _v1 = encoder.b;
                var encoder_ = _v1.b;
                return $elm$bytes$Bytes$Encode$encode(encoder_);
            case "ListEncoder":
                var encoders = encoder.a;
                return $elm$bytes$Bytes$Encode$encode($elm$bytes$Bytes$Encode$sequence(A2($elm$core$List$map, A2($elm$core$Basics$composeL, $elm$bytes$Bytes$Encode$bytes, $eriktim$elm_protocol_buffers$Protobuf$Encode$encode), encoders)));
            default:
                return $elm$bytes$Bytes$Encode$encode($elm$bytes$Bytes$Encode$sequence(_List_Nil));
        }
    };
    var $elm$http$Http$expectBytesResponse = F2(function(toMsg, toResult) {
        return A3(_Http_expect, "arraybuffer", _Http_toDataView, A2($elm$core$Basics$composeR, toResult, toMsg));
    });
    var $elm$bytes$Bytes$BE = {
        $: "BE"
    };
    var $elm$bytes$Bytes$Encode$U32 = F2(function(a, b) {
        return {
            $: "U32",
            a: a,
            b: b
        };
    });
    var $elm$bytes$Bytes$Encode$unsignedInt32 = $elm$bytes$Bytes$Encode$U32;
    var $elm$bytes$Bytes$width = _Bytes_width;
    var $anmolitor$elm_grpc$Grpc$requestEncoder = function(message) {
        var messageLength = $elm$bytes$Bytes$width(message);
        return $elm$bytes$Bytes$Encode$sequence(_List_fromArray([
            $elm$bytes$Bytes$Encode$unsignedInt8(0),
            A2($elm$bytes$Bytes$Encode$unsignedInt32, $elm$bytes$Bytes$BE, messageLength),
            $elm$bytes$Bytes$Encode$bytes(message)
        ]));
    };
    var $anmolitor$elm_grpc$Grpc$frameRequest = function(binaryData) {
        return $elm$bytes$Bytes$Encode$encode($anmolitor$elm_grpc$Grpc$requestEncoder(binaryData));
    };
    var $anmolitor$elm_grpc$Grpc$BadBody = function(a) {
        return {
            $: "BadBody",
            a: a
        };
    };
    var $anmolitor$elm_grpc$Grpc$BadStatus = function(a) {
        return {
            $: "BadStatus",
            a: a
        };
    };
    var $anmolitor$elm_grpc$Grpc$BadUrl = function(a) {
        return {
            $: "BadUrl",
            a: a
        };
    };
    var $anmolitor$elm_grpc$Grpc$NetworkError = {
        $: "NetworkError"
    };
    var $anmolitor$elm_grpc$Grpc$Ok_ = {
        $: "Ok_"
    };
    var $anmolitor$elm_grpc$Grpc$Timeout = {
        $: "Timeout"
    };
    var $elm$core$Maybe$andThen = F2(function(callback, maybeValue) {
        if (maybeValue.$ === "Just") {
            var value = maybeValue.a;
            return callback(value);
        } else return $elm$core$Maybe$Nothing;
    });
    var $elm$bytes$Bytes$Decode$decode = F2(function(_v0, bs) {
        var decoder = _v0.a;
        return A2(_Bytes_decode, decoder, bs);
    });
    var $eriktim$elm_protocol_buffers$Protobuf$Decode$decode = F2(function(_v0, bs) {
        var decoder = _v0.a;
        var wireType = $eriktim$elm_protocol_buffers$Internal$Protobuf$LengthDelimited($elm$bytes$Bytes$width(bs));
        return A2($elm$core$Maybe$map, $elm$core$Tuple$second, A2($elm$bytes$Bytes$Decode$decode, decoder(wireType), bs));
    });
    var $anmolitor$elm_grpc$Grpc$Aborted = {
        $: "Aborted"
    };
    var $anmolitor$elm_grpc$Grpc$AlreadyExists = {
        $: "AlreadyExists"
    };
    var $anmolitor$elm_grpc$Grpc$Cancelled = {
        $: "Cancelled"
    };
    var $anmolitor$elm_grpc$Grpc$DataLoss = {
        $: "DataLoss"
    };
    var $anmolitor$elm_grpc$Grpc$DeadlineExceeded = {
        $: "DeadlineExceeded"
    };
    var $anmolitor$elm_grpc$Grpc$FailedPrecondition = {
        $: "FailedPrecondition"
    };
    var $anmolitor$elm_grpc$Grpc$Internal = {
        $: "Internal"
    };
    var $anmolitor$elm_grpc$Grpc$InvalidArgument = {
        $: "InvalidArgument"
    };
    var $anmolitor$elm_grpc$Grpc$NotFound = {
        $: "NotFound"
    };
    var $anmolitor$elm_grpc$Grpc$OutOfRange = {
        $: "OutOfRange"
    };
    var $anmolitor$elm_grpc$Grpc$PermissionDenied = {
        $: "PermissionDenied"
    };
    var $anmolitor$elm_grpc$Grpc$ResourceExhausted = {
        $: "ResourceExhausted"
    };
    var $anmolitor$elm_grpc$Grpc$Unauthenticated = {
        $: "Unauthenticated"
    };
    var $anmolitor$elm_grpc$Grpc$Unavailable = {
        $: "Unavailable"
    };
    var $anmolitor$elm_grpc$Grpc$Unimplemented = {
        $: "Unimplemented"
    };
    var $anmolitor$elm_grpc$Grpc$Unknown = {
        $: "Unknown"
    };
    var $anmolitor$elm_grpc$Grpc$errCodeFromInt = function(n) {
        switch(n){
            case 0:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$Ok_);
            case 1:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$Cancelled);
            case 2:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$Unknown);
            case 3:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$InvalidArgument);
            case 4:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$DeadlineExceeded);
            case 5:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$NotFound);
            case 6:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$AlreadyExists);
            case 7:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$PermissionDenied);
            case 8:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$ResourceExhausted);
            case 9:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$FailedPrecondition);
            case 10:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$Aborted);
            case 11:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$OutOfRange);
            case 12:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$Unimplemented);
            case 13:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$Internal);
            case 14:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$Unavailable);
            case 15:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$DataLoss);
            case 16:
                return $elm$core$Maybe$Just($anmolitor$elm_grpc$Grpc$Unauthenticated);
            default:
                return $elm$core$Maybe$Nothing;
        }
    };
    var $elm$core$Result$fromMaybe = F2(function(err, maybe) {
        if (maybe.$ === "Just") {
            var v = maybe.a;
            return $elm$core$Result$Ok(v);
        } else return $elm$core$Result$Err(err);
    });
    var $anmolitor$elm_grpc$Grpc$httpBadStatusToGrpcStatus = function(statusCode) {
        switch(statusCode){
            case 400:
                return $anmolitor$elm_grpc$Grpc$Internal;
            case 401:
                return $anmolitor$elm_grpc$Grpc$Unauthenticated;
            case 403:
                return $anmolitor$elm_grpc$Grpc$PermissionDenied;
            case 404:
                return $anmolitor$elm_grpc$Grpc$Unimplemented;
            case 429:
                return $anmolitor$elm_grpc$Grpc$Unavailable;
            case 502:
                return $anmolitor$elm_grpc$Grpc$Unavailable;
            case 503:
                return $anmolitor$elm_grpc$Grpc$Unavailable;
            case 504:
                return $anmolitor$elm_grpc$Grpc$Unavailable;
            default:
                return $anmolitor$elm_grpc$Grpc$Unknown;
        }
    };
    var $anmolitor$elm_grpc$Grpc$Response = function(message) {
        return {
            message: message
        };
    };
    var $elm$bytes$Bytes$Decode$map2 = F3(function(func, _v0, _v1) {
        var decodeA = _v0.a;
        var decodeB = _v1.a;
        return $elm$bytes$Bytes$Decode$Decoder(F2(function(bites, offset) {
            var _v2 = A2(decodeA, bites, offset);
            var aOffset = _v2.a;
            var a = _v2.b;
            var _v3 = A2(decodeB, bites, aOffset);
            var bOffset = _v3.a;
            var b = _v3.b;
            return _Utils_Tuple2(bOffset, A2(func, a, b));
        }));
    });
    var $elm$bytes$Bytes$Decode$unsignedInt32 = function(endianness) {
        return $elm$bytes$Bytes$Decode$Decoder(_Bytes_read_u32(_Utils_eq(endianness, $elm$bytes$Bytes$LE)));
    };
    var $anmolitor$elm_grpc$Grpc$responseDecoder = A3($elm$bytes$Bytes$Decode$map2, function(_v0) {
        return $anmolitor$elm_grpc$Grpc$Response;
    }, $elm$bytes$Bytes$Decode$bytes(1), A2($elm$bytes$Bytes$Decode$andThen, $elm$bytes$Bytes$Decode$bytes, $elm$bytes$Bytes$Decode$unsignedInt32($elm$bytes$Bytes$BE)));
    var $anmolitor$elm_grpc$Grpc$handleResponse = F2(function(decoder, httpResponse) {
        var parseResponse = F3(function(isGoodStatus, metadata, bytes) {
            var defaultGrpcStatus = isGoodStatus ? $anmolitor$elm_grpc$Grpc$Ok_ : $anmolitor$elm_grpc$Grpc$httpBadStatusToGrpcStatus(metadata.statusCode);
            var grpcStatus = A2($elm$core$Maybe$withDefault, defaultGrpcStatus, A2($elm$core$Maybe$andThen, $anmolitor$elm_grpc$Grpc$errCodeFromInt, A2($elm$core$Maybe$andThen, $elm$core$String$toInt, A2($elm$core$Dict$get, "grpc-status", metadata.headers))));
            if (grpcStatus.$ === "Ok_") return A2($elm$core$Result$fromMaybe, $anmolitor$elm_grpc$Grpc$BadBody(bytes), A2($elm$core$Maybe$andThen, function(response) {
                return A2($eriktim$elm_protocol_buffers$Protobuf$Decode$decode, decoder, response.message);
            }, A2($elm$bytes$Bytes$Decode$decode, $anmolitor$elm_grpc$Grpc$responseDecoder, bytes)));
            else {
                var errMessage = A2($elm$core$Maybe$withDefault, metadata.statusText, A2($elm$core$Dict$get, "grpc-message", metadata.headers));
                return $elm$core$Result$Err($anmolitor$elm_grpc$Grpc$BadStatus({
                    errMessage: errMessage,
                    metadata: metadata,
                    response: bytes,
                    status: grpcStatus
                }));
            }
        });
        switch(httpResponse.$){
            case "GoodStatus_":
                var metadata = httpResponse.a;
                var bytes = httpResponse.b;
                return A3(parseResponse, true, metadata, bytes);
            case "BadUrl_":
                var badUrl = httpResponse.a;
                return $elm$core$Result$Err($anmolitor$elm_grpc$Grpc$BadUrl(badUrl));
            case "Timeout_":
                return $elm$core$Result$Err($anmolitor$elm_grpc$Grpc$Timeout);
            case "NetworkError_":
                return $elm$core$Result$Err($anmolitor$elm_grpc$Grpc$NetworkError);
            default:
                var metadata = httpResponse.a;
                var bytes = httpResponse.b;
                return A3(parseResponse, false, metadata, bytes);
        }
    });
    var $elm$http$Http$Request = function(a) {
        return {
            $: "Request",
            a: a
        };
    };
    var $elm$http$Http$State = F2(function(reqs, subs) {
        return {
            reqs: reqs,
            subs: subs
        };
    });
    var $elm$http$Http$init = $elm$core$Task$succeed(A2($elm$http$Http$State, $elm$core$Dict$empty, _List_Nil));
    var $elm$core$Process$kill = _Scheduler_kill;
    var $elm$core$Process$spawn = _Scheduler_spawn;
    var $elm$http$Http$updateReqs = F3(function(router, cmds, reqs) {
        updateReqs: while(true){
            if (!cmds.b) return $elm$core$Task$succeed(reqs);
            else {
                var cmd = cmds.a;
                var otherCmds = cmds.b;
                if (cmd.$ === "Cancel") {
                    var tracker = cmd.a;
                    var _v2 = A2($elm$core$Dict$get, tracker, reqs);
                    if (_v2.$ === "Nothing") {
                        var $temp$router = router, $temp$cmds = otherCmds, $temp$reqs = reqs;
                        router = $temp$router;
                        cmds = $temp$cmds;
                        reqs = $temp$reqs;
                        continue updateReqs;
                    } else {
                        var pid = _v2.a;
                        return A2($elm$core$Task$andThen, function(_v3) {
                            return A3($elm$http$Http$updateReqs, router, otherCmds, A2($elm$core$Dict$remove, tracker, reqs));
                        }, $elm$core$Process$kill(pid));
                    }
                } else {
                    var req = cmd.a;
                    return A2($elm$core$Task$andThen, function(pid) {
                        var _v4 = req.tracker;
                        if (_v4.$ === "Nothing") return A3($elm$http$Http$updateReqs, router, otherCmds, reqs);
                        else {
                            var tracker = _v4.a;
                            return A3($elm$http$Http$updateReqs, router, otherCmds, A3($elm$core$Dict$insert, tracker, pid, reqs));
                        }
                    }, $elm$core$Process$spawn(A3(_Http_toTask, router, $elm$core$Platform$sendToApp(router), req)));
                }
            }
        }
    });
    var $elm$http$Http$onEffects = F4(function(router, cmds, subs, state) {
        return A2($elm$core$Task$andThen, function(reqs) {
            return $elm$core$Task$succeed(A2($elm$http$Http$State, reqs, subs));
        }, A3($elm$http$Http$updateReqs, router, cmds, state.reqs));
    });
    var $elm$http$Http$maybeSend = F4(function(router, desiredTracker, progress, _v0) {
        var actualTracker = _v0.a;
        var toMsg = _v0.b;
        return _Utils_eq(desiredTracker, actualTracker) ? $elm$core$Maybe$Just(A2($elm$core$Platform$sendToApp, router, toMsg(progress))) : $elm$core$Maybe$Nothing;
    });
    var $elm$http$Http$onSelfMsg = F3(function(router, _v0, state) {
        var tracker = _v0.a;
        var progress = _v0.b;
        return A2($elm$core$Task$andThen, function(_v1) {
            return $elm$core$Task$succeed(state);
        }, $elm$core$Task$sequence(A2($elm$core$List$filterMap, A3($elm$http$Http$maybeSend, router, tracker, progress), state.subs)));
    });
    var $elm$http$Http$Cancel = function(a) {
        return {
            $: "Cancel",
            a: a
        };
    };
    var $elm$http$Http$cmdMap = F2(function(func, cmd) {
        if (cmd.$ === "Cancel") {
            var tracker = cmd.a;
            return $elm$http$Http$Cancel(tracker);
        } else {
            var r = cmd.a;
            return $elm$http$Http$Request({
                allowCookiesFromOtherDomains: r.allowCookiesFromOtherDomains,
                body: r.body,
                expect: A2(_Http_mapExpect, func, r.expect),
                headers: r.headers,
                method: r.method,
                timeout: r.timeout,
                tracker: r.tracker,
                url: r.url
            });
        }
    });
    var $elm$http$Http$MySub = F2(function(a, b) {
        return {
            $: "MySub",
            a: a,
            b: b
        };
    });
    var $elm$http$Http$subMap = F2(function(func, _v0) {
        var tracker = _v0.a;
        var toMsg = _v0.b;
        return A2($elm$http$Http$MySub, tracker, A2($elm$core$Basics$composeR, toMsg, func));
    });
    _Platform_effectManagers["Http"] = _Platform_createManager($elm$http$Http$init, $elm$http$Http$onEffects, $elm$http$Http$onSelfMsg, $elm$http$Http$cmdMap, $elm$http$Http$subMap);
    var $elm$http$Http$command = _Platform_leaf("Http");
    var $elm$http$Http$subscription = _Platform_leaf("Http");
    var $elm$http$Http$request = function(r) {
        return $elm$http$Http$command($elm$http$Http$Request({
            allowCookiesFromOtherDomains: false,
            body: r.body,
            expect: r.expect,
            headers: r.headers,
            method: r.method,
            timeout: r.timeout,
            tracker: r.tracker,
            url: r.url
        }));
    };
    var $elm$http$Http$riskyRequest = function(r) {
        return $elm$http$Http$command($elm$http$Http$Request({
            allowCookiesFromOtherDomains: true,
            body: r.body,
            expect: r.expect,
            headers: r.headers,
            method: r.method,
            timeout: r.timeout,
            tracker: r.tracker,
            url: r.url
        }));
    };
    var $anmolitor$elm_grpc$Grpc$rpcPath = function(_v0) {
        var service = _v0.a.service;
        var _package = _v0.a._package;
        var rpcName = _v0.a.rpcName;
        return "/" + (($elm$core$String$isEmpty(_package) ? "" : _package + ".") + (service + ("/" + rpcName)));
    };
    var $anmolitor$elm_grpc$Grpc$toCmd = F2(function(expect, _v0) {
        var req = _v0.a;
        var toHttpRequest = req.risky ? $elm$http$Http$riskyRequest : $elm$http$Http$request;
        var _v1 = req.rpc;
        var rpc = _v1.a;
        var body = A2($elm$http$Http$bytesBody, $anmolitor$elm_grpc$Grpc$grpcContentType, $anmolitor$elm_grpc$Grpc$frameRequest($eriktim$elm_protocol_buffers$Protobuf$Encode$encode(rpc.encoder(req.body))));
        return toHttpRequest({
            body: body,
            expect: A2($elm$http$Http$expectBytesResponse, expect, $anmolitor$elm_grpc$Grpc$handleResponse(rpc.decoder)),
            headers: req.headers,
            method: "POST",
            timeout: req.timeout,
            tracker: req.tracker,
            url: _Utils_ap(req.host, $anmolitor$elm_grpc$Grpc$rpcPath(req.rpc))
        });
    });
    var $author$project$Pages$Dashboard$sendVersionRequest = function(request) {
        var grpcRequest = A2($anmolitor$elm_grpc$Grpc$setHost, "http://localhost:8080", A3($anmolitor$elm_grpc$Grpc$addHeader, "password", "apitest", A2($anmolitor$elm_grpc$Grpc$new, $author$project$Proto$Io$Haveno$Protobuffer$GetVersion$getVersion, request)));
        return A2($anmolitor$elm_grpc$Grpc$toCmd, $author$project$Pages$Dashboard$GotVersion, grpcRequest);
    };
    var $author$project$Pages$Dashboard$init = function(fromMainToDashboard) {
        var newModel = A8($author$project$Pages$Dashboard$Model, $author$project$Pages$Dashboard$Loading, "Haveno-Web Dashboard", $author$project$Pages$Dashboard$Dashboard({
            name: "Loading..."
        }), "0.00", fromMainToDashboard.flagUrl, $elm$core$Maybe$Just(A6($author$project$Pages$Dashboard$HavenoAPKHttpRequest, $author$project$Extras$Constants$post, _List_Nil, "", $elm$http$Http$emptyBody, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing)), $elm$core$Maybe$Nothing, _List_Nil);
        var devOrProdServer = A2($elm$core$String$contains, $author$project$Extras$Constants$localorproductionServerAutoCheck, fromMainToDashboard.flagUrl.host) ? A6($elm$url$Url$Url, fromMainToDashboard.flagUrl.protocol, fromMainToDashboard.flagUrl.host, $elm$core$Maybe$Nothing, $author$project$Extras$Constants$productionProxyConfig, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing) : A6($elm$url$Url$Url, fromMainToDashboard.flagUrl.protocol, fromMainToDashboard.flagUrl.host, $elm$core$Maybe$Just(3000), $author$project$Extras$Constants$middleWarePath, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing);
        return _Utils_Tuple2(newModel, $author$project$Pages$Dashboard$sendVersionRequest({}));
    };
    var $author$project$Pages$Funds$Funds = function(a) {
        return {
            $: "Funds",
            a: a
        };
    };
    var $author$project$Pages$Funds$Loading = {
        $: "Loading"
    };
    var $author$project$Pages$Funds$initialModel = {
        root: $author$project$Pages$Funds$Funds({
            name: "Loading..."
        }),
        status: $author$project$Pages$Funds$Loading,
        title: "Funds"
    };
    var $author$project$Pages$Funds$init = function(_v0) {
        return _Utils_Tuple2(_Utils_update($author$project$Pages$Funds$initialModel, {
            title: "Haveno-Web Funds"
        }), $elm$core$Platform$Cmd$none);
    };
    var $author$project$Pages$Hardware$Hardware = function(a) {
        return {
            $: "Hardware",
            a: a
        };
    };
    var $author$project$Pages$Hardware$Loaded = {
        $: "Loaded"
    };
    var $author$project$Pages$Hardware$Login = function(a) {
        return {
            $: "Login",
            a: a
        };
    };
    var $author$project$Pages$Hardware$Model = function(status) {
        return function(title) {
            return function(root) {
                return function(flagUrl) {
                    return function(datetimeFromMain) {
                        return function(humanDateTime) {
                            return function(posixTmes) {
                                return function(apiSpecifics) {
                                    return function(queryType) {
                                        return function(toMongoDBMWConfig) {
                                            return function(isValidNewAccessToken) {
                                                return function(isHardwareLNSConnected) {
                                                    return function(isHardwareLNXConnected) {
                                                        return function(isXMRWalletConnected) {
                                                            return function(errors) {
                                                                return function(availableSlots) {
                                                                    return function(isWaitingForResponse) {
                                                                        return function(isReturnUser) {
                                                                            return function(emailpassword) {
                                                                                return function(selectedranking) {
                                                                                    return function(selectedSingleRank) {
                                                                                        return function(user) {
                                                                                            return function(result) {
                                                                                                return function(searchterm) {
                                                                                                    return function(searchResults) {
                                                                                                        return function(objectJSONfromJSPort) {
                                                                                                            return {
                                                                                                                apiSpecifics: apiSpecifics,
                                                                                                                availableSlots: availableSlots,
                                                                                                                datetimeFromMain: datetimeFromMain,
                                                                                                                emailpassword: emailpassword,
                                                                                                                errors: errors,
                                                                                                                flagUrl: flagUrl,
                                                                                                                humanDateTime: humanDateTime,
                                                                                                                isHardwareLNSConnected: isHardwareLNSConnected,
                                                                                                                isHardwareLNXConnected: isHardwareLNXConnected,
                                                                                                                isReturnUser: isReturnUser,
                                                                                                                isValidNewAccessToken: isValidNewAccessToken,
                                                                                                                isWaitingForResponse: isWaitingForResponse,
                                                                                                                isXMRWalletConnected: isXMRWalletConnected,
                                                                                                                objectJSONfromJSPort: objectJSONfromJSPort,
                                                                                                                posixTmes: posixTmes,
                                                                                                                queryType: queryType,
                                                                                                                result: result,
                                                                                                                root: root,
                                                                                                                searchResults: searchResults,
                                                                                                                searchterm: searchterm,
                                                                                                                selectedSingleRank: selectedSingleRank,
                                                                                                                selectedranking: selectedranking,
                                                                                                                status: status,
                                                                                                                title: title,
                                                                                                                toMongoDBMWConfig: toMongoDBMWConfig,
                                                                                                                user: user
                                                                                                            };
                                                                                                        };
                                                                                                    };
                                                                                                };
                                                                                            };
                                                                                        };
                                                                                    };
                                                                                };
                                                                            };
                                                                        };
                                                                    };
                                                                };
                                                            };
                                                        };
                                                    };
                                                };
                                            };
                                        };
                                    };
                                };
                            };
                        };
                    };
                };
            };
        };
    };
    var $author$project$Data$Hardware$None = {
        $: "None"
    };
    var $author$project$Pages$Hardware$ToMongoDBMWConfig = F6(function(method, headers, url, body, timeout, tracker) {
        return {
            body: body,
            headers: headers,
            method: method,
            timeout: timeout,
            tracker: tracker,
            url: url
        };
    });
    var $author$project$Data$Hardware$Undecided = {
        $: "Undecided"
    };
    var $author$project$Pages$Hardware$ApiSpecifics = F2(function(maxResults, accessToken) {
        return {
            accessToken: accessToken,
            maxResults: maxResults
        };
    });
    var $author$project$Pages$Hardware$apiSpecsPlaceHolder = A2($author$project$Pages$Hardware$ApiSpecifics, "", $elm$core$Maybe$Nothing);
    var $author$project$Extras$Constants$emptyEmailPassword = {
        email: "",
        password: ""
    };
    var $author$project$Data$Hardware$emptyRank = {
        challenger: {
            id: "String",
            nickname: "String"
        },
        player: {
            id: "String",
            nickname: "String"
        },
        rank: 0
    };
    var $author$project$Data$User$Spectator = function(a) {
        return {
            $: "Spectator",
            a: a
        };
    };
    var $author$project$Data$User$Male = {
        $: "Male"
    };
    var $author$project$Data$User$UserInfo = function(userid) {
        return function(password) {
            return function(passwordValidationError) {
                return function(token) {
                    return function(nickname) {
                        return function(isNameInputFocused) {
                            return function(nameValidationError) {
                                return function(age) {
                                    return function(gender) {
                                        return function(email) {
                                            return function(isEmailInputFocused) {
                                                return function(emailValidationError) {
                                                    return function(mobile) {
                                                        return function(isMobileInputFocused) {
                                                            return function(mobileValidationError) {
                                                                return function(datestamp) {
                                                                    return function(active) {
                                                                        return function(ownedRankings) {
                                                                            return function(memberRankings) {
                                                                                return function(updatetext) {
                                                                                    return function(description) {
                                                                                        return function(credits) {
                                                                                            return function(addInfo) {
                                                                                                return {
                                                                                                    active: active,
                                                                                                    addInfo: addInfo,
                                                                                                    age: age,
                                                                                                    credits: credits,
                                                                                                    datestamp: datestamp,
                                                                                                    description: description,
                                                                                                    email: email,
                                                                                                    emailValidationError: emailValidationError,
                                                                                                    gender: gender,
                                                                                                    isEmailInputFocused: isEmailInputFocused,
                                                                                                    isMobileInputFocused: isMobileInputFocused,
                                                                                                    isNameInputFocused: isNameInputFocused,
                                                                                                    memberRankings: memberRankings,
                                                                                                    mobile: mobile,
                                                                                                    mobileValidationError: mobileValidationError,
                                                                                                    nameValidationError: nameValidationError,
                                                                                                    nickname: nickname,
                                                                                                    ownedRankings: ownedRankings,
                                                                                                    password: password,
                                                                                                    passwordValidationError: passwordValidationError,
                                                                                                    token: token,
                                                                                                    updatetext: updatetext,
                                                                                                    userid: userid
                                                                                                };
                                                                                            };
                                                                                        };
                                                                                    };
                                                                                };
                                                                            };
                                                                        };
                                                                    };
                                                                };
                                                            };
                                                        };
                                                    };
                                                };
                                            };
                                        };
                                    };
                                };
                            };
                        };
                    };
                };
            };
        };
    };
    var $author$project$Data$User$emptyDescription = {
        comment: "",
        level: ""
    };
    var $author$project$Data$User$emptyUserInfo = $author$project$Data$User$UserInfo("")("")("")($elm$core$Maybe$Nothing)("")(false)("")(40)($author$project$Data$User$Male)($elm$core$Maybe$Nothing)(false)("")($elm$core$Maybe$Nothing)(false)("")(0)(false)(_List_Nil)(_List_Nil)("")($author$project$Data$User$emptyDescription)(0)("");
    var $author$project$Data$User$emptySpectator = $author$project$Data$User$Spectator($author$project$Data$User$emptyUserInfo);
    var $AdrianRibao$elm_derberos_date$Derberos$Date$Core$DateRecord = F8(function(year, month, day, hour, minute, second, millis, zone) {
        return {
            day: day,
            hour: hour,
            millis: millis,
            minute: minute,
            month: month,
            second: second,
            year: year,
            zone: zone
        };
    });
    var $elm$time$Time$Zone = F2(function(a, b) {
        return {
            $: "Zone",
            a: a,
            b: b
        };
    });
    var $elm$time$Time$utc = A2($elm$time$Time$Zone, 0, _List_Nil);
    var $author$project$Pages$Hardware$humandateTimePlaceholder = A8($AdrianRibao$elm_derberos_date$Derberos$Date$Core$DateRecord, 0, 0, 0, 0, 0, 0, 0, $elm$time$Time$utc);
    var $author$project$Pages$Hardware$init = function(fromMainToRankings) {
        var updatedFlagUrlToIncludeMongoDBMWSvr = A2($elm$core$String$contains, $author$project$Extras$Constants$localorproductionServerAutoCheck, fromMainToRankings.flagUrl.host) ? A6($elm$url$Url$Url, fromMainToRankings.flagUrl.protocol, fromMainToRankings.flagUrl.host, $elm$core$Maybe$Nothing, $author$project$Extras$Constants$productionProxyConfig, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing) : A6($elm$url$Url$Url, fromMainToRankings.flagUrl.protocol, fromMainToRankings.flagUrl.host, $elm$core$Maybe$Just(3000), $author$project$Extras$Constants$middleWarePath, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing);
        return _Utils_Tuple2($author$project$Pages$Hardware$Model($author$project$Pages$Hardware$Loaded)("Hardware")($author$project$Pages$Hardware$Hardware({
            name: "Loading..."
        }))(fromMainToRankings.flagUrl)(A2($elm$core$Maybe$withDefault, $elm$core$Maybe$Nothing, $elm$core$Maybe$Just(fromMainToRankings.time)))($author$project$Pages$Hardware$humandateTimePlaceholder)(_List_Nil)($author$project$Pages$Hardware$apiSpecsPlaceHolder)($author$project$Pages$Hardware$Login($author$project$Extras$Constants$emptyEmailPassword))($elm$core$Maybe$Just(A6($author$project$Pages$Hardware$ToMongoDBMWConfig, $author$project$Extras$Constants$post, _List_Nil, $elm$url$Url$toString(updatedFlagUrlToIncludeMongoDBMWSvr), $elm$http$Http$emptyBody, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing)))(false)(false)(false)(false)(_List_fromArray([
            ""
        ]))(_List_fromArray([
            $elm$core$Maybe$Nothing
        ]))(false)(false)({
            email: "",
            password: ""
        })($author$project$Data$Hardware$None)($author$project$Data$Hardware$emptyRank)($author$project$Data$User$emptySpectator)($author$project$Data$Hardware$Undecided)("")(_List_Nil)($elm$core$Maybe$Nothing), $elm$core$Platform$Cmd$none);
    };
    var $author$project$Pages$Market$Loading = {
        $: "Loading"
    };
    var $author$project$Pages$Market$Market = function(a) {
        return {
            $: "Market",
            a: a
        };
    };
    var $author$project$Pages$Market$initialModel = {
        root: $author$project$Pages$Market$Market({
            name: "Loading..."
        }),
        status: $author$project$Pages$Market$Loading,
        title: "Market"
    };
    var $author$project$Pages$Market$init = function(_v0) {
        return _Utils_Tuple2(_Utils_update($author$project$Pages$Market$initialModel, {
            title: "Haveno-Web Market"
        }), $elm$core$Platform$Cmd$none);
    };
    var $author$project$Pages$PingPong$Loading = {
        $: "Loading"
    };
    var $author$project$Pages$PingPong$PingPong = function(a) {
        return {
            $: "PingPong",
            a: a
        };
    };
    var $author$project$Pages$PingPong$initialModel = {
        root: $author$project$Pages$PingPong$PingPong({
            name: "Ready..."
        }),
        status: $author$project$Pages$PingPong$Loading,
        title: "PingPong"
    };
    var $author$project$Pages$PingPong$init = function(_v0) {
        return _Utils_Tuple2(_Utils_update($author$project$Pages$PingPong$initialModel, {
            title: "Haveno-Web Buy"
        }), $elm$core$Platform$Cmd$none);
    };
    var $author$project$Pages$Portfolio$Loading = {
        $: "Loading"
    };
    var $author$project$Pages$Portfolio$Portfolio = function(a) {
        return {
            $: "Portfolio",
            a: a
        };
    };
    var $author$project$Pages$Portfolio$initialModel = {
        root: $author$project$Pages$Portfolio$Portfolio({
            name: "Loading..."
        }),
        status: $author$project$Pages$Portfolio$Loading,
        title: "Portfolio"
    };
    var $author$project$Pages$Portfolio$init = function(_v0) {
        return _Utils_Tuple2(_Utils_update($author$project$Pages$Portfolio$initialModel, {
            title: "Haveno-Web Portfolio"
        }), $elm$core$Platform$Cmd$none);
    };
    var $author$project$Pages$Sell$Loading = {
        $: "Loading"
    };
    var $author$project$Pages$Sell$Sell = function(a) {
        return {
            $: "Sell",
            a: a
        };
    };
    var $author$project$Pages$Sell$initialModel = {
        root: $author$project$Pages$Sell$Sell({
            name: "Loading..."
        }),
        status: $author$project$Pages$Sell$Loading,
        title: "Sell"
    };
    var $author$project$Pages$Sell$init = function(_v0) {
        return _Utils_Tuple2(_Utils_update($author$project$Pages$Sell$initialModel, {
            title: "Haveno-Web Sell"
        }), $elm$core$Platform$Cmd$none);
    };
    var $author$project$Pages$Support$Loading = {
        $: "Loading"
    };
    var $author$project$Pages$Support$Support = function(a) {
        return {
            $: "Support",
            a: a
        };
    };
    var $author$project$Pages$Support$initialModel = {
        root: $author$project$Pages$Support$Support({
            name: "Loading..."
        }),
        status: $author$project$Pages$Support$Loading,
        title: "Support"
    };
    var $author$project$Pages$Support$init = function(_v0) {
        return _Utils_Tuple2(_Utils_update($author$project$Pages$Support$initialModel, {
            title: "Haveno-Web Support"
        }), $elm$core$Platform$Cmd$none);
    };
    var $elm$url$Url$Parser$State = F5(function(visited, unvisited, params, frag, value) {
        return {
            frag: frag,
            params: params,
            unvisited: unvisited,
            value: value,
            visited: visited
        };
    });
    var $elm$url$Url$Parser$getFirstMatch = function(states) {
        getFirstMatch: while(true){
            if (!states.b) return $elm$core$Maybe$Nothing;
            else {
                var state = states.a;
                var rest = states.b;
                var _v1 = state.unvisited;
                if (!_v1.b) return $elm$core$Maybe$Just(state.value);
                else {
                    if (_v1.a === "" && !_v1.b.b) return $elm$core$Maybe$Just(state.value);
                    else {
                        var $temp$states = rest;
                        states = $temp$states;
                        continue getFirstMatch;
                    }
                }
            }
        }
    };
    var $elm$url$Url$Parser$removeFinalEmpty = function(segments) {
        if (!segments.b) return _List_Nil;
        else {
            if (segments.a === "" && !segments.b.b) return _List_Nil;
            else {
                var segment = segments.a;
                var rest = segments.b;
                return A2($elm$core$List$cons, segment, $elm$url$Url$Parser$removeFinalEmpty(rest));
            }
        }
    };
    var $elm$url$Url$Parser$preparePath = function(path) {
        var _v0 = A2($elm$core$String$split, "/", path);
        if (_v0.b && _v0.a === "") {
            var segments = _v0.b;
            return $elm$url$Url$Parser$removeFinalEmpty(segments);
        } else {
            var segments = _v0;
            return $elm$url$Url$Parser$removeFinalEmpty(segments);
        }
    };
    var $elm$url$Url$Parser$addToParametersHelp = F2(function(value, maybeList) {
        if (maybeList.$ === "Nothing") return $elm$core$Maybe$Just(_List_fromArray([
            value
        ]));
        else {
            var list = maybeList.a;
            return $elm$core$Maybe$Just(A2($elm$core$List$cons, value, list));
        }
    });
    var $elm$url$Url$Parser$addParam = F2(function(segment, dict) {
        var _v0 = A2($elm$core$String$split, "=", segment);
        if (_v0.b && _v0.b.b && !_v0.b.b.b) {
            var rawKey = _v0.a;
            var _v1 = _v0.b;
            var rawValue = _v1.a;
            var _v2 = $elm$url$Url$percentDecode(rawKey);
            if (_v2.$ === "Nothing") return dict;
            else {
                var key = _v2.a;
                var _v3 = $elm$url$Url$percentDecode(rawValue);
                if (_v3.$ === "Nothing") return dict;
                else {
                    var value = _v3.a;
                    return A3($elm$core$Dict$update, key, $elm$url$Url$Parser$addToParametersHelp(value), dict);
                }
            }
        } else return dict;
    });
    var $elm$url$Url$Parser$prepareQuery = function(maybeQuery) {
        if (maybeQuery.$ === "Nothing") return $elm$core$Dict$empty;
        else {
            var qry = maybeQuery.a;
            return A3($elm$core$List$foldr, $elm$url$Url$Parser$addParam, $elm$core$Dict$empty, A2($elm$core$String$split, "&", qry));
        }
    };
    var $elm$url$Url$Parser$parse = F2(function(_v0, url) {
        var parser = _v0.a;
        return $elm$url$Url$Parser$getFirstMatch(parser(A5($elm$url$Url$Parser$State, _List_Nil, $elm$url$Url$Parser$preparePath(url.path), $elm$url$Url$Parser$prepareQuery(url.query), url.fragment, $elm$core$Basics$identity)));
    });
    var $author$project$Main$AdjustTimeZone = function(a) {
        return {
            $: "AdjustTimeZone",
            a: a
        };
    };
    var $author$project$Main$DashboardPage = function(a) {
        return {
            $: "DashboardPage",
            a: a
        };
    };
    var $author$project$Main$GotDashboardMsg = function(a) {
        return {
            $: "GotDashboardMsg",
            a: a
        };
    };
    var $elm$time$Time$Name = function(a) {
        return {
            $: "Name",
            a: a
        };
    };
    var $elm$time$Time$Offset = function(a) {
        return {
            $: "Offset",
            a: a
        };
    };
    var $elm$time$Time$customZone = $elm$time$Time$Zone;
    var $elm$time$Time$here = _Time_here(_Utils_Tuple0);
    var $author$project$Main$toDashboard = F2(function(model, _v0) {
        var dashboard = _v0.a;
        var cmd = _v0.b;
        return _Utils_Tuple2(_Utils_update(model, {
            page: $author$project$Main$DashboardPage(dashboard)
        }), $elm$core$Platform$Cmd$batch(_List_fromArray([
            A2($elm$core$Platform$Cmd$map, $author$project$Main$GotDashboardMsg, cmd),
            A2($elm$core$Task$perform, $author$project$Main$AdjustTimeZone, $elm$time$Time$here)
        ])));
    });
    var $author$project$Main$FundsPage = function(a) {
        return {
            $: "FundsPage",
            a: a
        };
    };
    var $author$project$Main$GotFundsMsg = function(a) {
        return {
            $: "GotFundsMsg",
            a: a
        };
    };
    var $author$project$Main$toFunds = F2(function(model, _v0) {
        var funds = _v0.a;
        var cmd = _v0.b;
        return _Utils_Tuple2(_Utils_update(model, {
            page: $author$project$Main$FundsPage(funds)
        }), A2($elm$core$Platform$Cmd$map, $author$project$Main$GotFundsMsg, cmd));
    });
    var $author$project$Main$GotHardwareMsg = function(a) {
        return {
            $: "GotHardwareMsg",
            a: a
        };
    };
    var $author$project$Main$HardwarePage = function(a) {
        return {
            $: "HardwarePage",
            a: a
        };
    };
    var $author$project$Main$toHardware = F2(function(model, _v0) {
        var hardware = _v0.a;
        var cmd = _v0.b;
        return _Utils_Tuple2(_Utils_update(model, {
            page: $author$project$Main$HardwarePage(hardware)
        }), A2($elm$core$Platform$Cmd$map, $author$project$Main$GotHardwareMsg, cmd));
    });
    var $author$project$Main$GotMarketMsg = function(a) {
        return {
            $: "GotMarketMsg",
            a: a
        };
    };
    var $author$project$Main$MarketPage = function(a) {
        return {
            $: "MarketPage",
            a: a
        };
    };
    var $author$project$Main$toMarket = F2(function(model, _v0) {
        var market = _v0.a;
        var cmd = _v0.b;
        return _Utils_Tuple2(_Utils_update(model, {
            page: $author$project$Main$MarketPage(market)
        }), A2($elm$core$Platform$Cmd$map, $author$project$Main$GotMarketMsg, cmd));
    });
    var $author$project$Main$GotPingPongMsg = function(a) {
        return {
            $: "GotPingPongMsg",
            a: a
        };
    };
    var $author$project$Main$PingPongPage = function(a) {
        return {
            $: "PingPongPage",
            a: a
        };
    };
    var $author$project$Main$toPingPong = F2(function(model, _v0) {
        var pingpong = _v0.a;
        var cmd = _v0.b;
        return _Utils_Tuple2(_Utils_update(model, {
            page: $author$project$Main$PingPongPage(pingpong)
        }), A2($elm$core$Platform$Cmd$map, $author$project$Main$GotPingPongMsg, cmd));
    });
    var $author$project$Main$GotPortfolioMsg = function(a) {
        return {
            $: "GotPortfolioMsg",
            a: a
        };
    };
    var $author$project$Main$PortfolioPage = function(a) {
        return {
            $: "PortfolioPage",
            a: a
        };
    };
    var $author$project$Main$toPortfolio = F2(function(model, _v0) {
        var portfolio = _v0.a;
        var cmd = _v0.b;
        return _Utils_Tuple2(_Utils_update(model, {
            page: $author$project$Main$PortfolioPage(portfolio)
        }), A2($elm$core$Platform$Cmd$map, $author$project$Main$GotPortfolioMsg, cmd));
    });
    var $author$project$Main$BuyPage = function(a) {
        return {
            $: "BuyPage",
            a: a
        };
    };
    var $author$project$Main$GotBuyMsg = function(a) {
        return {
            $: "GotBuyMsg",
            a: a
        };
    };
    var $author$project$Main$toPricing = F2(function(model, _v0) {
        var pricing = _v0.a;
        var cmd = _v0.b;
        return _Utils_Tuple2(_Utils_update(model, {
            page: $author$project$Main$BuyPage(pricing)
        }), A2($elm$core$Platform$Cmd$map, $author$project$Main$GotBuyMsg, cmd));
    });
    var $author$project$Main$GotSellMsg = function(a) {
        return {
            $: "GotSellMsg",
            a: a
        };
    };
    var $author$project$Main$SellPage = function(a) {
        return {
            $: "SellPage",
            a: a
        };
    };
    var $author$project$Main$toSell = F2(function(model, _v0) {
        var sell = _v0.a;
        var cmd = _v0.b;
        return _Utils_Tuple2(_Utils_update(model, {
            page: $author$project$Main$SellPage(sell)
        }), A2($elm$core$Platform$Cmd$map, $author$project$Main$GotSellMsg, cmd));
    });
    var $author$project$Main$GotSupportMsg = function(a) {
        return {
            $: "GotSupportMsg",
            a: a
        };
    };
    var $author$project$Main$SupportPage = function(a) {
        return {
            $: "SupportPage",
            a: a
        };
    };
    var $author$project$Main$toSupport = F2(function(model, _v0) {
        var support = _v0.a;
        var cmd = _v0.b;
        return _Utils_Tuple2(_Utils_update(model, {
            page: $author$project$Main$SupportPage(support)
        }), A2($elm$core$Platform$Cmd$map, $author$project$Main$GotSupportMsg, cmd));
    });
    var $author$project$Main$Buy = {
        $: "Buy"
    };
    var $author$project$Main$Dashboard = {
        $: "Dashboard"
    };
    var $author$project$Main$Funds = {
        $: "Funds"
    };
    var $author$project$Main$Hardware = {
        $: "Hardware"
    };
    var $author$project$Main$Market = {
        $: "Market"
    };
    var $author$project$Main$PingPong = {
        $: "PingPong"
    };
    var $author$project$Main$Portfolio = {
        $: "Portfolio"
    };
    var $author$project$Main$Sell = {
        $: "Sell"
    };
    var $author$project$Main$Support = {
        $: "Support"
    };
    var $elm$url$Url$Parser$Parser = function(a) {
        return {
            $: "Parser",
            a: a
        };
    };
    var $elm$url$Url$Parser$mapState = F2(function(func, _v0) {
        var visited = _v0.visited;
        var unvisited = _v0.unvisited;
        var params = _v0.params;
        var frag = _v0.frag;
        var value = _v0.value;
        return A5($elm$url$Url$Parser$State, visited, unvisited, params, frag, func(value));
    });
    var $elm$url$Url$Parser$map = F2(function(subValue, _v0) {
        var parseArg = _v0.a;
        return $elm$url$Url$Parser$Parser(function(_v1) {
            var visited = _v1.visited;
            var unvisited = _v1.unvisited;
            var params = _v1.params;
            var frag = _v1.frag;
            var value = _v1.value;
            return A2($elm$core$List$map, $elm$url$Url$Parser$mapState(value), parseArg(A5($elm$url$Url$Parser$State, visited, unvisited, params, frag, subValue)));
        });
    });
    var $elm$url$Url$Parser$oneOf = function(parsers) {
        return $elm$url$Url$Parser$Parser(function(state) {
            return A2($elm$core$List$concatMap, function(_v0) {
                var parser = _v0.a;
                return parser(state);
            }, parsers);
        });
    };
    var $elm$url$Url$Parser$s = function(str) {
        return $elm$url$Url$Parser$Parser(function(_v0) {
            var visited = _v0.visited;
            var unvisited = _v0.unvisited;
            var params = _v0.params;
            var frag = _v0.frag;
            var value = _v0.value;
            if (!unvisited.b) return _List_Nil;
            else {
                var next = unvisited.a;
                var rest = unvisited.b;
                return _Utils_eq(next, str) ? _List_fromArray([
                    A5($elm$url$Url$Parser$State, A2($elm$core$List$cons, next, visited), rest, params, frag, value)
                ]) : _List_Nil;
            }
        });
    };
    var $elm$url$Url$Parser$top = $elm$url$Url$Parser$Parser(function(state) {
        return _List_fromArray([
            state
        ]);
    });
    var $author$project$Main$urlAsPageParser = $elm$url$Url$Parser$oneOf(_List_fromArray([
        A2($elm$url$Url$Parser$map, $author$project$Main$Dashboard, $elm$url$Url$Parser$s("index.html")),
        A2($elm$url$Url$Parser$map, $author$project$Main$Dashboard, $elm$url$Url$Parser$top),
        A2($elm$url$Url$Parser$map, $author$project$Main$Sell, $elm$url$Url$Parser$s("sell")),
        A2($elm$url$Url$Parser$map, $author$project$Main$Portfolio, $elm$url$Url$Parser$s("portfolio")),
        A2($elm$url$Url$Parser$map, $author$project$Main$Funds, $elm$url$Url$Parser$s("funds")),
        A2($elm$url$Url$Parser$map, $author$project$Main$Support, $elm$url$Url$Parser$s("support")),
        A2($elm$url$Url$Parser$map, $author$project$Main$PingPong, $elm$url$Url$Parser$s("pingpong")),
        A2($elm$url$Url$Parser$map, $author$project$Main$Buy, $elm$url$Url$Parser$s("buy")),
        A2($elm$url$Url$Parser$map, $author$project$Main$Market, $elm$url$Url$Parser$s("market")),
        A2($elm$url$Url$Parser$map, $author$project$Main$Hardware, $elm$url$Url$Parser$s("hardware"))
    ]));
    var $author$project$Main$updateUrl = F2(function(url, model) {
        var urlMinusQueryStr = _Utils_update(url, {
            query: $elm$core$Maybe$Just("")
        });
        var oauthCode = $author$project$Main$gotCodeFromUrl(url);
        var _v0 = A2($elm$url$Url$Parser$parse, $author$project$Main$urlAsPageParser, urlMinusQueryStr);
        if (_v0.$ === "Just") switch(_v0.a.$){
            case "Dashboard":
                var _v1 = _v0.a;
                if (oauthCode.$ === "Nothing") return A2($author$project$Main$toDashboard, model, $author$project$Pages$Dashboard$init({
                    flagUrl: model.flag,
                    time: $elm$core$Maybe$Nothing
                }));
                else {
                    if (oauthCode.a === "") return A2($author$project$Main$toDashboard, model, $author$project$Pages$Dashboard$init({
                        flagUrl: model.flag,
                        time: $elm$core$Maybe$Nothing
                    }));
                    else return A2($author$project$Main$toDashboard, model, $author$project$Pages$Dashboard$init({
                        flagUrl: model.flag,
                        time: $elm$core$Maybe$Nothing
                    }));
                }
            case "Sell":
                var _v3 = _v0.a;
                return A2($author$project$Main$toSell, model, $author$project$Pages$Sell$init(_Utils_Tuple0));
            case "Portfolio":
                var _v4 = _v0.a;
                return A2($author$project$Main$toPortfolio, model, $author$project$Pages$Portfolio$init(_Utils_Tuple0));
            case "Funds":
                var _v5 = _v0.a;
                return A2($author$project$Main$toFunds, model, $author$project$Pages$Funds$init(_Utils_Tuple0));
            case "Support":
                var _v6 = _v0.a;
                return A2($author$project$Main$toSupport, model, $author$project$Pages$Support$init(_Utils_Tuple0));
            case "PingPong":
                var _v7 = _v0.a;
                return A2($author$project$Main$toPingPong, model, $author$project$Pages$PingPong$init(_Utils_Tuple0));
            case "Buy":
                var _v8 = _v0.a;
                return A2($author$project$Main$toPricing, model, $author$project$Pages$Buy$init(_Utils_Tuple0));
            case "Market":
                var _v9 = _v0.a;
                return A2($author$project$Main$toMarket, model, $author$project$Pages$Market$init(_Utils_Tuple0));
            default:
                var _v10 = _v0.a;
                return A2($author$project$Main$toHardware, model, $author$project$Pages$Hardware$init({
                    flagUrl: model.flag,
                    time: $elm$core$Maybe$Nothing
                }));
        }
        else return _Utils_Tuple2(_Utils_update(model, {
            page: $author$project$Main$NotFound
        }), $elm$core$Platform$Cmd$none);
    });
    var $elm$json$Json$Decode$andThen = _Json_andThen;
    var $elm$json$Json$Decode$fail = _Json_fail;
    var $author$project$Main$urlDecoder = A2($elm$json$Json$Decode$andThen, function(s) {
        var _v0 = $elm$url$Url$fromString(s);
        if (_v0.$ === "Just") {
            var url = _v0.a;
            return $elm$json$Json$Decode$succeed(url);
        } else return $elm$json$Json$Decode$fail("Invalid URL");
    }, $elm$json$Json$Decode$string);
    var $author$project$Main$init = F3(function(flag, url, key) {
        var navigate = function(newUrl) {
            return A2($elm$browser$Browser$Navigation$pushUrl, key, $elm$url$Url$toString(newUrl));
        };
        var decodedJsonFromIndexjs = function() {
            var _v0 = A2($elm$json$Json$Decode$decodeString, $author$project$Main$urlDecoder, flag);
            if (_v0.$ === "Ok") {
                var urL = _v0.a;
                return urL;
            } else return A6($elm$url$Url$Url, $elm$url$Url$Https, "haveno-web.squashpassion.com", $elm$core$Maybe$Nothing, "", $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing);
        }();
        return A2($author$project$Main$updateUrl, url, {
            errors: _List_fromArray([
                ""
            ]),
            flag: decodedJsonFromIndexjs,
            key: navigate,
            page: $author$project$Main$NotFound,
            time: $elm$time$Time$millisToPosix(0),
            zone: $elm$core$Maybe$Just($elm$time$Time$utc)
        });
    });
    var $elm$core$Platform$Sub$batch = _Platform_batch;
    var $author$project$Pages$Hardware$ResponseDataFromMain = function(a) {
        return {
            $: "ResponseDataFromMain",
            a: a
        };
    };
    var $author$project$Pages$Hardware$receiveMessageFromJs = _Platform_incomingPort("receiveMessageFromJs", $elm$json$Json$Decode$value);
    var $author$project$Pages$Hardware$hardwareSubscriptions = function(_v0) {
        return $elm$core$Platform$Sub$batch(_List_fromArray([
            $author$project$Pages$Hardware$receiveMessageFromJs($author$project$Pages$Hardware$ResponseDataFromMain)
        ]));
    };
    var $author$project$Extras$TestData$placeholderUrl = A6($elm$url$Url$Url, $elm$url$Url$Http, "localhost", $elm$core$Maybe$Just(3000), "", $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing);
    var $author$project$Main$subscriptions = function(_v0) {
        var _v1 = $author$project$Pages$Hardware$init({
            flagUrl: $author$project$Extras$TestData$placeholderUrl,
            time: $elm$core$Maybe$Nothing
        });
        var hardwaremodel = _v1.a;
        return $elm$core$Platform$Sub$batch(_List_fromArray([
            A2($elm$core$Platform$Sub$map, $author$project$Main$GotHardwareMsg, $author$project$Pages$Hardware$hardwareSubscriptions(hardwaremodel))
        ]));
    };
    var $author$project$Pages$Hardware$LoggedInUser = {
        $: "LoggedInUser"
    };
    var $author$project$Main$fromJsonToString = function(value) {
        return A2($elm$json$Json$Encode$encode, 0, value);
    };
    var $elm$browser$Browser$Navigation$load = _Browser_load;
    var $author$project$Main$sendMessageToJs = _Platform_outgoingPort("sendMessageToJs", $elm$json$Json$Encode$string);
    var $author$project$Pages$Buy$update = F2(function(msg, model) {
        var newModel = msg.a;
        return _Utils_Tuple2(_Utils_update(newModel, {
            title: model.title
        }), $elm$core$Platform$Cmd$none);
    });
    var $author$project$Extras$Constants$get = "GET";
    var $author$project$Extras$Constants$httpErrorToString = function(err) {
        switch(err.$){
            case "BadUrl":
                var url = err.a;
                return "Bad URL: " + url;
            case "Timeout":
                return "Request timed out";
            case "NetworkError":
                return "Network error occurred";
            case "BadStatus":
                var status = err.a;
                return "Bad status: " + $elm$core$String$fromInt(status);
            default:
                var body = err.a;
                return "Bad body: " + body;
        }
    };
    var $author$project$Pages$Dashboard$update = F2(function(msg, model) {
        switch(msg.$){
            case "GotVersion":
                if (msg.a.$ === "Ok") {
                    var versionResp = msg.a.a;
                    return _Utils_Tuple2(_Utils_update(model, {
                        version: $elm$core$Maybe$Just(versionResp)
                    }), $elm$core$Platform$Cmd$none);
                } else return _Utils_Tuple2(_Utils_update(model, {
                    version: model.version
                }), $elm$core$Platform$Cmd$none);
            case "GotInitialModel":
                var newModel = msg.a;
                return _Utils_Tuple2(_Utils_update(newModel, {
                    title: model.title
                }), $elm$core$Platform$Cmd$none);
            default:
                if (msg.a.$ === "Ok") {
                    var auth = msg.a.a;
                    var headers = _List_fromArray([
                        A2($elm$http$Http$header, "Authorization", "Bearer " + A2($elm$core$Maybe$withDefault, "No access token 2", $elm$core$Maybe$Just(auth.deployment_model)))
                    ]);
                    var flagUrlWithMongoDBMWAndPortUpdate = A2($elm$core$String$contains, $author$project$Extras$Constants$localorproductionServerAutoCheck, model.flagUrl.host) ? $elm$url$Url$toString(A6($elm$url$Url$Url, model.flagUrl.protocol, model.flagUrl.host, $elm$core$Maybe$Nothing, $author$project$Extras$Constants$middleWarePath, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing)) : $elm$url$Url$toString(A6($elm$url$Url$Url, model.flagUrl.protocol, model.flagUrl.host, $elm$core$Maybe$Just(3000), $author$project$Extras$Constants$middleWarePath, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing));
                    var newHttpParams = A6($author$project$Pages$Dashboard$HavenoAPKHttpRequest, $author$project$Extras$Constants$get, headers, flagUrlWithMongoDBMWAndPortUpdate, $elm$http$Http$emptyBody, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing);
                    var newModel = _Utils_update(model, {
                        havenoAPKHttpRequest: $elm$core$Maybe$Just(newHttpParams)
                    });
                    return _Utils_Tuple2(newModel, $elm$core$Platform$Cmd$none);
                } else {
                    var responseErr = msg.a.a;
                    var respErr = $author$project$Extras$Constants$httpErrorToString(responseErr);
                    return _Utils_Tuple2(_Utils_update(model, {
                        errors: _Utils_ap(model.errors, _List_fromArray([
                            respErr
                        ]))
                    }), $elm$core$Platform$Cmd$none);
                }
        }
    });
    var $author$project$Pages$Funds$update = F2(function(msg, model) {
        var newModel = msg.a;
        return _Utils_Tuple2(_Utils_update(newModel, {
            title: model.title
        }), $elm$core$Platform$Cmd$none);
    });
    var $author$project$Pages$Hardware$ConfirmDeleteOwnedRanking = {
        $: "ConfirmDeleteOwnedRanking"
    };
    var $author$project$Pages$Hardware$ConfirmDeleteUserView = {
        $: "ConfirmDeleteUserView"
    };
    var $author$project$Pages$Hardware$ConfirmJoinMemberView = {
        $: "ConfirmJoinMemberView"
    };
    var $author$project$Pages$Hardware$ConfirmLeaveMemberView = {
        $: "ConfirmLeaveMemberView"
    };
    var $author$project$Pages$Hardware$CreateChallengeView = F2(function(a, b) {
        return {
            $: "CreateChallengeView",
            a: a,
            b: b
        };
    });
    var $author$project$Pages$Hardware$CreatingNewLadder = function(a) {
        return {
            $: "CreatingNewLadder",
            a: a
        };
    };
    var $author$project$Types$DateType$CurrentDateTime = F2(function(a, b) {
        return {
            $: "CurrentDateTime",
            a: a,
            b: b
        };
    });
    var $author$project$Pages$Hardware$MemberSelectedView = {
        $: "MemberSelectedView"
    };
    var $author$project$Data$Hardware$Owned = function(a) {
        return {
            $: "Owned",
            a: a
        };
    };
    var $author$project$Pages$Hardware$OwnedSelectedView = {
        $: "OwnedSelectedView"
    };
    var $author$project$Pages$Hardware$PrepareResult = {
        $: "PrepareResult"
    };
    var $author$project$Data$Hardware$Rank = F3(function(rank, player, challenger) {
        return {
            challenger: challenger,
            player: player,
            rank: rank
        };
    });
    var $author$project$Pages$Hardware$RegisterUser = function(a) {
        return {
            $: "RegisterUser",
            a: a
        };
    };
    var $author$project$Data$User$Registered = function(a) {
        return {
            $: "Registered",
            a: a
        };
    };
    var $author$project$Types$DateType$SelectedDateTime = F2(function(a, b) {
        return {
            $: "SelectedDateTime",
            a: a,
            b: b
        };
    });
    var $author$project$Data$Hardware$Spectator = function(a) {
        return {
            $: "Spectator",
            a: a
        };
    };
    var $author$project$Pages$Hardware$SpectatorSelectedView = {
        $: "SpectatorSelectedView"
    };
    var $author$project$Pages$Hardware$UpdateComment = function(a) {
        return {
            $: "UpdateComment",
            a: a
        };
    };
    var $author$project$Pages$Hardware$UpdateEmail = function(a) {
        return {
            $: "UpdateEmail",
            a: a
        };
    };
    var $author$project$Pages$Hardware$UpdateLevel = function(a) {
        return {
            $: "UpdateLevel",
            a: a
        };
    };
    var $author$project$Pages$Hardware$UpdateMobile = function(a) {
        return {
            $: "UpdateMobile",
            a: a
        };
    };
    var $author$project$Pages$Hardware$UpdateNickName = function(a) {
        return {
            $: "UpdateNickName",
            a: a
        };
    };
    var $author$project$Pages$Hardware$UpdatePassword = function(a) {
        return {
            $: "UpdatePassword",
            a: a
        };
    };
    var $author$project$Pages$Hardware$UpdatePhone = function(a) {
        return {
            $: "UpdatePhone",
            a: a
        };
    };
    var $author$project$Pages$Hardware$CallResponse = function(a) {
        return {
            $: "CallResponse",
            a: a
        };
    };
    var $author$project$Extras$Constants$jsonKeyValue = F2(function(key, value) {
        return _Utils_Tuple2(key, $elm$json$Json$Encode$string(value));
    });
    var $author$project$Extras$Constants$numIntObject = function(str) {
        return $elm$json$Json$Encode$object(_List_fromArray([
            _Utils_Tuple2("$numberInt", $elm$json$Json$Encode$string(str))
        ]));
    };
    var $author$project$Extras$Constants$pipelineRequest = A2($elm$json$Json$Encode$list, $elm$core$Basics$identity, _List_fromArray([
        $elm$json$Json$Encode$object(_List_fromArray([
            _Utils_Tuple2("$match", $elm$json$Json$Encode$object(_List_fromArray([
                _Utils_Tuple2("_id", $elm$json$Json$Encode$object(_List_fromArray([
                    A2($author$project$Extras$Constants$jsonKeyValue, "$oid", "651fa006b15a534c69b119ef")
                ])))
            ])))
        ])),
        $elm$json$Json$Encode$object(_List_fromArray([
            _Utils_Tuple2("$lookup", $elm$json$Json$Encode$object(_List_fromArray([
                A2($author$project$Extras$Constants$jsonKeyValue, "from", "rankings"),
                _Utils_Tuple2("localField", $elm$json$Json$Encode$string("ownerOf")),
                _Utils_Tuple2("foreignField", $elm$json$Json$Encode$string("_id")),
                _Utils_Tuple2("as", $elm$json$Json$Encode$string("ownedRankings"))
            ])))
        ])),
        $elm$json$Json$Encode$object(_List_fromArray([
            _Utils_Tuple2("$lookup", $elm$json$Json$Encode$object(_List_fromArray([
                _Utils_Tuple2("from", $elm$json$Json$Encode$string("rankings")),
                _Utils_Tuple2("localField", $elm$json$Json$Encode$string("memberOf")),
                _Utils_Tuple2("foreignField", $elm$json$Json$Encode$string("_id")),
                _Utils_Tuple2("as", $elm$json$Json$Encode$string("memberRankings"))
            ])))
        ])),
        $elm$json$Json$Encode$object(_List_fromArray([
            _Utils_Tuple2("$lookup", $elm$json$Json$Encode$object(_List_fromArray([
                _Utils_Tuple2("from", $elm$json$Json$Encode$string("users")),
                _Utils_Tuple2("localField", $elm$json$Json$Encode$string("memberRankings.owner_id")),
                _Utils_Tuple2("foreignField", $elm$json$Json$Encode$string("_id")),
                _Utils_Tuple2("as", $elm$json$Json$Encode$string("memberRankingsWithOwnerName"))
            ])))
        ])),
        $elm$json$Json$Encode$object(_List_fromArray([
            _Utils_Tuple2("$project", $elm$json$Json$Encode$object(_List_fromArray([
                _Utils_Tuple2("_id", $author$project$Extras$Constants$numIntObject("1")),
                _Utils_Tuple2("userid", $author$project$Extras$Constants$numIntObject("1")),
                _Utils_Tuple2("nickname", $author$project$Extras$Constants$numIntObject("1")),
                _Utils_Tuple2("active", $author$project$Extras$Constants$numIntObject("1")),
                _Utils_Tuple2("description", $author$project$Extras$Constants$numIntObject("1")),
                _Utils_Tuple2("datestamp", $author$project$Extras$Constants$numIntObject("1")),
                _Utils_Tuple2("token", $author$project$Extras$Constants$numIntObject("1")),
                _Utils_Tuple2("updatetext", $author$project$Extras$Constants$numIntObject("1")),
                _Utils_Tuple2("mobile", $author$project$Extras$Constants$numIntObject("1")),
                _Utils_Tuple2("credits", $author$project$Extras$Constants$numIntObject("1")),
                _Utils_Tuple2("ownedRankings", $elm$json$Json$Encode$object(_List_fromArray([
                    _Utils_Tuple2("_id", $author$project$Extras$Constants$numIntObject("1")),
                    _Utils_Tuple2("active", $author$project$Extras$Constants$numIntObject("1")),
                    _Utils_Tuple2("owner_id", $author$project$Extras$Constants$numIntObject("1")),
                    _Utils_Tuple2("baseaddress", $author$project$Extras$Constants$numIntObject("1")),
                    _Utils_Tuple2("ranking", $author$project$Extras$Constants$numIntObject("1")),
                    _Utils_Tuple2("player_count", $author$project$Extras$Constants$numIntObject("1")),
                    _Utils_Tuple2("name", $author$project$Extras$Constants$numIntObject("1")),
                    A2($author$project$Extras$Constants$jsonKeyValue, "owner_name", "$nickname")
                ]))),
                _Utils_Tuple2("memberRankings", $elm$json$Json$Encode$object(_List_fromArray([
                    _Utils_Tuple2("_id", $author$project$Extras$Constants$numIntObject("1")),
                    _Utils_Tuple2("name", $author$project$Extras$Constants$numIntObject("1")),
                    _Utils_Tuple2("active", $author$project$Extras$Constants$numIntObject("1")),
                    _Utils_Tuple2("owner_id", $author$project$Extras$Constants$numIntObject("1")),
                    _Utils_Tuple2("baseaddress", $author$project$Extras$Constants$numIntObject("1")),
                    _Utils_Tuple2("ranking", $author$project$Extras$Constants$numIntObject("1")),
                    _Utils_Tuple2("player_count", $author$project$Extras$Constants$numIntObject("1")),
                    _Utils_Tuple2("owner_name", $elm$json$Json$Encode$object(_List_fromArray([
                        _Utils_Tuple2("owner_name", $elm$json$Json$Encode$string("$memberRankingsWithOwnerName.nickname"))
                    ])))
                ]))),
                _Utils_Tuple2("owner_ranking_count", $elm$json$Json$Encode$object(_List_fromArray([
                    _Utils_Tuple2("$size", $elm$json$Json$Encode$string("$ownedRankings"))
                ]))),
                _Utils_Tuple2("member_ranking_count", $elm$json$Json$Encode$object(_List_fromArray([
                    _Utils_Tuple2("$size", $elm$json$Json$Encode$string("$memberRankings"))
                ]))),
                _Utils_Tuple2("addInfo", $author$project$Extras$Constants$numIntObject("1")),
                _Utils_Tuple2("gender", $author$project$Extras$Constants$numIntObject("1")),
                _Utils_Tuple2("age", $author$project$Extras$Constants$numIntObject("1"))
            ])))
        ]))
    ]));
    var $author$project$Extras$Constants$callRequestJson = $elm$json$Json$Encode$object(_List_fromArray([
        _Utils_Tuple2("name", $elm$json$Json$Encode$string("aggregate")),
        _Utils_Tuple2("arguments", A2($elm$json$Json$Encode$list, $elm$core$Basics$identity, _List_fromArray([
            $elm$json$Json$Encode$object(_List_fromArray([
                _Utils_Tuple2("database", $elm$json$Json$Encode$string("sportrank")),
                _Utils_Tuple2("collection", $elm$json$Json$Encode$string("users")),
                _Utils_Tuple2("pipeline", $author$project$Extras$Constants$pipelineRequest)
            ]))
        ]))),
        _Utils_Tuple2("service", $elm$json$Json$Encode$string("mongodb-atlas"))
    ]));
    var $elm$http$Http$expectStringResponse = F2(function(toMsg, toResult) {
        return A3(_Http_expect, "", $elm$core$Basics$identity, A2($elm$core$Basics$composeR, toResult, toMsg));
    });
    var $elm$core$Result$mapError = F2(function(f, result) {
        if (result.$ === "Ok") {
            var v = result.a;
            return $elm$core$Result$Ok(v);
        } else {
            var e = result.a;
            return $elm$core$Result$Err(f(e));
        }
    });
    var $elm$http$Http$BadBody = function(a) {
        return {
            $: "BadBody",
            a: a
        };
    };
    var $elm$http$Http$BadStatus = function(a) {
        return {
            $: "BadStatus",
            a: a
        };
    };
    var $elm$http$Http$BadUrl = function(a) {
        return {
            $: "BadUrl",
            a: a
        };
    };
    var $elm$http$Http$NetworkError = {
        $: "NetworkError"
    };
    var $elm$http$Http$Timeout = {
        $: "Timeout"
    };
    var $elm$http$Http$resolve = F2(function(toResult, response) {
        switch(response.$){
            case "BadUrl_":
                var url = response.a;
                return $elm$core$Result$Err($elm$http$Http$BadUrl(url));
            case "Timeout_":
                return $elm$core$Result$Err($elm$http$Http$Timeout);
            case "NetworkError_":
                return $elm$core$Result$Err($elm$http$Http$NetworkError);
            case "BadStatus_":
                var metadata = response.a;
                return $elm$core$Result$Err($elm$http$Http$BadStatus(metadata.statusCode));
            default:
                var body = response.b;
                return A2($elm$core$Result$mapError, $elm$http$Http$BadBody, toResult(body));
        }
    });
    var $elm$http$Http$expectJson = F2(function(toMsg, decoder) {
        return A2($elm$http$Http$expectStringResponse, toMsg, $elm$http$Http$resolve(function(string) {
            return A2($elm$core$Result$mapError, $elm$json$Json$Decode$errorToString, A2($elm$json$Json$Decode$decodeString, decoder, string));
        }));
    });
    var $elm$json$Json$Decode$index = _Json_decodeIndex;
    var $elm$http$Http$jsonBody = function(value) {
        return A2(_Http_pair, "application/json", A2($elm$json$Json$Encode$encode, 0, value));
    };
    var $elm$json$Json$Decode$bool = _Json_decodeBool;
    var $author$project$Data$User$Description = F2(function(level, comment) {
        return {
            comment: comment,
            level: level
        };
    });
    var $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$custom = $elm$json$Json$Decode$map2($elm$core$Basics$apR);
    var $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required = F3(function(key, valDecoder, decoder) {
        return A2($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$custom, A2($elm$json$Json$Decode$field, key, valDecoder), decoder);
    });
    var $author$project$Data$User$descriptionDecoder = A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "comment", $elm$json$Json$Decode$string, A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "level", $elm$json$Json$Decode$string, $elm$json$Json$Decode$succeed($author$project$Data$User$Description)));
    var $author$project$Data$User$Female = {
        $: "Female"
    };
    var $author$project$Data$User$genderDecoder = A2($elm$json$Json$Decode$andThen, function(str) {
        switch(str){
            case "Male":
                return $elm$json$Json$Decode$succeed($author$project$Data$User$Male);
            case "Female":
                return $elm$json$Json$Decode$succeed($author$project$Data$User$Female);
            default:
                return $elm$json$Json$Decode$fail("Invalid gender");
        }
    }, $elm$json$Json$Decode$string);
    var $author$project$Data$User$idDecoder = A2($elm$json$Json$Decode$field, "$oid", $elm$json$Json$Decode$string);
    var $elm$json$Json$Decode$oneOf = _Json_oneOf;
    var $elm$json$Json$Decode$maybe = function(decoder) {
        return $elm$json$Json$Decode$oneOf(_List_fromArray([
            A2($elm$json$Json$Decode$map, $elm$core$Maybe$Just, decoder),
            $elm$json$Json$Decode$succeed($elm$core$Maybe$Nothing)
        ]));
    };
    var $author$project$Data$User$numberDecoder = A2($elm$json$Json$Decode$andThen, function(str) {
        var _v0 = $elm$core$String$toInt(str);
        if (_v0.$ === "Just") {
            var num = _v0.a;
            return $elm$json$Json$Decode$succeed(num);
        } else return $elm$json$Json$Decode$fail("Expected an integer");
    }, A2($elm$json$Json$Decode$field, "$numberInt", $elm$json$Json$Decode$string));
    var $elm$json$Json$Decode$null = _Json_decodeNull;
    var $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optionalDecoder = F3(function(path, valDecoder, fallback) {
        var nullOr = function(decoder) {
            return $elm$json$Json$Decode$oneOf(_List_fromArray([
                decoder,
                $elm$json$Json$Decode$null(fallback)
            ]));
        };
        var handleResult = function(input) {
            var _v0 = A2($elm$json$Json$Decode$decodeValue, A2($elm$json$Json$Decode$at, path, $elm$json$Json$Decode$value), input);
            if (_v0.$ === "Ok") {
                var rawValue = _v0.a;
                var _v1 = A2($elm$json$Json$Decode$decodeValue, nullOr(valDecoder), rawValue);
                if (_v1.$ === "Ok") {
                    var finalResult = _v1.a;
                    return $elm$json$Json$Decode$succeed(finalResult);
                } else return A2($elm$json$Json$Decode$at, path, nullOr(valDecoder));
            } else return $elm$json$Json$Decode$succeed(fallback);
        };
        return A2($elm$json$Json$Decode$andThen, handleResult, $elm$json$Json$Decode$value);
    });
    var $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional = F4(function(key, valDecoder, fallback, decoder) {
        return A2($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$custom, A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optionalDecoder, _List_fromArray([
            key
        ]), valDecoder, fallback), decoder);
    });
    var $author$project$Data$Hardware$Ranking = F8(function(id, active, name, owner_id, baseaddress, ladder, player_count, owner_name) {
        return {
            active: active,
            baseaddress: baseaddress,
            id: id,
            ladder: ladder,
            name: name,
            owner_id: owner_id,
            owner_name: owner_name,
            player_count: player_count
        };
    });
    var $author$project$Data$Hardware$BaseAddress = F2(function(street, city) {
        return {
            city: city,
            street: street
        };
    });
    var $author$project$Data$Hardware$baseAddressDecoder = A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "city", $elm$json$Json$Decode$string, A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "street", $elm$json$Json$Decode$string, $elm$json$Json$Decode$succeed($author$project$Data$Hardware$BaseAddress)));
    var $author$project$Data$Hardware$idDecoder = A2($elm$json$Json$Decode$field, "$oid", $elm$json$Json$Decode$string);
    var $author$project$Data$Hardware$ownerIdDecoder = A2($elm$json$Json$Decode$field, "$oid", $elm$json$Json$Decode$string);
    var $author$project$Data$Hardware$Player = F2(function(id, nickname) {
        return {
            id: id,
            nickname: nickname
        };
    });
    var $author$project$Data$Hardware$playerDecoder = A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "nickname", $elm$json$Json$Decode$string, A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "_id", $elm$json$Json$Decode$string, $elm$json$Json$Decode$succeed($author$project$Data$Hardware$Player)));
    var $author$project$Data$Hardware$rankDecoder = A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "challenger", $author$project$Data$Hardware$playerDecoder, A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "player", $author$project$Data$Hardware$playerDecoder, A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "rank", $elm$json$Json$Decode$int, $elm$json$Json$Decode$succeed($author$project$Data$Hardware$Rank))));
    var $author$project$Data$Hardware$rankingDecoder = A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "owner_name", $elm$json$Json$Decode$string, A4($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional, "player_count", $elm$json$Json$Decode$int, 1, A4($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional, "ranking", $elm$json$Json$Decode$list($author$project$Data$Hardware$rankDecoder), _List_fromArray([
        $author$project$Data$Hardware$emptyRank
    ]), A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "baseaddress", $author$project$Data$Hardware$baseAddressDecoder, A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "owner_id", $author$project$Data$Hardware$ownerIdDecoder, A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "name", $elm$json$Json$Decode$string, A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "active", $elm$json$Json$Decode$bool, A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "_id", $author$project$Data$Hardware$idDecoder, $elm$json$Json$Decode$succeed($author$project$Data$Hardware$Ranking)))))))));
    var $author$project$Data$User$stringToIntDecoder = A2($elm$json$Json$Decode$andThen, function(str) {
        var _v0 = $elm$core$String$toInt(str);
        if (_v0.$ === "Just") {
            var num = _v0.a;
            return $elm$json$Json$Decode$succeed(num);
        } else return $elm$json$Json$Decode$fail("Expected an integer");
    }, $elm$json$Json$Decode$string);
    var $author$project$Data$User$userInfoDecoder = A4($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional, "addInfo", $elm$json$Json$Decode$string, "No additional info supplied", A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "credits", A2($elm$json$Json$Decode$field, "$numberInt", $author$project$Data$User$stringToIntDecoder), A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "description", $author$project$Data$User$descriptionDecoder, A4($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional, "updatetext", $elm$json$Json$Decode$string, "", A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "memberRankings", $elm$json$Json$Decode$list($author$project$Data$Hardware$rankingDecoder), A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "ownedRankings", $elm$json$Json$Decode$list($author$project$Data$Hardware$rankingDecoder), A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "active", $elm$json$Json$Decode$bool, A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "datestamp", $author$project$Data$User$numberDecoder, A4($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional, "mobileValidationError", $elm$json$Json$Decode$string, "", A4($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional, "isMobileInputFocused", $elm$json$Json$Decode$bool, false, A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "mobile", $elm$json$Json$Decode$maybe($elm$json$Json$Decode$string), A4($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional, "emailValidationError", $elm$json$Json$Decode$string, "", A4($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional, "isEmailInputFocused", $elm$json$Json$Decode$bool, false, A4($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional, "email", $elm$json$Json$Decode$maybe($elm$json$Json$Decode$string), $elm$core$Maybe$Nothing, A4($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional, "gender", $author$project$Data$User$genderDecoder, $author$project$Data$User$Male, A4($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional, "age", $author$project$Data$User$numberDecoder, 20, A4($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional, "nameValidationError", $elm$json$Json$Decode$string, "", A4($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional, "isNameInputFocused", $elm$json$Json$Decode$bool, false, A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "nickname", $elm$json$Json$Decode$string, A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "token", $elm$json$Json$Decode$maybe($elm$json$Json$Decode$string), A4($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional, "password", $elm$json$Json$Decode$string, "", A4($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional, "email", $elm$json$Json$Decode$string, "", A3($NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required, "_id", $author$project$Data$User$idDecoder, $elm$json$Json$Decode$succeed($author$project$Data$User$UserInfo))))))))))))))))))))))));
    var $author$project$Pages$Hardware$callRequest = function(model) {
        var headers = _List_fromArray([
            A2($elm$http$Http$header, "Authorization", "Bearer " + A2($elm$core$Maybe$withDefault, "No access token ", model.apiSpecifics.accessToken))
        ]);
        var therequest = $elm$http$Http$request({
            body: $elm$http$Http$jsonBody($author$project$Extras$Constants$callRequestJson),
            expect: A2($elm$http$Http$expectJson, $author$project$Pages$Hardware$CallResponse, A2($elm$json$Json$Decode$index, 0, $author$project$Data$User$userInfoDecoder)),
            headers: headers,
            method: "POST",
            timeout: $elm$core$Maybe$Nothing,
            tracker: $elm$core$Maybe$Nothing,
            url: "https://ap-southeast-1.aws.realm.mongodb.com/api/client/v2.0/app/sr-espa1-snonq/functions/call"
        });
        return therequest;
    };
    var $author$project$Data$User$deleteRankingFromMemberRankings = F2(function(user, rankingid) {
        if (user.$ === "Registered") {
            var usrInfo = user.a;
            return A2($elm$core$List$filter, function(ranking) {
                return !_Utils_eq(ranking.id, rankingid);
            }, usrInfo.memberRankings);
        } else return _List_Nil;
    });
    var $author$project$Data$Hardware$emptyRanking = {
        active: false,
        baseaddress: {
            city: "",
            street: ""
        },
        id: "",
        ladder: _List_fromArray([
            $author$project$Data$Hardware$emptyRank
        ]),
        name: "",
        owner_id: "",
        owner_name: "",
        player_count: 0
    };
    var $author$project$Data$Hardware$gotRanking = function(ls) {
        switch(ls.$){
            case "Owned":
                var ranking = ls.a;
                return ranking;
            case "Member":
                var ranking = ls.a;
                return ranking;
            case "Spectator":
                var ranking = ls.a;
                return ranking;
            default:
                return $author$project$Data$Hardware$emptyRanking;
        }
    };
    var $author$project$Data$User$gotUserInfo = function(user) {
        if (user.$ === "Registered") {
            var usrInfo = user.a;
            return usrInfo;
        } else return $author$project$Data$User$emptyUserInfo;
    };
    var $author$project$Extras$Constants$noCurrentChallengerId = "6353e8b6aedf80653eb34191";
    var $author$project$Data$Hardware$isCurrentlyInAChallenge = function(rank) {
        return _Utils_eq(rank.player.id, $author$project$Extras$Constants$noCurrentChallengerId) || _Utils_eq(rank.challenger.id, $author$project$Extras$Constants$noCurrentChallengerId) ? false : true;
    };
    var $elm$parser$Parser$DeadEnd = F3(function(row, col, problem) {
        return {
            col: col,
            problem: problem,
            row: row
        };
    });
    var $elm$parser$Parser$problemToDeadEnd = function(p) {
        return A3($elm$parser$Parser$DeadEnd, p.row, p.col, p.problem);
    };
    var $elm$parser$Parser$Advanced$bagToList = F2(function(bag, list) {
        bagToList: while(true)switch(bag.$){
            case "Empty":
                return list;
            case "AddRight":
                var bag1 = bag.a;
                var x = bag.b;
                var $temp$bag = bag1, $temp$list = A2($elm$core$List$cons, x, list);
                bag = $temp$bag;
                list = $temp$list;
                continue bagToList;
            default:
                var bag1 = bag.a;
                var bag2 = bag.b;
                var $temp$bag = bag1, $temp$list = A2($elm$parser$Parser$Advanced$bagToList, bag2, list);
                bag = $temp$bag;
                list = $temp$list;
                continue bagToList;
        }
    });
    var $elm$parser$Parser$Advanced$run = F2(function(_v0, src) {
        var parse = _v0.a;
        var _v1 = parse({
            col: 1,
            context: _List_Nil,
            indent: 1,
            offset: 0,
            row: 1,
            src: src
        });
        if (_v1.$ === "Good") {
            var value = _v1.b;
            return $elm$core$Result$Ok(value);
        } else {
            var bag = _v1.b;
            return $elm$core$Result$Err(A2($elm$parser$Parser$Advanced$bagToList, bag, _List_Nil));
        }
    });
    var $elm$parser$Parser$run = F2(function(parser, source) {
        var _v0 = A2($elm$parser$Parser$Advanced$run, parser, source);
        if (_v0.$ === "Ok") {
            var a = _v0.a;
            return $elm$core$Result$Ok(a);
        } else {
            var problems = _v0.a;
            return $elm$core$Result$Err(A2($elm$core$List$map, $elm$parser$Parser$problemToDeadEnd, problems));
        }
    });
    var $elm$parser$Parser$Advanced$Bad = F2(function(a, b) {
        return {
            $: "Bad",
            a: a,
            b: b
        };
    });
    var $elm$parser$Parser$Advanced$Good = F3(function(a, b, c) {
        return {
            $: "Good",
            a: a,
            b: b,
            c: c
        };
    });
    var $elm$parser$Parser$Advanced$Parser = function(a) {
        return {
            $: "Parser",
            a: a
        };
    };
    var $elm$parser$Parser$Advanced$andThen = F2(function(callback, _v0) {
        var parseA = _v0.a;
        return $elm$parser$Parser$Advanced$Parser(function(s0) {
            var _v1 = parseA(s0);
            if (_v1.$ === "Bad") {
                var p = _v1.a;
                var x = _v1.b;
                return A2($elm$parser$Parser$Advanced$Bad, p, x);
            } else {
                var p1 = _v1.a;
                var a = _v1.b;
                var s1 = _v1.c;
                var _v2 = callback(a);
                var parseB = _v2.a;
                var _v3 = parseB(s1);
                if (_v3.$ === "Bad") {
                    var p2 = _v3.a;
                    var x = _v3.b;
                    return A2($elm$parser$Parser$Advanced$Bad, p1 || p2, x);
                } else {
                    var p2 = _v3.a;
                    var b = _v3.b;
                    var s2 = _v3.c;
                    return A3($elm$parser$Parser$Advanced$Good, p1 || p2, b, s2);
                }
            }
        });
    });
    var $elm$parser$Parser$andThen = $elm$parser$Parser$Advanced$andThen;
    var $elm$parser$Parser$Advanced$isSubChar = _Parser_isSubChar;
    var $elm$parser$Parser$Advanced$chompWhileHelp = F5(function(isGood, offset, row, col, s0) {
        chompWhileHelp: while(true){
            var newOffset = A3($elm$parser$Parser$Advanced$isSubChar, isGood, offset, s0.src);
            if (_Utils_eq(newOffset, -1)) return A3($elm$parser$Parser$Advanced$Good, _Utils_cmp(s0.offset, offset) < 0, _Utils_Tuple0, {
                col: col,
                context: s0.context,
                indent: s0.indent,
                offset: offset,
                row: row,
                src: s0.src
            });
            else if (_Utils_eq(newOffset, -2)) {
                var $temp$isGood = isGood, $temp$offset = offset + 1, $temp$row = row + 1, $temp$col = 1, $temp$s0 = s0;
                isGood = $temp$isGood;
                offset = $temp$offset;
                row = $temp$row;
                col = $temp$col;
                s0 = $temp$s0;
                continue chompWhileHelp;
            } else {
                var $temp$isGood = isGood, $temp$offset = newOffset, $temp$row = row, $temp$col = col + 1, $temp$s0 = s0;
                isGood = $temp$isGood;
                offset = $temp$offset;
                row = $temp$row;
                col = $temp$col;
                s0 = $temp$s0;
                continue chompWhileHelp;
            }
        }
    });
    var $elm$parser$Parser$Advanced$chompWhile = function(isGood) {
        return $elm$parser$Parser$Advanced$Parser(function(s) {
            return A5($elm$parser$Parser$Advanced$chompWhileHelp, isGood, s.offset, s.row, s.col, s);
        });
    };
    var $elm$parser$Parser$chompWhile = $elm$parser$Parser$Advanced$chompWhile;
    var $elm$parser$Parser$ExpectingEnd = {
        $: "ExpectingEnd"
    };
    var $elm$parser$Parser$Advanced$AddRight = F2(function(a, b) {
        return {
            $: "AddRight",
            a: a,
            b: b
        };
    });
    var $elm$parser$Parser$Advanced$DeadEnd = F4(function(row, col, problem, contextStack) {
        return {
            col: col,
            contextStack: contextStack,
            problem: problem,
            row: row
        };
    });
    var $elm$parser$Parser$Advanced$Empty = {
        $: "Empty"
    };
    var $elm$parser$Parser$Advanced$fromState = F2(function(s, x) {
        return A2($elm$parser$Parser$Advanced$AddRight, $elm$parser$Parser$Advanced$Empty, A4($elm$parser$Parser$Advanced$DeadEnd, s.row, s.col, x, s.context));
    });
    var $elm$parser$Parser$Advanced$end = function(x) {
        return $elm$parser$Parser$Advanced$Parser(function(s) {
            return _Utils_eq($elm$core$String$length(s.src), s.offset) ? A3($elm$parser$Parser$Advanced$Good, false, _Utils_Tuple0, s) : A2($elm$parser$Parser$Advanced$Bad, false, A2($elm$parser$Parser$Advanced$fromState, s, x));
        });
    };
    var $elm$parser$Parser$end = $elm$parser$Parser$Advanced$end($elm$parser$Parser$ExpectingEnd);
    var $elm$parser$Parser$Advanced$mapChompedString = F2(function(func, _v0) {
        var parse = _v0.a;
        return $elm$parser$Parser$Advanced$Parser(function(s0) {
            var _v1 = parse(s0);
            if (_v1.$ === "Bad") {
                var p = _v1.a;
                var x = _v1.b;
                return A2($elm$parser$Parser$Advanced$Bad, p, x);
            } else {
                var p = _v1.a;
                var a = _v1.b;
                var s1 = _v1.c;
                return A3($elm$parser$Parser$Advanced$Good, p, A2(func, A3($elm$core$String$slice, s0.offset, s1.offset, s0.src), a), s1);
            }
        });
    });
    var $elm$parser$Parser$Advanced$getChompedString = function(parser) {
        return A2($elm$parser$Parser$Advanced$mapChompedString, $elm$core$Basics$always, parser);
    };
    var $elm$parser$Parser$getChompedString = $elm$parser$Parser$Advanced$getChompedString;
    var $elm$parser$Parser$Advanced$map = F2(function(func, _v0) {
        var parse = _v0.a;
        return $elm$parser$Parser$Advanced$Parser(function(s0) {
            var _v1 = parse(s0);
            if (_v1.$ === "Good") {
                var p = _v1.a;
                var a = _v1.b;
                var s1 = _v1.c;
                return A3($elm$parser$Parser$Advanced$Good, p, func(a), s1);
            } else {
                var p = _v1.a;
                var x = _v1.b;
                return A2($elm$parser$Parser$Advanced$Bad, p, x);
            }
        });
    });
    var $elm$parser$Parser$map = $elm$parser$Parser$Advanced$map;
    var $elm$parser$Parser$Problem = function(a) {
        return {
            $: "Problem",
            a: a
        };
    };
    var $elm$parser$Parser$Advanced$problem = function(x) {
        return $elm$parser$Parser$Advanced$Parser(function(s) {
            return A2($elm$parser$Parser$Advanced$Bad, false, A2($elm$parser$Parser$Advanced$fromState, s, x));
        });
    };
    var $elm$parser$Parser$problem = function(msg) {
        return $elm$parser$Parser$Advanced$problem($elm$parser$Parser$Problem(msg));
    };
    var $elm$parser$Parser$Advanced$succeed = function(a) {
        return $elm$parser$Parser$Advanced$Parser(function(s) {
            return A3($elm$parser$Parser$Advanced$Good, false, a, s);
        });
    };
    var $elm$parser$Parser$succeed = $elm$parser$Parser$Advanced$succeed;
    var $author$project$Data$Hardware$validXMRAddressParser = A2($elm$parser$Parser$andThen, function(str) {
        return A2($elm$parser$Parser$map, function(_v0) {
            return str;
        }, $elm$parser$Parser$end);
    }, A2($elm$parser$Parser$andThen, function(str) {
        return $elm$core$String$length(str) === 95 ? $elm$parser$Parser$succeed(str) : $elm$parser$Parser$problem("Invalid length");
    }, $elm$parser$Parser$getChompedString($elm$parser$Parser$chompWhile($elm$core$Char$isAlphaNum))));
    var $author$project$Pages$Hardware$isValidXMRAddress = function(str) {
        var _v0 = A2($elm$parser$Parser$run, $author$project$Data$Hardware$validXMRAddressParser, str);
        if (_v0.$ === "Ok") return true;
        else return false;
    };
    var $author$project$Pages$Hardware$OperationEventMsg = function(operationEventMsg) {
        return {
            operationEventMsg: operationEventMsg
        };
    };
    var $author$project$Pages$Hardware$justmsgFieldFromJsonDecoder = A2($elm$json$Json$Decode$map, $author$project$Pages$Hardware$OperationEventMsg, A2($elm$json$Json$Decode$field, "operationEventMsg", $elm$json$Json$Decode$string));
    var $author$project$Extras$Constants$placeholderUrl = A6($elm$url$Url$Url, $elm$url$Url$Http, "localhost", $elm$core$Maybe$Just(3000), "", $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing);
    var $author$project$Pages$Hardware$ProfileResponse = function(a) {
        return {
            $: "ProfileResponse",
            a: a
        };
    };
    var $author$project$Pages$Hardware$SuccessfullProfileResult = F5(function(user_id, domain_id, identities, data, typeOfData) {
        return {
            data: data,
            domain_id: domain_id,
            identities: identities,
            typeOfData: typeOfData,
            user_id: user_id
        };
    });
    var $author$project$Pages$Hardware$Identities = F4(function(id, provider_type, provider_id, provider_data) {
        return {
            id: id,
            provider_data: provider_data,
            provider_id: provider_id,
            provider_type: provider_type
        };
    });
    var $elm$json$Json$Decode$map4 = _Json_map4;
    var $author$project$Pages$Hardware$ProviderData = function(email) {
        return {
            email: email
        };
    };
    var $author$project$Pages$Hardware$providerDataDecoder = A2($elm$json$Json$Decode$map, $author$project$Pages$Hardware$ProviderData, A2($elm$json$Json$Decode$field, "email", $elm$json$Json$Decode$string));
    var $author$project$Pages$Hardware$identitiesDecoder = $elm$json$Json$Decode$list(A5($elm$json$Json$Decode$map4, $author$project$Pages$Hardware$Identities, A2($elm$json$Json$Decode$field, "id", $elm$json$Json$Decode$string), A2($elm$json$Json$Decode$field, "provider_type", $elm$json$Json$Decode$string), A2($elm$json$Json$Decode$field, "provider_id", $elm$json$Json$Decode$string), A2($elm$json$Json$Decode$field, "provider_data", $author$project$Pages$Hardware$providerDataDecoder)));
    var $author$project$Pages$Hardware$profileDecoder = A6($elm$json$Json$Decode$map5, $author$project$Pages$Hardware$SuccessfullProfileResult, A2($elm$json$Json$Decode$field, "user_id", $elm$json$Json$Decode$string), A2($elm$json$Json$Decode$field, "domain_id", $elm$json$Json$Decode$string), A2($elm$json$Json$Decode$field, "identities", $author$project$Pages$Hardware$identitiesDecoder), A2($elm$json$Json$Decode$field, "data", $author$project$Pages$Hardware$providerDataDecoder), A2($elm$json$Json$Decode$field, "type", $elm$json$Json$Decode$string));
    var $author$project$Pages$Hardware$profileRequest = function(model) {
        var headers = _List_fromArray([
            A2($elm$http$Http$header, "Authorization", "Bearer " + A2($elm$core$Maybe$withDefault, "No access token ", model.apiSpecifics.accessToken))
        ]);
        var therequest = $elm$http$Http$request({
            body: $elm$http$Http$emptyBody,
            expect: A2($elm$http$Http$expectJson, $author$project$Pages$Hardware$ProfileResponse, $author$project$Pages$Hardware$profileDecoder),
            headers: headers,
            method: "GET",
            timeout: $elm$core$Maybe$Nothing,
            tracker: $elm$core$Maybe$Nothing,
            url: "https://ap-southeast-1.aws.realm.mongodb.com/api/client/v2.0/auth/profile"
        });
        return therequest;
    };
    var $author$project$Pages$Hardware$Error = function(a) {
        return {
            $: "Error",
            a: a
        };
    };
    var $author$project$Pages$Hardware$validateEmail = function(eml) {
        var pattern = $elm$regex$Regex$fromString("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$");
        if (eml.$ === "Just") {
            var email = eml.a;
            if (pattern.$ === "Just") {
                var patn = pattern.a;
                return A2($elm$regex$Regex$contains, patn, email) ? $elm$core$Result$Ok(email) : $elm$core$Result$Err("Please enter a valid email format");
            } else return $elm$core$Result$Err("");
        } else return $elm$core$Result$Err("Email ");
    };
    var $author$project$Pages$Hardware$validateName = function(nme) {
        var pattern = $elm$regex$Regex$fromString("^[a-zA-Z\\s]+$");
        if (nme.$ === "Just") {
            var name = nme.a;
            if ($elm$core$String$length(name) >= 3 && $elm$core$String$length(name) <= 30) {
                if (pattern.$ === "Just") {
                    var patn = pattern.a;
                    return A2($elm$regex$Regex$contains, patn, name) ? $elm$core$Result$Ok(name) : $elm$core$Result$Err("Name can only contain alphabetic characters");
                } else return $elm$core$Result$Err("Name can only contain alphabetic characters");
            } else {
                if ($elm$core$String$isEmpty(name)) return $elm$core$Result$Err("Name cannot be empty");
                else {
                    if ($elm$core$String$length(name) < 3) return $elm$core$Result$Err("Name must have at least 3 characters");
                    else return $elm$core$Result$Err("Name cannot exceed 30 characters");
                }
            }
        } else return $elm$core$Result$Err("Name ");
    };
    var $author$project$Pages$Hardware$validatePassword = function(pword) {
        var pattern = $elm$regex$Regex$fromString("^.{6,30}$");
        if (pattern.$ === "Just") {
            var patn = pattern.a;
            return A2($elm$regex$Regex$contains, patn, pword) ? $elm$core$Result$Ok(pword) : $elm$core$Result$Err("Please enter a password between 6 and 30 characters in length");
        } else return $elm$core$Result$Err("");
    };
    var $author$project$Pages$Hardware$updateNewUserRegistrationFormField = F3(function(msg, queryType, model) {
        var newUserDetails = function() {
            if (queryType.$ === "RegisterUser") {
                var userDetails = queryType.a;
                switch(msg.$){
                    case "UpdateNickName":
                        var nme = msg.a;
                        var newname = nme === "" ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(nme);
                        var vldResult = function() {
                            var _v3 = $author$project$Pages$Hardware$validateName(newname);
                            if (_v3.$ === "Ok") return "";
                            else {
                                var err = _v3.a;
                                return err;
                            }
                        }();
                        return _Utils_update(userDetails, {
                            nameValidationError: vldResult,
                            nickname: nme
                        });
                    case "UpdateAge":
                        var age = msg.a;
                        return _Utils_update(userDetails, {
                            age: age
                        });
                    case "UpdateGender":
                        var value = msg.a;
                        var newValue = function() {
                            switch(value){
                                case "Male":
                                    return $author$project$Data$User$Male;
                                case "Female":
                                    return $author$project$Data$User$Female;
                                default:
                                    return $author$project$Data$User$Male;
                            }
                        }();
                        return _Utils_update(userDetails, {
                            gender: newValue
                        });
                    case "UpdateEmail":
                        var email = msg.a;
                        var newemail = email === "" ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(email);
                        var vldResult = function() {
                            var _v5 = $author$project$Pages$Hardware$validateEmail(newemail);
                            if (_v5.$ === "Ok") return "";
                            else {
                                var err = _v5.a;
                                return err;
                            }
                        }();
                        return _Utils_update(userDetails, {
                            email: newemail,
                            emailValidationError: vldResult
                        });
                    case "UpdatePassword":
                        var pword = msg.a;
                        var vldResult = function() {
                            var _v6 = $author$project$Pages$Hardware$validatePassword(pword);
                            if (_v6.$ === "Ok") return "";
                            else {
                                var err = _v6.a;
                                return err;
                            }
                        }();
                        return _Utils_update(userDetails, {
                            password: pword,
                            passwordValidationError: vldResult
                        });
                    case "UpdateLevel":
                        var value = msg.a;
                        var desc = userDetails.description;
                        var newDesc = _Utils_update(desc, {
                            level: value
                        });
                        return _Utils_update(userDetails, {
                            description: newDesc
                        });
                    case "UpdateComment":
                        var value = msg.a;
                        var desc = userDetails.description;
                        var newDesc = _Utils_update(desc, {
                            comment: value
                        });
                        return _Utils_update(userDetails, {
                            description: newDesc
                        });
                    case "UpdateMobile":
                        var value = msg.a;
                        return _Utils_update(userDetails, {
                            mobile: $elm$core$Maybe$Just(value)
                        });
                    case "AddInfoInput":
                        var value = msg.a;
                        return _Utils_update(userDetails, {
                            addInfo: value
                        });
                    default:
                        return userDetails;
                }
            } else return $author$project$Data$User$emptyUserInfo;
        }();
        var newLoginOrRegistration = function() {
            if (queryType.$ === "RegisterUser") return $author$project$Pages$Hardware$RegisterUser(newUserDetails);
            else return $author$project$Pages$Hardware$Error("newLoginOrRegistration err");
        }();
        return _Utils_update(model, {
            queryType: newLoginOrRegistration
        });
    });
    var $author$project$Data$Hardware$updatedCity = F2(function(ranking, str) {
        var baseaddress = ranking.baseaddress;
        var newBaseAddress = _Utils_update(baseaddress, {
            city: str
        });
        return _Utils_update(ranking, {
            baseaddress: newBaseAddress
        });
    });
    var $author$project$Data$Hardware$updatedRankingName = F2(function(ranking, str) {
        return _Utils_update(ranking, {
            name: str
        });
    });
    var $author$project$Data$Hardware$updatedStreet = F2(function(ranking, str) {
        var baseaddress = ranking.baseaddress;
        var newBaseAddress = _Utils_update(baseaddress, {
            street: str
        });
        return _Utils_update(ranking, {
            baseaddress: newBaseAddress
        });
    });
    var $author$project$Pages$Hardware$update = F2(function(msg, model) {
        switch(msg.$){
            case "NoOp":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "CancelDialoguePrepareResultView":
                return _Utils_Tuple2(_Utils_update(model, {
                    queryType: $author$project$Pages$Hardware$MemberSelectedView
                }), $elm$core$Platform$Cmd$none);
            case "DialogueConfirmDeleteAccount":
                return _Utils_Tuple2(_Utils_update(model, {
                    queryType: $author$project$Pages$Hardware$ConfirmDeleteUserView
                }), $elm$core$Platform$Cmd$none);
            case "DeleteAccount":
                return _Utils_Tuple2(_Utils_update(model, {
                    queryType: $author$project$Pages$Hardware$Login($author$project$Extras$Constants$emptyEmailPassword)
                }), $elm$core$Platform$Cmd$none);
            case "ConfirmLeaveMemberRanking":
                var newUser = $author$project$Data$User$gotUserInfo(model.user);
                var newMemberRankings = function() {
                    var _v1 = model.selectedranking;
                    if (_v1.$ === "Member") {
                        var ranking = _v1.a;
                        return A2($author$project$Data$User$deleteRankingFromMemberRankings, model.user, ranking.id);
                    } else return _List_fromArray([
                        $author$project$Data$Hardware$emptyRanking
                    ]);
                }();
                var newUserInfo = _Utils_update(newUser, {
                    memberRankings: newMemberRankings
                });
                return _Utils_Tuple2(_Utils_update(model, {
                    queryType: $author$project$Pages$Hardware$LoggedInUser,
                    user: $author$project$Data$User$Registered(newUserInfo)
                }), $elm$core$Platform$Cmd$none);
            case "RegisteredUserJoin":
                return _Utils_Tuple2(_Utils_update(model, {
                    queryType: $author$project$Pages$Hardware$LoggedInUser
                }), $elm$core$Platform$Cmd$none);
            case "DialogueConfirmJoinView":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "DialogueConfirmLeaveView":
                return _Utils_Tuple2(_Utils_update(model, {
                    queryType: $author$project$Pages$Hardware$ConfirmLeaveMemberView
                }), $elm$core$Platform$Cmd$none);
            case "ConfirmJoin":
                return _Utils_Tuple2(_Utils_update(model, {
                    queryType: $author$project$Pages$Hardware$SpectatorSelectedView
                }), $elm$core$Platform$Cmd$none);
            case "SpectatorJoin":
                var _v2 = model.user;
                if (_v2.$ === "Registered") {
                    var userInfo = _v2.a;
                    return _Utils_Tuple2(_Utils_update(model, {
                        queryType: $author$project$Pages$Hardware$ConfirmJoinMemberView
                    }), $elm$core$Platform$Cmd$none);
                } else return _Utils_Tuple2(_Utils_update(model, {
                    queryType: $author$project$Pages$Hardware$RegisterUser($author$project$Data$User$emptyUserInfo)
                }), $elm$core$Platform$Cmd$none);
            case "CancelRegistration":
                return _Utils_Tuple2(_Utils_update(model, {
                    queryType: $author$project$Pages$Hardware$Login($author$project$Extras$Constants$emptyEmailPassword)
                }), $elm$core$Platform$Cmd$none);
            case "ConfirmChallenge":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "ConfirmResult":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "ViewRank":
                var rank = msg.a;
                var ranking = function() {
                    var _v3 = model.selectedranking;
                    switch(_v3.$){
                        case "Owned":
                            var rankng = _v3.a;
                            return rankng;
                        case "Member":
                            var rankng = _v3.a;
                            return rankng;
                        case "Spectator":
                            var rankng = _v3.a;
                            return rankng;
                        default:
                            return $author$project$Data$Hardware$emptyRanking;
                    }
                }();
                var qType = $author$project$Data$Hardware$isCurrentlyInAChallenge(rank) ? $author$project$Pages$Hardware$PrepareResult : A2($author$project$Pages$Hardware$CreateChallengeView, rank, ranking);
                return _Utils_Tuple2(_Utils_update(model, {
                    queryType: qType,
                    selectedSingleRank: rank
                }), $elm$core$Platform$Cmd$none);
            case "CancelCreateNewRanking":
                return _Utils_Tuple2(_Utils_update(model, {
                    queryType: $author$project$Pages$Hardware$LoggedInUser
                }), $elm$core$Platform$Cmd$none);
            case "CancelFetchedMember":
                return _Utils_Tuple2(_Utils_update(model, {
                    queryType: $author$project$Pages$Hardware$LoggedInUser
                }), $elm$core$Platform$Cmd$none);
            case "CancelFetchedOwned":
                return _Utils_Tuple2(_Utils_update(model, {
                    queryType: $author$project$Pages$Hardware$LoggedInUser
                }), $elm$core$Platform$Cmd$none);
            case "CancelFetchedSpectator":
                return _Utils_Tuple2(_Utils_update(model, {
                    queryType: $author$project$Pages$Hardware$LoggedInUser
                }), $elm$core$Platform$Cmd$none);
            case "DeleteOwnedRanking":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "DialogDeleteOwnedRanking":
                return _Utils_Tuple2(_Utils_update(model, {
                    queryType: $author$project$Pages$Hardware$ConfirmDeleteOwnedRanking
                }), $elm$core$Platform$Cmd$none);
            case "RankingNameChg":
                var value = msg.a;
                return _Utils_Tuple2(_Utils_update(model, {
                    selectedranking: $author$project$Data$Hardware$Owned(A2($author$project$Data$Hardware$updatedRankingName, $author$project$Data$Hardware$gotRanking(model.selectedranking), value))
                }), $elm$core$Platform$Cmd$none);
            case "StreetAddressChg":
                var value = msg.a;
                return _Utils_Tuple2(_Utils_update(model, {
                    selectedranking: $author$project$Data$Hardware$Owned(A2($author$project$Data$Hardware$updatedStreet, $author$project$Data$Hardware$gotRanking(model.selectedranking), value))
                }), $elm$core$Platform$Cmd$none);
            case "CityAddressChg":
                var value = msg.a;
                return _Utils_Tuple2(_Utils_update(model, {
                    selectedranking: $author$project$Data$Hardware$Owned(A2($author$project$Data$Hardware$updatedCity, $author$project$Data$Hardware$gotRanking(model.selectedranking), value))
                }), $elm$core$Platform$Cmd$none);
            case "CreateNewRanking":
                var userInfo = msg.a;
                var newRanking = $author$project$Data$Hardware$emptyRanking;
                var newRank = A3($author$project$Data$Hardware$Rank, 1, {
                    id: userInfo.userid,
                    nickname: userInfo.nickname
                }, {
                    id: $author$project$Extras$Constants$noCurrentChallengerId,
                    nickname: "Challenger"
                });
                return _Utils_Tuple2(_Utils_update(model, {
                    queryType: $author$project$Pages$Hardware$CreatingNewLadder(userInfo),
                    selectedranking: $author$project$Data$Hardware$Owned(_Utils_update(newRanking, {
                        active: true,
                        ladder: _List_fromArray([
                            newRank
                        ]),
                        owner_id: userInfo.userid,
                        owner_name: userInfo.nickname,
                        player_count: 1
                    }))
                }), $elm$core$Platform$Cmd$none);
            case "ViewMember":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "FetchMember":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "ListSpectator":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "FetchOwned":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "ResponseDataFromMain":
                var receivedJson = msg.a;
                var decodedHardwareDeviceMsg = function() {
                    var _v4 = A2($elm$json$Json$Decode$decodeValue, $author$project$Pages$Hardware$justmsgFieldFromJsonDecoder, receivedJson);
                    if (_v4.$ === "Ok") {
                        var message = _v4.a;
                        return message.operationEventMsg;
                    } else {
                        var err = _v4.a;
                        return "error";
                    }
                }();
                var updatedIsLNSConnected = decodedHardwareDeviceMsg === "nanoS" ? true : false;
                var updatedIsLNXConnected = decodedHardwareDeviceMsg === "nanoX" ? true : false;
                var updatedIsXMRConnected = $author$project$Pages$Hardware$isValidXMRAddress(decodedHardwareDeviceMsg) ? true : false;
                return _Utils_Tuple2(_Utils_update(model, {
                    isHardwareLNSConnected: updatedIsLNSConnected,
                    isHardwareLNXConnected: updatedIsLNXConnected,
                    isXMRWalletConnected: updatedIsXMRConnected
                }), $elm$core$Platform$Cmd$none);
            case "Confirm":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "ConfirmNewRanking":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "Cancel":
                return _Utils_Tuple2(function() {
                    var _v5 = model.queryType;
                    switch(_v5.$){
                        case "ConfirmDeleteOwnedRanking":
                            return _Utils_update(model, {
                                queryType: $author$project$Pages$Hardware$OwnedSelectedView
                            });
                        case "ConfirmChallengeView":
                            return _Utils_update(model, {
                                queryType: $author$project$Pages$Hardware$MemberSelectedView
                            });
                        case "CreateChallengeView":
                            return _Utils_update(model, {
                                queryType: $author$project$Pages$Hardware$LoggedInUser
                            });
                        default:
                            return _Utils_update(model, {
                                queryType: $author$project$Pages$Hardware$Login($author$project$Extras$Constants$emptyEmailPassword)
                            });
                    }
                }(), $elm$core$Platform$Cmd$none);
            case "LogOut":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "ClickedHardwareDeviceConnect":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "ClickedXMRWalletConnect":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "ClickedXMRInitiateTransaction":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "RegisUser":
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "Create":
                return _Utils_Tuple2(_Utils_update(model, {
                    queryType: $author$project$Pages$Hardware$RegisterUser($author$project$Data$User$emptyUserInfo)
                }), $elm$core$Platform$Cmd$none);
            case "SearchInputChg":
                var searchTerm = msg.a;
                return _Utils_Tuple2(_Utils_update(model, {
                    searchterm: searchTerm
                }), $elm$core$Platform$Cmd$none);
            case "UserLoginEmailInputChg":
                var newemail = msg.a;
                return _Utils_Tuple2(_Utils_update(model, {
                    emailpassword: {
                        email: newemail,
                        password: model.emailpassword.password
                    }
                }), $elm$core$Platform$Cmd$none);
            case "UserLoginPasswordInputChg":
                var newPwrd = msg.a;
                return _Utils_Tuple2(_Utils_update(model, {
                    emailpassword: {
                        email: model.emailpassword.email,
                        password: newPwrd
                    }
                }), $elm$core$Platform$Cmd$none);
            case "ToggleReturnUser":
                return _Utils_Tuple2(_Utils_update(model, {
                    isReturnUser: !model.isReturnUser
                }), $elm$core$Platform$Cmd$none);
            case "SelDateTime":
                var selectedHour = msg.a;
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "InputFocused":
                var inputElement = msg.a;
                var _v6 = model.queryType;
                if (_v6.$ === "RegisterUser") {
                    var bkaapt = _v6.a;
                    var newApiSpecs = model.apiSpecifics;
                    return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
                } else return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "InputBlurred":
                var inputElement = msg.a;
                var _v7 = model.queryType;
                if (_v7.$ === "RegisterUser") {
                    var bkaapt = _v7.a;
                    var newApiSpecs = model.apiSpecifics;
                    return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
                } else return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "Tick":
                var newTime = msg.a;
                var dateTimeOnlyUpdatedIfNotSelected = function() {
                    var _v8 = model.datetimeFromMain;
                    if (_v8.$ === "Just") {
                        if (_v8.a.$ === "CurrentDateTime") {
                            var _v9 = _v8.a;
                            return $elm$core$Maybe$Just(A2($author$project$Types$DateType$CurrentDateTime, newTime, $elm$time$Time$utc));
                        } else {
                            var _v10 = _v8.a;
                            var dt = _v10.a;
                            var zone = _v10.b;
                            return $elm$core$Maybe$Just(A2($author$project$Types$DateType$SelectedDateTime, dt, zone));
                        }
                    } else return $elm$core$Maybe$Just(A2($author$project$Types$DateType$CurrentDateTime, newTime, $elm$time$Time$utc));
                }();
                return _Utils_Tuple2(_Utils_update(model, {
                    datetimeFromMain: dateTimeOnlyUpdatedIfNotSelected
                }), $elm$core$Platform$Cmd$none);
            case "DismissErrors":
                return _Utils_Tuple2(_Utils_update(model, {
                    errors: _List_Nil
                }), $elm$core$Platform$Cmd$none);
            case "CallResponse":
                if (msg.a.$ === "Ok") {
                    var auth = msg.a.a;
                    var headers = _List_fromArray([
                        A2($elm$http$Http$header, "Authorization", "Bearer " + A2($elm$core$Maybe$withDefault, "No access token", auth.token))
                    ]);
                    var flagUrlWithMongoDBMWAndPortUpdate = A2($elm$core$String$contains, $author$project$Extras$Constants$localorproductionServerAutoCheck, model.flagUrl.host) ? $elm$url$Url$toString(A6($elm$url$Url$Url, model.flagUrl.protocol, model.flagUrl.host, $elm$core$Maybe$Nothing, $author$project$Extras$Constants$middleWarePath, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing)) : $elm$url$Url$toString(A6($elm$url$Url$Url, model.flagUrl.protocol, model.flagUrl.host, $elm$core$Maybe$Just(3000), $author$project$Extras$Constants$middleWarePath, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing));
                    var newHttpParams = A6($author$project$Pages$Hardware$ToMongoDBMWConfig, $author$project$Extras$Constants$get, headers, flagUrlWithMongoDBMWAndPortUpdate, $elm$http$Http$emptyBody, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing);
                    var newModel = _Utils_update(model, {
                        isValidNewAccessToken: true,
                        queryType: $author$project$Pages$Hardware$LoggedInUser,
                        toMongoDBMWConfig: $elm$core$Maybe$Just(newHttpParams),
                        user: $author$project$Data$User$Registered(auth)
                    });
                    var apiSpecs = model.apiSpecifics;
                    return _Utils_Tuple2(newModel, $elm$core$Platform$Cmd$none);
                } else {
                    var responseErr = msg.a.a;
                    var respErr = $author$project$Extras$Constants$httpErrorToString(responseErr);
                    var apiSpecs = model.apiSpecifics;
                    var newapiSpecs = _Utils_update(apiSpecs, {
                        accessToken: $elm$core$Maybe$Nothing
                    });
                    return _Utils_Tuple2(_Utils_update(model, {
                        apiSpecifics: newapiSpecs,
                        errors: _Utils_ap(model.errors, _List_fromArray([
                            respErr
                        ])),
                        isValidNewAccessToken: false
                    }), $elm$core$Platform$Cmd$none);
                }
            case "ProfileResponse":
                if (msg.a.$ === "Ok") {
                    var auth = msg.a.a;
                    var headers = _List_fromArray([
                        A2($elm$http$Http$header, "Authorization", "Bearer " + A2($elm$core$Maybe$withDefault, "No access token 2", $elm$core$Maybe$Just(auth.typeOfData)))
                    ]);
                    var flagUrlWithMongoDBMWAndPortUpdate = A2($elm$core$String$contains, $author$project$Extras$Constants$localorproductionServerAutoCheck, model.flagUrl.host) ? $elm$url$Url$toString(A6($elm$url$Url$Url, model.flagUrl.protocol, model.flagUrl.host, $elm$core$Maybe$Nothing, $author$project$Extras$Constants$middleWarePath, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing)) : $elm$url$Url$toString(A6($elm$url$Url$Url, model.flagUrl.protocol, model.flagUrl.host, $elm$core$Maybe$Just(3000), $author$project$Extras$Constants$middleWarePath, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing));
                    var newHttpParams = A6($author$project$Pages$Hardware$ToMongoDBMWConfig, $author$project$Extras$Constants$get, headers, flagUrlWithMongoDBMWAndPortUpdate, $elm$http$Http$emptyBody, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing);
                    var newModel = _Utils_update(model, {
                        isValidNewAccessToken: true,
                        toMongoDBMWConfig: $elm$core$Maybe$Just(newHttpParams)
                    });
                    var apiSpecs = model.apiSpecifics;
                    return _Utils_Tuple2(newModel, $author$project$Pages$Hardware$callRequest(newModel));
                } else {
                    var responseErr = msg.a.a;
                    var respErr = $author$project$Extras$Constants$httpErrorToString(responseErr);
                    var apiSpecs = model.apiSpecifics;
                    var newapiSpecs = _Utils_update(apiSpecs, {
                        accessToken: $elm$core$Maybe$Nothing
                    });
                    return _Utils_Tuple2(_Utils_update(model, {
                        apiSpecifics: newapiSpecs,
                        errors: _Utils_ap(model.errors, _List_fromArray([
                            respErr
                        ])),
                        isValidNewAccessToken: false
                    }), $elm$core$Platform$Cmd$none);
                }
            case "LNSConnectResponse":
                if (msg.a.$ === "Ok") {
                    var auth = msg.a.a;
                    var headers = _List_Nil;
                    var flagUrlWithMongoDBMWAndPortUpdate = A2($elm$core$String$contains, $author$project$Extras$Constants$localorproductionServerAutoCheck, model.flagUrl.host) ? $elm$url$Url$toString(A6($elm$url$Url$Url, model.flagUrl.protocol, model.flagUrl.host, $elm$core$Maybe$Nothing, $author$project$Extras$Constants$middleWarePath, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing)) : $elm$url$Url$toString(A6($elm$url$Url$Url, model.flagUrl.protocol, model.flagUrl.host, $elm$core$Maybe$Just(3000), $author$project$Extras$Constants$middleWarePath, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing));
                    var newHttpParams = A6($author$project$Pages$Hardware$ToMongoDBMWConfig, $author$project$Extras$Constants$get, headers, flagUrlWithMongoDBMWAndPortUpdate, $elm$http$Http$emptyBody, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing);
                    var newModel = _Utils_update(model, {
                        queryType: $author$project$Pages$Hardware$LoggedInUser,
                        toMongoDBMWConfig: $elm$core$Maybe$Just(newHttpParams)
                    });
                    var apiSpecs = model.apiSpecifics;
                    return _Utils_Tuple2(newModel, $elm$core$Platform$Cmd$none);
                } else {
                    var responseErr = msg.a.a;
                    var respErr = $author$project$Extras$Constants$httpErrorToString(responseErr);
                    var apiSpecs = model.apiSpecifics;
                    var newapiSpecs = _Utils_update(apiSpecs, {
                        accessToken: $elm$core$Maybe$Nothing
                    });
                    return _Utils_Tuple2(_Utils_update(model, {
                        apiSpecifics: newapiSpecs,
                        errors: _Utils_ap(model.errors, _List_fromArray([
                            respErr
                        ])),
                        isValidNewAccessToken: false
                    }), $elm$core$Platform$Cmd$none);
                }
            case "BookingForm":
                var separatePosixDateandTimeCombined = msg.a;
                var apiSpecs = model.apiSpecifics;
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "LoginResponse":
                if (msg.a.$ === "Ok") {
                    var auth = msg.a.a;
                    var headers = _List_fromArray([
                        A2($elm$http$Http$header, "Authorization", "Bearer " + A2($elm$core$Maybe$withDefault, "No access token 2", $elm$core$Maybe$Just(auth.access_token)))
                    ]);
                    var flagUrlWithMongoDBMWAndPortUpdate = A2($elm$core$String$contains, $author$project$Extras$Constants$localorproductionServerAutoCheck, model.flagUrl.host) ? $elm$url$Url$toString(A6($elm$url$Url$Url, model.flagUrl.protocol, model.flagUrl.host, $elm$core$Maybe$Nothing, $author$project$Extras$Constants$middleWarePath, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing)) : $elm$url$Url$toString(A6($elm$url$Url$Url, model.flagUrl.protocol, model.flagUrl.host, $elm$core$Maybe$Just(3000), $author$project$Extras$Constants$middleWarePath, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing));
                    var newHttpParams = A6($author$project$Pages$Hardware$ToMongoDBMWConfig, $author$project$Extras$Constants$get, headers, flagUrlWithMongoDBMWAndPortUpdate, $elm$http$Http$emptyBody, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing);
                    var apiSpecs = model.apiSpecifics;
                    var newModel = _Utils_update(model, {
                        apiSpecifics: _Utils_update(apiSpecs, {
                            accessToken: $elm$core$Maybe$Just(auth.access_token)
                        }),
                        isValidNewAccessToken: true,
                        queryType: $author$project$Pages$Hardware$LoggedInUser,
                        toMongoDBMWConfig: $elm$core$Maybe$Just(newHttpParams)
                    });
                    return _Utils_Tuple2(_Utils_update(newModel, {
                        isWaitingForResponse: false
                    }), $author$project$Pages$Hardware$profileRequest(newModel));
                } else {
                    var responseErr = msg.a.a;
                    var newFailedErr = function() {
                        if (responseErr.$ === "BadStatus" && responseErr.a === 401) return "Login Denied - Please try again ...";
                        else return "Login Denied - Please try again ...";
                    }();
                    var newModel = _Utils_update(model, {
                        errors: _List_fromArray([
                            newFailedErr
                        ])
                    });
                    return _Utils_Tuple2(newModel, $elm$core$Platform$Cmd$none);
                }
            case "SpectatorRankingResponse":
                if (msg.a.$ === "Ok") {
                    var specRankingResult = msg.a.a;
                    return _Utils_Tuple2(_Utils_update(model, {
                        isWaitingForResponse: false,
                        selectedranking: $author$project$Data$Hardware$Spectator(specRankingResult)
                    }), $elm$core$Platform$Cmd$none);
                } else {
                    var responseErr = msg.a.a;
                    return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
                }
            case "UpdateNickName":
                var value = msg.a;
                var newModel = A3($author$project$Pages$Hardware$updateNewUserRegistrationFormField, $author$project$Pages$Hardware$UpdateNickName(value), model.queryType, model);
                return _Utils_Tuple2(_Utils_update(newModel, {
                    errors: _List_fromArray([
                        ""
                    ])
                }), $elm$core$Platform$Cmd$none);
            case "UpdateAge":
                var value = msg.a;
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "UpdateGender":
                var value = msg.a;
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "UpdateEmail":
                var email = msg.a;
                return _Utils_Tuple2(A3($author$project$Pages$Hardware$updateNewUserRegistrationFormField, $author$project$Pages$Hardware$UpdateEmail(email), model.queryType, model), $elm$core$Platform$Cmd$none);
            case "UpdatePassword":
                var pword = msg.a;
                return _Utils_Tuple2(A3($author$project$Pages$Hardware$updateNewUserRegistrationFormField, $author$project$Pages$Hardware$UpdatePassword(pword), model.queryType, model), $elm$core$Platform$Cmd$none);
            case "UpdateLevel":
                var lvel = msg.a;
                return _Utils_Tuple2(A3($author$project$Pages$Hardware$updateNewUserRegistrationFormField, $author$project$Pages$Hardware$UpdateLevel(lvel), model.queryType, model), $elm$core$Platform$Cmd$none);
            case "UpdateComment":
                var comment = msg.a;
                return _Utils_Tuple2(A3($author$project$Pages$Hardware$updateNewUserRegistrationFormField, $author$project$Pages$Hardware$UpdateComment(comment), model.queryType, model), $elm$core$Platform$Cmd$none);
            case "UpdateMobile":
                var mobile = msg.a;
                return _Utils_Tuple2(A3($author$project$Pages$Hardware$updateNewUserRegistrationFormField, $author$project$Pages$Hardware$UpdateMobile(mobile), model.queryType, model), $elm$core$Platform$Cmd$none);
            case "UpdatePhone":
                var phone = msg.a;
                return _Utils_Tuple2(A3($author$project$Pages$Hardware$updateNewUserRegistrationFormField, $author$project$Pages$Hardware$UpdatePhone(phone), model.queryType, model), $elm$core$Platform$Cmd$none);
            case "CondoNameInput":
                var value = msg.a;
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "CondoAddressInput":
                var value = msg.a;
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "AddInfoInput":
                var value = msg.a;
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "FetchSpectatorRanking":
                var rankingId = msg.a;
                var updatedFlagUrlToIncludeMongoDBMWSvr = A2($elm$core$String$contains, $author$project$Extras$Constants$localorproductionServerAutoCheck, model.flagUrl.host) ? $elm$url$Url$toString(A6($elm$url$Url$Url, model.flagUrl.protocol, model.flagUrl.host, $elm$core$Maybe$Nothing, $author$project$Extras$Constants$productionProxyConfig, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing)) : $elm$url$Url$toString(A6($elm$url$Url$Url, model.flagUrl.protocol, model.flagUrl.host, $elm$core$Maybe$Just(3000), $author$project$Extras$Constants$middleWarePath, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing));
                var postDataForMongoDBMWSvr = $elm$json$Json$Encode$object(_List_fromArray([
                    _Utils_Tuple2("apiUrl", $elm$json$Json$Encode$string($elm$url$Url$toString($author$project$Extras$Constants$placeholderUrl))),
                    _Utils_Tuple2("query_type", $elm$json$Json$Encode$string("fetch")),
                    _Utils_Tuple2("rankingid", $elm$json$Json$Encode$string(rankingId))
                ]));
                var updatModelWithNewPostData = _Utils_update(model, {
                    errors: _List_fromArray([
                        ""
                    ]),
                    isWaitingForResponse: true,
                    queryType: $author$project$Pages$Hardware$SpectatorSelectedView,
                    selectedranking: $author$project$Data$Hardware$Spectator($author$project$Data$Hardware$emptyRanking),
                    toMongoDBMWConfig: $elm$core$Maybe$Just(A6($author$project$Pages$Hardware$ToMongoDBMWConfig, $author$project$Extras$Constants$post, _List_Nil, updatedFlagUrlToIncludeMongoDBMWSvr, $elm$http$Http$jsonBody(postDataForMongoDBMWSvr), $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing))
                });
                return _Utils_Tuple2(updatModelWithNewPostData, $elm$core$Platform$Cmd$none);
            default:
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
        }
    });
    var $author$project$Pages$Market$update = F2(function(msg, model) {
        var newModel = msg.a;
        return _Utils_Tuple2(_Utils_update(newModel, {
            title: model.title
        }), $elm$core$Platform$Cmd$none);
    });
    var $author$project$Pages$PingPong$Receive = function(a) {
        return {
            $: "Receive",
            a: a
        };
    };
    var $author$project$Pages$PingPong$PongResponse = function(message) {
        return {
            message: message
        };
    };
    var $author$project$Pages$PingPong$decodePongResponse = A2($elm$json$Json$Decode$map, $author$project$Pages$PingPong$PongResponse, A2($elm$json$Json$Decode$field, "message", $elm$json$Json$Decode$string));
    var $author$project$Pages$PingPong$encodePingRequest = function(request) {
        return $elm$json$Json$Encode$object(_List_fromArray([
            _Utils_Tuple2("message", $elm$json$Json$Encode$string(request.message))
        ]));
    };
    var $author$project$Pages$PingPong$update = F2(function(msg, model) {
        switch(msg.$){
            case "GotInitialModel":
                var newModel = msg.a;
                return _Utils_Tuple2(_Utils_update(newModel, {
                    title: model.title
                }), $elm$core$Platform$Cmd$none);
            case "Send":
                var therequest = $elm$http$Http$request({
                    body: $elm$http$Http$jsonBody($author$project$Pages$PingPong$encodePingRequest({
                        message: "Ping"
                    })),
                    expect: A2($elm$http$Http$expectJson, $author$project$Pages$PingPong$Receive, $author$project$Pages$PingPong$decodePongResponse),
                    headers: _List_Nil,
                    method: "POST",
                    timeout: $elm$core$Maybe$Nothing,
                    tracker: $elm$core$Maybe$Nothing,
                    url: "http://localhost:9001/ping"
                });
                return _Utils_Tuple2(_Utils_update(model, {
                    root: $author$project$Pages$PingPong$PingPong({
                        name: "Sending ..."
                    })
                }), therequest);
            default:
                if (msg.a.$ === "Ok") {
                    var response = msg.a.a;
                    return _Utils_Tuple2(_Utils_update(model, {
                        root: $author$project$Pages$PingPong$PingPong({
                            name: "Received: " + response.message
                        })
                    }), $elm$core$Platform$Cmd$none);
                } else return _Utils_Tuple2(_Utils_update(model, {
                    root: $author$project$Pages$PingPong$PingPong({
                        name: "Error receiving response"
                    })
                }), $elm$core$Platform$Cmd$none);
        }
    });
    var $author$project$Pages$Portfolio$update = F2(function(msg, model) {
        var newModel = msg.a;
        return _Utils_Tuple2(_Utils_update(newModel, {
            title: model.title
        }), $elm$core$Platform$Cmd$none);
    });
    var $author$project$Pages$Sell$update = F2(function(msg, model) {
        var newModel = msg.a;
        return _Utils_Tuple2(_Utils_update(newModel, {
            title: model.title
        }), $elm$core$Platform$Cmd$none);
    });
    var $author$project$Pages$Support$update = F2(function(msg, model) {
        var newModel = msg.a;
        return _Utils_Tuple2(_Utils_update(newModel, {
            title: model.title
        }), $elm$core$Platform$Cmd$none);
    });
    var $author$project$Main$update = F2(function(msg, model) {
        switch(msg.$){
            case "RecvText":
                var textMessageFromJs = msg.a;
                return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "Recv":
                var rawJsonMessage = msg.a;
                if (A2($elm$core$String$contains, "Problem", $author$project$Main$fromJsonToString(rawJsonMessage))) return _Utils_Tuple2(_Utils_update(model, {
                    errors: _Utils_ap(model.errors, _List_fromArray([
                        "Problem fetching data"
                    ]))
                }), $elm$core$Platform$Cmd$none);
                else {
                    if (A2($elm$core$String$contains, "LOGINDENIED", $author$project$Main$fromJsonToString(rawJsonMessage))) return _Utils_Tuple2(_Utils_update(model, {
                        errors: _Utils_ap(model.errors, _List_fromArray([
                            "Login Denied - Please try again ..."
                        ]))
                    }), $elm$core$Platform$Cmd$none);
                    else {
                        var _v1 = model.page;
                        if (_v1.$ === "HardwarePage") {
                            var hardware = _v1.a;
                            return A2($author$project$Main$toHardware, model, A2($author$project$Pages$Hardware$update, $author$project$Pages$Hardware$ResponseDataFromMain(rawJsonMessage), hardware));
                        } else return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
                    }
                }
            case "Tick":
                var newTime = msg.a;
                return _Utils_Tuple2(_Utils_update(model, {
                    time: newTime
                }), A2($elm$core$Task$perform, $author$project$Main$AdjustTimeZone, $elm$time$Time$here));
            case "AdjustTimeZone":
                var newZone = msg.a;
                return _Utils_Tuple2(_Utils_update(model, {
                    zone: $elm$core$Maybe$Just(newZone)
                }), $elm$core$Platform$Cmd$none);
            case "ClickedLink":
                var urlRequest = msg.a;
                if (urlRequest.$ === "External") {
                    var href = urlRequest.a;
                    return _Utils_Tuple2(model, $elm$browser$Browser$Navigation$load(href));
                } else {
                    var url = urlRequest.a;
                    var _v3 = $elm$url$Url$toString(url);
                    if (_v3 === "https://haveno-web.squashpassion.com/") return _Utils_Tuple2(model, $elm$browser$Browser$Navigation$load($elm$url$Url$toString(url)));
                    else return _Utils_Tuple2(model, model.key(url));
                }
            case "ChangedUrl":
                var url = msg.a;
                return A2($author$project$Main$updateUrl, url, model);
            case "GotDashboardMsg":
                var dashboardMsg = msg.a;
                var _v4 = model.page;
                if (_v4.$ === "DashboardPage") {
                    var dashboard = _v4.a;
                    return A2($author$project$Main$toDashboard, model, A2($author$project$Pages$Dashboard$update, dashboardMsg, dashboard));
                } else return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "GotSellMsg":
                var sellMsg = msg.a;
                var _v5 = model.page;
                if (_v5.$ === "SellPage") {
                    var sell = _v5.a;
                    return A2($author$project$Main$toSell, model, A2($author$project$Pages$Sell$update, sellMsg, sell));
                } else return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "GotPortfolioMsg":
                var termsMsg = msg.a;
                var _v6 = model.page;
                if (_v6.$ === "PortfolioPage") {
                    var terms = _v6.a;
                    return A2($author$project$Main$toPortfolio, model, A2($author$project$Pages$Portfolio$update, termsMsg, terms));
                } else return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "GotFundsMsg":
                var privacyMsg = msg.a;
                var _v7 = model.page;
                if (_v7.$ === "FundsPage") {
                    var privacy = _v7.a;
                    return A2($author$project$Main$toFunds, model, A2($author$project$Pages$Funds$update, privacyMsg, privacy));
                } else return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "GotSupportMsg":
                var supportMsg = msg.a;
                var _v8 = model.page;
                if (_v8.$ === "SupportPage") {
                    var support = _v8.a;
                    return A2($author$project$Main$toSupport, model, A2($author$project$Pages$Support$update, supportMsg, support));
                } else return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "GotPingPongMsg":
                var pingpongMsg = msg.a;
                var _v9 = model.page;
                if (_v9.$ === "PingPongPage") {
                    var pingpong = _v9.a;
                    return A2($author$project$Main$toPingPong, model, A2($author$project$Pages$PingPong$update, pingpongMsg, pingpong));
                } else return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "GotBuyMsg":
                var pricingMsg = msg.a;
                var _v10 = model.page;
                if (_v10.$ === "BuyPage") {
                    var pricing = _v10.a;
                    return A2($author$project$Main$toPricing, model, A2($author$project$Pages$Buy$update, pricingMsg, pricing));
                } else return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            case "GotMarketMsg":
                var aboutMsg = msg.a;
                var _v11 = model.page;
                if (_v11.$ === "MarketPage") {
                    var about = _v11.a;
                    return A2($author$project$Main$toMarket, model, A2($author$project$Pages$Market$update, aboutMsg, about));
                } else return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
            default:
                var hardwareMsg = msg.a;
                var _v12 = model.page;
                if (_v12.$ === "HardwarePage") {
                    var hardwareModel = _v12.a;
                    switch(hardwareMsg.$){
                        case "ClickedHardwareDeviceConnect":
                            var newHardwareModel = _Utils_update(hardwareModel, {
                                queryType: $author$project$Pages$Hardware$LoggedInUser
                            });
                            return _Utils_Tuple2(_Utils_update(model, {
                                page: $author$project$Main$HardwarePage(newHardwareModel)
                            }), $author$project$Main$sendMessageToJs("connectLNS"));
                        case "ClickedXMRWalletConnect":
                            var newHardwareModel = _Utils_update(hardwareModel, {
                                queryType: $author$project$Pages$Hardware$LoggedInUser
                            });
                            return _Utils_Tuple2(_Utils_update(model, {
                                page: $author$project$Main$HardwarePage(newHardwareModel)
                            }), $author$project$Main$sendMessageToJs("getMoneroAddress"));
                        case "ClickedXMRInitiateTransaction":
                            var amt = hardwareMsg.a;
                            var newHardwareModel = _Utils_update(hardwareModel, {
                                queryType: $author$project$Pages$Hardware$LoggedInUser
                            });
                            return _Utils_Tuple2(_Utils_update(model, {
                                page: $author$project$Main$HardwarePage(newHardwareModel)
                            }), $author$project$Main$sendMessageToJs("initiateXMRToBTCTrans " + ("~^&" + amt)));
                        default:
                            return A2($author$project$Main$toHardware, model, A2($author$project$Pages$Hardware$update, hardwareMsg, hardwareModel));
                    }
                } else return _Utils_Tuple2(model, $elm$core$Platform$Cmd$none);
        }
    });
    var $elm$html$Html$br = _VirtualDom_node("br");
    var $elm$html$Html$footer = _VirtualDom_node("footer");
    var $author$project$Main$footerContent = A2($elm$html$Html$footer, _List_Nil, _List_fromArray([
        A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$class("footer"),
            A2($elm$html$Html$Attributes$style, "text-align", "center")
        ]), _List_fromArray([
            A2($elm$html$Html$br, _List_Nil, _List_Nil),
            A2($elm$html$Html$span, _List_Nil, _List_fromArray([
                $elm$html$Html$text(""),
                A2($elm$html$Html$a, _List_fromArray([
                    $elm$html$Html$Attributes$href("https://github.com/haveno-dex/haveno")
                ]), _List_fromArray([
                    $elm$html$Html$text("Haveno-Dex")
                ])),
                A2($elm$html$Html$br, _List_Nil, _List_Nil),
                $elm$html$Html$text("Open source code & design"),
                A2($elm$html$Html$p, _List_Nil, _List_fromArray([
                    $elm$html$Html$text("Version 0.0.8")
                ]))
            ]))
        ]))
    ]));
    var $elm$html$Html$nav = _VirtualDom_node("nav");
    var $elm$html$Html$Attributes$classList = function(classes) {
        return $elm$html$Html$Attributes$class(A2($elm$core$String$join, " ", A2($elm$core$List$map, $elm$core$Tuple$first, A2($elm$core$List$filter, $elm$core$Tuple$second, classes))));
    };
    var $author$project$Main$isActive = function(_v0) {
        var link = _v0.link;
        var page = _v0.page;
        var _v1 = _Utils_Tuple2(link, page);
        switch(_v1.a.$){
            case "Dashboard":
                if (_v1.b.$ === "DashboardPage") {
                    var _v2 = _v1.a;
                    return true;
                } else {
                    var _v3 = _v1.a;
                    return false;
                }
            case "Sell":
                if (_v1.b.$ === "SellPage") {
                    var _v4 = _v1.a;
                    return true;
                } else {
                    var _v5 = _v1.a;
                    return false;
                }
            case "Portfolio":
                if (_v1.b.$ === "PortfolioPage") {
                    var _v6 = _v1.a;
                    return true;
                } else {
                    var _v7 = _v1.a;
                    return false;
                }
            case "Funds":
                if (_v1.b.$ === "FundsPage") {
                    var _v8 = _v1.a;
                    return true;
                } else {
                    var _v9 = _v1.a;
                    return false;
                }
            case "Support":
                if (_v1.b.$ === "SupportPage") {
                    var _v10 = _v1.a;
                    return true;
                } else {
                    var _v11 = _v1.a;
                    return false;
                }
            case "PingPong":
                if (_v1.b.$ === "PingPongPage") {
                    var _v12 = _v1.a;
                    return true;
                } else {
                    var _v13 = _v1.a;
                    return false;
                }
            case "Buy":
                if (_v1.b.$ === "BuyPage") {
                    var _v14 = _v1.a;
                    return true;
                } else {
                    var _v15 = _v1.a;
                    return false;
                }
            case "Market":
                if (_v1.b.$ === "MarketPage") {
                    var _v16 = _v1.a;
                    return true;
                } else {
                    var _v17 = _v1.a;
                    return false;
                }
            default:
                if (_v1.b.$ === "HardwarePage") {
                    var _v18 = _v1.a;
                    return true;
                } else {
                    var _v19 = _v1.a;
                    return false;
                }
        }
    };
    var $elm$html$Html$Attributes$alt = $elm$html$Html$Attributes$stringProperty("alt");
    var $elm$html$Html$Attributes$height = function(n) {
        return A2(_VirtualDom_attribute, "height", $elm$core$String$fromInt(n));
    };
    var $elm$html$Html$img = _VirtualDom_node("img");
    var $elm$html$Html$Attributes$src = function(url) {
        return A2($elm$html$Html$Attributes$stringProperty, "src", _VirtualDom_noJavaScriptOrHtmlUri(url));
    };
    var $elm$html$Html$Attributes$width = function(n) {
        return A2(_VirtualDom_attribute, "width", $elm$core$String$fromInt(n));
    };
    var $author$project$Main$logoImage = A2($elm$html$Html$img, _List_fromArray([
        $elm$html$Html$Attributes$src("resources/Logos/monero_icon.jpg"),
        $elm$html$Html$Attributes$width(200),
        $elm$html$Html$Attributes$height(67),
        $elm$html$Html$Attributes$alt("Monero Logo"),
        $elm$html$Html$Attributes$title("Monero Logo")
    ]), _List_Nil);
    var $author$project$Main$navLinks = function(page) {
        var navLink = F2(function(route, _v0) {
            var url = _v0.url;
            var caption = _v0.caption;
            return A2($elm$html$Html$li, _List_fromArray([
                $elm$html$Html$Attributes$classList(_List_fromArray([
                    _Utils_Tuple2("active", $author$project$Main$isActive({
                        link: route,
                        page: page
                    })),
                    _Utils_Tuple2("navLink", true)
                ]))
            ]), _List_fromArray([
                A2($elm$html$Html$a, _List_fromArray([
                    $elm$html$Html$Attributes$href(url)
                ]), _List_fromArray([
                    $elm$html$Html$text(caption)
                ]))
            ]));
        });
        var links = A2($elm$html$Html$ul, _List_Nil, _List_fromArray([
            A2($elm$html$Html$li, _List_fromArray([
                $elm$html$Html$Attributes$class("logo")
            ]), _List_fromArray([
                A2($elm$html$Html$a, _List_fromArray([
                    $elm$html$Html$Attributes$href("https://haveno-web.squashpassion.com"),
                    $elm$html$Html$Attributes$class("logoImageShrink")
                ]), _List_fromArray([
                    $author$project$Main$logoImage
                ]))
            ])),
            A2(navLink, $author$project$Main$Dashboard, {
                caption: "Dashboard",
                url: "/"
            }),
            A2(navLink, $author$project$Main$Market, {
                caption: "Market",
                url: "market"
            }),
            A2(navLink, $author$project$Main$Support, {
                caption: "Support",
                url: "support"
            }),
            A2(navLink, $author$project$Main$PingPong, {
                caption: "PingPong",
                url: "pingpong"
            }),
            A2(navLink, $author$project$Main$Sell, {
                caption: "Sell",
                url: "sell"
            }),
            A2(navLink, $author$project$Main$Buy, {
                caption: "Buy",
                url: "buy"
            }),
            A2(navLink, $author$project$Main$Hardware, {
                caption: "Hardware",
                url: "hardware"
            }),
            A2(navLink, $author$project$Main$Portfolio, {
                caption: "Portfolio",
                url: "portfolio"
            })
        ]));
        return links;
    };
    var $author$project$Main$burgerMenu = function(page) {
        return A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$class("menu-btn"),
            $elm$html$Html$Attributes$id("menu-btn")
        ]), _List_fromArray([
            A2($elm$html$Html$div, _List_fromArray([
                $elm$html$Html$Attributes$class("menu-btn_burger")
            ]), _List_Nil),
            A2($elm$html$Html$nav, _List_fromArray([
                $elm$html$Html$Attributes$class("below800pxnavlinks")
            ]), _List_fromArray([
                $author$project$Main$navLinks(page)
            ]))
        ]));
    };
    var $elm$html$Html$header = _VirtualDom_node("header");
    var $elm$html$Html$i = _VirtualDom_node("i");
    var $elm$html$Html$Attributes$name = $elm$html$Html$Attributes$stringProperty("name");
    var $elm$html$Html$Attributes$target = $elm$html$Html$Attributes$stringProperty("target");
    var $author$project$Main$socialsLinks = A2($elm$html$Html$div, _List_fromArray([
        $elm$html$Html$Attributes$class("socials-main-container")
    ]), _List_fromArray([
        A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$class("socials-sub-container socials-sub-container-whatsapp")
        ]), _List_fromArray([
            A2($elm$html$Html$i, _List_Nil, _List_fromArray([
                A2($elm$html$Html$a, _List_fromArray([
                    $elm$html$Html$Attributes$href(""),
                    $elm$html$Html$Attributes$target("_blank")
                ]), _List_fromArray([
                    A3($elm$html$Html$node, "ion-icon", _List_fromArray([
                        $elm$html$Html$Attributes$name("logo-whatsapp")
                    ]), _List_Nil)
                ]))
            ]))
        ]))
    ]));
    var $author$project$Main$topLinksLeft = function() {
        var navLink = function(_v0) {
            var url = _v0.url;
            var caption = _v0.caption;
            return A2($elm$html$Html$li, _List_fromArray([
                $elm$html$Html$Attributes$class("emailphone")
            ]), _List_fromArray([
                A2($elm$html$Html$a, _List_fromArray([
                    $elm$html$Html$Attributes$href(url)
                ]), _List_fromArray([
                    $elm$html$Html$text(caption)
                ]))
            ]));
        };
        var links = A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$class("topLinksLeft")
        ]), _List_fromArray([
            A2($elm$html$Html$i, _List_fromArray([
                $elm$html$Html$Attributes$class("material-icons")
            ]), _List_fromArray([
                $elm$html$Html$text("email")
            ])),
            navLink({
                caption: "potential support url   ",
                url: "/"
            }),
            A2($elm$html$Html$i, _List_fromArray([
                $elm$html$Html$Attributes$class("material-icons")
            ]), _List_fromArray([
                $elm$html$Html$text("support")
            ])),
            navLink({
                caption: "other potential support",
                url: "support"
            })
        ]));
        return links;
    }();
    var $author$project$Main$topLinksLogoImage = A2($elm$html$Html$img, _List_fromArray([
        $elm$html$Html$Attributes$src("resources/Logos/monero_icon.jpg"),
        $elm$html$Html$Attributes$width(100),
        $elm$html$Html$Attributes$height(33),
        $elm$html$Html$Attributes$alt("Monero Logo"),
        $elm$html$Html$Attributes$title("Monero Logo")
    ]), _List_Nil);
    var $author$project$Main$topLinksLogo = A2($elm$html$Html$div, _List_fromArray([
        $elm$html$Html$Attributes$class("topLinksLogo")
    ]), _List_fromArray([
        A2($elm$html$Html$a, _List_fromArray([
            $elm$html$Html$Attributes$href("https://haveno-web.squashpassion.com")
        ]), _List_fromArray([
            $author$project$Main$topLinksLogoImage
        ]))
    ]));
    var $author$project$Main$pageHeader = function(page) {
        var pageheader = A2($elm$html$Html$header, _List_Nil, _List_fromArray([
            A2($elm$html$Html$div, _List_fromArray([
                $elm$html$Html$Attributes$class("topLinks-flex-container")
            ]), _List_fromArray([
                $author$project$Main$burgerMenu(page),
                $author$project$Main$topLinksLogo,
                $author$project$Main$topLinksLeft,
                $author$project$Main$socialsLinks
            ])),
            A2($elm$html$Html$div, _List_fromArray([
                $elm$html$Html$Attributes$class("main-nav-flex-container")
            ]), _List_fromArray([
                A2($elm$html$Html$div, _List_fromArray([
                    $elm$html$Html$Attributes$class("section")
                ]), _List_Nil),
                A2($elm$html$Html$div, _List_fromArray([
                    $elm$html$Html$Attributes$class("nav-section-above800px")
                ]), _List_fromArray([
                    A2($elm$html$Html$nav, _List_fromArray([
                        $elm$html$Html$Attributes$class("above800pxnavlinks")
                    ]), _List_fromArray([
                        $author$project$Main$navLinks(page)
                    ]))
                ])),
                A2($elm$html$Html$div, _List_fromArray([
                    $elm$html$Html$Attributes$class("section")
                ]), _List_Nil)
            ]))
        ]));
        return pageheader;
    };
    var $author$project$Main$showVideoOrBanner = function(page) {
        return A2($elm$html$Html$img, _List_fromArray([
            $elm$html$Html$Attributes$class("banner"),
            $elm$html$Html$Attributes$src("resources/Banners/monero - 1918x494.png"),
            $elm$html$Html$Attributes$alt("Monero"),
            $elm$html$Html$Attributes$width(1918),
            $elm$html$Html$Attributes$height(494),
            $elm$html$Html$Attributes$title("Monero Banner")
        ]), _List_Nil);
    };
    var $author$project$Buttons$Default$defaultButton = function(btnName) {
        return A2($elm$html$Html$div, _List_fromArray([
            A2($elm$html$Html$Attributes$style, "align-self", "center")
        ]), _List_fromArray([
            A2($elm$html$Html$button, _List_fromArray([
                $elm$html$Html$Attributes$class("default-button")
            ]), _List_fromArray([
                A2($elm$html$Html$a, _List_fromArray([
                    A2($elm$html$Html$Attributes$style, "color", "white"),
                    function() {
                        switch(btnName){
                            case "contact":
                                return $elm$html$Html$Attributes$href("/contact");
                            case "hardware":
                                return $elm$html$Html$Attributes$href("/hardware");
                            case "cost":
                                return $elm$html$Html$Attributes$href("/pricing");
                            default:
                                return $elm$html$Html$Attributes$href("/");
                        }
                    }()
                ]), _List_fromArray([
                    function() {
                        switch(btnName){
                            case "hardware":
                                return $elm$html$Html$text("Hardware Now");
                            case "cost":
                                return $elm$html$Html$text("Buy");
                            default:
                                return $elm$html$Html$text("");
                        }
                    }()
                ]))
            ]))
        ]));
    };
    var $elm$html$Html$h1 = _VirtualDom_node("h1");
    var $elm$html$Html$section = _VirtualDom_node("section");
    var $author$project$Pages$Buy$content = A2($elm$html$Html$section, _List_fromArray([
        $elm$html$Html$Attributes$id("page"),
        $elm$html$Html$Attributes$class("section-background"),
        $elm$html$Html$Attributes$class("text-center")
    ]), _List_fromArray([
        A2($elm$html$Html$ul, _List_Nil, _List_fromArray([
            A2($elm$html$Html$h1, _List_fromArray([
                $elm$html$Html$Attributes$class("pricing")
            ]), _List_fromArray([
                $elm$html$Html$text("Buy")
            ])),
            $author$project$Buttons$Default$defaultButton("hardware")
        ]))
    ]));
    var $author$project$Pages$Buy$view = function(_v0) {
        return $author$project$Pages$Buy$content;
    };
    var $elm$html$Html$h2 = _VirtualDom_node("h2");
    var $author$project$Pages$Dashboard$content = function(model) {
        return A2($elm$html$Html$section, _List_fromArray([
            $elm$html$Html$Attributes$id("page"),
            $elm$html$Html$Attributes$class("section-background")
        ]), _List_fromArray([
            A2($elm$html$Html$div, _List_fromArray([
                $elm$html$Html$Attributes$class("container container--narrow")
            ]), _List_fromArray([
                A2($elm$html$Html$h1, _List_fromArray([
                    $elm$html$Html$Attributes$classList(_List_fromArray([
                        _Utils_Tuple2("text-center", true),
                        _Utils_Tuple2("Dashboard", true)
                    ]))
                ]), _List_fromArray([
                    $elm$html$Html$text("Haveno Web")
                ])),
                A2($elm$html$Html$h2, _List_fromArray([
                    $elm$html$Html$Attributes$class("text-center")
                ]), _List_fromArray([
                    $elm$html$Html$text("Online Dex")
                ])),
                A2($elm$html$Html$div, _List_Nil, _List_fromArray([
                    A2($elm$html$Html$div, _List_fromArray([
                        $elm$html$Html$Attributes$class("text-center")
                    ]), _List_fromArray([
                        $elm$html$Html$text("Welcome to Haveno Web, the online decentralized exchange for Haveno, the private, untraceable cryptocurrency.")
                    ]))
                ])),
                A2($elm$html$Html$div, _List_Nil, _List_fromArray([
                    A2($elm$html$Html$div, _List_fromArray([
                        $elm$html$Html$Attributes$class("text-center")
                    ]), _List_fromArray([
                        $elm$html$Html$text("Your version is:")
                    ]))
                ])),
                A2($elm$html$Html$div, _List_Nil, _List_fromArray([
                    A2($elm$html$Html$div, _List_fromArray([
                        $elm$html$Html$Attributes$class("text-center")
                    ]), _List_fromArray([
                        $elm$html$Html$text(A2($elm$core$Maybe$withDefault, "", A2($elm$core$Maybe$map, function($) {
                            return $.version;
                        }, model.version)))
                    ]))
                ]))
            ]))
        ]));
    };
    var $author$project$Pages$Dashboard$view = function(model) {
        return $author$project$Pages$Dashboard$content(model);
    };
    var $author$project$Pages$Funds$htmlContent = A2($elm$html$Html$section, _List_fromArray([
        $elm$html$Html$Attributes$id("page"),
        $elm$html$Html$Attributes$class("section-background"),
        $elm$html$Html$Attributes$class("text-center"),
        $elm$html$Html$Attributes$class("split")
    ]), _List_fromArray([
        A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$class("split-col")
        ]), _List_fromArray([
            A2($elm$html$Html$h1, _List_Nil, _List_fromArray([
                $elm$html$Html$text("")
            ]))
        ])),
        A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$class("split-col")
        ]), _List_fromArray([
            A2($elm$html$Html$h1, _List_Nil, _List_fromArray([
                $elm$html$Html$text("Funds")
            ])),
            $author$project$Buttons$Default$defaultButton("hardware")
        ])),
        A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$class("split-col")
        ]), _List_fromArray([
            A2($elm$html$Html$h1, _List_Nil, _List_fromArray([
                $elm$html$Html$text("")
            ]))
        ]))
    ]));
    var $author$project$Pages$Funds$content = A2($elm$html$Html$div, _List_fromArray([
        $elm$html$Html$Attributes$id("page")
    ]), _List_fromArray([
        A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$id("content"),
            $elm$html$Html$Attributes$class("col3-column")
        ]), _List_fromArray([
            $author$project$Pages$Funds$htmlContent
        ]))
    ]));
    var $author$project$Pages$Funds$view = function(_v0) {
        return $author$project$Pages$Funds$content;
    };
    var $mdgriffith$elm_ui$Internal$Model$Unkeyed = function(a) {
        return {
            $: "Unkeyed",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Model$AsColumn = {
        $: "AsColumn"
    };
    var $mdgriffith$elm_ui$Internal$Model$asColumn = $mdgriffith$elm_ui$Internal$Model$AsColumn;
    var $mdgriffith$elm_ui$Internal$Style$classes = {
        above: "a",
        active: "atv",
        alignBottom: "ab",
        alignCenterX: "cx",
        alignCenterY: "cy",
        alignContainerBottom: "acb",
        alignContainerCenterX: "accx",
        alignContainerCenterY: "accy",
        alignContainerRight: "acr",
        alignLeft: "al",
        alignRight: "ar",
        alignTop: "at",
        alignedHorizontally: "ah",
        alignedVertically: "av",
        any: "s",
        behind: "bh",
        below: "b",
        bold: "w7",
        borderDashed: "bd",
        borderDotted: "bdt",
        borderNone: "bn",
        borderSolid: "bs",
        capturePointerEvents: "cpe",
        clip: "cp",
        clipX: "cpx",
        clipY: "cpy",
        column: "c",
        container: "ctr",
        contentBottom: "cb",
        contentCenterX: "ccx",
        contentCenterY: "ccy",
        contentLeft: "cl",
        contentRight: "cr",
        contentTop: "ct",
        cursorPointer: "cptr",
        cursorText: "ctxt",
        focus: "fcs",
        focusedWithin: "focus-within",
        fullSize: "fs",
        grid: "g",
        hasBehind: "hbh",
        heightContent: "hc",
        heightExact: "he",
        heightFill: "hf",
        heightFillPortion: "hfp",
        hover: "hv",
        imageContainer: "ic",
        inFront: "fr",
        inputLabel: "lbl",
        inputMultiline: "iml",
        inputMultilineFiller: "imlf",
        inputMultilineParent: "imlp",
        inputMultilineWrapper: "implw",
        inputText: "it",
        italic: "i",
        link: "lnk",
        nearby: "nb",
        noTextSelection: "notxt",
        onLeft: "ol",
        onRight: "or",
        opaque: "oq",
        overflowHidden: "oh",
        page: "pg",
        paragraph: "p",
        passPointerEvents: "ppe",
        root: "ui",
        row: "r",
        scrollbars: "sb",
        scrollbarsX: "sbx",
        scrollbarsY: "sby",
        seButton: "sbt",
        single: "e",
        sizeByCapital: "cap",
        spaceEvenly: "sev",
        strike: "sk",
        text: "t",
        textCenter: "tc",
        textExtraBold: "w8",
        textExtraLight: "w2",
        textHeavy: "w9",
        textJustify: "tj",
        textJustifyAll: "tja",
        textLeft: "tl",
        textLight: "w3",
        textMedium: "w5",
        textNormalWeight: "w4",
        textRight: "tr",
        textSemiBold: "w6",
        textThin: "w1",
        textUnitalicized: "tun",
        transition: "ts",
        transparent: "clr",
        underline: "u",
        widthContent: "wc",
        widthExact: "we",
        widthFill: "wf",
        widthFillPortion: "wfp",
        wrapped: "wrp"
    };
    var $mdgriffith$elm_ui$Internal$Model$Generic = {
        $: "Generic"
    };
    var $mdgriffith$elm_ui$Internal$Model$div = $mdgriffith$elm_ui$Internal$Model$Generic;
    var $mdgriffith$elm_ui$Internal$Model$NoNearbyChildren = {
        $: "NoNearbyChildren"
    };
    var $mdgriffith$elm_ui$Internal$Model$columnClass = $mdgriffith$elm_ui$Internal$Style$classes.any + (" " + $mdgriffith$elm_ui$Internal$Style$classes.column);
    var $mdgriffith$elm_ui$Internal$Model$gridClass = $mdgriffith$elm_ui$Internal$Style$classes.any + (" " + $mdgriffith$elm_ui$Internal$Style$classes.grid);
    var $mdgriffith$elm_ui$Internal$Model$pageClass = $mdgriffith$elm_ui$Internal$Style$classes.any + (" " + $mdgriffith$elm_ui$Internal$Style$classes.page);
    var $mdgriffith$elm_ui$Internal$Model$paragraphClass = $mdgriffith$elm_ui$Internal$Style$classes.any + (" " + $mdgriffith$elm_ui$Internal$Style$classes.paragraph);
    var $mdgriffith$elm_ui$Internal$Model$rowClass = $mdgriffith$elm_ui$Internal$Style$classes.any + (" " + $mdgriffith$elm_ui$Internal$Style$classes.row);
    var $mdgriffith$elm_ui$Internal$Model$singleClass = $mdgriffith$elm_ui$Internal$Style$classes.any + (" " + $mdgriffith$elm_ui$Internal$Style$classes.single);
    var $mdgriffith$elm_ui$Internal$Model$contextClasses = function(context) {
        switch(context.$){
            case "AsRow":
                return $mdgriffith$elm_ui$Internal$Model$rowClass;
            case "AsColumn":
                return $mdgriffith$elm_ui$Internal$Model$columnClass;
            case "AsEl":
                return $mdgriffith$elm_ui$Internal$Model$singleClass;
            case "AsGrid":
                return $mdgriffith$elm_ui$Internal$Model$gridClass;
            case "AsParagraph":
                return $mdgriffith$elm_ui$Internal$Model$paragraphClass;
            default:
                return $mdgriffith$elm_ui$Internal$Model$pageClass;
        }
    };
    var $mdgriffith$elm_ui$Internal$Model$Keyed = function(a) {
        return {
            $: "Keyed",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Model$NoStyleSheet = {
        $: "NoStyleSheet"
    };
    var $mdgriffith$elm_ui$Internal$Model$Styled = function(a) {
        return {
            $: "Styled",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Model$Unstyled = function(a) {
        return {
            $: "Unstyled",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Model$addChildren = F2(function(existing, nearbyChildren) {
        switch(nearbyChildren.$){
            case "NoNearbyChildren":
                return existing;
            case "ChildrenBehind":
                var behind = nearbyChildren.a;
                return _Utils_ap(behind, existing);
            case "ChildrenInFront":
                var inFront = nearbyChildren.a;
                return _Utils_ap(existing, inFront);
            default:
                var behind = nearbyChildren.a;
                var inFront = nearbyChildren.b;
                return _Utils_ap(behind, _Utils_ap(existing, inFront));
        }
    });
    var $mdgriffith$elm_ui$Internal$Model$addKeyedChildren = F3(function(key, existing, nearbyChildren) {
        switch(nearbyChildren.$){
            case "NoNearbyChildren":
                return existing;
            case "ChildrenBehind":
                var behind = nearbyChildren.a;
                return _Utils_ap(A2($elm$core$List$map, function(x) {
                    return _Utils_Tuple2(key, x);
                }, behind), existing);
            case "ChildrenInFront":
                var inFront = nearbyChildren.a;
                return _Utils_ap(existing, A2($elm$core$List$map, function(x) {
                    return _Utils_Tuple2(key, x);
                }, inFront));
            default:
                var behind = nearbyChildren.a;
                var inFront = nearbyChildren.b;
                return _Utils_ap(A2($elm$core$List$map, function(x) {
                    return _Utils_Tuple2(key, x);
                }, behind), _Utils_ap(existing, A2($elm$core$List$map, function(x) {
                    return _Utils_Tuple2(key, x);
                }, inFront)));
        }
    });
    var $mdgriffith$elm_ui$Internal$Model$AsEl = {
        $: "AsEl"
    };
    var $mdgriffith$elm_ui$Internal$Model$asEl = $mdgriffith$elm_ui$Internal$Model$AsEl;
    var $mdgriffith$elm_ui$Internal$Model$AsParagraph = {
        $: "AsParagraph"
    };
    var $mdgriffith$elm_ui$Internal$Model$asParagraph = $mdgriffith$elm_ui$Internal$Model$AsParagraph;
    var $mdgriffith$elm_ui$Internal$Flag$Flag = function(a) {
        return {
            $: "Flag",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Flag$Second = function(a) {
        return {
            $: "Second",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Flag$flag = function(i) {
        return i > 31 ? $mdgriffith$elm_ui$Internal$Flag$Second(1 << i - 32) : $mdgriffith$elm_ui$Internal$Flag$Flag(1 << i);
    };
    var $mdgriffith$elm_ui$Internal$Flag$alignBottom = $mdgriffith$elm_ui$Internal$Flag$flag(41);
    var $mdgriffith$elm_ui$Internal$Flag$alignRight = $mdgriffith$elm_ui$Internal$Flag$flag(40);
    var $mdgriffith$elm_ui$Internal$Flag$centerX = $mdgriffith$elm_ui$Internal$Flag$flag(42);
    var $mdgriffith$elm_ui$Internal$Flag$centerY = $mdgriffith$elm_ui$Internal$Flag$flag(43);
    var $mdgriffith$elm_ui$Internal$Model$lengthClassName = function(x) {
        switch(x.$){
            case "Px":
                var px = x.a;
                return $elm$core$String$fromInt(px) + "px";
            case "Content":
                return "auto";
            case "Fill":
                var i = x.a;
                return $elm$core$String$fromInt(i) + "fr";
            case "Min":
                var min = x.a;
                var len = x.b;
                return "min" + ($elm$core$String$fromInt(min) + $mdgriffith$elm_ui$Internal$Model$lengthClassName(len));
            default:
                var max = x.a;
                var len = x.b;
                return "max" + ($elm$core$String$fromInt(max) + $mdgriffith$elm_ui$Internal$Model$lengthClassName(len));
        }
    };
    var $elm$core$Basics$round = _Basics_round;
    var $mdgriffith$elm_ui$Internal$Model$floatClass = function(x) {
        return $elm$core$String$fromInt($elm$core$Basics$round(x * 255));
    };
    var $mdgriffith$elm_ui$Internal$Model$transformClass = function(transform) {
        switch(transform.$){
            case "Untransformed":
                return $elm$core$Maybe$Nothing;
            case "Moved":
                var _v1 = transform.a;
                var x = _v1.a;
                var y = _v1.b;
                var z = _v1.c;
                return $elm$core$Maybe$Just("mv-" + ($mdgriffith$elm_ui$Internal$Model$floatClass(x) + ("-" + ($mdgriffith$elm_ui$Internal$Model$floatClass(y) + ("-" + $mdgriffith$elm_ui$Internal$Model$floatClass(z))))));
            default:
                var _v2 = transform.a;
                var tx = _v2.a;
                var ty = _v2.b;
                var tz = _v2.c;
                var _v3 = transform.b;
                var sx = _v3.a;
                var sy = _v3.b;
                var sz = _v3.c;
                var _v4 = transform.c;
                var ox = _v4.a;
                var oy = _v4.b;
                var oz = _v4.c;
                var angle = transform.d;
                return $elm$core$Maybe$Just("tfrm-" + ($mdgriffith$elm_ui$Internal$Model$floatClass(tx) + ("-" + ($mdgriffith$elm_ui$Internal$Model$floatClass(ty) + ("-" + ($mdgriffith$elm_ui$Internal$Model$floatClass(tz) + ("-" + ($mdgriffith$elm_ui$Internal$Model$floatClass(sx) + ("-" + ($mdgriffith$elm_ui$Internal$Model$floatClass(sy) + ("-" + ($mdgriffith$elm_ui$Internal$Model$floatClass(sz) + ("-" + ($mdgriffith$elm_ui$Internal$Model$floatClass(ox) + ("-" + ($mdgriffith$elm_ui$Internal$Model$floatClass(oy) + ("-" + ($mdgriffith$elm_ui$Internal$Model$floatClass(oz) + ("-" + $mdgriffith$elm_ui$Internal$Model$floatClass(angle))))))))))))))))))));
        }
    };
    var $mdgriffith$elm_ui$Internal$Model$getStyleName = function(style) {
        switch(style.$){
            case "Shadows":
                var name = style.a;
                return name;
            case "Transparency":
                var name = style.a;
                var o = style.b;
                return name;
            case "Style":
                var _class = style.a;
                return _class;
            case "FontFamily":
                var name = style.a;
                return name;
            case "FontSize":
                var i = style.a;
                return "font-size-" + $elm$core$String$fromInt(i);
            case "Single":
                var _class = style.a;
                return _class;
            case "Colored":
                var _class = style.a;
                return _class;
            case "SpacingStyle":
                var cls = style.a;
                var x = style.b;
                var y = style.c;
                return cls;
            case "PaddingStyle":
                var cls = style.a;
                var top = style.b;
                var right = style.c;
                var bottom = style.d;
                var left = style.e;
                return cls;
            case "BorderWidth":
                var cls = style.a;
                var top = style.b;
                var right = style.c;
                var bottom = style.d;
                var left = style.e;
                return cls;
            case "GridTemplateStyle":
                var template = style.a;
                return "grid-rows-" + (A2($elm$core$String$join, "-", A2($elm$core$List$map, $mdgriffith$elm_ui$Internal$Model$lengthClassName, template.rows)) + ("-cols-" + (A2($elm$core$String$join, "-", A2($elm$core$List$map, $mdgriffith$elm_ui$Internal$Model$lengthClassName, template.columns)) + ("-space-x-" + ($mdgriffith$elm_ui$Internal$Model$lengthClassName(template.spacing.a) + ("-space-y-" + $mdgriffith$elm_ui$Internal$Model$lengthClassName(template.spacing.b)))))));
            case "GridPosition":
                var pos = style.a;
                return "gp grid-pos-" + ($elm$core$String$fromInt(pos.row) + ("-" + ($elm$core$String$fromInt(pos.col) + ("-" + ($elm$core$String$fromInt(pos.width) + ("-" + $elm$core$String$fromInt(pos.height)))))));
            case "PseudoSelector":
                var selector = style.a;
                var subStyle = style.b;
                var name = function() {
                    switch(selector.$){
                        case "Focus":
                            return "fs";
                        case "Hover":
                            return "hv";
                        default:
                            return "act";
                    }
                }();
                return A2($elm$core$String$join, " ", A2($elm$core$List$map, function(sty) {
                    var _v1 = $mdgriffith$elm_ui$Internal$Model$getStyleName(sty);
                    if (_v1 === "") return "";
                    else {
                        var styleName = _v1;
                        return styleName + ("-" + name);
                    }
                }, subStyle));
            default:
                var x = style.a;
                return A2($elm$core$Maybe$withDefault, "", $mdgriffith$elm_ui$Internal$Model$transformClass(x));
        }
    };
    var $elm$core$Dict$member = F2(function(key, dict) {
        var _v0 = A2($elm$core$Dict$get, key, dict);
        if (_v0.$ === "Just") return true;
        else return false;
    });
    var $elm$core$Set$member = F2(function(key, _v0) {
        var dict = _v0.a;
        return A2($elm$core$Dict$member, key, dict);
    });
    var $mdgriffith$elm_ui$Internal$Model$reduceStyles = F2(function(style, nevermind) {
        var cache = nevermind.a;
        var existing = nevermind.b;
        var styleName = $mdgriffith$elm_ui$Internal$Model$getStyleName(style);
        return A2($elm$core$Set$member, styleName, cache) ? nevermind : _Utils_Tuple2(A2($elm$core$Set$insert, styleName, cache), A2($elm$core$List$cons, style, existing));
    });
    var $mdgriffith$elm_ui$Internal$Model$Property = F2(function(a, b) {
        return {
            $: "Property",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Model$Style = F2(function(a, b) {
        return {
            $: "Style",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Style$dot = function(c) {
        return "." + c;
    };
    var $mdgriffith$elm_ui$Internal$Model$formatColor = function(_v0) {
        var red = _v0.a;
        var green = _v0.b;
        var blue = _v0.c;
        var alpha = _v0.d;
        return "rgba(" + ($elm$core$String$fromInt($elm$core$Basics$round(red * 255)) + ("," + $elm$core$String$fromInt($elm$core$Basics$round(green * 255)) + ("," + $elm$core$String$fromInt($elm$core$Basics$round(blue * 255)) + ("," + ($elm$core$String$fromFloat(alpha) + ")")))));
    };
    var $mdgriffith$elm_ui$Internal$Model$formatBoxShadow = function(shadow) {
        return A2($elm$core$String$join, " ", A2($elm$core$List$filterMap, $elm$core$Basics$identity, _List_fromArray([
            shadow.inset ? $elm$core$Maybe$Just("inset") : $elm$core$Maybe$Nothing,
            $elm$core$Maybe$Just($elm$core$String$fromFloat(shadow.offset.a) + "px"),
            $elm$core$Maybe$Just($elm$core$String$fromFloat(shadow.offset.b) + "px"),
            $elm$core$Maybe$Just($elm$core$String$fromFloat(shadow.blur) + "px"),
            $elm$core$Maybe$Just($elm$core$String$fromFloat(shadow.size) + "px"),
            $elm$core$Maybe$Just($mdgriffith$elm_ui$Internal$Model$formatColor(shadow.color))
        ])));
    };
    var $mdgriffith$elm_ui$Internal$Model$renderFocusStyle = function(focus) {
        return _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Model$Style, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.focusedWithin) + ":focus-within", A2($elm$core$List$filterMap, $elm$core$Basics$identity, _List_fromArray([
                A2($elm$core$Maybe$map, function(color) {
                    return A2($mdgriffith$elm_ui$Internal$Model$Property, "border-color", $mdgriffith$elm_ui$Internal$Model$formatColor(color));
                }, focus.borderColor),
                A2($elm$core$Maybe$map, function(color) {
                    return A2($mdgriffith$elm_ui$Internal$Model$Property, "background-color", $mdgriffith$elm_ui$Internal$Model$formatColor(color));
                }, focus.backgroundColor),
                A2($elm$core$Maybe$map, function(shadow) {
                    return A2($mdgriffith$elm_ui$Internal$Model$Property, "box-shadow", $mdgriffith$elm_ui$Internal$Model$formatBoxShadow({
                        blur: shadow.blur,
                        color: shadow.color,
                        inset: false,
                        offset: A2($elm$core$Tuple$mapSecond, $elm$core$Basics$toFloat, A2($elm$core$Tuple$mapFirst, $elm$core$Basics$toFloat, shadow.offset)),
                        size: shadow.size
                    }));
                }, focus.shadow),
                $elm$core$Maybe$Just(A2($mdgriffith$elm_ui$Internal$Model$Property, "outline", "none"))
            ]))),
            A2($mdgriffith$elm_ui$Internal$Model$Style, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any) + ":focus .focusable, " + ($mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any) + ".focusable:focus, " + (".ui-slide-bar:focus + " + ($mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any) + " .focusable-thumb"))), A2($elm$core$List$filterMap, $elm$core$Basics$identity, _List_fromArray([
                A2($elm$core$Maybe$map, function(color) {
                    return A2($mdgriffith$elm_ui$Internal$Model$Property, "border-color", $mdgriffith$elm_ui$Internal$Model$formatColor(color));
                }, focus.borderColor),
                A2($elm$core$Maybe$map, function(color) {
                    return A2($mdgriffith$elm_ui$Internal$Model$Property, "background-color", $mdgriffith$elm_ui$Internal$Model$formatColor(color));
                }, focus.backgroundColor),
                A2($elm$core$Maybe$map, function(shadow) {
                    return A2($mdgriffith$elm_ui$Internal$Model$Property, "box-shadow", $mdgriffith$elm_ui$Internal$Model$formatBoxShadow({
                        blur: shadow.blur,
                        color: shadow.color,
                        inset: false,
                        offset: A2($elm$core$Tuple$mapSecond, $elm$core$Basics$toFloat, A2($elm$core$Tuple$mapFirst, $elm$core$Basics$toFloat, shadow.offset)),
                        size: shadow.size
                    }));
                }, focus.shadow),
                $elm$core$Maybe$Just(A2($mdgriffith$elm_ui$Internal$Model$Property, "outline", "none"))
            ])))
        ]);
    };
    var $elm$virtual_dom$VirtualDom$property = F2(function(key, value) {
        return A2(_VirtualDom_property, _VirtualDom_noInnerHtmlOrFormAction(key), _VirtualDom_noJavaScriptOrHtmlJson(value));
    });
    var $mdgriffith$elm_ui$Internal$Style$AllChildren = F2(function(a, b) {
        return {
            $: "AllChildren",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Style$Batch = function(a) {
        return {
            $: "Batch",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Style$Child = F2(function(a, b) {
        return {
            $: "Child",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Style$Class = F2(function(a, b) {
        return {
            $: "Class",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Style$Descriptor = F2(function(a, b) {
        return {
            $: "Descriptor",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Style$Left = {
        $: "Left"
    };
    var $mdgriffith$elm_ui$Internal$Style$Prop = F2(function(a, b) {
        return {
            $: "Prop",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Style$Right = {
        $: "Right"
    };
    var $mdgriffith$elm_ui$Internal$Style$Self = function(a) {
        return {
            $: "Self",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Style$Supports = F2(function(a, b) {
        return {
            $: "Supports",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Style$Content = function(a) {
        return {
            $: "Content",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Style$Bottom = {
        $: "Bottom"
    };
    var $mdgriffith$elm_ui$Internal$Style$CenterX = {
        $: "CenterX"
    };
    var $mdgriffith$elm_ui$Internal$Style$CenterY = {
        $: "CenterY"
    };
    var $mdgriffith$elm_ui$Internal$Style$Top = {
        $: "Top"
    };
    var $mdgriffith$elm_ui$Internal$Style$alignments = _List_fromArray([
        $mdgriffith$elm_ui$Internal$Style$Top,
        $mdgriffith$elm_ui$Internal$Style$Bottom,
        $mdgriffith$elm_ui$Internal$Style$Right,
        $mdgriffith$elm_ui$Internal$Style$Left,
        $mdgriffith$elm_ui$Internal$Style$CenterX,
        $mdgriffith$elm_ui$Internal$Style$CenterY
    ]);
    var $mdgriffith$elm_ui$Internal$Style$contentName = function(desc) {
        switch(desc.a.$){
            case "Top":
                var _v1 = desc.a;
                return $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.contentTop);
            case "Bottom":
                var _v2 = desc.a;
                return $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.contentBottom);
            case "Right":
                var _v3 = desc.a;
                return $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.contentRight);
            case "Left":
                var _v4 = desc.a;
                return $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.contentLeft);
            case "CenterX":
                var _v5 = desc.a;
                return $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.contentCenterX);
            default:
                var _v6 = desc.a;
                return $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.contentCenterY);
        }
    };
    var $mdgriffith$elm_ui$Internal$Style$selfName = function(desc) {
        switch(desc.a.$){
            case "Top":
                var _v1 = desc.a;
                return $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.alignTop);
            case "Bottom":
                var _v2 = desc.a;
                return $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.alignBottom);
            case "Right":
                var _v3 = desc.a;
                return $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.alignRight);
            case "Left":
                var _v4 = desc.a;
                return $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.alignLeft);
            case "CenterX":
                var _v5 = desc.a;
                return $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.alignCenterX);
            default:
                var _v6 = desc.a;
                return $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.alignCenterY);
        }
    };
    var $mdgriffith$elm_ui$Internal$Style$describeAlignment = function(values) {
        var createDescription = function(alignment) {
            var _v0 = values(alignment);
            var content = _v0.a;
            var indiv = _v0.b;
            return _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$contentName($mdgriffith$elm_ui$Internal$Style$Content(alignment)), content),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$selfName($mdgriffith$elm_ui$Internal$Style$Self(alignment)), indiv)
                ]))
            ]);
        };
        return $mdgriffith$elm_ui$Internal$Style$Batch(A2($elm$core$List$concatMap, createDescription, $mdgriffith$elm_ui$Internal$Style$alignments));
    };
    var $mdgriffith$elm_ui$Internal$Style$elDescription = _List_fromArray([
        A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "flex"),
        A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-direction", "column"),
        A2($mdgriffith$elm_ui$Internal$Style$Prop, "white-space", "pre"),
        A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.hasBehind), _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "z-index", "0"),
            A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.behind), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "z-index", "-1")
            ]))
        ])),
        A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.seButton), _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.text), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.heightFill), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "0")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.widthFill), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-self", "auto !important")
                ]))
            ]))
        ])),
        A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.heightContent), _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "height", "auto")
        ])),
        A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.heightFill), _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "100000")
        ])),
        A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.widthFill), _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "width", "100%")
        ])),
        A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.widthFillPortion), _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "width", "100%")
        ])),
        A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.widthContent), _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-self", "flex-start")
        ])),
        $mdgriffith$elm_ui$Internal$Style$describeAlignment(function(alignment) {
            switch(alignment.$){
                case "Top":
                    return _Utils_Tuple2(_List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "justify-content", "flex-start")
                    ]), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-bottom", "auto !important"),
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-top", "0 !important")
                    ]));
                case "Bottom":
                    return _Utils_Tuple2(_List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "justify-content", "flex-end")
                    ]), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-top", "auto !important"),
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-bottom", "0 !important")
                    ]));
                case "Right":
                    return _Utils_Tuple2(_List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-items", "flex-end")
                    ]), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-self", "flex-end")
                    ]));
                case "Left":
                    return _Utils_Tuple2(_List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-items", "flex-start")
                    ]), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-self", "flex-start")
                    ]));
                case "CenterX":
                    return _Utils_Tuple2(_List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-items", "center")
                    ]), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-self", "center")
                    ]));
                default:
                    return _Utils_Tuple2(_List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any), _List_fromArray([
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-top", "auto"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-bottom", "auto")
                        ]))
                    ]), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-top", "auto !important"),
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-bottom", "auto !important")
                    ]));
            }
        })
    ]);
    var $mdgriffith$elm_ui$Internal$Style$gridAlignments = function(values) {
        var createDescription = function(alignment) {
            return _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$selfName($mdgriffith$elm_ui$Internal$Style$Self(alignment)), values(alignment))
                ]))
            ]);
        };
        return $mdgriffith$elm_ui$Internal$Style$Batch(A2($elm$core$List$concatMap, createDescription, $mdgriffith$elm_ui$Internal$Style$alignments));
    };
    var $mdgriffith$elm_ui$Internal$Style$Above = {
        $: "Above"
    };
    var $mdgriffith$elm_ui$Internal$Style$Behind = {
        $: "Behind"
    };
    var $mdgriffith$elm_ui$Internal$Style$Below = {
        $: "Below"
    };
    var $mdgriffith$elm_ui$Internal$Style$OnLeft = {
        $: "OnLeft"
    };
    var $mdgriffith$elm_ui$Internal$Style$OnRight = {
        $: "OnRight"
    };
    var $mdgriffith$elm_ui$Internal$Style$Within = {
        $: "Within"
    };
    var $mdgriffith$elm_ui$Internal$Style$locations = function() {
        var loc = $mdgriffith$elm_ui$Internal$Style$Above;
        var _v0 = function() {
            switch(loc.$){
                case "Above":
                    return _Utils_Tuple0;
                case "Below":
                    return _Utils_Tuple0;
                case "OnRight":
                    return _Utils_Tuple0;
                case "OnLeft":
                    return _Utils_Tuple0;
                case "Within":
                    return _Utils_Tuple0;
                default:
                    return _Utils_Tuple0;
            }
        }();
        return _List_fromArray([
            $mdgriffith$elm_ui$Internal$Style$Above,
            $mdgriffith$elm_ui$Internal$Style$Below,
            $mdgriffith$elm_ui$Internal$Style$OnRight,
            $mdgriffith$elm_ui$Internal$Style$OnLeft,
            $mdgriffith$elm_ui$Internal$Style$Within,
            $mdgriffith$elm_ui$Internal$Style$Behind
        ]);
    }();
    var $mdgriffith$elm_ui$Internal$Style$baseSheet = _List_fromArray([
        A2($mdgriffith$elm_ui$Internal$Style$Class, "html,body", _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "height", "100%"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "padding", "0"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin", "0")
        ])),
        A2($mdgriffith$elm_ui$Internal$Style$Class, _Utils_ap($mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any), _Utils_ap($mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.single), $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.imageContainer))), _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "block"),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.heightFill), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Child, "img", _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "max-height", "100%"),
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "object-fit", "cover")
                ]))
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.widthFill), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Child, "img", _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "max-width", "100%"),
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "object-fit", "cover")
                ]))
            ]))
        ])),
        A2($mdgriffith$elm_ui$Internal$Style$Class, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any) + ":focus", _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "outline", "none")
        ])),
        A2($mdgriffith$elm_ui$Internal$Style$Class, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.root), _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "width", "100%"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "height", "auto"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "min-height", "100%"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "z-index", "0"),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, _Utils_ap($mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any), $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.heightFill)), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "height", "100%"),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.heightFill), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "height", "100%")
                ]))
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.inFront), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.nearby), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "position", "fixed"),
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "z-index", "20")
                ]))
            ]))
        ])),
        A2($mdgriffith$elm_ui$Internal$Style$Class, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.nearby), _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "position", "relative"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "border", "none"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "flex"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-direction", "row"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-basis", "auto"),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.single), $mdgriffith$elm_ui$Internal$Style$elDescription),
            $mdgriffith$elm_ui$Internal$Style$Batch(function(fn) {
                return A2($elm$core$List$map, fn, $mdgriffith$elm_ui$Internal$Style$locations);
            }(function(loc) {
                switch(loc.$){
                    case "Above":
                        return A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.above), _List_fromArray([
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "position", "absolute"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "bottom", "100%"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "left", "0"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "width", "100%"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "z-index", "20"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin", "0 !important"),
                            A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.heightFill), _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "height", "auto")
                            ])),
                            A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.widthFill), _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "width", "100%")
                            ])),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "pointer-events", "none"),
                            A2($mdgriffith$elm_ui$Internal$Style$Child, "*", _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "pointer-events", "auto")
                            ]))
                        ]));
                    case "Below":
                        return A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.below), _List_fromArray([
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "position", "absolute"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "bottom", "0"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "left", "0"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "height", "0"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "width", "100%"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "z-index", "20"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin", "0 !important"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "pointer-events", "none"),
                            A2($mdgriffith$elm_ui$Internal$Style$Child, "*", _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "pointer-events", "auto")
                            ])),
                            A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.heightFill), _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "height", "auto")
                            ]))
                        ]));
                    case "OnRight":
                        return A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.onRight), _List_fromArray([
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "position", "absolute"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "left", "100%"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "top", "0"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "height", "100%"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin", "0 !important"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "z-index", "20"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "pointer-events", "none"),
                            A2($mdgriffith$elm_ui$Internal$Style$Child, "*", _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "pointer-events", "auto")
                            ]))
                        ]));
                    case "OnLeft":
                        return A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.onLeft), _List_fromArray([
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "position", "absolute"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "right", "100%"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "top", "0"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "height", "100%"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin", "0 !important"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "z-index", "20"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "pointer-events", "none"),
                            A2($mdgriffith$elm_ui$Internal$Style$Child, "*", _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "pointer-events", "auto")
                            ]))
                        ]));
                    case "Within":
                        return A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.inFront), _List_fromArray([
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "position", "absolute"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "width", "100%"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "height", "100%"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "left", "0"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "top", "0"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin", "0 !important"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "pointer-events", "none"),
                            A2($mdgriffith$elm_ui$Internal$Style$Child, "*", _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "pointer-events", "auto")
                            ]))
                        ]));
                    default:
                        return A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.behind), _List_fromArray([
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "position", "absolute"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "width", "100%"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "height", "100%"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "left", "0"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "top", "0"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin", "0 !important"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "z-index", "0"),
                            A2($mdgriffith$elm_ui$Internal$Style$Prop, "pointer-events", "none"),
                            A2($mdgriffith$elm_ui$Internal$Style$Child, "*", _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "pointer-events", "auto")
                            ]))
                        ]));
                }
            }))
        ])),
        A2($mdgriffith$elm_ui$Internal$Style$Class, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any), _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "position", "relative"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "border", "none"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-shrink", "0"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "flex"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-direction", "row"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-basis", "auto"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "resize", "none"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-feature-settings", "inherit"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "box-sizing", "border-box"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin", "0"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "padding", "0"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "border-width", "0"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "border-style", "solid"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-size", "inherit"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "color", "inherit"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-family", "inherit"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "line-height", "1"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-weight", "inherit"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "text-decoration", "none"),
            A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-style", "inherit"),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.wrapped), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-wrap", "wrap")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.noTextSelection), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "-moz-user-select", "none"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "-webkit-user-select", "none"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "-ms-user-select", "none"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "user-select", "none")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.cursorPointer), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "cursor", "pointer")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.cursorText), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "cursor", "text")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.passPointerEvents), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "pointer-events", "none !important")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.capturePointerEvents), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "pointer-events", "auto !important")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.transparent), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "opacity", "0")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.opaque), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "opacity", "1")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot(_Utils_ap($mdgriffith$elm_ui$Internal$Style$classes.hover, $mdgriffith$elm_ui$Internal$Style$classes.transparent)) + ":hover", _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "opacity", "0")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot(_Utils_ap($mdgriffith$elm_ui$Internal$Style$classes.hover, $mdgriffith$elm_ui$Internal$Style$classes.opaque)) + ":hover", _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "opacity", "1")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot(_Utils_ap($mdgriffith$elm_ui$Internal$Style$classes.focus, $mdgriffith$elm_ui$Internal$Style$classes.transparent)) + ":focus", _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "opacity", "0")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot(_Utils_ap($mdgriffith$elm_ui$Internal$Style$classes.focus, $mdgriffith$elm_ui$Internal$Style$classes.opaque)) + ":focus", _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "opacity", "1")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot(_Utils_ap($mdgriffith$elm_ui$Internal$Style$classes.active, $mdgriffith$elm_ui$Internal$Style$classes.transparent)) + ":active", _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "opacity", "0")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot(_Utils_ap($mdgriffith$elm_ui$Internal$Style$classes.active, $mdgriffith$elm_ui$Internal$Style$classes.opaque)) + ":active", _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "opacity", "1")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.transition), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "transition", A2($elm$core$String$join, ", ", A2($elm$core$List$map, function(x) {
                    return x + " 160ms";
                }, _List_fromArray([
                    "transform",
                    "opacity",
                    "filter",
                    "background-color",
                    "color",
                    "font-size"
                ]))))
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.scrollbars), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "overflow", "auto"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-shrink", "1")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.scrollbarsX), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "overflow-x", "auto"),
                A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.row), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-shrink", "1")
                ]))
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.scrollbarsY), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "overflow-y", "auto"),
                A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.column), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-shrink", "1")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.single), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-shrink", "1")
                ]))
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.clip), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "overflow", "hidden")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.clipX), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "overflow-x", "hidden")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.clipY), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "overflow-y", "hidden")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.widthContent), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "width", "auto")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.borderNone), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "border-width", "0")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.borderDashed), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "border-style", "dashed")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.borderDotted), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "border-style", "dotted")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.borderSolid), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "border-style", "solid")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.text), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "white-space", "pre"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "inline-block")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.inputText), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "line-height", "1.05"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "background", "transparent"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "text-align", "inherit")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.single), $mdgriffith$elm_ui$Internal$Style$elDescription),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.row), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "flex"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-direction", "row"),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-basis", "0%"),
                    A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.widthExact), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-basis", "auto")
                    ])),
                    A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.link), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-basis", "auto")
                    ]))
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.heightFill), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-self", "stretch !important")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.heightFillPortion), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-self", "stretch !important")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.widthFill), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "100000")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.container), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "0"),
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-basis", "auto"),
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-self", "stretch")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, "u:first-of-type." + $mdgriffith$elm_ui$Internal$Style$classes.alignContainerRight, _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "1")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, "s:first-of-type." + $mdgriffith$elm_ui$Internal$Style$classes.alignContainerCenterX, _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "1"),
                    A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.alignCenterX), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-left", "auto !important")
                    ]))
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, "s:last-of-type." + $mdgriffith$elm_ui$Internal$Style$classes.alignContainerCenterX, _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "1"),
                    A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.alignCenterX), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-right", "auto !important")
                    ]))
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, "s:only-of-type." + $mdgriffith$elm_ui$Internal$Style$classes.alignContainerCenterX, _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "1"),
                    A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.alignCenterY), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-top", "auto !important"),
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-bottom", "auto !important")
                    ]))
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, "s:last-of-type." + ($mdgriffith$elm_ui$Internal$Style$classes.alignContainerCenterX + " ~ u"), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "0")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, "u:first-of-type." + ($mdgriffith$elm_ui$Internal$Style$classes.alignContainerRight + (" ~ s." + $mdgriffith$elm_ui$Internal$Style$classes.alignContainerCenterX)), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "0")
                ])),
                $mdgriffith$elm_ui$Internal$Style$describeAlignment(function(alignment) {
                    switch(alignment.$){
                        case "Top":
                            return _Utils_Tuple2(_List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-items", "flex-start")
                            ]), _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-self", "flex-start")
                            ]));
                        case "Bottom":
                            return _Utils_Tuple2(_List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-items", "flex-end")
                            ]), _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-self", "flex-end")
                            ]));
                        case "Right":
                            return _Utils_Tuple2(_List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "justify-content", "flex-end")
                            ]), _List_Nil);
                        case "Left":
                            return _Utils_Tuple2(_List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "justify-content", "flex-start")
                            ]), _List_Nil);
                        case "CenterX":
                            return _Utils_Tuple2(_List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "justify-content", "center")
                            ]), _List_Nil);
                        default:
                            return _Utils_Tuple2(_List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-items", "center")
                            ]), _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-self", "center")
                            ]));
                    }
                }),
                A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.spaceEvenly), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "justify-content", "space-between")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.inputLabel), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-items", "baseline")
                ]))
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.column), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "flex"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-direction", "column"),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-basis", "0px"),
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "min-height", "min-content"),
                    A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.heightExact), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-basis", "auto")
                    ]))
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.heightFill), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "100000")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.widthFill), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "width", "100%")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.widthFillPortion), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "width", "100%")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.widthContent), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-self", "flex-start")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, "u:first-of-type." + $mdgriffith$elm_ui$Internal$Style$classes.alignContainerBottom, _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "1")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, "s:first-of-type." + $mdgriffith$elm_ui$Internal$Style$classes.alignContainerCenterY, _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "1"),
                    A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.alignCenterY), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-top", "auto !important"),
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-bottom", "0 !important")
                    ]))
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, "s:last-of-type." + $mdgriffith$elm_ui$Internal$Style$classes.alignContainerCenterY, _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "1"),
                    A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.alignCenterY), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-bottom", "auto !important"),
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-top", "0 !important")
                    ]))
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, "s:only-of-type." + $mdgriffith$elm_ui$Internal$Style$classes.alignContainerCenterY, _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "1"),
                    A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.alignCenterY), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-top", "auto !important"),
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-bottom", "auto !important")
                    ]))
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, "s:last-of-type." + ($mdgriffith$elm_ui$Internal$Style$classes.alignContainerCenterY + " ~ u"), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "0")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, "u:first-of-type." + ($mdgriffith$elm_ui$Internal$Style$classes.alignContainerBottom + (" ~ s." + $mdgriffith$elm_ui$Internal$Style$classes.alignContainerCenterY)), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "0")
                ])),
                $mdgriffith$elm_ui$Internal$Style$describeAlignment(function(alignment) {
                    switch(alignment.$){
                        case "Top":
                            return _Utils_Tuple2(_List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "justify-content", "flex-start")
                            ]), _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-bottom", "auto")
                            ]));
                        case "Bottom":
                            return _Utils_Tuple2(_List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "justify-content", "flex-end")
                            ]), _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin-top", "auto")
                            ]));
                        case "Right":
                            return _Utils_Tuple2(_List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-items", "flex-end")
                            ]), _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-self", "flex-end")
                            ]));
                        case "Left":
                            return _Utils_Tuple2(_List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-items", "flex-start")
                            ]), _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-self", "flex-start")
                            ]));
                        case "CenterX":
                            return _Utils_Tuple2(_List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-items", "center")
                            ]), _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-self", "center")
                            ]));
                        default:
                            return _Utils_Tuple2(_List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "justify-content", "center")
                            ]), _List_Nil);
                    }
                }),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.container), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-grow", "0"),
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-basis", "auto"),
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "width", "100%"),
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-self", "stretch !important")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.spaceEvenly), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "justify-content", "space-between")
                ]))
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.grid), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "-ms-grid"),
                A2($mdgriffith$elm_ui$Internal$Style$Child, ".gp", _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "width", "100%")
                    ]))
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Supports, _Utils_Tuple2("display", "grid"), _List_fromArray([
                    _Utils_Tuple2("display", "grid")
                ])),
                $mdgriffith$elm_ui$Internal$Style$gridAlignments(function(alignment) {
                    switch(alignment.$){
                        case "Top":
                            return _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "justify-content", "flex-start")
                            ]);
                        case "Bottom":
                            return _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "justify-content", "flex-end")
                            ]);
                        case "Right":
                            return _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-items", "flex-end")
                            ]);
                        case "Left":
                            return _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-items", "flex-start")
                            ]);
                        case "CenterX":
                            return _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "align-items", "center")
                            ]);
                        default:
                            return _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "justify-content", "center")
                            ]);
                    }
                })
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.page), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "block"),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any + ":first-child"), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin", "0 !important")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any + ($mdgriffith$elm_ui$Internal$Style$selfName($mdgriffith$elm_ui$Internal$Style$Self($mdgriffith$elm_ui$Internal$Style$Left)) + (":first-child + ." + $mdgriffith$elm_ui$Internal$Style$classes.any))), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin", "0 !important")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any + ($mdgriffith$elm_ui$Internal$Style$selfName($mdgriffith$elm_ui$Internal$Style$Self($mdgriffith$elm_ui$Internal$Style$Right)) + (":first-child + ." + $mdgriffith$elm_ui$Internal$Style$classes.any))), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "margin", "0 !important")
                ])),
                $mdgriffith$elm_ui$Internal$Style$describeAlignment(function(alignment) {
                    switch(alignment.$){
                        case "Top":
                            return _Utils_Tuple2(_List_Nil, _List_Nil);
                        case "Bottom":
                            return _Utils_Tuple2(_List_Nil, _List_Nil);
                        case "Right":
                            return _Utils_Tuple2(_List_Nil, _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "float", "right"),
                                A2($mdgriffith$elm_ui$Internal$Style$Descriptor, "::after", _List_fromArray([
                                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "content", '""'),
                                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "table"),
                                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "clear", "both")
                                ]))
                            ]));
                        case "Left":
                            return _Utils_Tuple2(_List_Nil, _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "float", "left"),
                                A2($mdgriffith$elm_ui$Internal$Style$Descriptor, "::after", _List_fromArray([
                                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "content", '""'),
                                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "table"),
                                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "clear", "both")
                                ]))
                            ]));
                        case "CenterX":
                            return _Utils_Tuple2(_List_Nil, _List_Nil);
                        default:
                            return _Utils_Tuple2(_List_Nil, _List_Nil);
                    }
                })
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.inputMultiline), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "white-space", "pre-wrap !important"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "height", "100%"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "width", "100%"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "background-color", "transparent")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.inputMultilineWrapper), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.single), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "flex-basis", "auto")
                ]))
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.inputMultilineParent), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "white-space", "pre-wrap !important"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "cursor", "text"),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.inputMultilineFiller), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "white-space", "pre-wrap !important"),
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "color", "transparent")
                ]))
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.paragraph), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "block"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "white-space", "normal"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "overflow-wrap", "break-word"),
                A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.hasBehind), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "z-index", "0"),
                    A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.behind), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "z-index", "-1")
                    ]))
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$AllChildren, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.text), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "inline"),
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "white-space", "normal")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$AllChildren, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.paragraph), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "inline"),
                    A2($mdgriffith$elm_ui$Internal$Style$Descriptor, "::after", _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "content", "none")
                    ])),
                    A2($mdgriffith$elm_ui$Internal$Style$Descriptor, "::before", _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "content", "none")
                    ]))
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$AllChildren, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.single), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "inline"),
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "white-space", "normal"),
                    A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.widthExact), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "inline-block")
                    ])),
                    A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.inFront), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "flex")
                    ])),
                    A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.behind), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "flex")
                    ])),
                    A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.above), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "flex")
                    ])),
                    A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.below), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "flex")
                    ])),
                    A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.onRight), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "flex")
                    ])),
                    A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.onLeft), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "flex")
                    ])),
                    A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.text), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "inline"),
                        A2($mdgriffith$elm_ui$Internal$Style$Prop, "white-space", "normal")
                    ]))
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.row), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "inline")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.column), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "inline-flex")
                ])),
                A2($mdgriffith$elm_ui$Internal$Style$Child, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.grid), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "inline-grid")
                ])),
                $mdgriffith$elm_ui$Internal$Style$describeAlignment(function(alignment) {
                    switch(alignment.$){
                        case "Top":
                            return _Utils_Tuple2(_List_Nil, _List_Nil);
                        case "Bottom":
                            return _Utils_Tuple2(_List_Nil, _List_Nil);
                        case "Right":
                            return _Utils_Tuple2(_List_Nil, _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "float", "right")
                            ]));
                        case "Left":
                            return _Utils_Tuple2(_List_Nil, _List_fromArray([
                                A2($mdgriffith$elm_ui$Internal$Style$Prop, "float", "left")
                            ]));
                        case "CenterX":
                            return _Utils_Tuple2(_List_Nil, _List_Nil);
                        default:
                            return _Utils_Tuple2(_List_Nil, _List_Nil);
                    }
                })
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, ".hidden", _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "display", "none")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.textThin), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-weight", "100")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.textExtraLight), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-weight", "200")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.textLight), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-weight", "300")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.textNormalWeight), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-weight", "400")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.textMedium), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-weight", "500")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.textSemiBold), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-weight", "600")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.bold), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-weight", "700")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.textExtraBold), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-weight", "800")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.textHeavy), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-weight", "900")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.italic), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-style", "italic")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.strike), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "text-decoration", "line-through")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.underline), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "text-decoration", "underline"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "text-decoration-skip-ink", "auto"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "text-decoration-skip", "ink")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, _Utils_ap($mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.underline), $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.strike)), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "text-decoration", "line-through underline"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "text-decoration-skip-ink", "auto"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "text-decoration-skip", "ink")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.textUnitalicized), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-style", "normal")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.textJustify), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "text-align", "justify")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.textJustifyAll), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "text-align", "justify-all")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.textCenter), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "text-align", "center")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.textRight), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "text-align", "right")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, $mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.textLeft), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "text-align", "left")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Descriptor, ".modal", _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "position", "fixed"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "left", "0"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "top", "0"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "width", "100%"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "height", "100%"),
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "pointer-events", "none")
            ]))
        ]))
    ]);
    var $mdgriffith$elm_ui$Internal$Style$fontVariant = function(_var) {
        return _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Style$Class, ".v-" + _var, _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-feature-settings", '"' + (_var + '"'))
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Class, ".v-" + (_var + "-off"), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-feature-settings", '"' + (_var + '" 0'))
            ]))
        ]);
    };
    var $mdgriffith$elm_ui$Internal$Style$commonValues = $elm$core$List$concat(_List_fromArray([
        A2($elm$core$List$map, function(x) {
            return A2($mdgriffith$elm_ui$Internal$Style$Class, ".border-" + $elm$core$String$fromInt(x), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "border-width", $elm$core$String$fromInt(x) + "px")
            ]));
        }, A2($elm$core$List$range, 0, 6)),
        A2($elm$core$List$map, function(i) {
            return A2($mdgriffith$elm_ui$Internal$Style$Class, ".font-size-" + $elm$core$String$fromInt(i), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-size", $elm$core$String$fromInt(i) + "px")
            ]));
        }, A2($elm$core$List$range, 8, 32)),
        A2($elm$core$List$map, function(i) {
            return A2($mdgriffith$elm_ui$Internal$Style$Class, ".p-" + $elm$core$String$fromInt(i), _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "padding", $elm$core$String$fromInt(i) + "px")
            ]));
        }, A2($elm$core$List$range, 0, 24)),
        _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Style$Class, ".v-smcp", _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-variant", "small-caps")
            ])),
            A2($mdgriffith$elm_ui$Internal$Style$Class, ".v-smcp-off", _List_fromArray([
                A2($mdgriffith$elm_ui$Internal$Style$Prop, "font-variant", "normal")
            ]))
        ]),
        $mdgriffith$elm_ui$Internal$Style$fontVariant("zero"),
        $mdgriffith$elm_ui$Internal$Style$fontVariant("onum"),
        $mdgriffith$elm_ui$Internal$Style$fontVariant("liga"),
        $mdgriffith$elm_ui$Internal$Style$fontVariant("dlig"),
        $mdgriffith$elm_ui$Internal$Style$fontVariant("ordn"),
        $mdgriffith$elm_ui$Internal$Style$fontVariant("tnum"),
        $mdgriffith$elm_ui$Internal$Style$fontVariant("afrc"),
        $mdgriffith$elm_ui$Internal$Style$fontVariant("frac")
    ]));
    var $mdgriffith$elm_ui$Internal$Style$explainer = "\n.explain {\n    border: 6px solid rgb(174, 121, 15) !important;\n}\n.explain > ." + ($mdgriffith$elm_ui$Internal$Style$classes.any + (" {\n    border: 4px dashed rgb(0, 151, 167) !important;\n}\n\n.ctr {\n    border: none !important;\n}\n.explain > .ctr > ." + ($mdgriffith$elm_ui$Internal$Style$classes.any + " {\n    border: 4px dashed rgb(0, 151, 167) !important;\n}\n\n")));
    var $mdgriffith$elm_ui$Internal$Style$inputTextReset = '\ninput[type="search"],\ninput[type="search"]::-webkit-search-decoration,\ninput[type="search"]::-webkit-search-cancel-button,\ninput[type="search"]::-webkit-search-results-button,\ninput[type="search"]::-webkit-search-results-decoration {\n  -webkit-appearance:none;\n}\n';
    var $mdgriffith$elm_ui$Internal$Style$sliderReset = "\ninput[type=range] {\n  -webkit-appearance: none; \n  background: transparent;\n  position:absolute;\n  left:0;\n  top:0;\n  z-index:10;\n  width: 100%;\n  outline: dashed 1px;\n  height: 100%;\n  opacity: 0;\n}\n";
    var $mdgriffith$elm_ui$Internal$Style$thumbReset = "\ninput[type=range]::-webkit-slider-thumb {\n    -webkit-appearance: none;\n    opacity: 0.5;\n    width: 80px;\n    height: 80px;\n    background-color: black;\n    border:none;\n    border-radius: 5px;\n}\ninput[type=range]::-moz-range-thumb {\n    opacity: 0.5;\n    width: 80px;\n    height: 80px;\n    background-color: black;\n    border:none;\n    border-radius: 5px;\n}\ninput[type=range]::-ms-thumb {\n    opacity: 0.5;\n    width: 80px;\n    height: 80px;\n    background-color: black;\n    border:none;\n    border-radius: 5px;\n}\ninput[type=range][orient=vertical]{\n    writing-mode: bt-lr; /* IE */\n    -webkit-appearance: slider-vertical;  /* WebKit */\n}\n";
    var $mdgriffith$elm_ui$Internal$Style$trackReset = "\ninput[type=range]::-moz-range-track {\n    background: transparent;\n    cursor: pointer;\n}\ninput[type=range]::-ms-track {\n    background: transparent;\n    cursor: pointer;\n}\ninput[type=range]::-webkit-slider-runnable-track {\n    background: transparent;\n    cursor: pointer;\n}\n";
    var $mdgriffith$elm_ui$Internal$Style$overrides = "@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {" + ($mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any) + ($mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.row) + (" > " + ($mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any) + (" { flex-basis: auto !important; } " + ($mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any) + ($mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.row) + (" > " + ($mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any) + ($mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.container) + (" { flex-basis: auto !important; }}" + ($mdgriffith$elm_ui$Internal$Style$inputTextReset + ($mdgriffith$elm_ui$Internal$Style$sliderReset + ($mdgriffith$elm_ui$Internal$Style$trackReset + ($mdgriffith$elm_ui$Internal$Style$thumbReset + $mdgriffith$elm_ui$Internal$Style$explainer)))))))))))))));
    var $elm$core$String$concat = function(strings) {
        return A2($elm$core$String$join, "", strings);
    };
    var $mdgriffith$elm_ui$Internal$Style$Intermediate = function(a) {
        return {
            $: "Intermediate",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Style$emptyIntermediate = F2(function(selector, closing) {
        return $mdgriffith$elm_ui$Internal$Style$Intermediate({
            closing: closing,
            others: _List_Nil,
            props: _List_Nil,
            selector: selector
        });
    });
    var $mdgriffith$elm_ui$Internal$Style$renderRules = F2(function(_v0, rulesToRender) {
        var parent = _v0.a;
        var generateIntermediates = F2(function(rule, rendered) {
            switch(rule.$){
                case "Prop":
                    var name = rule.a;
                    var val = rule.b;
                    return _Utils_update(rendered, {
                        props: A2($elm$core$List$cons, _Utils_Tuple2(name, val), rendered.props)
                    });
                case "Supports":
                    var _v2 = rule.a;
                    var prop = _v2.a;
                    var value = _v2.b;
                    var props = rule.b;
                    return _Utils_update(rendered, {
                        others: A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Style$Intermediate({
                            closing: "\n}",
                            others: _List_Nil,
                            props: props,
                            selector: "@supports (" + (prop + (":" + (value + (") {" + parent.selector))))
                        }), rendered.others)
                    });
                case "Adjacent":
                    var selector = rule.a;
                    var adjRules = rule.b;
                    return _Utils_update(rendered, {
                        others: A2($elm$core$List$cons, A2($mdgriffith$elm_ui$Internal$Style$renderRules, A2($mdgriffith$elm_ui$Internal$Style$emptyIntermediate, parent.selector + (" + " + selector), ""), adjRules), rendered.others)
                    });
                case "Child":
                    var child = rule.a;
                    var childRules = rule.b;
                    return _Utils_update(rendered, {
                        others: A2($elm$core$List$cons, A2($mdgriffith$elm_ui$Internal$Style$renderRules, A2($mdgriffith$elm_ui$Internal$Style$emptyIntermediate, parent.selector + (" > " + child), ""), childRules), rendered.others)
                    });
                case "AllChildren":
                    var child = rule.a;
                    var childRules = rule.b;
                    return _Utils_update(rendered, {
                        others: A2($elm$core$List$cons, A2($mdgriffith$elm_ui$Internal$Style$renderRules, A2($mdgriffith$elm_ui$Internal$Style$emptyIntermediate, parent.selector + (" " + child), ""), childRules), rendered.others)
                    });
                case "Descriptor":
                    var descriptor = rule.a;
                    var descriptorRules = rule.b;
                    return _Utils_update(rendered, {
                        others: A2($elm$core$List$cons, A2($mdgriffith$elm_ui$Internal$Style$renderRules, A2($mdgriffith$elm_ui$Internal$Style$emptyIntermediate, _Utils_ap(parent.selector, descriptor), ""), descriptorRules), rendered.others)
                    });
                default:
                    var batched = rule.a;
                    return _Utils_update(rendered, {
                        others: A2($elm$core$List$cons, A2($mdgriffith$elm_ui$Internal$Style$renderRules, A2($mdgriffith$elm_ui$Internal$Style$emptyIntermediate, parent.selector, ""), batched), rendered.others)
                    });
            }
        });
        return $mdgriffith$elm_ui$Internal$Style$Intermediate(A3($elm$core$List$foldr, generateIntermediates, parent, rulesToRender));
    });
    var $mdgriffith$elm_ui$Internal$Style$renderCompact = function(styleClasses) {
        var renderValues = function(values) {
            return $elm$core$String$concat(A2($elm$core$List$map, function(_v3) {
                var x = _v3.a;
                var y = _v3.b;
                return x + (":" + (y + ";"));
            }, values));
        };
        var renderClass = function(rule) {
            var _v2 = rule.props;
            if (!_v2.b) return "";
            else return rule.selector + ("{" + (renderValues(rule.props) + (rule.closing + "}")));
        };
        var renderIntermediate = function(_v0) {
            var rule = _v0.a;
            return _Utils_ap(renderClass(rule), $elm$core$String$concat(A2($elm$core$List$map, renderIntermediate, rule.others)));
        };
        return $elm$core$String$concat(A2($elm$core$List$map, renderIntermediate, A3($elm$core$List$foldr, F2(function(_v1, existing) {
            var name = _v1.a;
            var styleRules = _v1.b;
            return A2($elm$core$List$cons, A2($mdgriffith$elm_ui$Internal$Style$renderRules, A2($mdgriffith$elm_ui$Internal$Style$emptyIntermediate, name, ""), styleRules), existing);
        }), _List_Nil, styleClasses)));
    };
    var $mdgriffith$elm_ui$Internal$Style$rules = _Utils_ap($mdgriffith$elm_ui$Internal$Style$overrides, $mdgriffith$elm_ui$Internal$Style$renderCompact(_Utils_ap($mdgriffith$elm_ui$Internal$Style$baseSheet, $mdgriffith$elm_ui$Internal$Style$commonValues)));
    var $mdgriffith$elm_ui$Internal$Model$staticRoot = function(opts) {
        var _v0 = opts.mode;
        switch(_v0.$){
            case "Layout":
                return A3($elm$virtual_dom$VirtualDom$node, "div", _List_Nil, _List_fromArray([
                    A3($elm$virtual_dom$VirtualDom$node, "style", _List_Nil, _List_fromArray([
                        $elm$virtual_dom$VirtualDom$text($mdgriffith$elm_ui$Internal$Style$rules)
                    ]))
                ]));
            case "NoStaticStyleSheet":
                return $elm$virtual_dom$VirtualDom$text("");
            default:
                return A3($elm$virtual_dom$VirtualDom$node, "elm-ui-static-rules", _List_fromArray([
                    A2($elm$virtual_dom$VirtualDom$property, "rules", $elm$json$Json$Encode$string($mdgriffith$elm_ui$Internal$Style$rules))
                ]), _List_Nil);
        }
    };
    var $elm$core$List$any = F2(function(isOkay, list) {
        any: while(true){
            if (!list.b) return false;
            else {
                var x = list.a;
                var xs = list.b;
                if (isOkay(x)) return true;
                else {
                    var $temp$isOkay = isOkay, $temp$list = xs;
                    isOkay = $temp$isOkay;
                    list = $temp$list;
                    continue any;
                }
            }
        }
    });
    var $mdgriffith$elm_ui$Internal$Model$fontName = function(font) {
        switch(font.$){
            case "Serif":
                return "serif";
            case "SansSerif":
                return "sans-serif";
            case "Monospace":
                return "monospace";
            case "Typeface":
                var name = font.a;
                return '"' + (name + '"');
            case "ImportFont":
                var name = font.a;
                var url = font.b;
                return '"' + (name + '"');
            default:
                var name = font.a.name;
                return '"' + (name + '"');
        }
    };
    var $mdgriffith$elm_ui$Internal$Model$isSmallCaps = function(_var) {
        switch(_var.$){
            case "VariantActive":
                var name = _var.a;
                return name === "smcp";
            case "VariantOff":
                var name = _var.a;
                return false;
            default:
                var name = _var.a;
                var index = _var.b;
                return name === "smcp" && index === 1;
        }
    };
    var $mdgriffith$elm_ui$Internal$Model$hasSmallCaps = function(typeface) {
        if (typeface.$ === "FontWith") {
            var font = typeface.a;
            return A2($elm$core$List$any, $mdgriffith$elm_ui$Internal$Model$isSmallCaps, font.variants);
        } else return false;
    };
    var $elm$core$Basics$min = F2(function(x, y) {
        return _Utils_cmp(x, y) < 0 ? x : y;
    });
    var $mdgriffith$elm_ui$Internal$Model$renderProps = F3(function(force, _v0, existing) {
        var key = _v0.a;
        var val = _v0.b;
        return force ? existing + ("\n  " + (key + (": " + (val + " !important;")))) : existing + ("\n  " + (key + (": " + (val + ";"))));
    });
    var $mdgriffith$elm_ui$Internal$Model$renderStyle = F4(function(options, maybePseudo, selector, props) {
        if (maybePseudo.$ === "Nothing") return _List_fromArray([
            selector + ("{" + (A3($elm$core$List$foldl, $mdgriffith$elm_ui$Internal$Model$renderProps(false), "", props) + "\n}"))
        ]);
        else {
            var pseudo = maybePseudo.a;
            switch(pseudo.$){
                case "Hover":
                    var _v2 = options.hover;
                    switch(_v2.$){
                        case "NoHover":
                            return _List_Nil;
                        case "ForceHover":
                            return _List_fromArray([
                                selector + ("-hv {" + (A3($elm$core$List$foldl, $mdgriffith$elm_ui$Internal$Model$renderProps(true), "", props) + "\n}"))
                            ]);
                        default:
                            return _List_fromArray([
                                selector + ("-hv:hover {" + (A3($elm$core$List$foldl, $mdgriffith$elm_ui$Internal$Model$renderProps(false), "", props) + "\n}"))
                            ]);
                    }
                case "Focus":
                    var renderedProps = A3($elm$core$List$foldl, $mdgriffith$elm_ui$Internal$Model$renderProps(false), "", props);
                    return _List_fromArray([
                        selector + ("-fs:focus {" + (renderedProps + "\n}")),
                        "." + ($mdgriffith$elm_ui$Internal$Style$classes.any + (":focus " + (selector + "-fs  {"))) + (renderedProps + "\n}"),
                        selector + "-fs:focus-within {" + (renderedProps + "\n}"),
                        ".ui-slide-bar:focus + " + ($mdgriffith$elm_ui$Internal$Style$dot($mdgriffith$elm_ui$Internal$Style$classes.any) + (" .focusable-thumb" + (selector + "-fs {"))) + (renderedProps + "\n}")
                    ]);
                default:
                    return _List_fromArray([
                        selector + ("-act:active {" + (A3($elm$core$List$foldl, $mdgriffith$elm_ui$Internal$Model$renderProps(false), "", props) + "\n}"))
                    ]);
            }
        }
    });
    var $mdgriffith$elm_ui$Internal$Model$renderVariant = function(_var) {
        switch(_var.$){
            case "VariantActive":
                var name = _var.a;
                return '"' + (name + '"');
            case "VariantOff":
                var name = _var.a;
                return '"' + (name + '" 0');
            default:
                var name = _var.a;
                var index = _var.b;
                return '"' + (name + ('" ' + $elm$core$String$fromInt(index)));
        }
    };
    var $mdgriffith$elm_ui$Internal$Model$renderVariants = function(typeface) {
        if (typeface.$ === "FontWith") {
            var font = typeface.a;
            return $elm$core$Maybe$Just(A2($elm$core$String$join, ", ", A2($elm$core$List$map, $mdgriffith$elm_ui$Internal$Model$renderVariant, font.variants)));
        } else return $elm$core$Maybe$Nothing;
    };
    var $mdgriffith$elm_ui$Internal$Model$transformValue = function(transform) {
        switch(transform.$){
            case "Untransformed":
                return $elm$core$Maybe$Nothing;
            case "Moved":
                var _v1 = transform.a;
                var x = _v1.a;
                var y = _v1.b;
                var z = _v1.c;
                return $elm$core$Maybe$Just("translate3d(" + ($elm$core$String$fromFloat(x) + ("px, " + ($elm$core$String$fromFloat(y) + ("px, " + ($elm$core$String$fromFloat(z) + "px)"))))));
            default:
                var _v2 = transform.a;
                var tx = _v2.a;
                var ty = _v2.b;
                var tz = _v2.c;
                var _v3 = transform.b;
                var sx = _v3.a;
                var sy = _v3.b;
                var sz = _v3.c;
                var _v4 = transform.c;
                var ox = _v4.a;
                var oy = _v4.b;
                var oz = _v4.c;
                var angle = transform.d;
                var translate = "translate3d(" + ($elm$core$String$fromFloat(tx) + ("px, " + ($elm$core$String$fromFloat(ty) + ("px, " + ($elm$core$String$fromFloat(tz) + "px)")))));
                var scale = "scale3d(" + ($elm$core$String$fromFloat(sx) + (", " + ($elm$core$String$fromFloat(sy) + (", " + ($elm$core$String$fromFloat(sz) + ")")))));
                var rotate = "rotate3d(" + ($elm$core$String$fromFloat(ox) + (", " + ($elm$core$String$fromFloat(oy) + (", " + ($elm$core$String$fromFloat(oz) + (", " + ($elm$core$String$fromFloat(angle) + "rad)")))))));
                return $elm$core$Maybe$Just(translate + (" " + (scale + (" " + rotate))));
        }
    };
    var $mdgriffith$elm_ui$Internal$Model$renderStyleRule = F3(function(options, rule, maybePseudo) {
        switch(rule.$){
            case "Style":
                var selector = rule.a;
                var props = rule.b;
                return A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, selector, props);
            case "Shadows":
                var name = rule.a;
                var prop = rule.b;
                return A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, "." + name, _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Model$Property, "box-shadow", prop)
                ]));
            case "Transparency":
                var name = rule.a;
                var transparency = rule.b;
                var opacity = A2($elm$core$Basics$max, 0, A2($elm$core$Basics$min, 1, 1 - transparency));
                return A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, "." + name, _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Model$Property, "opacity", $elm$core$String$fromFloat(opacity))
                ]));
            case "FontSize":
                var i = rule.a;
                return A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, ".font-size-" + $elm$core$String$fromInt(i), _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Model$Property, "font-size", $elm$core$String$fromInt(i) + "px")
                ]));
            case "FontFamily":
                var name = rule.a;
                var typefaces = rule.b;
                var features = A2($elm$core$String$join, ", ", A2($elm$core$List$filterMap, $mdgriffith$elm_ui$Internal$Model$renderVariants, typefaces));
                var families = _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Model$Property, "font-family", A2($elm$core$String$join, ", ", A2($elm$core$List$map, $mdgriffith$elm_ui$Internal$Model$fontName, typefaces))),
                    A2($mdgriffith$elm_ui$Internal$Model$Property, "font-feature-settings", features),
                    A2($mdgriffith$elm_ui$Internal$Model$Property, "font-variant", A2($elm$core$List$any, $mdgriffith$elm_ui$Internal$Model$hasSmallCaps, typefaces) ? "small-caps" : "normal")
                ]);
                return A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, "." + name, families);
            case "Single":
                var _class = rule.a;
                var prop = rule.b;
                var val = rule.c;
                return A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, "." + _class, _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Model$Property, prop, val)
                ]));
            case "Colored":
                var _class = rule.a;
                var prop = rule.b;
                var color = rule.c;
                return A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, "." + _class, _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Model$Property, prop, $mdgriffith$elm_ui$Internal$Model$formatColor(color))
                ]));
            case "SpacingStyle":
                var cls = rule.a;
                var x = rule.b;
                var y = rule.c;
                var yPx = $elm$core$String$fromInt(y) + "px";
                var xPx = $elm$core$String$fromInt(x) + "px";
                var single = "." + $mdgriffith$elm_ui$Internal$Style$classes.single;
                var row = "." + $mdgriffith$elm_ui$Internal$Style$classes.row;
                var wrappedRow = "." + ($mdgriffith$elm_ui$Internal$Style$classes.wrapped + row);
                var right = "." + $mdgriffith$elm_ui$Internal$Style$classes.alignRight;
                var paragraph = "." + $mdgriffith$elm_ui$Internal$Style$classes.paragraph;
                var page = "." + $mdgriffith$elm_ui$Internal$Style$classes.page;
                var left = "." + $mdgriffith$elm_ui$Internal$Style$classes.alignLeft;
                var halfY = $elm$core$String$fromFloat(y / 2) + "px";
                var halfX = $elm$core$String$fromFloat(x / 2) + "px";
                var column = "." + $mdgriffith$elm_ui$Internal$Style$classes.column;
                var _class = "." + cls;
                var any = "." + $mdgriffith$elm_ui$Internal$Style$classes.any;
                return $elm$core$List$concat(_List_fromArray([
                    A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, _class + (row + (" > " + (any + (" + " + any)))), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "margin-left", xPx)
                    ])),
                    A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, _class + (wrappedRow + (" > " + any)), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "margin", halfY + (" " + halfX))
                    ])),
                    A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, _class + (column + (" > " + (any + (" + " + any)))), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "margin-top", yPx)
                    ])),
                    A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, _class + (page + (" > " + (any + (" + " + any)))), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "margin-top", yPx)
                    ])),
                    A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, _class + (page + (" > " + left)), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "margin-right", xPx)
                    ])),
                    A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, _class + (page + (" > " + right)), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "margin-left", xPx)
                    ])),
                    A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, _Utils_ap(_class, paragraph), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "line-height", "calc(1em + " + ($elm$core$String$fromInt(y) + "px)"))
                    ])),
                    A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, "textarea" + (any + _class), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "line-height", "calc(1em + " + ($elm$core$String$fromInt(y) + "px)")),
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "height", "calc(100% + " + ($elm$core$String$fromInt(y) + "px)"))
                    ])),
                    A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, _class + (paragraph + (" > " + left)), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "margin-right", xPx)
                    ])),
                    A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, _class + (paragraph + (" > " + right)), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "margin-left", xPx)
                    ])),
                    A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, _class + (paragraph + "::after"), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "content", "''"),
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "display", "block"),
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "height", "0"),
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "width", "0"),
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "margin-top", $elm$core$String$fromInt(-1 * (y / 2 | 0)) + "px")
                    ])),
                    A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, _class + (paragraph + "::before"), _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "content", "''"),
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "display", "block"),
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "height", "0"),
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "width", "0"),
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "margin-bottom", $elm$core$String$fromInt(-1 * (y / 2 | 0)) + "px")
                    ]))
                ]));
            case "PaddingStyle":
                var cls = rule.a;
                var top = rule.b;
                var right = rule.c;
                var bottom = rule.d;
                var left = rule.e;
                var _class = "." + cls;
                return A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, _class, _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Model$Property, "padding", $elm$core$String$fromFloat(top) + ("px " + ($elm$core$String$fromFloat(right) + ("px " + ($elm$core$String$fromFloat(bottom) + ("px " + ($elm$core$String$fromFloat(left) + "px")))))))
                ]));
            case "BorderWidth":
                var cls = rule.a;
                var top = rule.b;
                var right = rule.c;
                var bottom = rule.d;
                var left = rule.e;
                var _class = "." + cls;
                return A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, _class, _List_fromArray([
                    A2($mdgriffith$elm_ui$Internal$Model$Property, "border-width", $elm$core$String$fromInt(top) + ("px " + ($elm$core$String$fromInt(right) + ("px " + ($elm$core$String$fromInt(bottom) + ("px " + ($elm$core$String$fromInt(left) + "px")))))))
                ]));
            case "GridTemplateStyle":
                var template = rule.a;
                var toGridLengthHelper = F3(function(minimum, maximum, x) {
                    toGridLengthHelper: while(true)switch(x.$){
                        case "Px":
                            var px = x.a;
                            return $elm$core$String$fromInt(px) + "px";
                        case "Content":
                            var _v2 = _Utils_Tuple2(minimum, maximum);
                            if (_v2.a.$ === "Nothing") {
                                if (_v2.b.$ === "Nothing") {
                                    var _v3 = _v2.a;
                                    var _v4 = _v2.b;
                                    return "max-content";
                                } else {
                                    var _v6 = _v2.a;
                                    var maxSize = _v2.b.a;
                                    return "minmax(max-content, " + ($elm$core$String$fromInt(maxSize) + "px)");
                                }
                            } else if (_v2.b.$ === "Nothing") {
                                var minSize = _v2.a.a;
                                var _v5 = _v2.b;
                                return "minmax(" + ($elm$core$String$fromInt(minSize) + "px, max-content)");
                            } else {
                                var minSize = _v2.a.a;
                                var maxSize = _v2.b.a;
                                return "minmax(" + ($elm$core$String$fromInt(minSize) + ("px, " + ($elm$core$String$fromInt(maxSize) + "px)")));
                            }
                        case "Fill":
                            var i = x.a;
                            var _v7 = _Utils_Tuple2(minimum, maximum);
                            if (_v7.a.$ === "Nothing") {
                                if (_v7.b.$ === "Nothing") {
                                    var _v8 = _v7.a;
                                    var _v9 = _v7.b;
                                    return $elm$core$String$fromInt(i) + "fr";
                                } else {
                                    var _v11 = _v7.a;
                                    var maxSize = _v7.b.a;
                                    return "minmax(max-content, " + ($elm$core$String$fromInt(maxSize) + "px)");
                                }
                            } else if (_v7.b.$ === "Nothing") {
                                var minSize = _v7.a.a;
                                var _v10 = _v7.b;
                                return "minmax(" + ($elm$core$String$fromInt(minSize) + ("px, " + ($elm$core$String$fromInt(i) + "frfr)")));
                            } else {
                                var minSize = _v7.a.a;
                                var maxSize = _v7.b.a;
                                return "minmax(" + ($elm$core$String$fromInt(minSize) + ("px, " + ($elm$core$String$fromInt(maxSize) + "px)")));
                            }
                        case "Min":
                            var m = x.a;
                            var len = x.b;
                            var $temp$minimum = $elm$core$Maybe$Just(m), $temp$maximum = maximum, $temp$x = len;
                            minimum = $temp$minimum;
                            maximum = $temp$maximum;
                            x = $temp$x;
                            continue toGridLengthHelper;
                        default:
                            var m = x.a;
                            var len = x.b;
                            var $temp$minimum = minimum, $temp$maximum = $elm$core$Maybe$Just(m), $temp$x = len;
                            minimum = $temp$minimum;
                            maximum = $temp$maximum;
                            x = $temp$x;
                            continue toGridLengthHelper;
                    }
                });
                var toGridLength = function(x) {
                    return A3(toGridLengthHelper, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing, x);
                };
                var xSpacing = toGridLength(template.spacing.a);
                var ySpacing = toGridLength(template.spacing.b);
                var rows = function(x) {
                    return "grid-template-rows: " + (x + ";");
                }(A2($elm$core$String$join, " ", A2($elm$core$List$map, toGridLength, template.rows)));
                var msRows = function(x) {
                    return "-ms-grid-rows: " + (x + ";");
                }(A2($elm$core$String$join, ySpacing, A2($elm$core$List$map, toGridLength, template.columns)));
                var msColumns = function(x) {
                    return "-ms-grid-columns: " + (x + ";");
                }(A2($elm$core$String$join, ySpacing, A2($elm$core$List$map, toGridLength, template.columns)));
                var gapY = "grid-row-gap:" + (toGridLength(template.spacing.b) + ";");
                var gapX = "grid-column-gap:" + (toGridLength(template.spacing.a) + ";");
                var columns = function(x) {
                    return "grid-template-columns: " + (x + ";");
                }(A2($elm$core$String$join, " ", A2($elm$core$List$map, toGridLength, template.columns)));
                var _class = ".grid-rows-" + (A2($elm$core$String$join, "-", A2($elm$core$List$map, $mdgriffith$elm_ui$Internal$Model$lengthClassName, template.rows)) + ("-cols-" + (A2($elm$core$String$join, "-", A2($elm$core$List$map, $mdgriffith$elm_ui$Internal$Model$lengthClassName, template.columns)) + ("-space-x-" + ($mdgriffith$elm_ui$Internal$Model$lengthClassName(template.spacing.a) + ("-space-y-" + $mdgriffith$elm_ui$Internal$Model$lengthClassName(template.spacing.b)))))));
                var modernGrid = _class + ("{" + (columns + (rows + (gapX + (gapY + "}")))));
                var supports = "@supports (display:grid) {" + (modernGrid + "}");
                var base = _class + ("{" + (msColumns + (msRows + "}")));
                return _List_fromArray([
                    base,
                    supports
                ]);
            case "GridPosition":
                var position = rule.a;
                var msPosition = A2($elm$core$String$join, " ", _List_fromArray([
                    "-ms-grid-row: " + ($elm$core$String$fromInt(position.row) + ";"),
                    "-ms-grid-row-span: " + ($elm$core$String$fromInt(position.height) + ";"),
                    "-ms-grid-column: " + ($elm$core$String$fromInt(position.col) + ";"),
                    "-ms-grid-column-span: " + ($elm$core$String$fromInt(position.width) + ";")
                ]));
                var modernPosition = A2($elm$core$String$join, " ", _List_fromArray([
                    "grid-row: " + ($elm$core$String$fromInt(position.row) + (" / " + ($elm$core$String$fromInt(position.row + position.height) + ";"))),
                    "grid-column: " + ($elm$core$String$fromInt(position.col) + (" / " + ($elm$core$String$fromInt(position.col + position.width) + ";")))
                ]));
                var _class = ".grid-pos-" + ($elm$core$String$fromInt(position.row) + ("-" + ($elm$core$String$fromInt(position.col) + ("-" + ($elm$core$String$fromInt(position.width) + ("-" + $elm$core$String$fromInt(position.height)))))));
                var modernGrid = _class + ("{" + (modernPosition + "}"));
                var supports = "@supports (display:grid) {" + (modernGrid + "}");
                var base = _class + ("{" + (msPosition + "}"));
                return _List_fromArray([
                    base,
                    supports
                ]);
            case "PseudoSelector":
                var _class = rule.a;
                var styles = rule.b;
                var renderPseudoRule = function(style) {
                    return A3($mdgriffith$elm_ui$Internal$Model$renderStyleRule, options, style, $elm$core$Maybe$Just(_class));
                };
                return A2($elm$core$List$concatMap, renderPseudoRule, styles);
            default:
                var transform = rule.a;
                var val = $mdgriffith$elm_ui$Internal$Model$transformValue(transform);
                var _class = $mdgriffith$elm_ui$Internal$Model$transformClass(transform);
                var _v12 = _Utils_Tuple2(_class, val);
                if (_v12.a.$ === "Just" && _v12.b.$ === "Just") {
                    var cls = _v12.a.a;
                    var v = _v12.b.a;
                    return A4($mdgriffith$elm_ui$Internal$Model$renderStyle, options, maybePseudo, "." + cls, _List_fromArray([
                        A2($mdgriffith$elm_ui$Internal$Model$Property, "transform", v)
                    ]));
                } else return _List_Nil;
        }
    });
    var $mdgriffith$elm_ui$Internal$Model$encodeStyles = F2(function(options, stylesheet) {
        return $elm$json$Json$Encode$object(A2($elm$core$List$map, function(style) {
            var styled = A3($mdgriffith$elm_ui$Internal$Model$renderStyleRule, options, style, $elm$core$Maybe$Nothing);
            return _Utils_Tuple2($mdgriffith$elm_ui$Internal$Model$getStyleName(style), A2($elm$json$Json$Encode$list, $elm$json$Json$Encode$string, styled));
        }, stylesheet));
    });
    var $mdgriffith$elm_ui$Internal$Model$bracket = F2(function(selector, rules) {
        var renderPair = function(_v0) {
            var name = _v0.a;
            var val = _v0.b;
            return name + (": " + (val + ";"));
        };
        return selector + (" {" + (A2($elm$core$String$join, "", A2($elm$core$List$map, renderPair, rules)) + "}"));
    });
    var $mdgriffith$elm_ui$Internal$Model$fontRule = F3(function(name, modifier, _v0) {
        var parentAdj = _v0.a;
        var textAdjustment = _v0.b;
        return _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Model$bracket, "." + (name + ("." + (modifier + (", " + ("." + (name + (" ." + modifier))))))), parentAdj),
            A2($mdgriffith$elm_ui$Internal$Model$bracket, "." + (name + ("." + (modifier + ("> ." + ($mdgriffith$elm_ui$Internal$Style$classes.text + (", ." + (name + (" ." + (modifier + (" > ." + $mdgriffith$elm_ui$Internal$Style$classes.text)))))))))), textAdjustment)
        ]);
    });
    var $mdgriffith$elm_ui$Internal$Model$renderFontAdjustmentRule = F3(function(fontToAdjust, _v0, otherFontName) {
        var full = _v0.a;
        var capital = _v0.b;
        var name = _Utils_eq(fontToAdjust, otherFontName) ? fontToAdjust : otherFontName + (" ." + fontToAdjust);
        return A2($elm$core$String$join, " ", _Utils_ap(A3($mdgriffith$elm_ui$Internal$Model$fontRule, name, $mdgriffith$elm_ui$Internal$Style$classes.sizeByCapital, capital), A3($mdgriffith$elm_ui$Internal$Model$fontRule, name, $mdgriffith$elm_ui$Internal$Style$classes.fullSize, full)));
    });
    var $mdgriffith$elm_ui$Internal$Model$renderNullAdjustmentRule = F2(function(fontToAdjust, otherFontName) {
        var name = _Utils_eq(fontToAdjust, otherFontName) ? fontToAdjust : otherFontName + (" ." + fontToAdjust);
        return A2($elm$core$String$join, " ", _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Model$bracket, "." + (name + ("." + ($mdgriffith$elm_ui$Internal$Style$classes.sizeByCapital + (", " + ("." + (name + (" ." + $mdgriffith$elm_ui$Internal$Style$classes.sizeByCapital))))))), _List_fromArray([
                _Utils_Tuple2("line-height", "1")
            ])),
            A2($mdgriffith$elm_ui$Internal$Model$bracket, "." + (name + ("." + ($mdgriffith$elm_ui$Internal$Style$classes.sizeByCapital + ("> ." + ($mdgriffith$elm_ui$Internal$Style$classes.text + (", ." + (name + (" ." + ($mdgriffith$elm_ui$Internal$Style$classes.sizeByCapital + (" > ." + $mdgriffith$elm_ui$Internal$Style$classes.text)))))))))), _List_fromArray([
                _Utils_Tuple2("vertical-align", "0"),
                _Utils_Tuple2("line-height", "1")
            ]))
        ]));
    });
    var $mdgriffith$elm_ui$Internal$Model$adjust = F3(function(size, height, vertical) {
        return {
            height: height / size,
            size: size,
            vertical: vertical
        };
    });
    var $elm$core$List$maximum = function(list) {
        if (list.b) {
            var x = list.a;
            var xs = list.b;
            return $elm$core$Maybe$Just(A3($elm$core$List$foldl, $elm$core$Basics$max, x, xs));
        } else return $elm$core$Maybe$Nothing;
    };
    var $elm$core$List$minimum = function(list) {
        if (list.b) {
            var x = list.a;
            var xs = list.b;
            return $elm$core$Maybe$Just(A3($elm$core$List$foldl, $elm$core$Basics$min, x, xs));
        } else return $elm$core$Maybe$Nothing;
    };
    var $mdgriffith$elm_ui$Internal$Model$convertAdjustment = function(adjustment) {
        var lines = _List_fromArray([
            adjustment.capital,
            adjustment.baseline,
            adjustment.descender,
            adjustment.lowercase
        ]);
        var lineHeight = 1.5;
        var normalDescender = (lineHeight - 1) / 2;
        var oldMiddle = lineHeight / 2;
        var descender = A2($elm$core$Maybe$withDefault, adjustment.descender, $elm$core$List$minimum(lines));
        var newBaseline = A2($elm$core$Maybe$withDefault, adjustment.baseline, $elm$core$List$minimum(A2($elm$core$List$filter, function(x) {
            return !_Utils_eq(x, descender);
        }, lines)));
        var base = lineHeight;
        var ascender = A2($elm$core$Maybe$withDefault, adjustment.capital, $elm$core$List$maximum(lines));
        var capitalSize = 1 / (ascender - newBaseline);
        var capitalVertical = 1 - ascender;
        var fullSize = 1 / (ascender - descender);
        var fullVertical = 1 - ascender;
        var newCapitalMiddle = (ascender - newBaseline) / 2 + newBaseline;
        var newFullMiddle = (ascender - descender) / 2 + descender;
        return {
            capital: A3($mdgriffith$elm_ui$Internal$Model$adjust, capitalSize, ascender - newBaseline, capitalVertical),
            full: A3($mdgriffith$elm_ui$Internal$Model$adjust, fullSize, ascender - descender, fullVertical)
        };
    };
    var $mdgriffith$elm_ui$Internal$Model$fontAdjustmentRules = function(converted) {
        return _Utils_Tuple2(_List_fromArray([
            _Utils_Tuple2("display", "block")
        ]), _List_fromArray([
            _Utils_Tuple2("display", "inline-block"),
            _Utils_Tuple2("line-height", $elm$core$String$fromFloat(converted.height)),
            _Utils_Tuple2("vertical-align", $elm$core$String$fromFloat(converted.vertical) + "em"),
            _Utils_Tuple2("font-size", $elm$core$String$fromFloat(converted.size) + "em")
        ]));
    };
    var $mdgriffith$elm_ui$Internal$Model$typefaceAdjustment = function(typefaces) {
        return A3($elm$core$List$foldl, F2(function(face, found) {
            if (found.$ === "Nothing") {
                if (face.$ === "FontWith") {
                    var _with = face.a;
                    var _v2 = _with.adjustment;
                    if (_v2.$ === "Nothing") return found;
                    else {
                        var adjustment = _v2.a;
                        return $elm$core$Maybe$Just(_Utils_Tuple2($mdgriffith$elm_ui$Internal$Model$fontAdjustmentRules(function($) {
                            return $.full;
                        }($mdgriffith$elm_ui$Internal$Model$convertAdjustment(adjustment))), $mdgriffith$elm_ui$Internal$Model$fontAdjustmentRules(function($) {
                            return $.capital;
                        }($mdgriffith$elm_ui$Internal$Model$convertAdjustment(adjustment)))));
                    }
                } else return found;
            } else return found;
        }), $elm$core$Maybe$Nothing, typefaces);
    };
    var $mdgriffith$elm_ui$Internal$Model$renderTopLevelValues = function(rules) {
        var withImport = function(font) {
            if (font.$ === "ImportFont") {
                var url = font.b;
                return $elm$core$Maybe$Just("@import url('" + (url + "');"));
            } else return $elm$core$Maybe$Nothing;
        };
        var fontImports = function(_v2) {
            var name = _v2.a;
            var typefaces = _v2.b;
            var imports = A2($elm$core$String$join, "\n", A2($elm$core$List$filterMap, withImport, typefaces));
            return imports;
        };
        var allNames = A2($elm$core$List$map, $elm$core$Tuple$first, rules);
        var fontAdjustments = function(_v1) {
            var name = _v1.a;
            var typefaces = _v1.b;
            var _v0 = $mdgriffith$elm_ui$Internal$Model$typefaceAdjustment(typefaces);
            if (_v0.$ === "Nothing") return A2($elm$core$String$join, "", A2($elm$core$List$map, $mdgriffith$elm_ui$Internal$Model$renderNullAdjustmentRule(name), allNames));
            else {
                var adjustment = _v0.a;
                return A2($elm$core$String$join, "", A2($elm$core$List$map, A2($mdgriffith$elm_ui$Internal$Model$renderFontAdjustmentRule, name, adjustment), allNames));
            }
        };
        return _Utils_ap(A2($elm$core$String$join, "\n", A2($elm$core$List$map, fontImports, rules)), A2($elm$core$String$join, "\n", A2($elm$core$List$map, fontAdjustments, rules)));
    };
    var $mdgriffith$elm_ui$Internal$Model$topLevelValue = function(rule) {
        if (rule.$ === "FontFamily") {
            var name = rule.a;
            var typefaces = rule.b;
            return $elm$core$Maybe$Just(_Utils_Tuple2(name, typefaces));
        } else return $elm$core$Maybe$Nothing;
    };
    var $mdgriffith$elm_ui$Internal$Model$toStyleSheetString = F2(function(options, stylesheet) {
        var combine = F2(function(style, rendered) {
            return {
                rules: _Utils_ap(rendered.rules, A3($mdgriffith$elm_ui$Internal$Model$renderStyleRule, options, style, $elm$core$Maybe$Nothing)),
                topLevel: function() {
                    var _v1 = $mdgriffith$elm_ui$Internal$Model$topLevelValue(style);
                    if (_v1.$ === "Nothing") return rendered.topLevel;
                    else {
                        var topLevel = _v1.a;
                        return A2($elm$core$List$cons, topLevel, rendered.topLevel);
                    }
                }()
            };
        });
        var _v0 = A3($elm$core$List$foldl, combine, {
            rules: _List_Nil,
            topLevel: _List_Nil
        }, stylesheet);
        var topLevel = _v0.topLevel;
        var rules = _v0.rules;
        return _Utils_ap($mdgriffith$elm_ui$Internal$Model$renderTopLevelValues(topLevel), $elm$core$String$concat(rules));
    });
    var $mdgriffith$elm_ui$Internal$Model$toStyleSheet = F2(function(options, styleSheet) {
        var _v0 = options.mode;
        switch(_v0.$){
            case "Layout":
                return A3($elm$virtual_dom$VirtualDom$node, "div", _List_Nil, _List_fromArray([
                    A3($elm$virtual_dom$VirtualDom$node, "style", _List_Nil, _List_fromArray([
                        $elm$virtual_dom$VirtualDom$text(A2($mdgriffith$elm_ui$Internal$Model$toStyleSheetString, options, styleSheet))
                    ]))
                ]));
            case "NoStaticStyleSheet":
                return A3($elm$virtual_dom$VirtualDom$node, "div", _List_Nil, _List_fromArray([
                    A3($elm$virtual_dom$VirtualDom$node, "style", _List_Nil, _List_fromArray([
                        $elm$virtual_dom$VirtualDom$text(A2($mdgriffith$elm_ui$Internal$Model$toStyleSheetString, options, styleSheet))
                    ]))
                ]));
            default:
                return A3($elm$virtual_dom$VirtualDom$node, "elm-ui-rules", _List_fromArray([
                    A2($elm$virtual_dom$VirtualDom$property, "rules", A2($mdgriffith$elm_ui$Internal$Model$encodeStyles, options, styleSheet))
                ]), _List_Nil);
        }
    });
    var $mdgriffith$elm_ui$Internal$Model$embedKeyed = F4(function(_static, opts, styles, children) {
        var dynamicStyleSheet = A2($mdgriffith$elm_ui$Internal$Model$toStyleSheet, opts, A3($elm$core$List$foldl, $mdgriffith$elm_ui$Internal$Model$reduceStyles, _Utils_Tuple2($elm$core$Set$empty, $mdgriffith$elm_ui$Internal$Model$renderFocusStyle(opts.focus)), styles).b);
        return _static ? A2($elm$core$List$cons, _Utils_Tuple2("static-stylesheet", $mdgriffith$elm_ui$Internal$Model$staticRoot(opts)), A2($elm$core$List$cons, _Utils_Tuple2("dynamic-stylesheet", dynamicStyleSheet), children)) : A2($elm$core$List$cons, _Utils_Tuple2("dynamic-stylesheet", dynamicStyleSheet), children);
    });
    var $mdgriffith$elm_ui$Internal$Model$embedWith = F4(function(_static, opts, styles, children) {
        var dynamicStyleSheet = A2($mdgriffith$elm_ui$Internal$Model$toStyleSheet, opts, A3($elm$core$List$foldl, $mdgriffith$elm_ui$Internal$Model$reduceStyles, _Utils_Tuple2($elm$core$Set$empty, $mdgriffith$elm_ui$Internal$Model$renderFocusStyle(opts.focus)), styles).b);
        return _static ? A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$staticRoot(opts), A2($elm$core$List$cons, dynamicStyleSheet, children)) : A2($elm$core$List$cons, dynamicStyleSheet, children);
    });
    var $mdgriffith$elm_ui$Internal$Flag$heightBetween = $mdgriffith$elm_ui$Internal$Flag$flag(45);
    var $mdgriffith$elm_ui$Internal$Flag$heightFill = $mdgriffith$elm_ui$Internal$Flag$flag(37);
    var $mdgriffith$elm_ui$Internal$Flag$present = F2(function(myFlag, _v0) {
        var fieldOne = _v0.a;
        var fieldTwo = _v0.b;
        if (myFlag.$ === "Flag") {
            var first = myFlag.a;
            return _Utils_eq(first & fieldOne, first);
        } else {
            var second = myFlag.a;
            return _Utils_eq(second & fieldTwo, second);
        }
    });
    var $elm$html$Html$s = _VirtualDom_node("s");
    var $elm$html$Html$u = _VirtualDom_node("u");
    var $mdgriffith$elm_ui$Internal$Flag$widthBetween = $mdgriffith$elm_ui$Internal$Flag$flag(44);
    var $mdgriffith$elm_ui$Internal$Flag$widthFill = $mdgriffith$elm_ui$Internal$Flag$flag(39);
    var $mdgriffith$elm_ui$Internal$Model$finalizeNode = F6(function(has, node, attributes, children, embedMode, parentContext) {
        var createNode = F2(function(nodeName, attrs) {
            if (children.$ === "Keyed") {
                var keyed = children.a;
                return A3($elm$virtual_dom$VirtualDom$keyedNode, nodeName, attrs, function() {
                    switch(embedMode.$){
                        case "NoStyleSheet":
                            return keyed;
                        case "OnlyDynamic":
                            var opts = embedMode.a;
                            var styles = embedMode.b;
                            return A4($mdgriffith$elm_ui$Internal$Model$embedKeyed, false, opts, styles, keyed);
                        default:
                            var opts = embedMode.a;
                            var styles = embedMode.b;
                            return A4($mdgriffith$elm_ui$Internal$Model$embedKeyed, true, opts, styles, keyed);
                    }
                }());
            } else {
                var unkeyed = children.a;
                return A2(function() {
                    switch(nodeName){
                        case "div":
                            return $elm$html$Html$div;
                        case "p":
                            return $elm$html$Html$p;
                        default:
                            return $elm$virtual_dom$VirtualDom$node(nodeName);
                    }
                }(), attrs, function() {
                    switch(embedMode.$){
                        case "NoStyleSheet":
                            return unkeyed;
                        case "OnlyDynamic":
                            var opts = embedMode.a;
                            var styles = embedMode.b;
                            return A4($mdgriffith$elm_ui$Internal$Model$embedWith, false, opts, styles, unkeyed);
                        default:
                            var opts = embedMode.a;
                            var styles = embedMode.b;
                            return A4($mdgriffith$elm_ui$Internal$Model$embedWith, true, opts, styles, unkeyed);
                    }
                }());
            }
        });
        var html = function() {
            switch(node.$){
                case "Generic":
                    return A2(createNode, "div", attributes);
                case "NodeName":
                    var nodeName = node.a;
                    return A2(createNode, nodeName, attributes);
                default:
                    var nodeName = node.a;
                    var internal = node.b;
                    return A3($elm$virtual_dom$VirtualDom$node, nodeName, attributes, _List_fromArray([
                        A2(createNode, internal, _List_fromArray([
                            $elm$html$Html$Attributes$class($mdgriffith$elm_ui$Internal$Style$classes.any + (" " + $mdgriffith$elm_ui$Internal$Style$classes.single))
                        ]))
                    ]));
            }
        }();
        switch(parentContext.$){
            case "AsRow":
                return A2($mdgriffith$elm_ui$Internal$Flag$present, $mdgriffith$elm_ui$Internal$Flag$widthFill, has) && !A2($mdgriffith$elm_ui$Internal$Flag$present, $mdgriffith$elm_ui$Internal$Flag$widthBetween, has) ? html : A2($mdgriffith$elm_ui$Internal$Flag$present, $mdgriffith$elm_ui$Internal$Flag$alignRight, has) ? A2($elm$html$Html$u, _List_fromArray([
                    $elm$html$Html$Attributes$class(A2($elm$core$String$join, " ", _List_fromArray([
                        $mdgriffith$elm_ui$Internal$Style$classes.any,
                        $mdgriffith$elm_ui$Internal$Style$classes.single,
                        $mdgriffith$elm_ui$Internal$Style$classes.container,
                        $mdgriffith$elm_ui$Internal$Style$classes.contentCenterY,
                        $mdgriffith$elm_ui$Internal$Style$classes.alignContainerRight
                    ])))
                ]), _List_fromArray([
                    html
                ])) : A2($mdgriffith$elm_ui$Internal$Flag$present, $mdgriffith$elm_ui$Internal$Flag$centerX, has) ? A2($elm$html$Html$s, _List_fromArray([
                    $elm$html$Html$Attributes$class(A2($elm$core$String$join, " ", _List_fromArray([
                        $mdgriffith$elm_ui$Internal$Style$classes.any,
                        $mdgriffith$elm_ui$Internal$Style$classes.single,
                        $mdgriffith$elm_ui$Internal$Style$classes.container,
                        $mdgriffith$elm_ui$Internal$Style$classes.contentCenterY,
                        $mdgriffith$elm_ui$Internal$Style$classes.alignContainerCenterX
                    ])))
                ]), _List_fromArray([
                    html
                ])) : html;
            case "AsColumn":
                return A2($mdgriffith$elm_ui$Internal$Flag$present, $mdgriffith$elm_ui$Internal$Flag$heightFill, has) && !A2($mdgriffith$elm_ui$Internal$Flag$present, $mdgriffith$elm_ui$Internal$Flag$heightBetween, has) ? html : A2($mdgriffith$elm_ui$Internal$Flag$present, $mdgriffith$elm_ui$Internal$Flag$centerY, has) ? A2($elm$html$Html$s, _List_fromArray([
                    $elm$html$Html$Attributes$class(A2($elm$core$String$join, " ", _List_fromArray([
                        $mdgriffith$elm_ui$Internal$Style$classes.any,
                        $mdgriffith$elm_ui$Internal$Style$classes.single,
                        $mdgriffith$elm_ui$Internal$Style$classes.container,
                        $mdgriffith$elm_ui$Internal$Style$classes.alignContainerCenterY
                    ])))
                ]), _List_fromArray([
                    html
                ])) : A2($mdgriffith$elm_ui$Internal$Flag$present, $mdgriffith$elm_ui$Internal$Flag$alignBottom, has) ? A2($elm$html$Html$u, _List_fromArray([
                    $elm$html$Html$Attributes$class(A2($elm$core$String$join, " ", _List_fromArray([
                        $mdgriffith$elm_ui$Internal$Style$classes.any,
                        $mdgriffith$elm_ui$Internal$Style$classes.single,
                        $mdgriffith$elm_ui$Internal$Style$classes.container,
                        $mdgriffith$elm_ui$Internal$Style$classes.alignContainerBottom
                    ])))
                ]), _List_fromArray([
                    html
                ])) : html;
            default:
                return html;
        }
    });
    var $mdgriffith$elm_ui$Internal$Model$textElementClasses = $mdgriffith$elm_ui$Internal$Style$classes.any + (" " + ($mdgriffith$elm_ui$Internal$Style$classes.text + (" " + ($mdgriffith$elm_ui$Internal$Style$classes.widthContent + (" " + $mdgriffith$elm_ui$Internal$Style$classes.heightContent)))));
    var $mdgriffith$elm_ui$Internal$Model$textElement = function(str) {
        return A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$class($mdgriffith$elm_ui$Internal$Model$textElementClasses)
        ]), _List_fromArray([
            $elm$html$Html$text(str)
        ]));
    };
    var $mdgriffith$elm_ui$Internal$Model$textElementFillClasses = $mdgriffith$elm_ui$Internal$Style$classes.any + (" " + ($mdgriffith$elm_ui$Internal$Style$classes.text + (" " + ($mdgriffith$elm_ui$Internal$Style$classes.widthFill + (" " + $mdgriffith$elm_ui$Internal$Style$classes.heightFill)))));
    var $mdgriffith$elm_ui$Internal$Model$textElementFill = function(str) {
        return A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$class($mdgriffith$elm_ui$Internal$Model$textElementFillClasses)
        ]), _List_fromArray([
            $elm$html$Html$text(str)
        ]));
    };
    var $mdgriffith$elm_ui$Internal$Model$createElement = F3(function(context, children, rendered) {
        var gatherKeyed = F2(function(_v8, _v9) {
            var key = _v8.a;
            var child = _v8.b;
            var htmls = _v9.a;
            var existingStyles = _v9.b;
            switch(child.$){
                case "Unstyled":
                    var html = child.a;
                    return _Utils_eq(context, $mdgriffith$elm_ui$Internal$Model$asParagraph) ? _Utils_Tuple2(A2($elm$core$List$cons, _Utils_Tuple2(key, html(context)), htmls), existingStyles) : _Utils_Tuple2(A2($elm$core$List$cons, _Utils_Tuple2(key, html(context)), htmls), existingStyles);
                case "Styled":
                    var styled = child.a;
                    return _Utils_eq(context, $mdgriffith$elm_ui$Internal$Model$asParagraph) ? _Utils_Tuple2(A2($elm$core$List$cons, _Utils_Tuple2(key, A2(styled.html, $mdgriffith$elm_ui$Internal$Model$NoStyleSheet, context)), htmls), $elm$core$List$isEmpty(existingStyles) ? styled.styles : _Utils_ap(styled.styles, existingStyles)) : _Utils_Tuple2(A2($elm$core$List$cons, _Utils_Tuple2(key, A2(styled.html, $mdgriffith$elm_ui$Internal$Model$NoStyleSheet, context)), htmls), $elm$core$List$isEmpty(existingStyles) ? styled.styles : _Utils_ap(styled.styles, existingStyles));
                case "Text":
                    var str = child.a;
                    return _Utils_Tuple2(A2($elm$core$List$cons, _Utils_Tuple2(key, _Utils_eq(context, $mdgriffith$elm_ui$Internal$Model$asEl) ? $mdgriffith$elm_ui$Internal$Model$textElementFill(str) : $mdgriffith$elm_ui$Internal$Model$textElement(str)), htmls), existingStyles);
                default:
                    return _Utils_Tuple2(htmls, existingStyles);
            }
        });
        var gather = F2(function(child, _v6) {
            var htmls = _v6.a;
            var existingStyles = _v6.b;
            switch(child.$){
                case "Unstyled":
                    var html = child.a;
                    return _Utils_eq(context, $mdgriffith$elm_ui$Internal$Model$asParagraph) ? _Utils_Tuple2(A2($elm$core$List$cons, html(context), htmls), existingStyles) : _Utils_Tuple2(A2($elm$core$List$cons, html(context), htmls), existingStyles);
                case "Styled":
                    var styled = child.a;
                    return _Utils_eq(context, $mdgriffith$elm_ui$Internal$Model$asParagraph) ? _Utils_Tuple2(A2($elm$core$List$cons, A2(styled.html, $mdgriffith$elm_ui$Internal$Model$NoStyleSheet, context), htmls), $elm$core$List$isEmpty(existingStyles) ? styled.styles : _Utils_ap(styled.styles, existingStyles)) : _Utils_Tuple2(A2($elm$core$List$cons, A2(styled.html, $mdgriffith$elm_ui$Internal$Model$NoStyleSheet, context), htmls), $elm$core$List$isEmpty(existingStyles) ? styled.styles : _Utils_ap(styled.styles, existingStyles));
                case "Text":
                    var str = child.a;
                    return _Utils_Tuple2(A2($elm$core$List$cons, _Utils_eq(context, $mdgriffith$elm_ui$Internal$Model$asEl) ? $mdgriffith$elm_ui$Internal$Model$textElementFill(str) : $mdgriffith$elm_ui$Internal$Model$textElement(str), htmls), existingStyles);
                default:
                    return _Utils_Tuple2(htmls, existingStyles);
            }
        });
        if (children.$ === "Keyed") {
            var keyedChildren = children.a;
            var _v1 = A3($elm$core$List$foldr, gatherKeyed, _Utils_Tuple2(_List_Nil, _List_Nil), keyedChildren);
            var keyed = _v1.a;
            var styles = _v1.b;
            var newStyles = $elm$core$List$isEmpty(styles) ? rendered.styles : _Utils_ap(rendered.styles, styles);
            if (!newStyles.b) return $mdgriffith$elm_ui$Internal$Model$Unstyled(A5($mdgriffith$elm_ui$Internal$Model$finalizeNode, rendered.has, rendered.node, rendered.attributes, $mdgriffith$elm_ui$Internal$Model$Keyed(A3($mdgriffith$elm_ui$Internal$Model$addKeyedChildren, "nearby-element-pls", keyed, rendered.children)), $mdgriffith$elm_ui$Internal$Model$NoStyleSheet));
            else {
                var allStyles = newStyles;
                return $mdgriffith$elm_ui$Internal$Model$Styled({
                    html: A4($mdgriffith$elm_ui$Internal$Model$finalizeNode, rendered.has, rendered.node, rendered.attributes, $mdgriffith$elm_ui$Internal$Model$Keyed(A3($mdgriffith$elm_ui$Internal$Model$addKeyedChildren, "nearby-element-pls", keyed, rendered.children))),
                    styles: allStyles
                });
            }
        } else {
            var unkeyedChildren = children.a;
            var _v3 = A3($elm$core$List$foldr, gather, _Utils_Tuple2(_List_Nil, _List_Nil), unkeyedChildren);
            var unkeyed = _v3.a;
            var styles = _v3.b;
            var newStyles = $elm$core$List$isEmpty(styles) ? rendered.styles : _Utils_ap(rendered.styles, styles);
            if (!newStyles.b) return $mdgriffith$elm_ui$Internal$Model$Unstyled(A5($mdgriffith$elm_ui$Internal$Model$finalizeNode, rendered.has, rendered.node, rendered.attributes, $mdgriffith$elm_ui$Internal$Model$Unkeyed(A2($mdgriffith$elm_ui$Internal$Model$addChildren, unkeyed, rendered.children)), $mdgriffith$elm_ui$Internal$Model$NoStyleSheet));
            else {
                var allStyles = newStyles;
                return $mdgriffith$elm_ui$Internal$Model$Styled({
                    html: A4($mdgriffith$elm_ui$Internal$Model$finalizeNode, rendered.has, rendered.node, rendered.attributes, $mdgriffith$elm_ui$Internal$Model$Unkeyed(A2($mdgriffith$elm_ui$Internal$Model$addChildren, unkeyed, rendered.children))),
                    styles: allStyles
                });
            }
        }
    });
    var $mdgriffith$elm_ui$Internal$Model$Single = F3(function(a, b, c) {
        return {
            $: "Single",
            a: a,
            b: b,
            c: c
        };
    });
    var $mdgriffith$elm_ui$Internal$Model$Transform = function(a) {
        return {
            $: "Transform",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Flag$Field = F2(function(a, b) {
        return {
            $: "Field",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Flag$add = F2(function(myFlag, _v0) {
        var one = _v0.a;
        var two = _v0.b;
        if (myFlag.$ === "Flag") {
            var first = myFlag.a;
            return A2($mdgriffith$elm_ui$Internal$Flag$Field, first | one, two);
        } else {
            var second = myFlag.a;
            return A2($mdgriffith$elm_ui$Internal$Flag$Field, one, second | two);
        }
    });
    var $mdgriffith$elm_ui$Internal$Model$ChildrenBehind = function(a) {
        return {
            $: "ChildrenBehind",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Model$ChildrenBehindAndInFront = F2(function(a, b) {
        return {
            $: "ChildrenBehindAndInFront",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Model$ChildrenInFront = function(a) {
        return {
            $: "ChildrenInFront",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Model$nearbyElement = F2(function(location, elem) {
        return A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$class(function() {
                switch(location.$){
                    case "Above":
                        return A2($elm$core$String$join, " ", _List_fromArray([
                            $mdgriffith$elm_ui$Internal$Style$classes.nearby,
                            $mdgriffith$elm_ui$Internal$Style$classes.single,
                            $mdgriffith$elm_ui$Internal$Style$classes.above
                        ]));
                    case "Below":
                        return A2($elm$core$String$join, " ", _List_fromArray([
                            $mdgriffith$elm_ui$Internal$Style$classes.nearby,
                            $mdgriffith$elm_ui$Internal$Style$classes.single,
                            $mdgriffith$elm_ui$Internal$Style$classes.below
                        ]));
                    case "OnRight":
                        return A2($elm$core$String$join, " ", _List_fromArray([
                            $mdgriffith$elm_ui$Internal$Style$classes.nearby,
                            $mdgriffith$elm_ui$Internal$Style$classes.single,
                            $mdgriffith$elm_ui$Internal$Style$classes.onRight
                        ]));
                    case "OnLeft":
                        return A2($elm$core$String$join, " ", _List_fromArray([
                            $mdgriffith$elm_ui$Internal$Style$classes.nearby,
                            $mdgriffith$elm_ui$Internal$Style$classes.single,
                            $mdgriffith$elm_ui$Internal$Style$classes.onLeft
                        ]));
                    case "InFront":
                        return A2($elm$core$String$join, " ", _List_fromArray([
                            $mdgriffith$elm_ui$Internal$Style$classes.nearby,
                            $mdgriffith$elm_ui$Internal$Style$classes.single,
                            $mdgriffith$elm_ui$Internal$Style$classes.inFront
                        ]));
                    default:
                        return A2($elm$core$String$join, " ", _List_fromArray([
                            $mdgriffith$elm_ui$Internal$Style$classes.nearby,
                            $mdgriffith$elm_ui$Internal$Style$classes.single,
                            $mdgriffith$elm_ui$Internal$Style$classes.behind
                        ]));
                }
            }())
        ]), _List_fromArray([
            function() {
                switch(elem.$){
                    case "Empty":
                        return $elm$virtual_dom$VirtualDom$text("");
                    case "Text":
                        var str = elem.a;
                        return $mdgriffith$elm_ui$Internal$Model$textElement(str);
                    case "Unstyled":
                        var html = elem.a;
                        return html($mdgriffith$elm_ui$Internal$Model$asEl);
                    default:
                        var styled = elem.a;
                        return A2(styled.html, $mdgriffith$elm_ui$Internal$Model$NoStyleSheet, $mdgriffith$elm_ui$Internal$Model$asEl);
                }
            }()
        ]));
    });
    var $mdgriffith$elm_ui$Internal$Model$addNearbyElement = F3(function(location, elem, existing) {
        var nearby = A2($mdgriffith$elm_ui$Internal$Model$nearbyElement, location, elem);
        switch(existing.$){
            case "NoNearbyChildren":
                if (location.$ === "Behind") return $mdgriffith$elm_ui$Internal$Model$ChildrenBehind(_List_fromArray([
                    nearby
                ]));
                else return $mdgriffith$elm_ui$Internal$Model$ChildrenInFront(_List_fromArray([
                    nearby
                ]));
            case "ChildrenBehind":
                var existingBehind = existing.a;
                if (location.$ === "Behind") return $mdgriffith$elm_ui$Internal$Model$ChildrenBehind(A2($elm$core$List$cons, nearby, existingBehind));
                else return A2($mdgriffith$elm_ui$Internal$Model$ChildrenBehindAndInFront, existingBehind, _List_fromArray([
                    nearby
                ]));
            case "ChildrenInFront":
                var existingInFront = existing.a;
                if (location.$ === "Behind") return A2($mdgriffith$elm_ui$Internal$Model$ChildrenBehindAndInFront, _List_fromArray([
                    nearby
                ]), existingInFront);
                else return $mdgriffith$elm_ui$Internal$Model$ChildrenInFront(A2($elm$core$List$cons, nearby, existingInFront));
            default:
                var existingBehind = existing.a;
                var existingInFront = existing.b;
                if (location.$ === "Behind") return A2($mdgriffith$elm_ui$Internal$Model$ChildrenBehindAndInFront, A2($elm$core$List$cons, nearby, existingBehind), existingInFront);
                else return A2($mdgriffith$elm_ui$Internal$Model$ChildrenBehindAndInFront, existingBehind, A2($elm$core$List$cons, nearby, existingInFront));
        }
    });
    var $mdgriffith$elm_ui$Internal$Model$Embedded = F2(function(a, b) {
        return {
            $: "Embedded",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Model$NodeName = function(a) {
        return {
            $: "NodeName",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Model$addNodeName = F2(function(newNode, old) {
        switch(old.$){
            case "Generic":
                return $mdgriffith$elm_ui$Internal$Model$NodeName(newNode);
            case "NodeName":
                var name = old.a;
                return A2($mdgriffith$elm_ui$Internal$Model$Embedded, name, newNode);
            default:
                var x = old.a;
                var y = old.b;
                return A2($mdgriffith$elm_ui$Internal$Model$Embedded, x, y);
        }
    });
    var $mdgriffith$elm_ui$Internal$Model$alignXName = function(align) {
        switch(align.$){
            case "Left":
                return $mdgriffith$elm_ui$Internal$Style$classes.alignedHorizontally + (" " + $mdgriffith$elm_ui$Internal$Style$classes.alignLeft);
            case "Right":
                return $mdgriffith$elm_ui$Internal$Style$classes.alignedHorizontally + (" " + $mdgriffith$elm_ui$Internal$Style$classes.alignRight);
            default:
                return $mdgriffith$elm_ui$Internal$Style$classes.alignedHorizontally + (" " + $mdgriffith$elm_ui$Internal$Style$classes.alignCenterX);
        }
    };
    var $mdgriffith$elm_ui$Internal$Model$alignYName = function(align) {
        switch(align.$){
            case "Top":
                return $mdgriffith$elm_ui$Internal$Style$classes.alignedVertically + (" " + $mdgriffith$elm_ui$Internal$Style$classes.alignTop);
            case "Bottom":
                return $mdgriffith$elm_ui$Internal$Style$classes.alignedVertically + (" " + $mdgriffith$elm_ui$Internal$Style$classes.alignBottom);
            default:
                return $mdgriffith$elm_ui$Internal$Style$classes.alignedVertically + (" " + $mdgriffith$elm_ui$Internal$Style$classes.alignCenterY);
        }
    };
    var $mdgriffith$elm_ui$Internal$Model$FullTransform = F4(function(a, b, c, d) {
        return {
            $: "FullTransform",
            a: a,
            b: b,
            c: c,
            d: d
        };
    });
    var $mdgriffith$elm_ui$Internal$Model$Moved = function(a) {
        return {
            $: "Moved",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Model$composeTransformation = F2(function(transform, component) {
        switch(transform.$){
            case "Untransformed":
                switch(component.$){
                    case "MoveX":
                        var x = component.a;
                        return $mdgriffith$elm_ui$Internal$Model$Moved(_Utils_Tuple3(x, 0, 0));
                    case "MoveY":
                        var y = component.a;
                        return $mdgriffith$elm_ui$Internal$Model$Moved(_Utils_Tuple3(0, y, 0));
                    case "MoveZ":
                        var z = component.a;
                        return $mdgriffith$elm_ui$Internal$Model$Moved(_Utils_Tuple3(0, 0, z));
                    case "MoveXYZ":
                        var xyz = component.a;
                        return $mdgriffith$elm_ui$Internal$Model$Moved(xyz);
                    case "Rotate":
                        var xyz = component.a;
                        var angle = component.b;
                        return A4($mdgriffith$elm_ui$Internal$Model$FullTransform, _Utils_Tuple3(0, 0, 0), _Utils_Tuple3(1, 1, 1), xyz, angle);
                    default:
                        var xyz = component.a;
                        return A4($mdgriffith$elm_ui$Internal$Model$FullTransform, _Utils_Tuple3(0, 0, 0), xyz, _Utils_Tuple3(0, 0, 1), 0);
                }
            case "Moved":
                var moved = transform.a;
                var x = moved.a;
                var y = moved.b;
                var z = moved.c;
                switch(component.$){
                    case "MoveX":
                        var newX = component.a;
                        return $mdgriffith$elm_ui$Internal$Model$Moved(_Utils_Tuple3(newX, y, z));
                    case "MoveY":
                        var newY = component.a;
                        return $mdgriffith$elm_ui$Internal$Model$Moved(_Utils_Tuple3(x, newY, z));
                    case "MoveZ":
                        var newZ = component.a;
                        return $mdgriffith$elm_ui$Internal$Model$Moved(_Utils_Tuple3(x, y, newZ));
                    case "MoveXYZ":
                        var xyz = component.a;
                        return $mdgriffith$elm_ui$Internal$Model$Moved(xyz);
                    case "Rotate":
                        var xyz = component.a;
                        var angle = component.b;
                        return A4($mdgriffith$elm_ui$Internal$Model$FullTransform, moved, _Utils_Tuple3(1, 1, 1), xyz, angle);
                    default:
                        var scale = component.a;
                        return A4($mdgriffith$elm_ui$Internal$Model$FullTransform, moved, scale, _Utils_Tuple3(0, 0, 1), 0);
                }
            default:
                var moved = transform.a;
                var x = moved.a;
                var y = moved.b;
                var z = moved.c;
                var scaled = transform.b;
                var origin = transform.c;
                var angle = transform.d;
                switch(component.$){
                    case "MoveX":
                        var newX = component.a;
                        return A4($mdgriffith$elm_ui$Internal$Model$FullTransform, _Utils_Tuple3(newX, y, z), scaled, origin, angle);
                    case "MoveY":
                        var newY = component.a;
                        return A4($mdgriffith$elm_ui$Internal$Model$FullTransform, _Utils_Tuple3(x, newY, z), scaled, origin, angle);
                    case "MoveZ":
                        var newZ = component.a;
                        return A4($mdgriffith$elm_ui$Internal$Model$FullTransform, _Utils_Tuple3(x, y, newZ), scaled, origin, angle);
                    case "MoveXYZ":
                        var newMove = component.a;
                        return A4($mdgriffith$elm_ui$Internal$Model$FullTransform, newMove, scaled, origin, angle);
                    case "Rotate":
                        var newOrigin = component.a;
                        var newAngle = component.b;
                        return A4($mdgriffith$elm_ui$Internal$Model$FullTransform, moved, scaled, newOrigin, newAngle);
                    default:
                        var newScale = component.a;
                        return A4($mdgriffith$elm_ui$Internal$Model$FullTransform, moved, newScale, origin, angle);
                }
        }
    });
    var $mdgriffith$elm_ui$Internal$Flag$height = $mdgriffith$elm_ui$Internal$Flag$flag(7);
    var $mdgriffith$elm_ui$Internal$Flag$heightContent = $mdgriffith$elm_ui$Internal$Flag$flag(36);
    var $mdgriffith$elm_ui$Internal$Flag$merge = F2(function(_v0, _v1) {
        var one = _v0.a;
        var two = _v0.b;
        var three = _v1.a;
        var four = _v1.b;
        return A2($mdgriffith$elm_ui$Internal$Flag$Field, one | three, two | four);
    });
    var $mdgriffith$elm_ui$Internal$Flag$none = A2($mdgriffith$elm_ui$Internal$Flag$Field, 0, 0);
    var $mdgriffith$elm_ui$Internal$Model$renderHeight = function(h) {
        switch(h.$){
            case "Px":
                var px = h.a;
                var val = $elm$core$String$fromInt(px);
                var name = "height-px-" + val;
                return _Utils_Tuple3($mdgriffith$elm_ui$Internal$Flag$none, $mdgriffith$elm_ui$Internal$Style$classes.heightExact + (" " + name), _List_fromArray([
                    A3($mdgriffith$elm_ui$Internal$Model$Single, name, "height", val + "px")
                ]));
            case "Content":
                return _Utils_Tuple3(A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$heightContent, $mdgriffith$elm_ui$Internal$Flag$none), $mdgriffith$elm_ui$Internal$Style$classes.heightContent, _List_Nil);
            case "Fill":
                var portion = h.a;
                return portion === 1 ? _Utils_Tuple3(A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$heightFill, $mdgriffith$elm_ui$Internal$Flag$none), $mdgriffith$elm_ui$Internal$Style$classes.heightFill, _List_Nil) : _Utils_Tuple3(A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$heightFill, $mdgriffith$elm_ui$Internal$Flag$none), $mdgriffith$elm_ui$Internal$Style$classes.heightFillPortion + (" height-fill-" + $elm$core$String$fromInt(portion)), _List_fromArray([
                    A3($mdgriffith$elm_ui$Internal$Model$Single, $mdgriffith$elm_ui$Internal$Style$classes.any + ("." + ($mdgriffith$elm_ui$Internal$Style$classes.column + (" > " + $mdgriffith$elm_ui$Internal$Style$dot("height-fill-" + $elm$core$String$fromInt(portion))))), "flex-grow", $elm$core$String$fromInt(portion * 100000))
                ]));
            case "Min":
                var minSize = h.a;
                var len = h.b;
                var cls = "min-height-" + $elm$core$String$fromInt(minSize);
                var style = A3($mdgriffith$elm_ui$Internal$Model$Single, cls, "min-height", $elm$core$String$fromInt(minSize) + "px !important");
                var _v1 = $mdgriffith$elm_ui$Internal$Model$renderHeight(len);
                var newFlag = _v1.a;
                var newAttrs = _v1.b;
                var newStyle = _v1.c;
                return _Utils_Tuple3(A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$heightBetween, newFlag), cls + (" " + newAttrs), A2($elm$core$List$cons, style, newStyle));
            default:
                var maxSize = h.a;
                var len = h.b;
                var cls = "max-height-" + $elm$core$String$fromInt(maxSize);
                var style = A3($mdgriffith$elm_ui$Internal$Model$Single, cls, "max-height", $elm$core$String$fromInt(maxSize) + "px");
                var _v2 = $mdgriffith$elm_ui$Internal$Model$renderHeight(len);
                var newFlag = _v2.a;
                var newAttrs = _v2.b;
                var newStyle = _v2.c;
                return _Utils_Tuple3(A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$heightBetween, newFlag), cls + (" " + newAttrs), A2($elm$core$List$cons, style, newStyle));
        }
    };
    var $mdgriffith$elm_ui$Internal$Flag$widthContent = $mdgriffith$elm_ui$Internal$Flag$flag(38);
    var $mdgriffith$elm_ui$Internal$Model$renderWidth = function(w) {
        switch(w.$){
            case "Px":
                var px = w.a;
                return _Utils_Tuple3($mdgriffith$elm_ui$Internal$Flag$none, $mdgriffith$elm_ui$Internal$Style$classes.widthExact + (" width-px-" + $elm$core$String$fromInt(px)), _List_fromArray([
                    A3($mdgriffith$elm_ui$Internal$Model$Single, "width-px-" + $elm$core$String$fromInt(px), "width", $elm$core$String$fromInt(px) + "px")
                ]));
            case "Content":
                return _Utils_Tuple3(A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$widthContent, $mdgriffith$elm_ui$Internal$Flag$none), $mdgriffith$elm_ui$Internal$Style$classes.widthContent, _List_Nil);
            case "Fill":
                var portion = w.a;
                return portion === 1 ? _Utils_Tuple3(A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$widthFill, $mdgriffith$elm_ui$Internal$Flag$none), $mdgriffith$elm_ui$Internal$Style$classes.widthFill, _List_Nil) : _Utils_Tuple3(A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$widthFill, $mdgriffith$elm_ui$Internal$Flag$none), $mdgriffith$elm_ui$Internal$Style$classes.widthFillPortion + (" width-fill-" + $elm$core$String$fromInt(portion)), _List_fromArray([
                    A3($mdgriffith$elm_ui$Internal$Model$Single, $mdgriffith$elm_ui$Internal$Style$classes.any + ("." + ($mdgriffith$elm_ui$Internal$Style$classes.row + (" > " + $mdgriffith$elm_ui$Internal$Style$dot("width-fill-" + $elm$core$String$fromInt(portion))))), "flex-grow", $elm$core$String$fromInt(portion * 100000))
                ]));
            case "Min":
                var minSize = w.a;
                var len = w.b;
                var cls = "min-width-" + $elm$core$String$fromInt(minSize);
                var style = A3($mdgriffith$elm_ui$Internal$Model$Single, cls, "min-width", $elm$core$String$fromInt(minSize) + "px");
                var _v1 = $mdgriffith$elm_ui$Internal$Model$renderWidth(len);
                var newFlag = _v1.a;
                var newAttrs = _v1.b;
                var newStyle = _v1.c;
                return _Utils_Tuple3(A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$widthBetween, newFlag), cls + (" " + newAttrs), A2($elm$core$List$cons, style, newStyle));
            default:
                var maxSize = w.a;
                var len = w.b;
                var cls = "max-width-" + $elm$core$String$fromInt(maxSize);
                var style = A3($mdgriffith$elm_ui$Internal$Model$Single, cls, "max-width", $elm$core$String$fromInt(maxSize) + "px");
                var _v2 = $mdgriffith$elm_ui$Internal$Model$renderWidth(len);
                var newFlag = _v2.a;
                var newAttrs = _v2.b;
                var newStyle = _v2.c;
                return _Utils_Tuple3(A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$widthBetween, newFlag), cls + (" " + newAttrs), A2($elm$core$List$cons, style, newStyle));
        }
    };
    var $mdgriffith$elm_ui$Internal$Flag$borderWidth = $mdgriffith$elm_ui$Internal$Flag$flag(27);
    var $mdgriffith$elm_ui$Internal$Model$skippable = F2(function(flag, style) {
        if (_Utils_eq(flag, $mdgriffith$elm_ui$Internal$Flag$borderWidth)) {
            if (style.$ === "Single") {
                var val = style.c;
                switch(val){
                    case "0px":
                        return true;
                    case "1px":
                        return true;
                    case "2px":
                        return true;
                    case "3px":
                        return true;
                    case "4px":
                        return true;
                    case "5px":
                        return true;
                    case "6px":
                        return true;
                    default:
                        return false;
                }
            } else return false;
        } else switch(style.$){
            case "FontSize":
                var i = style.a;
                return i >= 8 && i <= 32;
            case "PaddingStyle":
                var name = style.a;
                var t = style.b;
                var r = style.c;
                var b = style.d;
                var l = style.e;
                return _Utils_eq(t, b) && _Utils_eq(t, r) && _Utils_eq(t, l) && t >= 0 && t <= 24;
            default:
                return false;
        }
    });
    var $mdgriffith$elm_ui$Internal$Flag$width = $mdgriffith$elm_ui$Internal$Flag$flag(6);
    var $mdgriffith$elm_ui$Internal$Flag$xAlign = $mdgriffith$elm_ui$Internal$Flag$flag(30);
    var $mdgriffith$elm_ui$Internal$Flag$yAlign = $mdgriffith$elm_ui$Internal$Flag$flag(29);
    var $mdgriffith$elm_ui$Internal$Model$gatherAttrRecursive = F8(function(classes, node, has, transform, styles, attrs, children, elementAttrs) {
        gatherAttrRecursive: while(true)if (!elementAttrs.b) {
            var _v1 = $mdgriffith$elm_ui$Internal$Model$transformClass(transform);
            if (_v1.$ === "Nothing") return {
                attributes: A2($elm$core$List$cons, $elm$html$Html$Attributes$class(classes), attrs),
                children: children,
                has: has,
                node: node,
                styles: styles
            };
            else {
                var _class = _v1.a;
                return {
                    attributes: A2($elm$core$List$cons, $elm$html$Html$Attributes$class(classes + (" " + _class)), attrs),
                    children: children,
                    has: has,
                    node: node,
                    styles: A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$Transform(transform), styles)
                };
            }
        } else {
            var attribute = elementAttrs.a;
            var remaining = elementAttrs.b;
            switch(attribute.$){
                case "NoAttribute":
                    var $temp$classes = classes, $temp$node = node, $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                    classes = $temp$classes;
                    node = $temp$node;
                    has = $temp$has;
                    transform = $temp$transform;
                    styles = $temp$styles;
                    attrs = $temp$attrs;
                    children = $temp$children;
                    elementAttrs = $temp$elementAttrs;
                    continue gatherAttrRecursive;
                case "Class":
                    var flag = attribute.a;
                    var exactClassName = attribute.b;
                    if (A2($mdgriffith$elm_ui$Internal$Flag$present, flag, has)) {
                        var $temp$classes = classes, $temp$node = node, $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                        classes = $temp$classes;
                        node = $temp$node;
                        has = $temp$has;
                        transform = $temp$transform;
                        styles = $temp$styles;
                        attrs = $temp$attrs;
                        children = $temp$children;
                        elementAttrs = $temp$elementAttrs;
                        continue gatherAttrRecursive;
                    } else {
                        var $temp$classes = exactClassName + (" " + classes), $temp$node = node, $temp$has = A2($mdgriffith$elm_ui$Internal$Flag$add, flag, has), $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                        classes = $temp$classes;
                        node = $temp$node;
                        has = $temp$has;
                        transform = $temp$transform;
                        styles = $temp$styles;
                        attrs = $temp$attrs;
                        children = $temp$children;
                        elementAttrs = $temp$elementAttrs;
                        continue gatherAttrRecursive;
                    }
                case "Attr":
                    var actualAttribute = attribute.a;
                    var $temp$classes = classes, $temp$node = node, $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = A2($elm$core$List$cons, actualAttribute, attrs), $temp$children = children, $temp$elementAttrs = remaining;
                    classes = $temp$classes;
                    node = $temp$node;
                    has = $temp$has;
                    transform = $temp$transform;
                    styles = $temp$styles;
                    attrs = $temp$attrs;
                    children = $temp$children;
                    elementAttrs = $temp$elementAttrs;
                    continue gatherAttrRecursive;
                case "StyleClass":
                    var flag = attribute.a;
                    var style = attribute.b;
                    if (A2($mdgriffith$elm_ui$Internal$Flag$present, flag, has)) {
                        var $temp$classes = classes, $temp$node = node, $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                        classes = $temp$classes;
                        node = $temp$node;
                        has = $temp$has;
                        transform = $temp$transform;
                        styles = $temp$styles;
                        attrs = $temp$attrs;
                        children = $temp$children;
                        elementAttrs = $temp$elementAttrs;
                        continue gatherAttrRecursive;
                    } else if (A2($mdgriffith$elm_ui$Internal$Model$skippable, flag, style)) {
                        var $temp$classes = $mdgriffith$elm_ui$Internal$Model$getStyleName(style) + (" " + classes), $temp$node = node, $temp$has = A2($mdgriffith$elm_ui$Internal$Flag$add, flag, has), $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                        classes = $temp$classes;
                        node = $temp$node;
                        has = $temp$has;
                        transform = $temp$transform;
                        styles = $temp$styles;
                        attrs = $temp$attrs;
                        children = $temp$children;
                        elementAttrs = $temp$elementAttrs;
                        continue gatherAttrRecursive;
                    } else {
                        var $temp$classes = $mdgriffith$elm_ui$Internal$Model$getStyleName(style) + (" " + classes), $temp$node = node, $temp$has = A2($mdgriffith$elm_ui$Internal$Flag$add, flag, has), $temp$transform = transform, $temp$styles = A2($elm$core$List$cons, style, styles), $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                        classes = $temp$classes;
                        node = $temp$node;
                        has = $temp$has;
                        transform = $temp$transform;
                        styles = $temp$styles;
                        attrs = $temp$attrs;
                        children = $temp$children;
                        elementAttrs = $temp$elementAttrs;
                        continue gatherAttrRecursive;
                    }
                case "TransformComponent":
                    var flag = attribute.a;
                    var component = attribute.b;
                    var $temp$classes = classes, $temp$node = node, $temp$has = A2($mdgriffith$elm_ui$Internal$Flag$add, flag, has), $temp$transform = A2($mdgriffith$elm_ui$Internal$Model$composeTransformation, transform, component), $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                    classes = $temp$classes;
                    node = $temp$node;
                    has = $temp$has;
                    transform = $temp$transform;
                    styles = $temp$styles;
                    attrs = $temp$attrs;
                    children = $temp$children;
                    elementAttrs = $temp$elementAttrs;
                    continue gatherAttrRecursive;
                case "Width":
                    var width = attribute.a;
                    if (A2($mdgriffith$elm_ui$Internal$Flag$present, $mdgriffith$elm_ui$Internal$Flag$width, has)) {
                        var $temp$classes = classes, $temp$node = node, $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                        classes = $temp$classes;
                        node = $temp$node;
                        has = $temp$has;
                        transform = $temp$transform;
                        styles = $temp$styles;
                        attrs = $temp$attrs;
                        children = $temp$children;
                        elementAttrs = $temp$elementAttrs;
                        continue gatherAttrRecursive;
                    } else switch(width.$){
                        case "Px":
                            var px = width.a;
                            var $temp$classes = $mdgriffith$elm_ui$Internal$Style$classes.widthExact + (" width-px-" + $elm$core$String$fromInt(px)) + (" " + classes), $temp$node = node, $temp$has = A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$width, has), $temp$transform = transform, $temp$styles = A2($elm$core$List$cons, A3($mdgriffith$elm_ui$Internal$Model$Single, "width-px-" + $elm$core$String$fromInt(px), "width", $elm$core$String$fromInt(px) + "px"), styles), $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                            classes = $temp$classes;
                            node = $temp$node;
                            has = $temp$has;
                            transform = $temp$transform;
                            styles = $temp$styles;
                            attrs = $temp$attrs;
                            children = $temp$children;
                            elementAttrs = $temp$elementAttrs;
                            continue gatherAttrRecursive;
                        case "Content":
                            var $temp$classes = classes + (" " + $mdgriffith$elm_ui$Internal$Style$classes.widthContent), $temp$node = node, $temp$has = A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$widthContent, A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$width, has)), $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                            classes = $temp$classes;
                            node = $temp$node;
                            has = $temp$has;
                            transform = $temp$transform;
                            styles = $temp$styles;
                            attrs = $temp$attrs;
                            children = $temp$children;
                            elementAttrs = $temp$elementAttrs;
                            continue gatherAttrRecursive;
                        case "Fill":
                            var portion = width.a;
                            if (portion === 1) {
                                var $temp$classes = classes + (" " + $mdgriffith$elm_ui$Internal$Style$classes.widthFill), $temp$node = node, $temp$has = A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$widthFill, A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$width, has)), $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                                classes = $temp$classes;
                                node = $temp$node;
                                has = $temp$has;
                                transform = $temp$transform;
                                styles = $temp$styles;
                                attrs = $temp$attrs;
                                children = $temp$children;
                                elementAttrs = $temp$elementAttrs;
                                continue gatherAttrRecursive;
                            } else {
                                var $temp$classes = classes + (" " + ($mdgriffith$elm_ui$Internal$Style$classes.widthFillPortion + (" width-fill-" + $elm$core$String$fromInt(portion)))), $temp$node = node, $temp$has = A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$widthFill, A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$width, has)), $temp$transform = transform, $temp$styles = A2($elm$core$List$cons, A3($mdgriffith$elm_ui$Internal$Model$Single, $mdgriffith$elm_ui$Internal$Style$classes.any + ("." + ($mdgriffith$elm_ui$Internal$Style$classes.row + (" > " + $mdgriffith$elm_ui$Internal$Style$dot("width-fill-" + $elm$core$String$fromInt(portion))))), "flex-grow", $elm$core$String$fromInt(portion * 100000)), styles), $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                                classes = $temp$classes;
                                node = $temp$node;
                                has = $temp$has;
                                transform = $temp$transform;
                                styles = $temp$styles;
                                attrs = $temp$attrs;
                                children = $temp$children;
                                elementAttrs = $temp$elementAttrs;
                                continue gatherAttrRecursive;
                            }
                        default:
                            var _v4 = $mdgriffith$elm_ui$Internal$Model$renderWidth(width);
                            var addToFlags = _v4.a;
                            var newClass = _v4.b;
                            var newStyles = _v4.c;
                            var $temp$classes = classes + (" " + newClass), $temp$node = node, $temp$has = A2($mdgriffith$elm_ui$Internal$Flag$merge, addToFlags, A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$width, has)), $temp$transform = transform, $temp$styles = _Utils_ap(newStyles, styles), $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                            classes = $temp$classes;
                            node = $temp$node;
                            has = $temp$has;
                            transform = $temp$transform;
                            styles = $temp$styles;
                            attrs = $temp$attrs;
                            children = $temp$children;
                            elementAttrs = $temp$elementAttrs;
                            continue gatherAttrRecursive;
                    }
                case "Height":
                    var height = attribute.a;
                    if (A2($mdgriffith$elm_ui$Internal$Flag$present, $mdgriffith$elm_ui$Internal$Flag$height, has)) {
                        var $temp$classes = classes, $temp$node = node, $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                        classes = $temp$classes;
                        node = $temp$node;
                        has = $temp$has;
                        transform = $temp$transform;
                        styles = $temp$styles;
                        attrs = $temp$attrs;
                        children = $temp$children;
                        elementAttrs = $temp$elementAttrs;
                        continue gatherAttrRecursive;
                    } else switch(height.$){
                        case "Px":
                            var px = height.a;
                            var val = $elm$core$String$fromInt(px) + "px";
                            var name = "height-px-" + val;
                            var $temp$classes = $mdgriffith$elm_ui$Internal$Style$classes.heightExact + (" " + (name + (" " + classes))), $temp$node = node, $temp$has = A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$height, has), $temp$transform = transform, $temp$styles = A2($elm$core$List$cons, A3($mdgriffith$elm_ui$Internal$Model$Single, name, "height ", val), styles), $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                            classes = $temp$classes;
                            node = $temp$node;
                            has = $temp$has;
                            transform = $temp$transform;
                            styles = $temp$styles;
                            attrs = $temp$attrs;
                            children = $temp$children;
                            elementAttrs = $temp$elementAttrs;
                            continue gatherAttrRecursive;
                        case "Content":
                            var $temp$classes = $mdgriffith$elm_ui$Internal$Style$classes.heightContent + (" " + classes), $temp$node = node, $temp$has = A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$heightContent, A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$height, has)), $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                            classes = $temp$classes;
                            node = $temp$node;
                            has = $temp$has;
                            transform = $temp$transform;
                            styles = $temp$styles;
                            attrs = $temp$attrs;
                            children = $temp$children;
                            elementAttrs = $temp$elementAttrs;
                            continue gatherAttrRecursive;
                        case "Fill":
                            var portion = height.a;
                            if (portion === 1) {
                                var $temp$classes = $mdgriffith$elm_ui$Internal$Style$classes.heightFill + (" " + classes), $temp$node = node, $temp$has = A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$heightFill, A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$height, has)), $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                                classes = $temp$classes;
                                node = $temp$node;
                                has = $temp$has;
                                transform = $temp$transform;
                                styles = $temp$styles;
                                attrs = $temp$attrs;
                                children = $temp$children;
                                elementAttrs = $temp$elementAttrs;
                                continue gatherAttrRecursive;
                            } else {
                                var $temp$classes = classes + (" " + ($mdgriffith$elm_ui$Internal$Style$classes.heightFillPortion + (" height-fill-" + $elm$core$String$fromInt(portion)))), $temp$node = node, $temp$has = A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$heightFill, A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$height, has)), $temp$transform = transform, $temp$styles = A2($elm$core$List$cons, A3($mdgriffith$elm_ui$Internal$Model$Single, $mdgriffith$elm_ui$Internal$Style$classes.any + ("." + ($mdgriffith$elm_ui$Internal$Style$classes.column + (" > " + $mdgriffith$elm_ui$Internal$Style$dot("height-fill-" + $elm$core$String$fromInt(portion))))), "flex-grow", $elm$core$String$fromInt(portion * 100000)), styles), $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                                classes = $temp$classes;
                                node = $temp$node;
                                has = $temp$has;
                                transform = $temp$transform;
                                styles = $temp$styles;
                                attrs = $temp$attrs;
                                children = $temp$children;
                                elementAttrs = $temp$elementAttrs;
                                continue gatherAttrRecursive;
                            }
                        default:
                            var _v6 = $mdgriffith$elm_ui$Internal$Model$renderHeight(height);
                            var addToFlags = _v6.a;
                            var newClass = _v6.b;
                            var newStyles = _v6.c;
                            var $temp$classes = classes + (" " + newClass), $temp$node = node, $temp$has = A2($mdgriffith$elm_ui$Internal$Flag$merge, addToFlags, A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$height, has)), $temp$transform = transform, $temp$styles = _Utils_ap(newStyles, styles), $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                            classes = $temp$classes;
                            node = $temp$node;
                            has = $temp$has;
                            transform = $temp$transform;
                            styles = $temp$styles;
                            attrs = $temp$attrs;
                            children = $temp$children;
                            elementAttrs = $temp$elementAttrs;
                            continue gatherAttrRecursive;
                    }
                case "Describe":
                    var description = attribute.a;
                    switch(description.$){
                        case "Main":
                            var $temp$classes = classes, $temp$node = A2($mdgriffith$elm_ui$Internal$Model$addNodeName, "main", node), $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                            classes = $temp$classes;
                            node = $temp$node;
                            has = $temp$has;
                            transform = $temp$transform;
                            styles = $temp$styles;
                            attrs = $temp$attrs;
                            children = $temp$children;
                            elementAttrs = $temp$elementAttrs;
                            continue gatherAttrRecursive;
                        case "Navigation":
                            var $temp$classes = classes, $temp$node = A2($mdgriffith$elm_ui$Internal$Model$addNodeName, "nav", node), $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                            classes = $temp$classes;
                            node = $temp$node;
                            has = $temp$has;
                            transform = $temp$transform;
                            styles = $temp$styles;
                            attrs = $temp$attrs;
                            children = $temp$children;
                            elementAttrs = $temp$elementAttrs;
                            continue gatherAttrRecursive;
                        case "ContentInfo":
                            var $temp$classes = classes, $temp$node = A2($mdgriffith$elm_ui$Internal$Model$addNodeName, "footer", node), $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                            classes = $temp$classes;
                            node = $temp$node;
                            has = $temp$has;
                            transform = $temp$transform;
                            styles = $temp$styles;
                            attrs = $temp$attrs;
                            children = $temp$children;
                            elementAttrs = $temp$elementAttrs;
                            continue gatherAttrRecursive;
                        case "Complementary":
                            var $temp$classes = classes, $temp$node = A2($mdgriffith$elm_ui$Internal$Model$addNodeName, "aside", node), $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                            classes = $temp$classes;
                            node = $temp$node;
                            has = $temp$has;
                            transform = $temp$transform;
                            styles = $temp$styles;
                            attrs = $temp$attrs;
                            children = $temp$children;
                            elementAttrs = $temp$elementAttrs;
                            continue gatherAttrRecursive;
                        case "Heading":
                            var i = description.a;
                            if (i <= 1) {
                                var $temp$classes = classes, $temp$node = A2($mdgriffith$elm_ui$Internal$Model$addNodeName, "h1", node), $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                                classes = $temp$classes;
                                node = $temp$node;
                                has = $temp$has;
                                transform = $temp$transform;
                                styles = $temp$styles;
                                attrs = $temp$attrs;
                                children = $temp$children;
                                elementAttrs = $temp$elementAttrs;
                                continue gatherAttrRecursive;
                            } else if (i < 7) {
                                var $temp$classes = classes, $temp$node = A2($mdgriffith$elm_ui$Internal$Model$addNodeName, "h" + $elm$core$String$fromInt(i), node), $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                                classes = $temp$classes;
                                node = $temp$node;
                                has = $temp$has;
                                transform = $temp$transform;
                                styles = $temp$styles;
                                attrs = $temp$attrs;
                                children = $temp$children;
                                elementAttrs = $temp$elementAttrs;
                                continue gatherAttrRecursive;
                            } else {
                                var $temp$classes = classes, $temp$node = A2($mdgriffith$elm_ui$Internal$Model$addNodeName, "h6", node), $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                                classes = $temp$classes;
                                node = $temp$node;
                                has = $temp$has;
                                transform = $temp$transform;
                                styles = $temp$styles;
                                attrs = $temp$attrs;
                                children = $temp$children;
                                elementAttrs = $temp$elementAttrs;
                                continue gatherAttrRecursive;
                            }
                        case "Paragraph":
                            var $temp$classes = classes, $temp$node = node, $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                            classes = $temp$classes;
                            node = $temp$node;
                            has = $temp$has;
                            transform = $temp$transform;
                            styles = $temp$styles;
                            attrs = $temp$attrs;
                            children = $temp$children;
                            elementAttrs = $temp$elementAttrs;
                            continue gatherAttrRecursive;
                        case "Button":
                            var $temp$classes = classes, $temp$node = node, $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = A2($elm$core$List$cons, A2($elm$virtual_dom$VirtualDom$attribute, "role", "button"), attrs), $temp$children = children, $temp$elementAttrs = remaining;
                            classes = $temp$classes;
                            node = $temp$node;
                            has = $temp$has;
                            transform = $temp$transform;
                            styles = $temp$styles;
                            attrs = $temp$attrs;
                            children = $temp$children;
                            elementAttrs = $temp$elementAttrs;
                            continue gatherAttrRecursive;
                        case "Label":
                            var label = description.a;
                            var $temp$classes = classes, $temp$node = node, $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = A2($elm$core$List$cons, A2($elm$virtual_dom$VirtualDom$attribute, "aria-label", label), attrs), $temp$children = children, $temp$elementAttrs = remaining;
                            classes = $temp$classes;
                            node = $temp$node;
                            has = $temp$has;
                            transform = $temp$transform;
                            styles = $temp$styles;
                            attrs = $temp$attrs;
                            children = $temp$children;
                            elementAttrs = $temp$elementAttrs;
                            continue gatherAttrRecursive;
                        case "LivePolite":
                            var $temp$classes = classes, $temp$node = node, $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = A2($elm$core$List$cons, A2($elm$virtual_dom$VirtualDom$attribute, "aria-live", "polite"), attrs), $temp$children = children, $temp$elementAttrs = remaining;
                            classes = $temp$classes;
                            node = $temp$node;
                            has = $temp$has;
                            transform = $temp$transform;
                            styles = $temp$styles;
                            attrs = $temp$attrs;
                            children = $temp$children;
                            elementAttrs = $temp$elementAttrs;
                            continue gatherAttrRecursive;
                        default:
                            var $temp$classes = classes, $temp$node = node, $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = A2($elm$core$List$cons, A2($elm$virtual_dom$VirtualDom$attribute, "aria-live", "assertive"), attrs), $temp$children = children, $temp$elementAttrs = remaining;
                            classes = $temp$classes;
                            node = $temp$node;
                            has = $temp$has;
                            transform = $temp$transform;
                            styles = $temp$styles;
                            attrs = $temp$attrs;
                            children = $temp$children;
                            elementAttrs = $temp$elementAttrs;
                            continue gatherAttrRecursive;
                    }
                case "Nearby":
                    var location = attribute.a;
                    var elem = attribute.b;
                    var newStyles = function() {
                        switch(elem.$){
                            case "Empty":
                                return styles;
                            case "Text":
                                var str = elem.a;
                                return styles;
                            case "Unstyled":
                                var html = elem.a;
                                return styles;
                            default:
                                var styled = elem.a;
                                return _Utils_ap(styles, styled.styles);
                        }
                    }();
                    var $temp$classes = classes, $temp$node = node, $temp$has = has, $temp$transform = transform, $temp$styles = newStyles, $temp$attrs = attrs, $temp$children = A3($mdgriffith$elm_ui$Internal$Model$addNearbyElement, location, elem, children), $temp$elementAttrs = remaining;
                    classes = $temp$classes;
                    node = $temp$node;
                    has = $temp$has;
                    transform = $temp$transform;
                    styles = $temp$styles;
                    attrs = $temp$attrs;
                    children = $temp$children;
                    elementAttrs = $temp$elementAttrs;
                    continue gatherAttrRecursive;
                case "AlignX":
                    var x = attribute.a;
                    if (A2($mdgriffith$elm_ui$Internal$Flag$present, $mdgriffith$elm_ui$Internal$Flag$xAlign, has)) {
                        var $temp$classes = classes, $temp$node = node, $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                        classes = $temp$classes;
                        node = $temp$node;
                        has = $temp$has;
                        transform = $temp$transform;
                        styles = $temp$styles;
                        attrs = $temp$attrs;
                        children = $temp$children;
                        elementAttrs = $temp$elementAttrs;
                        continue gatherAttrRecursive;
                    } else {
                        var $temp$classes = $mdgriffith$elm_ui$Internal$Model$alignXName(x) + (" " + classes), $temp$node = node, $temp$has = function(flags) {
                            switch(x.$){
                                case "CenterX":
                                    return A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$centerX, flags);
                                case "Right":
                                    return A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$alignRight, flags);
                                default:
                                    return flags;
                            }
                        }(A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$xAlign, has)), $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                        classes = $temp$classes;
                        node = $temp$node;
                        has = $temp$has;
                        transform = $temp$transform;
                        styles = $temp$styles;
                        attrs = $temp$attrs;
                        children = $temp$children;
                        elementAttrs = $temp$elementAttrs;
                        continue gatherAttrRecursive;
                    }
                default:
                    var y = attribute.a;
                    if (A2($mdgriffith$elm_ui$Internal$Flag$present, $mdgriffith$elm_ui$Internal$Flag$yAlign, has)) {
                        var $temp$classes = classes, $temp$node = node, $temp$has = has, $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                        classes = $temp$classes;
                        node = $temp$node;
                        has = $temp$has;
                        transform = $temp$transform;
                        styles = $temp$styles;
                        attrs = $temp$attrs;
                        children = $temp$children;
                        elementAttrs = $temp$elementAttrs;
                        continue gatherAttrRecursive;
                    } else {
                        var $temp$classes = $mdgriffith$elm_ui$Internal$Model$alignYName(y) + (" " + classes), $temp$node = node, $temp$has = function(flags) {
                            switch(y.$){
                                case "CenterY":
                                    return A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$centerY, flags);
                                case "Bottom":
                                    return A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$alignBottom, flags);
                                default:
                                    return flags;
                            }
                        }(A2($mdgriffith$elm_ui$Internal$Flag$add, $mdgriffith$elm_ui$Internal$Flag$yAlign, has)), $temp$transform = transform, $temp$styles = styles, $temp$attrs = attrs, $temp$children = children, $temp$elementAttrs = remaining;
                        classes = $temp$classes;
                        node = $temp$node;
                        has = $temp$has;
                        transform = $temp$transform;
                        styles = $temp$styles;
                        attrs = $temp$attrs;
                        children = $temp$children;
                        elementAttrs = $temp$elementAttrs;
                        continue gatherAttrRecursive;
                    }
            }
        }
    });
    var $mdgriffith$elm_ui$Internal$Model$Untransformed = {
        $: "Untransformed"
    };
    var $mdgriffith$elm_ui$Internal$Model$untransformed = $mdgriffith$elm_ui$Internal$Model$Untransformed;
    var $mdgriffith$elm_ui$Internal$Model$element = F4(function(context, node, attributes, children) {
        return A3($mdgriffith$elm_ui$Internal$Model$createElement, context, children, A8($mdgriffith$elm_ui$Internal$Model$gatherAttrRecursive, $mdgriffith$elm_ui$Internal$Model$contextClasses(context), node, $mdgriffith$elm_ui$Internal$Flag$none, $mdgriffith$elm_ui$Internal$Model$untransformed, _List_Nil, _List_Nil, $mdgriffith$elm_ui$Internal$Model$NoNearbyChildren, $elm$core$List$reverse(attributes)));
    });
    var $mdgriffith$elm_ui$Internal$Model$Height = function(a) {
        return {
            $: "Height",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Element$height = $mdgriffith$elm_ui$Internal$Model$Height;
    var $mdgriffith$elm_ui$Internal$Model$Attr = function(a) {
        return {
            $: "Attr",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Model$htmlClass = function(cls) {
        return $mdgriffith$elm_ui$Internal$Model$Attr($elm$html$Html$Attributes$class(cls));
    };
    var $mdgriffith$elm_ui$Internal$Model$Content = {
        $: "Content"
    };
    var $mdgriffith$elm_ui$Element$shrink = $mdgriffith$elm_ui$Internal$Model$Content;
    var $mdgriffith$elm_ui$Internal$Model$Width = function(a) {
        return {
            $: "Width",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Element$width = $mdgriffith$elm_ui$Internal$Model$Width;
    var $mdgriffith$elm_ui$Element$column = F2(function(attrs, children) {
        return A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asColumn, $mdgriffith$elm_ui$Internal$Model$div, A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$htmlClass($mdgriffith$elm_ui$Internal$Style$classes.contentTop + (" " + $mdgriffith$elm_ui$Internal$Style$classes.contentLeft)), A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$height($mdgriffith$elm_ui$Element$shrink), A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$shrink), attrs))), $mdgriffith$elm_ui$Internal$Model$Unkeyed(children));
    });
    var $author$project$Pages$Hardware$CancelFetchedMember = {
        $: "CancelFetchedMember"
    };
    var $author$project$Pages$Hardware$DeleteAccount = {
        $: "DeleteAccount"
    };
    var $mdgriffith$elm_ui$Internal$Model$AlignX = function(a) {
        return {
            $: "AlignX",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Model$CenterX = {
        $: "CenterX"
    };
    var $mdgriffith$elm_ui$Element$centerX = $mdgriffith$elm_ui$Internal$Model$AlignX($mdgriffith$elm_ui$Internal$Model$CenterX);
    var $mdgriffith$elm_ui$Internal$Model$AlignY = function(a) {
        return {
            $: "AlignY",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Model$CenterY = {
        $: "CenterY"
    };
    var $mdgriffith$elm_ui$Element$centerY = $mdgriffith$elm_ui$Internal$Model$AlignY($mdgriffith$elm_ui$Internal$Model$CenterY);
    var $mdgriffith$elm_ui$Internal$Model$Colored = F3(function(a, b, c) {
        return {
            $: "Colored",
            a: a,
            b: b,
            c: c
        };
    });
    var $mdgriffith$elm_ui$Internal$Model$StyleClass = F2(function(a, b) {
        return {
            $: "StyleClass",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Flag$bgColor = $mdgriffith$elm_ui$Internal$Flag$flag(8);
    var $mdgriffith$elm_ui$Internal$Model$formatColorClass = function(_v0) {
        var red = _v0.a;
        var green = _v0.b;
        var blue = _v0.c;
        var alpha = _v0.d;
        return $mdgriffith$elm_ui$Internal$Model$floatClass(red) + ("-" + ($mdgriffith$elm_ui$Internal$Model$floatClass(green) + ("-" + ($mdgriffith$elm_ui$Internal$Model$floatClass(blue) + ("-" + $mdgriffith$elm_ui$Internal$Model$floatClass(alpha))))));
    };
    var $mdgriffith$elm_ui$Element$Background$color = function(clr) {
        return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$bgColor, A3($mdgriffith$elm_ui$Internal$Model$Colored, "bg-" + $mdgriffith$elm_ui$Internal$Model$formatColorClass(clr), "background-color", clr));
    };
    var $mdgriffith$elm_ui$Internal$Model$Fill = function(a) {
        return {
            $: "Fill",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Element$fill = $mdgriffith$elm_ui$Internal$Model$Fill(1);
    var $mdgriffith$elm_ui$Internal$Model$Describe = function(a) {
        return {
            $: "Describe",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Model$Main = {
        $: "Main"
    };
    var $mdgriffith$elm_ui$Element$Region$mainContent = $mdgriffith$elm_ui$Internal$Model$Describe($mdgriffith$elm_ui$Internal$Model$Main);
    var $mdgriffith$elm_ui$Internal$Model$Max = F2(function(a, b) {
        return {
            $: "Max",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Element$maximum = F2(function(i, l) {
        return A2($mdgriffith$elm_ui$Internal$Model$Max, i, l);
    });
    var $mdgriffith$elm_ui$Internal$Model$PaddingStyle = F5(function(a, b, c, d, e) {
        return {
            $: "PaddingStyle",
            a: a,
            b: b,
            c: c,
            d: d,
            e: e
        };
    });
    var $mdgriffith$elm_ui$Internal$Flag$padding = $mdgriffith$elm_ui$Internal$Flag$flag(2);
    var $mdgriffith$elm_ui$Element$padding = function(x) {
        var f = x;
        return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$padding, A5($mdgriffith$elm_ui$Internal$Model$PaddingStyle, "p-" + $elm$core$String$fromInt(x), f, f, f, f));
    };
    var $mdgriffith$elm_ui$Internal$Model$Rgba = F4(function(a, b, c, d) {
        return {
            $: "Rgba",
            a: a,
            b: b,
            c: c,
            d: d
        };
    });
    var $mdgriffith$elm_ui$Element$rgb255 = F3(function(red, green, blue) {
        return A4($mdgriffith$elm_ui$Internal$Model$Rgba, red / 255, green / 255, blue / 255, 1);
    });
    var $Orasund$elm_ui_framework$Framework$container = _List_fromArray([
        $mdgriffith$elm_ui$Element$centerX,
        $mdgriffith$elm_ui$Element$centerY,
        $mdgriffith$elm_ui$Element$width(A2($mdgriffith$elm_ui$Element$maximum, 1200, $mdgriffith$elm_ui$Element$fill)),
        $mdgriffith$elm_ui$Element$padding(20),
        $mdgriffith$elm_ui$Element$Region$mainContent,
        $mdgriffith$elm_ui$Element$Background$color(A3($mdgriffith$elm_ui$Element$rgb255, 255, 255, 255))
    ]);
    var $mdgriffith$elm_ui$Element$el = F2(function(attrs, child) {
        return A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asEl, $mdgriffith$elm_ui$Internal$Model$div, A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$shrink), A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$height($mdgriffith$elm_ui$Element$shrink), attrs)), $mdgriffith$elm_ui$Internal$Model$Unkeyed(_List_fromArray([
            child
        ])));
    });
    var $mdgriffith$elm_ui$Internal$Model$Left = {
        $: "Left"
    };
    var $mdgriffith$elm_ui$Element$alignLeft = $mdgriffith$elm_ui$Internal$Model$AlignX($mdgriffith$elm_ui$Internal$Model$Left);
    var $mdgriffith$elm_ui$Internal$Model$Class = F2(function(a, b) {
        return {
            $: "Class",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Flag$fontWeight = $mdgriffith$elm_ui$Internal$Flag$flag(13);
    var $mdgriffith$elm_ui$Element$Font$bold = A2($mdgriffith$elm_ui$Internal$Model$Class, $mdgriffith$elm_ui$Internal$Flag$fontWeight, $mdgriffith$elm_ui$Internal$Style$classes.bold);
    var $elm$core$Basics$clamp = F3(function(low, high, number) {
        return _Utils_cmp(number, low) < 0 ? low : _Utils_cmp(number, high) > 0 ? high : number;
    });
    var $mdgriffith$elm_ui$Internal$Model$Heading = function(a) {
        return {
            $: "Heading",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Element$Region$heading = A2($elm$core$Basics$composeL, $mdgriffith$elm_ui$Internal$Model$Describe, $mdgriffith$elm_ui$Internal$Model$Heading);
    var $mdgriffith$elm_ui$Internal$Model$paddingName = F4(function(top, right, bottom, left) {
        return "pad-" + ($elm$core$String$fromInt(top) + ("-" + ($elm$core$String$fromInt(right) + ("-" + ($elm$core$String$fromInt(bottom) + ("-" + $elm$core$String$fromInt(left)))))));
    });
    var $mdgriffith$elm_ui$Element$paddingEach = function(_v0) {
        var top = _v0.top;
        var right = _v0.right;
        var bottom = _v0.bottom;
        var left = _v0.left;
        if (_Utils_eq(top, right) && _Utils_eq(top, bottom) && _Utils_eq(top, left)) {
            var topFloat = top;
            return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$padding, A5($mdgriffith$elm_ui$Internal$Model$PaddingStyle, "p-" + $elm$core$String$fromInt(top), topFloat, topFloat, topFloat, topFloat));
        } else return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$padding, A5($mdgriffith$elm_ui$Internal$Model$PaddingStyle, A4($mdgriffith$elm_ui$Internal$Model$paddingName, top, right, bottom, left), top, right, bottom, left));
    };
    var $mdgriffith$elm_ui$Internal$Model$FontSize = function(a) {
        return {
            $: "FontSize",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Flag$fontSize = $mdgriffith$elm_ui$Internal$Flag$flag(4);
    var $mdgriffith$elm_ui$Element$Font$size = function(i) {
        return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$fontSize, $mdgriffith$elm_ui$Internal$Model$FontSize(i));
    };
    var $Orasund$elm_ui_framework$Framework$Heading$h = function(inputLevel) {
        var level = A3($elm$core$Basics$clamp, 1, 6, inputLevel);
        var size = level === 6 ? 14 : 32 - (level - 1) * 4;
        return _List_fromArray([
            $mdgriffith$elm_ui$Element$Region$heading(level),
            $mdgriffith$elm_ui$Element$Font$size(size),
            $mdgriffith$elm_ui$Element$paddingEach({
                bottom: 2,
                left: 0,
                right: 0,
                top: 2
            }),
            $mdgriffith$elm_ui$Element$alignLeft,
            $mdgriffith$elm_ui$Element$Font$bold
        ]);
    };
    var $Orasund$elm_ui_framework$Framework$Heading$h5 = $Orasund$elm_ui_framework$Framework$Heading$h(5);
    var $mdgriffith$elm_ui$Internal$Model$Button = {
        $: "Button"
    };
    var $elm$json$Json$Encode$bool = _Json_wrap;
    var $elm$html$Html$Attributes$boolProperty = F2(function(key, bool) {
        return A2(_VirtualDom_property, key, $elm$json$Json$Encode$bool(bool));
    });
    var $elm$html$Html$Attributes$disabled = $elm$html$Html$Attributes$boolProperty("disabled");
    var $mdgriffith$elm_ui$Element$Input$enter = "Enter";
    var $mdgriffith$elm_ui$Internal$Model$NoAttribute = {
        $: "NoAttribute"
    };
    var $mdgriffith$elm_ui$Element$Input$hasFocusStyle = function(attr) {
        if (attr.$ === "StyleClass" && attr.b.$ === "PseudoSelector" && attr.b.a.$ === "Focus") {
            var _v1 = attr.b;
            var _v2 = _v1.a;
            return true;
        } else return false;
    };
    var $mdgriffith$elm_ui$Element$Input$focusDefault = function(attrs) {
        return A2($elm$core$List$any, $mdgriffith$elm_ui$Element$Input$hasFocusStyle, attrs) ? $mdgriffith$elm_ui$Internal$Model$NoAttribute : $mdgriffith$elm_ui$Internal$Model$htmlClass("focusable");
    };
    var $mdgriffith$elm_ui$Element$Events$onClick = A2($elm$core$Basics$composeL, $mdgriffith$elm_ui$Internal$Model$Attr, $elm$html$Html$Events$onClick);
    var $elm$virtual_dom$VirtualDom$MayPreventDefault = function(a) {
        return {
            $: "MayPreventDefault",
            a: a
        };
    };
    var $elm$html$Html$Events$preventDefaultOn = F2(function(event, decoder) {
        return A2($elm$virtual_dom$VirtualDom$on, event, $elm$virtual_dom$VirtualDom$MayPreventDefault(decoder));
    });
    var $mdgriffith$elm_ui$Element$Input$onKeyLookup = function(lookup) {
        var decode = function(code) {
            var _v0 = lookup(code);
            if (_v0.$ === "Nothing") return $elm$json$Json$Decode$fail("No key matched");
            else {
                var msg = _v0.a;
                return $elm$json$Json$Decode$succeed(msg);
            }
        };
        var isKey = A2($elm$json$Json$Decode$andThen, decode, A2($elm$json$Json$Decode$field, "key", $elm$json$Json$Decode$string));
        return $mdgriffith$elm_ui$Internal$Model$Attr(A2($elm$html$Html$Events$preventDefaultOn, "keydown", A2($elm$json$Json$Decode$map, function(fired) {
            return _Utils_Tuple2(fired, true);
        }, isKey)));
    };
    var $mdgriffith$elm_ui$Internal$Flag$cursor = $mdgriffith$elm_ui$Internal$Flag$flag(21);
    var $mdgriffith$elm_ui$Element$pointer = A2($mdgriffith$elm_ui$Internal$Model$Class, $mdgriffith$elm_ui$Internal$Flag$cursor, $mdgriffith$elm_ui$Internal$Style$classes.cursorPointer);
    var $mdgriffith$elm_ui$Element$Input$space = " ";
    var $elm$html$Html$Attributes$tabindex = function(n) {
        return A2(_VirtualDom_attribute, "tabIndex", $elm$core$String$fromInt(n));
    };
    var $mdgriffith$elm_ui$Element$Input$button = F2(function(attrs, _v0) {
        var onPress = _v0.onPress;
        var label = _v0.label;
        return A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asEl, $mdgriffith$elm_ui$Internal$Model$div, A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$shrink), A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$height($mdgriffith$elm_ui$Element$shrink), A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$htmlClass($mdgriffith$elm_ui$Internal$Style$classes.contentCenterX + (" " + ($mdgriffith$elm_ui$Internal$Style$classes.contentCenterY + (" " + ($mdgriffith$elm_ui$Internal$Style$classes.seButton + (" " + $mdgriffith$elm_ui$Internal$Style$classes.noTextSelection)))))), A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$pointer, A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$Input$focusDefault(attrs), A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$Describe($mdgriffith$elm_ui$Internal$Model$Button), A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$Attr($elm$html$Html$Attributes$tabindex(0)), function() {
            if (onPress.$ === "Nothing") return A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$Attr($elm$html$Html$Attributes$disabled(true)), attrs);
            else {
                var msg = onPress.a;
                return A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$Events$onClick(msg), A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$Input$onKeyLookup(function(code) {
                    return _Utils_eq(code, $mdgriffith$elm_ui$Element$Input$enter) ? $elm$core$Maybe$Just(msg) : _Utils_eq(code, $mdgriffith$elm_ui$Element$Input$space) ? $elm$core$Maybe$Just(msg) : $elm$core$Maybe$Nothing;
                }), attrs));
            }
        }()))))))), $mdgriffith$elm_ui$Internal$Model$Unkeyed(_List_fromArray([
            label
        ])));
    });
    var $mdgriffith$elm_ui$Internal$Flag$fontAlignment = $mdgriffith$elm_ui$Internal$Flag$flag(12);
    var $mdgriffith$elm_ui$Element$Font$center = A2($mdgriffith$elm_ui$Internal$Model$Class, $mdgriffith$elm_ui$Internal$Flag$fontAlignment, $mdgriffith$elm_ui$Internal$Style$classes.textCenter);
    var $mdgriffith$elm_ui$Internal$Flag$borderColor = $mdgriffith$elm_ui$Internal$Flag$flag(28);
    var $mdgriffith$elm_ui$Element$Border$color = function(clr) {
        return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$borderColor, A3($mdgriffith$elm_ui$Internal$Model$Colored, "bc-" + $mdgriffith$elm_ui$Internal$Model$formatColorClass(clr), "border-color", clr));
    };
    var $Orasund$elm_ui_framework$Framework$Color$grey = A3($mdgriffith$elm_ui$Element$rgb255, 122, 122, 122);
    var $mdgriffith$elm_ui$Internal$Model$Hover = {
        $: "Hover"
    };
    var $mdgriffith$elm_ui$Internal$Model$PseudoSelector = F2(function(a, b) {
        return {
            $: "PseudoSelector",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Flag$hover = $mdgriffith$elm_ui$Internal$Flag$flag(33);
    var $mdgriffith$elm_ui$Internal$Model$Nearby = F2(function(a, b) {
        return {
            $: "Nearby",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Model$TransformComponent = F2(function(a, b) {
        return {
            $: "TransformComponent",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Model$Empty = {
        $: "Empty"
    };
    var $mdgriffith$elm_ui$Internal$Model$Text = function(a) {
        return {
            $: "Text",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Model$map = F2(function(fn, el) {
        switch(el.$){
            case "Styled":
                var styled = el.a;
                return $mdgriffith$elm_ui$Internal$Model$Styled({
                    html: F2(function(add, context) {
                        return A2($elm$virtual_dom$VirtualDom$map, fn, A2(styled.html, add, context));
                    }),
                    styles: styled.styles
                });
            case "Unstyled":
                var html = el.a;
                return $mdgriffith$elm_ui$Internal$Model$Unstyled(A2($elm$core$Basics$composeL, $elm$virtual_dom$VirtualDom$map(fn), html));
            case "Text":
                var str = el.a;
                return $mdgriffith$elm_ui$Internal$Model$Text(str);
            default:
                return $mdgriffith$elm_ui$Internal$Model$Empty;
        }
    });
    var $elm$virtual_dom$VirtualDom$mapAttribute = _VirtualDom_mapAttribute;
    var $mdgriffith$elm_ui$Internal$Model$mapAttrFromStyle = F2(function(fn, attr) {
        switch(attr.$){
            case "NoAttribute":
                return $mdgriffith$elm_ui$Internal$Model$NoAttribute;
            case "Describe":
                var description = attr.a;
                return $mdgriffith$elm_ui$Internal$Model$Describe(description);
            case "AlignX":
                var x = attr.a;
                return $mdgriffith$elm_ui$Internal$Model$AlignX(x);
            case "AlignY":
                var y = attr.a;
                return $mdgriffith$elm_ui$Internal$Model$AlignY(y);
            case "Width":
                var x = attr.a;
                return $mdgriffith$elm_ui$Internal$Model$Width(x);
            case "Height":
                var x = attr.a;
                return $mdgriffith$elm_ui$Internal$Model$Height(x);
            case "Class":
                var x = attr.a;
                var y = attr.b;
                return A2($mdgriffith$elm_ui$Internal$Model$Class, x, y);
            case "StyleClass":
                var flag = attr.a;
                var style = attr.b;
                return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, flag, style);
            case "Nearby":
                var location = attr.a;
                var elem = attr.b;
                return A2($mdgriffith$elm_ui$Internal$Model$Nearby, location, A2($mdgriffith$elm_ui$Internal$Model$map, fn, elem));
            case "Attr":
                var htmlAttr = attr.a;
                return $mdgriffith$elm_ui$Internal$Model$Attr(A2($elm$virtual_dom$VirtualDom$mapAttribute, fn, htmlAttr));
            default:
                var fl = attr.a;
                var trans = attr.b;
                return A2($mdgriffith$elm_ui$Internal$Model$TransformComponent, fl, trans);
        }
    });
    var $mdgriffith$elm_ui$Internal$Model$removeNever = function(style) {
        return A2($mdgriffith$elm_ui$Internal$Model$mapAttrFromStyle, $elm$core$Basics$never, style);
    };
    var $mdgriffith$elm_ui$Internal$Model$unwrapDecsHelper = F2(function(attr, _v0) {
        var styles = _v0.a;
        var trans = _v0.b;
        var _v1 = $mdgriffith$elm_ui$Internal$Model$removeNever(attr);
        switch(_v1.$){
            case "StyleClass":
                var style = _v1.b;
                return _Utils_Tuple2(A2($elm$core$List$cons, style, styles), trans);
            case "TransformComponent":
                var flag = _v1.a;
                var component = _v1.b;
                return _Utils_Tuple2(styles, A2($mdgriffith$elm_ui$Internal$Model$composeTransformation, trans, component));
            default:
                return _Utils_Tuple2(styles, trans);
        }
    });
    var $mdgriffith$elm_ui$Internal$Model$unwrapDecorations = function(attrs) {
        var _v0 = A3($elm$core$List$foldl, $mdgriffith$elm_ui$Internal$Model$unwrapDecsHelper, _Utils_Tuple2(_List_Nil, $mdgriffith$elm_ui$Internal$Model$Untransformed), attrs);
        var styles = _v0.a;
        var transform = _v0.b;
        return A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$Transform(transform), styles);
    };
    var $mdgriffith$elm_ui$Element$mouseOver = function(decs) {
        return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$hover, A2($mdgriffith$elm_ui$Internal$Model$PseudoSelector, $mdgriffith$elm_ui$Internal$Model$Hover, $mdgriffith$elm_ui$Internal$Model$unwrapDecorations(decs)));
    };
    var $mdgriffith$elm_ui$Element$paddingXY = F2(function(x, y) {
        if (_Utils_eq(x, y)) {
            var f = x;
            return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$padding, A5($mdgriffith$elm_ui$Internal$Model$PaddingStyle, "p-" + $elm$core$String$fromInt(x), f, f, f, f));
        } else {
            var yFloat = y;
            var xFloat = x;
            return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$padding, A5($mdgriffith$elm_ui$Internal$Model$PaddingStyle, "p-" + ($elm$core$String$fromInt(x) + ("-" + $elm$core$String$fromInt(y))), yFloat, xFloat, yFloat, xFloat));
        }
    });
    var $mdgriffith$elm_ui$Internal$Model$Top = {
        $: "Top"
    };
    var $mdgriffith$elm_ui$Element$alignTop = $mdgriffith$elm_ui$Internal$Model$AlignY($mdgriffith$elm_ui$Internal$Model$Top);
    var $Orasund$elm_ui_framework$Framework$Color$lighterGrey = A3($mdgriffith$elm_ui$Element$rgb255, 245, 245, 245);
    var $Orasund$elm_ui_framework$Framework$Color$light = _List_fromArray([
        $mdgriffith$elm_ui$Element$Background$color($Orasund$elm_ui_framework$Framework$Color$lighterGrey),
        $mdgriffith$elm_ui$Element$Border$color($Orasund$elm_ui_framework$Framework$Color$lighterGrey)
    ]);
    var $Orasund$elm_ui_framework$Framework$Color$lightGrey = A3($mdgriffith$elm_ui$Element$rgb255, 219, 219, 219);
    var $mdgriffith$elm_ui$Element$rgba = $mdgriffith$elm_ui$Internal$Model$Rgba;
    var $mdgriffith$elm_ui$Internal$Model$boxShadowClass = function(shadow) {
        return $elm$core$String$concat(_List_fromArray([
            shadow.inset ? "box-inset" : "box-",
            $mdgriffith$elm_ui$Internal$Model$floatClass(shadow.offset.a) + "px",
            $mdgriffith$elm_ui$Internal$Model$floatClass(shadow.offset.b) + "px",
            $mdgriffith$elm_ui$Internal$Model$floatClass(shadow.blur) + "px",
            $mdgriffith$elm_ui$Internal$Model$floatClass(shadow.size) + "px",
            $mdgriffith$elm_ui$Internal$Model$formatColorClass(shadow.color)
        ]));
    };
    var $mdgriffith$elm_ui$Internal$Flag$shadows = $mdgriffith$elm_ui$Internal$Flag$flag(19);
    var $mdgriffith$elm_ui$Element$Border$shadow = function(almostShade) {
        var shade = {
            blur: almostShade.blur,
            color: almostShade.color,
            inset: false,
            offset: almostShade.offset,
            size: almostShade.size
        };
        return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$shadows, A3($mdgriffith$elm_ui$Internal$Model$Single, $mdgriffith$elm_ui$Internal$Model$boxShadowClass(shade), "box-shadow", $mdgriffith$elm_ui$Internal$Model$formatBoxShadow(shade)));
    };
    var $mdgriffith$elm_ui$Internal$Flag$borderRound = $mdgriffith$elm_ui$Internal$Flag$flag(17);
    var $mdgriffith$elm_ui$Element$Border$rounded = function(radius) {
        return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$borderRound, A3($mdgriffith$elm_ui$Internal$Model$Single, "br-" + $elm$core$String$fromInt(radius), "border-radius", $elm$core$String$fromInt(radius) + "px"));
    };
    var $Orasund$elm_ui_framework$Framework$Color$simple = _List_fromArray([
        $mdgriffith$elm_ui$Element$Background$color($Orasund$elm_ui_framework$Framework$Color$lightGrey),
        $mdgriffith$elm_ui$Element$Border$color($Orasund$elm_ui_framework$Framework$Color$lightGrey)
    ]);
    var $Orasund$elm_ui_framework$Framework$Tag$simple = _Utils_ap($Orasund$elm_ui_framework$Framework$Color$simple, _List_fromArray([
        $mdgriffith$elm_ui$Element$Border$rounded(4),
        A2($mdgriffith$elm_ui$Element$paddingXY, 7, 4)
    ]));
    var $mdgriffith$elm_ui$Internal$Model$BorderWidth = F5(function(a, b, c, d, e) {
        return {
            $: "BorderWidth",
            a: a,
            b: b,
            c: c,
            d: d,
            e: e
        };
    });
    var $mdgriffith$elm_ui$Element$Border$width = function(v) {
        return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$borderWidth, A5($mdgriffith$elm_ui$Internal$Model$BorderWidth, "b-" + $elm$core$String$fromInt(v), v, v, v, v));
    };
    var $Orasund$elm_ui_framework$Framework$Card$simple = _Utils_ap($Orasund$elm_ui_framework$Framework$Tag$simple, _Utils_ap($Orasund$elm_ui_framework$Framework$Color$light, _List_fromArray([
        $mdgriffith$elm_ui$Element$Border$shadow({
            blur: 10,
            color: A4($mdgriffith$elm_ui$Element$rgba, 0, 0, 0, 0.05),
            offset: _Utils_Tuple2(0, 2),
            size: 1
        }),
        $mdgriffith$elm_ui$Element$Border$width(1),
        $mdgriffith$elm_ui$Element$Border$color($Orasund$elm_ui_framework$Framework$Color$lightGrey),
        $mdgriffith$elm_ui$Element$alignTop,
        $mdgriffith$elm_ui$Element$padding(20),
        $mdgriffith$elm_ui$Element$height($mdgriffith$elm_ui$Element$shrink)
    ])));
    var $Orasund$elm_ui_framework$Framework$Button$simple = _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, _Utils_ap($Orasund$elm_ui_framework$Framework$Color$simple, _List_fromArray([
        $mdgriffith$elm_ui$Element$Font$center,
        $mdgriffith$elm_ui$Element$mouseOver(_List_fromArray([
            $mdgriffith$elm_ui$Element$Border$color($Orasund$elm_ui_framework$Framework$Color$grey)
        ])),
        A2($mdgriffith$elm_ui$Element$paddingXY, 16, 12)
    ])));
    var $Orasund$elm_ui_framework$Framework$Button$fill = _Utils_ap($Orasund$elm_ui_framework$Framework$Button$simple, _List_fromArray([
        $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill)
    ]));
    var $Orasund$elm_ui_framework$Framework$Color$cyan = A3($mdgriffith$elm_ui$Element$rgb255, 32, 156, 238);
    var $Orasund$elm_ui_framework$Framework$Color$info = _List_fromArray([
        $mdgriffith$elm_ui$Element$Background$color($Orasund$elm_ui_framework$Framework$Color$cyan),
        $mdgriffith$elm_ui$Element$Border$color($Orasund$elm_ui_framework$Framework$Color$cyan)
    ]);
    var $mdgriffith$elm_ui$Element$text = function(content) {
        return $mdgriffith$elm_ui$Internal$Model$Text(content);
    };
    var $author$project$Pages$Hardware$infoBtn = F2(function(label, msg) {
        return A2($mdgriffith$elm_ui$Element$Input$button, _Utils_ap($Orasund$elm_ui_framework$Framework$Button$simple, _Utils_ap($Orasund$elm_ui_framework$Framework$Button$fill, $Orasund$elm_ui_framework$Framework$Color$info)), {
            label: $mdgriffith$elm_ui$Element$text(label),
            onPress: $elm$core$Maybe$Just(msg)
        });
    });
    var $elm$html$Html$Attributes$attribute = $elm$virtual_dom$VirtualDom$attribute;
    var $mdgriffith$elm_ui$Internal$Flag$fontColor = $mdgriffith$elm_ui$Internal$Flag$flag(14);
    var $mdgriffith$elm_ui$Element$Font$color = function(fontColor) {
        return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$fontColor, A3($mdgriffith$elm_ui$Internal$Model$Colored, "fc-" + $mdgriffith$elm_ui$Internal$Model$formatColorClass(fontColor), "color", fontColor));
    };
    var $Orasund$elm_ui_framework$Framework$Color$darkerGrey = A3($mdgriffith$elm_ui$Element$rgb255, 18, 18, 18);
    var $Orasund$elm_ui_framework$Framework$layoutAttributes = _Utils_ap(_List_fromArray([
        $mdgriffith$elm_ui$Element$Font$size(16),
        $mdgriffith$elm_ui$Element$Font$color($Orasund$elm_ui_framework$Framework$Color$darkerGrey)
    ]), $Orasund$elm_ui_framework$Framework$Color$light);
    var $mdgriffith$elm_ui$Internal$Model$FocusStyleOption = function(a) {
        return {
            $: "FocusStyleOption",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Element$focusStyle = $mdgriffith$elm_ui$Internal$Model$FocusStyleOption;
    var $elm$core$List$singleton = function(value) {
        return _List_fromArray([
            value
        ]);
    };
    var $Orasund$elm_ui_framework$Framework$Color$turquoise = A3($mdgriffith$elm_ui$Element$rgb255, 0, 209, 178);
    var $Orasund$elm_ui_framework$Framework$layoutOptions = $elm$core$List$singleton($mdgriffith$elm_ui$Element$focusStyle({
        backgroundColor: $elm$core$Maybe$Nothing,
        borderColor: $elm$core$Maybe$Just($Orasund$elm_ui_framework$Framework$Color$turquoise),
        shadow: $elm$core$Maybe$Just({
            blur: 10,
            color: $Orasund$elm_ui_framework$Framework$Color$turquoise,
            offset: _Utils_Tuple2(0, 0),
            size: 1
        })
    }));
    var $mdgriffith$elm_ui$Internal$Model$OnlyDynamic = F2(function(a, b) {
        return {
            $: "OnlyDynamic",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Model$StaticRootAndDynamic = F2(function(a, b) {
        return {
            $: "StaticRootAndDynamic",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Model$AllowHover = {
        $: "AllowHover"
    };
    var $mdgriffith$elm_ui$Internal$Model$Layout = {
        $: "Layout"
    };
    var $mdgriffith$elm_ui$Internal$Model$focusDefaultStyle = {
        backgroundColor: $elm$core$Maybe$Nothing,
        borderColor: $elm$core$Maybe$Nothing,
        shadow: $elm$core$Maybe$Just({
            blur: 0,
            color: A4($mdgriffith$elm_ui$Internal$Model$Rgba, 155 / 255, 203 / 255, 1, 1),
            offset: _Utils_Tuple2(0, 0),
            size: 3
        })
    };
    var $mdgriffith$elm_ui$Internal$Model$optionsToRecord = function(options) {
        var combine = F2(function(opt, record) {
            switch(opt.$){
                case "HoverOption":
                    var hoverable = opt.a;
                    var _v4 = record.hover;
                    if (_v4.$ === "Nothing") return _Utils_update(record, {
                        hover: $elm$core$Maybe$Just(hoverable)
                    });
                    else return record;
                case "FocusStyleOption":
                    var focusStyle = opt.a;
                    var _v5 = record.focus;
                    if (_v5.$ === "Nothing") return _Utils_update(record, {
                        focus: $elm$core$Maybe$Just(focusStyle)
                    });
                    else return record;
                default:
                    var renderMode = opt.a;
                    var _v6 = record.mode;
                    if (_v6.$ === "Nothing") return _Utils_update(record, {
                        mode: $elm$core$Maybe$Just(renderMode)
                    });
                    else return record;
            }
        });
        var andFinally = function(record) {
            return {
                focus: function() {
                    var _v0 = record.focus;
                    if (_v0.$ === "Nothing") return $mdgriffith$elm_ui$Internal$Model$focusDefaultStyle;
                    else {
                        var focusable = _v0.a;
                        return focusable;
                    }
                }(),
                hover: function() {
                    var _v1 = record.hover;
                    if (_v1.$ === "Nothing") return $mdgriffith$elm_ui$Internal$Model$AllowHover;
                    else {
                        var hoverable = _v1.a;
                        return hoverable;
                    }
                }(),
                mode: function() {
                    var _v2 = record.mode;
                    if (_v2.$ === "Nothing") return $mdgriffith$elm_ui$Internal$Model$Layout;
                    else {
                        var actualMode = _v2.a;
                        return actualMode;
                    }
                }()
            };
        };
        return andFinally(A3($elm$core$List$foldr, combine, {
            focus: $elm$core$Maybe$Nothing,
            hover: $elm$core$Maybe$Nothing,
            mode: $elm$core$Maybe$Nothing
        }, options));
    };
    var $mdgriffith$elm_ui$Internal$Model$toHtml = F2(function(mode, el) {
        switch(el.$){
            case "Unstyled":
                var html = el.a;
                return html($mdgriffith$elm_ui$Internal$Model$asEl);
            case "Styled":
                var styles = el.a.styles;
                var html = el.a.html;
                return A2(html, mode(styles), $mdgriffith$elm_ui$Internal$Model$asEl);
            case "Text":
                var text = el.a;
                return $mdgriffith$elm_ui$Internal$Model$textElement(text);
            default:
                return $mdgriffith$elm_ui$Internal$Model$textElement("");
        }
    });
    var $mdgriffith$elm_ui$Internal$Model$renderRoot = F3(function(optionList, attributes, child) {
        var options = $mdgriffith$elm_ui$Internal$Model$optionsToRecord(optionList);
        var embedStyle = function() {
            var _v0 = options.mode;
            if (_v0.$ === "NoStaticStyleSheet") return $mdgriffith$elm_ui$Internal$Model$OnlyDynamic(options);
            else return $mdgriffith$elm_ui$Internal$Model$StaticRootAndDynamic(options);
        }();
        return A2($mdgriffith$elm_ui$Internal$Model$toHtml, embedStyle, A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asEl, $mdgriffith$elm_ui$Internal$Model$div, attributes, $mdgriffith$elm_ui$Internal$Model$Unkeyed(_List_fromArray([
            child
        ]))));
    });
    var $mdgriffith$elm_ui$Internal$Model$FontFamily = F2(function(a, b) {
        return {
            $: "FontFamily",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Model$SansSerif = {
        $: "SansSerif"
    };
    var $mdgriffith$elm_ui$Internal$Model$Typeface = function(a) {
        return {
            $: "Typeface",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Flag$fontFamily = $mdgriffith$elm_ui$Internal$Flag$flag(5);
    var $elm$core$String$toLower = _String_toLower;
    var $elm$core$String$words = _String_words;
    var $mdgriffith$elm_ui$Internal$Model$renderFontClassName = F2(function(font, current) {
        return _Utils_ap(current, function() {
            switch(font.$){
                case "Serif":
                    return "serif";
                case "SansSerif":
                    return "sans-serif";
                case "Monospace":
                    return "monospace";
                case "Typeface":
                    var name = font.a;
                    return A2($elm$core$String$join, "-", $elm$core$String$words($elm$core$String$toLower(name)));
                case "ImportFont":
                    var name = font.a;
                    var url = font.b;
                    return A2($elm$core$String$join, "-", $elm$core$String$words($elm$core$String$toLower(name)));
                default:
                    var name = font.a.name;
                    return A2($elm$core$String$join, "-", $elm$core$String$words($elm$core$String$toLower(name)));
            }
        }());
    });
    var $mdgriffith$elm_ui$Internal$Model$rootStyle = function() {
        var families = _List_fromArray([
            $mdgriffith$elm_ui$Internal$Model$Typeface("Open Sans"),
            $mdgriffith$elm_ui$Internal$Model$Typeface("Helvetica"),
            $mdgriffith$elm_ui$Internal$Model$Typeface("Verdana"),
            $mdgriffith$elm_ui$Internal$Model$SansSerif
        ]);
        return _List_fromArray([
            A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$bgColor, A3($mdgriffith$elm_ui$Internal$Model$Colored, "bg-" + $mdgriffith$elm_ui$Internal$Model$formatColorClass(A4($mdgriffith$elm_ui$Internal$Model$Rgba, 1, 1, 1, 0)), "background-color", A4($mdgriffith$elm_ui$Internal$Model$Rgba, 1, 1, 1, 0))),
            A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$fontColor, A3($mdgriffith$elm_ui$Internal$Model$Colored, "fc-" + $mdgriffith$elm_ui$Internal$Model$formatColorClass(A4($mdgriffith$elm_ui$Internal$Model$Rgba, 0, 0, 0, 1)), "color", A4($mdgriffith$elm_ui$Internal$Model$Rgba, 0, 0, 0, 1))),
            A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$fontSize, $mdgriffith$elm_ui$Internal$Model$FontSize(20)),
            A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$fontFamily, A2($mdgriffith$elm_ui$Internal$Model$FontFamily, A3($elm$core$List$foldl, $mdgriffith$elm_ui$Internal$Model$renderFontClassName, "font-", families), families))
        ]);
    }();
    var $mdgriffith$elm_ui$Element$layoutWith = F3(function(_v0, attrs, child) {
        var options = _v0.options;
        return A3($mdgriffith$elm_ui$Internal$Model$renderRoot, options, A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$htmlClass(A2($elm$core$String$join, " ", _List_fromArray([
            $mdgriffith$elm_ui$Internal$Style$classes.root,
            $mdgriffith$elm_ui$Internal$Style$classes.any,
            $mdgriffith$elm_ui$Internal$Style$classes.single
        ]))), _Utils_ap($mdgriffith$elm_ui$Internal$Model$rootStyle, attrs)), child);
    });
    var $Orasund$elm_ui_framework$Framework$layout = function(attributes) {
        return A2($mdgriffith$elm_ui$Element$layoutWith, {
            options: $Orasund$elm_ui_framework$Framework$layoutOptions
        }, _Utils_ap($Orasund$elm_ui_framework$Framework$layoutAttributes, attributes));
    };
    var $Orasund$elm_ui_framework$Framework$responsiveLayout = F2(function(attributes, view) {
        return A2($elm$html$Html$div, _List_Nil, _List_fromArray([
            A3($elm$html$Html$node, "meta", _List_fromArray([
                A2($elm$html$Html$Attributes$attribute, "name", "viewport"),
                A2($elm$html$Html$Attributes$attribute, "content", "width=device-width, initial-scale=1.0")
            ]), _List_Nil),
            A2($Orasund$elm_ui_framework$Framework$layout, attributes, view)
        ]));
    });
    var $mdgriffith$elm_ui$Internal$Model$SpacingStyle = F3(function(a, b, c) {
        return {
            $: "SpacingStyle",
            a: a,
            b: b,
            c: c
        };
    });
    var $mdgriffith$elm_ui$Internal$Flag$spacing = $mdgriffith$elm_ui$Internal$Flag$flag(3);
    var $mdgriffith$elm_ui$Internal$Model$spacingName = F2(function(x, y) {
        return "spacing-" + ($elm$core$String$fromInt(x) + ("-" + $elm$core$String$fromInt(y)));
    });
    var $mdgriffith$elm_ui$Element$spacing = function(x) {
        return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$spacing, A3($mdgriffith$elm_ui$Internal$Model$SpacingStyle, A2($mdgriffith$elm_ui$Internal$Model$spacingName, x, x), x, x));
    };
    var $Orasund$elm_ui_framework$Framework$Grid$simple = _List_fromArray([
        $mdgriffith$elm_ui$Element$spacing(10),
        $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill),
        $mdgriffith$elm_ui$Element$alignTop
    ]);
    var $author$project$Pages$Hardware$confirmDeleteUserView = function(userInfo) {
        return A2($Orasund$elm_ui_framework$Framework$responsiveLayout, _List_Nil, A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$container, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h5, $mdgriffith$elm_ui$Element$text(userInfo.nickname + " - Are you sure you want to delete your account?\n            Please note that this will delete all your AND THE RANKING MEMBER'S rankings and is IRREVERSIBLE!\n            (You may wish to inform them before deleting)")),
            A2($mdgriffith$elm_ui$Element$column, A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill), _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple)), _List_fromArray([
                A2($author$project$Pages$Hardware$infoBtn, "Delete User Account", $author$project$Pages$Hardware$DeleteAccount),
                A2($author$project$Pages$Hardware$infoBtn, "Cancel", $author$project$Pages$Hardware$CancelFetchedMember)
            ]))
        ])));
    };
    var $author$project$Pages$Hardware$CancelFetchedSpectator = {
        $: "CancelFetchedSpectator"
    };
    var $author$project$Pages$Hardware$ConfirmJoin = F3(function(a, b, c) {
        return {
            $: "ConfirmJoin",
            a: a,
            b: b,
            c: c
        };
    });
    var $author$project$Data$Hardware$gotLowestRank = function(ranks) {
        if (!ranks.b) return $elm$core$Maybe$Nothing;
        else if (!ranks.b.b) {
            var rank = ranks.a;
            return $elm$core$Maybe$Just(rank);
        } else {
            var head = ranks.a;
            var tail = ranks.b;
            var findMaxHelper = F2(function(currentMax, remainingList) {
                findMaxHelper: while(true){
                    if (!remainingList.b) return currentMax;
                    else {
                        var next = remainingList.a;
                        var rest = remainingList.b;
                        if (_Utils_cmp(next.rank, currentMax.rank) > 0) {
                            var $temp$currentMax = next, $temp$remainingList = rest;
                            currentMax = $temp$currentMax;
                            remainingList = $temp$remainingList;
                            continue findMaxHelper;
                        } else {
                            var $temp$currentMax = currentMax, $temp$remainingList = rest;
                            currentMax = $temp$currentMax;
                            remainingList = $temp$remainingList;
                            continue findMaxHelper;
                        }
                    }
                }
            });
            return $elm$core$Maybe$Just(A2(findMaxHelper, head, tail));
        }
    };
    var $author$project$SR$Elements$spectatorSelectedRankingHeaderEl = F2(function(userInfo, r) {
        return A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h5, $mdgriffith$elm_ui$Element$text(userInfo.nickname + (" you're interested in joining" + (" - " + (r.name + (" Id no: " + (r.id + (" . \n Which is owned by " + (r.owner_name + (" id no: " + r.owner_id))))))))));
    });
    var $mdgriffith$elm_ui$Internal$Model$AsRow = {
        $: "AsRow"
    };
    var $mdgriffith$elm_ui$Internal$Model$asRow = $mdgriffith$elm_ui$Internal$Model$AsRow;
    var $mdgriffith$elm_ui$Internal$Model$Padding = F5(function(a, b, c, d, e) {
        return {
            $: "Padding",
            a: a,
            b: b,
            c: c,
            d: d,
            e: e
        };
    });
    var $mdgriffith$elm_ui$Internal$Model$Spaced = F3(function(a, b, c) {
        return {
            $: "Spaced",
            a: a,
            b: b,
            c: c
        };
    });
    var $mdgriffith$elm_ui$Internal$Model$extractSpacingAndPadding = function(attrs) {
        return A3($elm$core$List$foldr, F2(function(attr, _v0) {
            var pad = _v0.a;
            var spacing = _v0.b;
            return _Utils_Tuple2(function() {
                if (pad.$ === "Just") {
                    var x = pad.a;
                    return pad;
                } else {
                    if (attr.$ === "StyleClass" && attr.b.$ === "PaddingStyle") {
                        var _v3 = attr.b;
                        var name = _v3.a;
                        var t = _v3.b;
                        var r = _v3.c;
                        var b = _v3.d;
                        var l = _v3.e;
                        return $elm$core$Maybe$Just(A5($mdgriffith$elm_ui$Internal$Model$Padding, name, t, r, b, l));
                    } else return $elm$core$Maybe$Nothing;
                }
            }(), function() {
                if (spacing.$ === "Just") {
                    var x = spacing.a;
                    return spacing;
                } else {
                    if (attr.$ === "StyleClass" && attr.b.$ === "SpacingStyle") {
                        var _v6 = attr.b;
                        var name = _v6.a;
                        var x = _v6.b;
                        var y = _v6.c;
                        return $elm$core$Maybe$Just(A3($mdgriffith$elm_ui$Internal$Model$Spaced, name, x, y));
                    } else return $elm$core$Maybe$Nothing;
                }
            }());
        }), _Utils_Tuple2($elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing), attrs);
    };
    var $mdgriffith$elm_ui$Internal$Model$paddingNameFloat = F4(function(top, right, bottom, left) {
        return "pad-" + ($mdgriffith$elm_ui$Internal$Model$floatClass(top) + ("-" + ($mdgriffith$elm_ui$Internal$Model$floatClass(right) + ("-" + ($mdgriffith$elm_ui$Internal$Model$floatClass(bottom) + ("-" + $mdgriffith$elm_ui$Internal$Model$floatClass(left)))))));
    });
    var $mdgriffith$elm_ui$Element$wrappedRow = F2(function(attrs, children) {
        var _v0 = $mdgriffith$elm_ui$Internal$Model$extractSpacingAndPadding(attrs);
        var padded = _v0.a;
        var spaced = _v0.b;
        if (spaced.$ === "Nothing") return A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asRow, $mdgriffith$elm_ui$Internal$Model$div, A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$htmlClass($mdgriffith$elm_ui$Internal$Style$classes.contentLeft + (" " + ($mdgriffith$elm_ui$Internal$Style$classes.contentCenterY + (" " + $mdgriffith$elm_ui$Internal$Style$classes.wrapped)))), A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$shrink), A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$height($mdgriffith$elm_ui$Element$shrink), attrs))), $mdgriffith$elm_ui$Internal$Model$Unkeyed(children));
        else {
            var _v2 = spaced.a;
            var spaceName = _v2.a;
            var x = _v2.b;
            var y = _v2.c;
            var newPadding = function() {
                if (padded.$ === "Just") {
                    var _v5 = padded.a;
                    var name = _v5.a;
                    var t = _v5.b;
                    var r = _v5.c;
                    var b = _v5.d;
                    var l = _v5.e;
                    if (_Utils_cmp(r, x / 2) > -1 && _Utils_cmp(b, y / 2) > -1) {
                        var newTop = t - y / 2;
                        var newRight = r - x / 2;
                        var newLeft = l - x / 2;
                        var newBottom = b - y / 2;
                        return $elm$core$Maybe$Just(A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$padding, A5($mdgriffith$elm_ui$Internal$Model$PaddingStyle, A4($mdgriffith$elm_ui$Internal$Model$paddingNameFloat, newTop, newRight, newBottom, newLeft), newTop, newRight, newBottom, newLeft)));
                    } else return $elm$core$Maybe$Nothing;
                } else return $elm$core$Maybe$Nothing;
            }();
            if (newPadding.$ === "Just") {
                var pad = newPadding.a;
                return A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asRow, $mdgriffith$elm_ui$Internal$Model$div, A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$htmlClass($mdgriffith$elm_ui$Internal$Style$classes.contentLeft + (" " + ($mdgriffith$elm_ui$Internal$Style$classes.contentCenterY + (" " + $mdgriffith$elm_ui$Internal$Style$classes.wrapped)))), A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$shrink), A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$height($mdgriffith$elm_ui$Element$shrink), _Utils_ap(attrs, _List_fromArray([
                    pad
                ]))))), $mdgriffith$elm_ui$Internal$Model$Unkeyed(children));
            } else {
                var halfY = -(y / 2);
                var halfX = -(x / 2);
                return A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asEl, $mdgriffith$elm_ui$Internal$Model$div, attrs, $mdgriffith$elm_ui$Internal$Model$Unkeyed(_List_fromArray([
                    A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asRow, $mdgriffith$elm_ui$Internal$Model$div, A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$htmlClass($mdgriffith$elm_ui$Internal$Style$classes.contentLeft + (" " + ($mdgriffith$elm_ui$Internal$Style$classes.contentCenterY + (" " + $mdgriffith$elm_ui$Internal$Style$classes.wrapped)))), A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$Attr(A2($elm$html$Html$Attributes$style, "margin", $elm$core$String$fromFloat(halfY) + ("px" + (" " + ($elm$core$String$fromFloat(halfX) + "px"))))), A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$Attr(A2($elm$html$Html$Attributes$style, "width", "calc(100% + " + ($elm$core$String$fromInt(x) + "px)"))), A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$Attr(A2($elm$html$Html$Attributes$style, "height", "calc(100% + " + ($elm$core$String$fromInt(y) + "px)"))), A2($elm$core$List$cons, A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$spacing, A3($mdgriffith$elm_ui$Internal$Model$SpacingStyle, spaceName, x, y)), _List_Nil))))), $mdgriffith$elm_ui$Internal$Model$Unkeyed(children))
                ])));
            }
        }
    });
    var $author$project$Pages$Hardware$confirmJoinView = F2(function(userInfo, ranking) {
        return A2($Orasund$elm_ui_framework$Framework$responsiveLayout, _List_Nil, A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$container, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$wrappedRow, _List_Nil, _List_fromArray([
                A2($author$project$SR$Elements$spectatorSelectedRankingHeaderEl, userInfo, ranking)
            ])),
            A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h5, $mdgriffith$elm_ui$Element$text(userInfo.nickname + (" - Are you sure you want to join" + (ranking.owner_name + "'s  ranking?")))),
            A2($mdgriffith$elm_ui$Element$column, A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill), _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple)), _List_fromArray([
                A2($author$project$Pages$Hardware$infoBtn, "Join", A3($author$project$Pages$Hardware$ConfirmJoin, ranking, userInfo.userid, A2($elm$core$Maybe$withDefault, $author$project$Data$Hardware$emptyRank, $author$project$Data$Hardware$gotLowestRank(ranking.ladder)).rank)),
                A2($author$project$Pages$Hardware$infoBtn, "Cancel", $author$project$Pages$Hardware$CancelFetchedSpectator)
            ]))
        ])));
    });
    var $author$project$Pages$Hardware$ConfirmLeaveMemberRanking = F2(function(a, b) {
        return {
            $: "ConfirmLeaveMemberRanking",
            a: a,
            b: b
        };
    });
    var $author$project$SR$Elements$memberSelectedRankingHeaderEl = F2(function(userInfo, r) {
        return A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h5, $mdgriffith$elm_ui$Element$text(userInfo.nickname + (" you're a member of" + (" - " + (r.name + (" Id no: " + (r.id + (" . \n Which is owned by " + (r.owner_name + (" id no: " + r.owner_id))))))))));
    });
    var $author$project$Pages$Hardware$confirmLeaveView = F2(function(userInfo, ranking) {
        return A2($Orasund$elm_ui_framework$Framework$responsiveLayout, _List_Nil, A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$container, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$wrappedRow, _List_Nil, _List_fromArray([
                A2($author$project$SR$Elements$memberSelectedRankingHeaderEl, userInfo, ranking)
            ])),
            A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h5, $mdgriffith$elm_ui$Element$text(userInfo.nickname + (" - Are you sure you want to leave " + (ranking.owner_name + "'s  ranking?")))),
            A2($mdgriffith$elm_ui$Element$column, A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill), _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple)), _List_fromArray([
                A2($author$project$Pages$Hardware$infoBtn, "Leave", A2($author$project$Pages$Hardware$ConfirmLeaveMemberRanking, ranking, userInfo.userid)),
                A2($author$project$Pages$Hardware$infoBtn, "Cancel", $author$project$Pages$Hardware$CancelFetchedMember)
            ]))
        ])));
    });
    var $author$project$Pages$Hardware$Cancel = {
        $: "Cancel"
    };
    var $author$project$Pages$Hardware$ConfirmChallenge = F2(function(a, b) {
        return {
            $: "ConfirmChallenge",
            a: a,
            b: b
        };
    });
    var $Orasund$elm_ui_framework$Framework$Card$fill = _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, _List_fromArray([
        $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill)
    ]));
    var $Orasund$elm_ui_framework$Framework$Heading$h6 = $Orasund$elm_ui_framework$Framework$Heading$h(6);
    var $author$project$Pages$Hardware$isUserRankedHigher = F2(function(userInfo, ranking) {
        var userRank = A2($elm$core$Maybe$map, function($) {
            return $.rank;
        }, $elm$core$List$head(A2($elm$core$List$filter, function(r) {
            return _Utils_eq(r.player.id, userInfo.userid);
        }, ranking.ladder)));
        var otherRank = A2($elm$core$Maybe$map, function($) {
            return $.rank;
        }, $elm$core$List$head(A2($elm$core$List$filter, function(r) {
            return !_Utils_eq(r.player.id, userInfo.userid);
        }, ranking.ladder)));
        var _v0 = _Utils_Tuple2(userRank, otherRank);
        if (_v0.a.$ === "Just" && _v0.b.$ === "Just") {
            var ur = _v0.a.a;
            var or = _v0.b.a;
            return _Utils_cmp(ur, or) < 0;
        } else return false;
    });
    var $mdgriffith$elm_ui$Internal$Model$Paragraph = {
        $: "Paragraph"
    };
    var $mdgriffith$elm_ui$Element$paragraph = F2(function(attrs, children) {
        return A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asParagraph, $mdgriffith$elm_ui$Internal$Model$div, A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$Describe($mdgriffith$elm_ui$Internal$Model$Paragraph), A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill), A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$spacing(5), attrs))), $mdgriffith$elm_ui$Internal$Model$Unkeyed(children));
    });
    var $mdgriffith$elm_ui$Element$Border$widthXY = F2(function(x, y) {
        return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$borderWidth, A5($mdgriffith$elm_ui$Internal$Model$BorderWidth, "b-" + ($elm$core$String$fromInt(x) + ("-" + $elm$core$String$fromInt(y))), y, x, y, x));
    });
    var $mdgriffith$elm_ui$Element$Border$widthEach = function(_v0) {
        var bottom = _v0.bottom;
        var top = _v0.top;
        var left = _v0.left;
        var right = _v0.right;
        return _Utils_eq(top, bottom) && _Utils_eq(left, right) ? _Utils_eq(top, right) ? $mdgriffith$elm_ui$Element$Border$width(top) : A2($mdgriffith$elm_ui$Element$Border$widthXY, left, top) : A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$borderWidth, A5($mdgriffith$elm_ui$Internal$Model$BorderWidth, "b-" + ($elm$core$String$fromInt(top) + ("-" + ($elm$core$String$fromInt(right) + ("-" + ($elm$core$String$fromInt(bottom) + ("-" + $elm$core$String$fromInt(left))))))), top, right, bottom, left));
    };
    var $Orasund$elm_ui_framework$Framework$Grid$section = _Utils_ap($Orasund$elm_ui_framework$Framework$Grid$simple, _List_fromArray([
        $mdgriffith$elm_ui$Element$Border$widthEach({
            bottom: 0,
            left: 0,
            right: 0,
            top: 2
        }),
        $mdgriffith$elm_ui$Element$Border$color($Orasund$elm_ui_framework$Framework$Color$lightGrey),
        $mdgriffith$elm_ui$Element$paddingEach({
            bottom: 30,
            left: 0,
            right: 0,
            top: 10
        })
    ]));
    var $author$project$Pages$Hardware$createChallengeView = F3(function(uinfo, rank, ranking) {
        return !_Utils_eq(rank.player.id, uinfo.userid) ? !A2($author$project$Pages$Hardware$isUserRankedHigher, uinfo, ranking) ? A2($Orasund$elm_ui_framework$Framework$responsiveLayout, _List_Nil, A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$section, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h6, $mdgriffith$elm_ui$Element$text(" Your opponent's details: ")),
            A2($mdgriffith$elm_ui$Element$paragraph, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$fill, $Orasund$elm_ui_framework$Framework$Color$info), _List_fromArray([
                A2($mdgriffith$elm_ui$Element$el, _List_Nil, $mdgriffith$elm_ui$Element$text(uinfo.nickname + (" you are challenging " + rank.player.nickname)))
            ])),
            A2($mdgriffith$elm_ui$Element$el, _List_Nil, $mdgriffith$elm_ui$Element$text("Email: ")),
            A2($mdgriffith$elm_ui$Element$paragraph, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$fill, $Orasund$elm_ui_framework$Framework$Color$info), _List_fromArray([
                A2($mdgriffith$elm_ui$Element$el, _List_Nil, $mdgriffith$elm_ui$Element$text("challenger@c.com"))
            ])),
            A2($mdgriffith$elm_ui$Element$el, _List_Nil, $mdgriffith$elm_ui$Element$text("Mobile: ")),
            A2($mdgriffith$elm_ui$Element$paragraph, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$fill, $Orasund$elm_ui_framework$Framework$Color$info), _List_fromArray([
                A2($mdgriffith$elm_ui$Element$el, _List_Nil, $mdgriffith$elm_ui$Element$text("challenger mobile"))
            ])),
            A2($mdgriffith$elm_ui$Element$column, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple), _List_fromArray([
                A2($mdgriffith$elm_ui$Element$wrappedRow, $Orasund$elm_ui_framework$Framework$Grid$simple, _List_fromArray([
                    A2($mdgriffith$elm_ui$Element$Input$button, _Utils_ap($Orasund$elm_ui_framework$Framework$Button$simple, $Orasund$elm_ui_framework$Framework$Color$simple), {
                        label: $mdgriffith$elm_ui$Element$text("Cancel"),
                        onPress: $elm$core$Maybe$Just($author$project$Pages$Hardware$Cancel)
                    }),
                    A2($mdgriffith$elm_ui$Element$Input$button, _Utils_ap($Orasund$elm_ui_framework$Framework$Button$simple, $Orasund$elm_ui_framework$Framework$Color$info), {
                        label: $mdgriffith$elm_ui$Element$text("Confirm"),
                        onPress: $elm$core$Maybe$Just(A2($author$project$Pages$Hardware$ConfirmChallenge, ranking, rank))
                    })
                ]))
            ]))
        ]))) : A2($Orasund$elm_ui_framework$Framework$responsiveLayout, _List_Nil, A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$section, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$paragraph, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$fill, $Orasund$elm_ui_framework$Framework$Color$info), _List_fromArray([
                A2($mdgriffith$elm_ui$Element$el, _List_Nil, $mdgriffith$elm_ui$Element$text(uinfo.nickname + " aim high! Challenge up "))
            ])),
            A2($mdgriffith$elm_ui$Element$column, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple), _List_fromArray([
                A2($mdgriffith$elm_ui$Element$wrappedRow, $Orasund$elm_ui_framework$Framework$Grid$simple, _List_fromArray([
                    A2($mdgriffith$elm_ui$Element$Input$button, _Utils_ap($Orasund$elm_ui_framework$Framework$Button$simple, $Orasund$elm_ui_framework$Framework$Color$simple), {
                        label: $mdgriffith$elm_ui$Element$text("Cancel"),
                        onPress: $elm$core$Maybe$Just($author$project$Pages$Hardware$Cancel)
                    })
                ]))
            ]))
        ]))) : A2($Orasund$elm_ui_framework$Framework$responsiveLayout, _List_Nil, A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$section, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$paragraph, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$fill, $Orasund$elm_ui_framework$Framework$Color$info), _List_fromArray([
                A2($mdgriffith$elm_ui$Element$el, _List_Nil, $mdgriffith$elm_ui$Element$text(rank.player.nickname + " you can't challenge yourself! "))
            ])),
            A2($mdgriffith$elm_ui$Element$column, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple), _List_fromArray([
                A2($mdgriffith$elm_ui$Element$wrappedRow, $Orasund$elm_ui_framework$Framework$Grid$simple, _List_fromArray([
                    A2($mdgriffith$elm_ui$Element$Input$button, _Utils_ap($Orasund$elm_ui_framework$Framework$Button$simple, $Orasund$elm_ui_framework$Framework$Color$simple), {
                        label: $mdgriffith$elm_ui$Element$text("Cancel"),
                        onPress: $elm$core$Maybe$Just($author$project$Pages$Hardware$Cancel)
                    })
                ]))
            ]))
        ])));
    });
    var $author$project$Pages$Hardware$CityAddressChg = function(a) {
        return {
            $: "CityAddressChg",
            a: a
        };
    };
    var $author$project$Pages$Hardware$RankingNameChg = function(a) {
        return {
            $: "RankingNameChg",
            a: a
        };
    };
    var $author$project$Pages$Hardware$StreetAddressChg = function(a) {
        return {
            $: "StreetAddressChg",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Element$htmlAttribute = $mdgriffith$elm_ui$Internal$Model$Attr;
    var $Orasund$elm_ui_framework$Framework$Input$label = _List_fromArray([
        $mdgriffith$elm_ui$Element$centerX,
        $mdgriffith$elm_ui$Element$padding(10),
        $mdgriffith$elm_ui$Element$height($mdgriffith$elm_ui$Element$shrink),
        $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill)
    ]);
    var $mdgriffith$elm_ui$Element$Input$Label = F3(function(a, b, c) {
        return {
            $: "Label",
            a: a,
            b: b,
            c: c
        };
    });
    var $mdgriffith$elm_ui$Element$Input$OnLeft = {
        $: "OnLeft"
    };
    var $mdgriffith$elm_ui$Element$Input$labelLeft = $mdgriffith$elm_ui$Element$Input$Label($mdgriffith$elm_ui$Element$Input$OnLeft);
    var $mdgriffith$elm_ui$Element$Font$alignLeft = A2($mdgriffith$elm_ui$Internal$Model$Class, $mdgriffith$elm_ui$Internal$Flag$fontAlignment, $mdgriffith$elm_ui$Internal$Style$classes.textLeft);
    var $mdgriffith$elm_ui$Element$rgb = F3(function(r, g, b) {
        return A4($mdgriffith$elm_ui$Internal$Model$Rgba, r, g, b, 1);
    });
    var $author$project$SR$Elements$colors = {
        black: A3($mdgriffith$elm_ui$Element$rgb255, 0, 0, 0),
        blue: A3($mdgriffith$elm_ui$Element$rgb255, 2, 7, 239),
        coral: A3($mdgriffith$elm_ui$Element$rgb255, 204, 75, 75),
        darkBlue: A3($mdgriffith$elm_ui$Element$rgb, 0, 0, 0.9),
        green: A3($mdgriffith$elm_ui$Element$rgb255, 0, 153, 0),
        grey: A3($mdgriffith$elm_ui$Element$rgb, 0.9, 0.9, 0.9),
        lightblue: A3($mdgriffith$elm_ui$Element$rgb255, 0, 128, 255),
        purple: A3($mdgriffith$elm_ui$Element$rgb255, 102, 0, 102),
        red: A3($mdgriffith$elm_ui$Element$rgb, 0.8, 0, 0),
        white: A3($mdgriffith$elm_ui$Element$rgb255, 255, 255, 255)
    };
    var $elm$regex$Regex$never = _Regex_never;
    var $author$project$Utils$Validation$Validate$isValid4to20Chars = function(str) {
        return A2($elm$regex$Regex$contains, A2($elm$core$Maybe$withDefault, $elm$regex$Regex$never, $elm$regex$Regex$fromString("(?!.*[\\.\\-\\_]{2,})^[a-zA-Z0-9\\.\\-\\_]{4,20}$")), str);
    };
    var $mdgriffith$elm_ui$Internal$Model$MoveX = function(a) {
        return {
            $: "MoveX",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Flag$moveX = $mdgriffith$elm_ui$Internal$Flag$flag(25);
    var $mdgriffith$elm_ui$Element$moveLeft = function(x) {
        return A2($mdgriffith$elm_ui$Internal$Model$TransformComponent, $mdgriffith$elm_ui$Internal$Flag$moveX, $mdgriffith$elm_ui$Internal$Model$MoveX(-x));
    };
    var $author$project$SR$Elements$ladderCityValidation = function(ranking) {
        return $author$project$Utils$Validation$Validate$isValid4to20Chars(ranking.baseaddress.city) ? A2($mdgriffith$elm_ui$Element$el, _Utils_ap(A2($elm$core$List$append, _List_fromArray([
            $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("laddercityValidMsg"))
        ]), _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$color($author$project$SR$Elements$colors.green),
            $mdgriffith$elm_ui$Element$Font$alignLeft
        ])), _List_fromArray([
            $mdgriffith$elm_ui$Element$moveLeft(1.0)
        ])), $mdgriffith$elm_ui$Element$text("City name OK!")) : A2($mdgriffith$elm_ui$Element$el, _Utils_ap(A2($elm$core$List$append, _List_fromArray([
            $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("laddercityValidMsg"))
        ]), _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$color($author$project$SR$Elements$colors.blue),
            $mdgriffith$elm_ui$Element$Font$alignLeft
        ])), _List_fromArray([
            $mdgriffith$elm_ui$Element$moveLeft(0.0)
        ])), $mdgriffith$elm_ui$Element$text("If entered, must be unique (4-20 continuous chars)"));
    };
    var $author$project$SR$Elements$ladderNameValidation = function(ranking) {
        return $author$project$Utils$Validation$Validate$isValid4to20Chars(ranking.name) ? A2($mdgriffith$elm_ui$Element$el, _Utils_ap(A2($elm$core$List$append, _List_fromArray([
            $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("laddernameValidMsg"))
        ]), _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$color($author$project$SR$Elements$colors.green),
            $mdgriffith$elm_ui$Element$Font$alignLeft
        ])), _List_fromArray([
            $mdgriffith$elm_ui$Element$moveLeft(1.0)
        ])), $mdgriffith$elm_ui$Element$text("Ranking name OK!")) : A2($mdgriffith$elm_ui$Element$el, _Utils_ap(A2($elm$core$List$append, _List_fromArray([
            $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("laddernameValidMsg"))
        ]), _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$color($author$project$SR$Elements$colors.red),
            $mdgriffith$elm_ui$Element$Font$alignLeft
        ])), _List_fromArray([
            $mdgriffith$elm_ui$Element$moveLeft(0.0)
        ])), $mdgriffith$elm_ui$Element$text("Must be unique (4-20 continuous chars)"));
    };
    var $author$project$SR$Elements$ladderStreetValidation = function(ranking) {
        return $author$project$Utils$Validation$Validate$isValid4to20Chars(ranking.baseaddress.street) ? A2($mdgriffith$elm_ui$Element$el, _Utils_ap(A2($elm$core$List$append, _List_fromArray([
            $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("ladderstreetValidMsg"))
        ]), _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$color($author$project$SR$Elements$colors.green),
            $mdgriffith$elm_ui$Element$Font$alignLeft
        ])), _List_fromArray([
            $mdgriffith$elm_ui$Element$moveLeft(1.0)
        ])), $mdgriffith$elm_ui$Element$text("Street name OK!")) : A2($mdgriffith$elm_ui$Element$el, _Utils_ap(A2($elm$core$List$append, _List_fromArray([
            $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("ladderstreetValidMsg"))
        ]), _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$color($author$project$SR$Elements$colors.blue),
            $mdgriffith$elm_ui$Element$Font$alignLeft
        ])), _List_fromArray([
            $mdgriffith$elm_ui$Element$moveLeft(0.0)
        ])), $mdgriffith$elm_ui$Element$text("If entered, must be unique (4-20 continuous chars)"));
    };
    var $mdgriffith$elm_ui$Element$Input$Placeholder = F2(function(a, b) {
        return {
            $: "Placeholder",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Element$Input$placeholder = $mdgriffith$elm_ui$Element$Input$Placeholder;
    var $author$project$Pages$Hardware$CancelCreateNewRanking = {
        $: "CancelCreateNewRanking"
    };
    var $author$project$Pages$Hardware$ConfirmNewRanking = F2(function(a, b) {
        return {
            $: "ConfirmNewRanking",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Model$Focus = {
        $: "Focus"
    };
    var $mdgriffith$elm_ui$Internal$Flag$focus = $mdgriffith$elm_ui$Internal$Flag$flag(31);
    var $mdgriffith$elm_ui$Element$focused = function(decs) {
        return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$focus, A2($mdgriffith$elm_ui$Internal$Model$PseudoSelector, $mdgriffith$elm_ui$Internal$Model$Focus, $mdgriffith$elm_ui$Internal$Model$unwrapDecorations(decs)));
    };
    var $Orasund$elm_ui_framework$Framework$Color$disabled = _Utils_ap($Orasund$elm_ui_framework$Framework$Color$simple, _List_fromArray([
        $mdgriffith$elm_ui$Element$Font$color($Orasund$elm_ui_framework$Framework$Color$grey),
        $mdgriffith$elm_ui$Element$mouseOver(_List_Nil),
        $mdgriffith$elm_ui$Element$focused(_List_Nil),
        $mdgriffith$elm_ui$Element$htmlAttribute(A2($elm$html$Html$Attributes$style, "cursor", "not-allowed"))
    ]));
    var $author$project$Pages$Hardware$enableButton = function(enable) {
        return enable ? $Orasund$elm_ui_framework$Framework$Color$info : $Orasund$elm_ui_framework$Framework$Color$disabled;
    };
    var $author$project$Pages$Hardware$isValidatedForAllLadderDetailsInput = function(ranking) {
        return $author$project$Utils$Validation$Validate$isValid4to20Chars(ranking.name) && (ranking.baseaddress.street === "" || $author$project$Utils$Validation$Validate$isValid4to20Chars(ranking.baseaddress.street)) && (ranking.baseaddress.city === "" || $author$project$Utils$Validation$Validate$isValid4to20Chars(ranking.baseaddress.city));
    };
    var $Orasund$elm_ui_framework$Framework$Color$yellow = A3($mdgriffith$elm_ui$Element$rgb255, 255, 221, 87);
    var $Orasund$elm_ui_framework$Framework$Color$warning = _List_fromArray([
        $mdgriffith$elm_ui$Element$Background$color($Orasund$elm_ui_framework$Framework$Color$yellow),
        $mdgriffith$elm_ui$Element$Border$color($Orasund$elm_ui_framework$Framework$Color$yellow)
    ]);
    var $author$project$SR$Elements$missingDataPara = A2($mdgriffith$elm_ui$Element$paragraph, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$fill, $Orasund$elm_ui_framework$Framework$Color$warning), _List_fromArray([
        A2($mdgriffith$elm_ui$Element$el, _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$bold
        ]), $mdgriffith$elm_ui$Element$text("Please note: ")),
        A2($mdgriffith$elm_ui$Element$paragraph, _List_Nil, $elm$core$List$singleton($mdgriffith$elm_ui$Element$text("Essential data is missing!")))
    ]));
    var $author$project$SR$Elements$warningParagraph = A2($mdgriffith$elm_ui$Element$paragraph, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$fill, $Orasund$elm_ui_framework$Framework$Color$warning), _List_fromArray([
        A2($mdgriffith$elm_ui$Element$el, _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$bold
        ]), $mdgriffith$elm_ui$Element$text("Please note: ")),
        A2($mdgriffith$elm_ui$Element$paragraph, _List_Nil, $elm$core$List$singleton($mdgriffith$elm_ui$Element$text("Can all your members find the venue (if there is one)?")))
    ]));
    var $author$project$Pages$Hardware$rankingDetailsConfirmPanel = F2(function(ranking, userInfo) {
        return $author$project$Pages$Hardware$isValidatedForAllLadderDetailsInput(ranking) ? A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$section, _List_fromArray([
            ranking.baseaddress.street === "" && ranking.baseaddress.city === "" ? $author$project$SR$Elements$warningParagraph : $mdgriffith$elm_ui$Element$text("Click to continue ..."),
            A2($mdgriffith$elm_ui$Element$column, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple), _List_fromArray([
                A2($mdgriffith$elm_ui$Element$wrappedRow, $Orasund$elm_ui_framework$Framework$Grid$simple, _List_fromArray([
                    A2($mdgriffith$elm_ui$Element$Input$button, _Utils_ap($Orasund$elm_ui_framework$Framework$Button$simple, $Orasund$elm_ui_framework$Framework$Color$info), {
                        label: $mdgriffith$elm_ui$Element$text("Cancel"),
                        onPress: $elm$core$Maybe$Just($author$project$Pages$Hardware$CancelCreateNewRanking)
                    }),
                    A2($mdgriffith$elm_ui$Element$Input$button, _Utils_ap($Orasund$elm_ui_framework$Framework$Button$simple, $author$project$Pages$Hardware$enableButton($author$project$Pages$Hardware$isValidatedForAllLadderDetailsInput(ranking))), {
                        label: $mdgriffith$elm_ui$Element$text("Confirm"),
                        onPress: $elm$core$Maybe$Just(A2($author$project$Pages$Hardware$ConfirmNewRanking, ranking, $author$project$Data$User$Registered(userInfo)))
                    })
                ]))
            ]))
        ])) : A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$section, _List_fromArray([
            $author$project$SR$Elements$missingDataPara,
            A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h6, $mdgriffith$elm_ui$Element$text("Click to continue ...")),
            A2($mdgriffith$elm_ui$Element$column, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple), _List_fromArray([
                A2($mdgriffith$elm_ui$Element$wrappedRow, $Orasund$elm_ui_framework$Framework$Grid$simple, _List_fromArray([
                    A2($mdgriffith$elm_ui$Element$Input$button, _Utils_ap($Orasund$elm_ui_framework$Framework$Button$simple, $Orasund$elm_ui_framework$Framework$Color$info), {
                        label: $mdgriffith$elm_ui$Element$text("Cancel"),
                        onPress: $elm$core$Maybe$Just($author$project$Pages$Hardware$CancelCreateNewRanking)
                    })
                ]))
            ]))
        ]));
    });
    var $Orasund$elm_ui_framework$Framework$Input$simple = _List_fromArray([
        $mdgriffith$elm_ui$Element$Background$color($Orasund$elm_ui_framework$Framework$Color$lighterGrey),
        $mdgriffith$elm_ui$Element$Font$color($Orasund$elm_ui_framework$Framework$Color$darkerGrey)
    ]);
    var $mdgriffith$elm_ui$Element$Input$TextInputNode = function(a) {
        return {
            $: "TextInputNode",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Element$Input$TextArea = {
        $: "TextArea"
    };
    var $mdgriffith$elm_ui$Internal$Model$LivePolite = {
        $: "LivePolite"
    };
    var $mdgriffith$elm_ui$Element$Region$announce = $mdgriffith$elm_ui$Internal$Model$Describe($mdgriffith$elm_ui$Internal$Model$LivePolite);
    var $mdgriffith$elm_ui$Element$Input$applyLabel = F3(function(attrs, label, input) {
        if (label.$ === "HiddenLabel") {
            var labelText = label.a;
            return A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asColumn, $mdgriffith$elm_ui$Internal$Model$NodeName("label"), attrs, $mdgriffith$elm_ui$Internal$Model$Unkeyed(_List_fromArray([
                input
            ])));
        } else {
            var position = label.a;
            var labelAttrs = label.b;
            var labelChild = label.c;
            var labelElement = A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asEl, $mdgriffith$elm_ui$Internal$Model$div, labelAttrs, $mdgriffith$elm_ui$Internal$Model$Unkeyed(_List_fromArray([
                labelChild
            ])));
            switch(position.$){
                case "Above":
                    return A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asColumn, $mdgriffith$elm_ui$Internal$Model$NodeName("label"), A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$htmlClass($mdgriffith$elm_ui$Internal$Style$classes.inputLabel), attrs), $mdgriffith$elm_ui$Internal$Model$Unkeyed(_List_fromArray([
                        labelElement,
                        input
                    ])));
                case "Below":
                    return A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asColumn, $mdgriffith$elm_ui$Internal$Model$NodeName("label"), A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$htmlClass($mdgriffith$elm_ui$Internal$Style$classes.inputLabel), attrs), $mdgriffith$elm_ui$Internal$Model$Unkeyed(_List_fromArray([
                        input,
                        labelElement
                    ])));
                case "OnRight":
                    return A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asRow, $mdgriffith$elm_ui$Internal$Model$NodeName("label"), A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$htmlClass($mdgriffith$elm_ui$Internal$Style$classes.inputLabel), attrs), $mdgriffith$elm_ui$Internal$Model$Unkeyed(_List_fromArray([
                        input,
                        labelElement
                    ])));
                default:
                    return A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asRow, $mdgriffith$elm_ui$Internal$Model$NodeName("label"), A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$htmlClass($mdgriffith$elm_ui$Internal$Style$classes.inputLabel), attrs), $mdgriffith$elm_ui$Internal$Model$Unkeyed(_List_fromArray([
                        labelElement,
                        input
                    ])));
            }
        }
    });
    var $mdgriffith$elm_ui$Element$Input$autofill = A2($elm$core$Basics$composeL, $mdgriffith$elm_ui$Internal$Model$Attr, $elm$html$Html$Attributes$attribute("autocomplete"));
    var $mdgriffith$elm_ui$Internal$Model$Behind = {
        $: "Behind"
    };
    var $mdgriffith$elm_ui$Element$createNearby = F2(function(loc, element) {
        if (element.$ === "Empty") return $mdgriffith$elm_ui$Internal$Model$NoAttribute;
        else return A2($mdgriffith$elm_ui$Internal$Model$Nearby, loc, element);
    });
    var $mdgriffith$elm_ui$Element$behindContent = function(element) {
        return A2($mdgriffith$elm_ui$Element$createNearby, $mdgriffith$elm_ui$Internal$Model$Behind, element);
    };
    var $mdgriffith$elm_ui$Internal$Model$MoveY = function(a) {
        return {
            $: "MoveY",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Internal$Flag$moveY = $mdgriffith$elm_ui$Internal$Flag$flag(26);
    var $mdgriffith$elm_ui$Element$moveUp = function(y) {
        return A2($mdgriffith$elm_ui$Internal$Model$TransformComponent, $mdgriffith$elm_ui$Internal$Flag$moveY, $mdgriffith$elm_ui$Internal$Model$MoveY(-y));
    };
    var $mdgriffith$elm_ui$Element$Input$calcMoveToCompensateForPadding = function(attrs) {
        var gatherSpacing = F2(function(attr, found) {
            if (attr.$ === "StyleClass" && attr.b.$ === "SpacingStyle") {
                var _v2 = attr.b;
                var x = _v2.b;
                var y = _v2.c;
                if (found.$ === "Nothing") return $elm$core$Maybe$Just(y);
                else return found;
            } else return found;
        });
        var _v0 = A3($elm$core$List$foldr, gatherSpacing, $elm$core$Maybe$Nothing, attrs);
        if (_v0.$ === "Nothing") return $mdgriffith$elm_ui$Internal$Model$NoAttribute;
        else {
            var vSpace = _v0.a;
            return $mdgriffith$elm_ui$Element$moveUp($elm$core$Basics$floor(vSpace / 2));
        }
    };
    var $mdgriffith$elm_ui$Internal$Flag$overflow = $mdgriffith$elm_ui$Internal$Flag$flag(20);
    var $mdgriffith$elm_ui$Element$clip = A2($mdgriffith$elm_ui$Internal$Model$Class, $mdgriffith$elm_ui$Internal$Flag$overflow, $mdgriffith$elm_ui$Internal$Style$classes.clip);
    var $mdgriffith$elm_ui$Element$Input$darkGrey = A3($mdgriffith$elm_ui$Element$rgb, 186 / 255, 189 / 255, 182 / 255);
    var $mdgriffith$elm_ui$Element$Input$defaultTextPadding = A2($mdgriffith$elm_ui$Element$paddingXY, 12, 12);
    var $mdgriffith$elm_ui$Element$Input$white = A3($mdgriffith$elm_ui$Element$rgb, 1, 1, 1);
    var $mdgriffith$elm_ui$Element$Input$defaultTextBoxStyle = _List_fromArray([
        $mdgriffith$elm_ui$Element$Input$defaultTextPadding,
        $mdgriffith$elm_ui$Element$Border$rounded(3),
        $mdgriffith$elm_ui$Element$Border$color($mdgriffith$elm_ui$Element$Input$darkGrey),
        $mdgriffith$elm_ui$Element$Background$color($mdgriffith$elm_ui$Element$Input$white),
        $mdgriffith$elm_ui$Element$Border$width(1),
        $mdgriffith$elm_ui$Element$spacing(5),
        $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill),
        $mdgriffith$elm_ui$Element$height($mdgriffith$elm_ui$Element$shrink)
    ]);
    var $mdgriffith$elm_ui$Element$Input$getHeight = function(attr) {
        if (attr.$ === "Height") {
            var h = attr.a;
            return $elm$core$Maybe$Just(h);
        } else return $elm$core$Maybe$Nothing;
    };
    var $mdgriffith$elm_ui$Internal$Model$Label = function(a) {
        return {
            $: "Label",
            a: a
        };
    };
    var $mdgriffith$elm_ui$Element$Input$hiddenLabelAttribute = function(label) {
        if (label.$ === "HiddenLabel") {
            var textLabel = label.a;
            return $mdgriffith$elm_ui$Internal$Model$Describe($mdgriffith$elm_ui$Internal$Model$Label(textLabel));
        } else return $mdgriffith$elm_ui$Internal$Model$NoAttribute;
    };
    var $mdgriffith$elm_ui$Internal$Model$InFront = {
        $: "InFront"
    };
    var $mdgriffith$elm_ui$Element$inFront = function(element) {
        return A2($mdgriffith$elm_ui$Element$createNearby, $mdgriffith$elm_ui$Internal$Model$InFront, element);
    };
    var $mdgriffith$elm_ui$Element$Input$isConstrained = function(len) {
        isConstrained: while(true)switch(len.$){
            case "Content":
                return false;
            case "Px":
                return true;
            case "Fill":
                return true;
            case "Min":
                var l = len.b;
                var $temp$len = l;
                len = $temp$len;
                continue isConstrained;
            default:
                var l = len.b;
                return true;
        }
    };
    var $mdgriffith$elm_ui$Element$Input$isHiddenLabel = function(label) {
        if (label.$ === "HiddenLabel") return true;
        else return false;
    };
    var $mdgriffith$elm_ui$Element$Input$isStacked = function(label) {
        if (label.$ === "Label") {
            var loc = label.a;
            switch(loc.$){
                case "OnRight":
                    return false;
                case "OnLeft":
                    return false;
                case "Above":
                    return true;
                default:
                    return true;
            }
        } else return true;
    };
    var $mdgriffith$elm_ui$Element$Input$negateBox = function(box) {
        return {
            bottom: -box.bottom,
            left: -box.left,
            right: -box.right,
            top: -box.top
        };
    };
    var $mdgriffith$elm_ui$Element$Input$isFill = function(len) {
        isFill: while(true)switch(len.$){
            case "Fill":
                return true;
            case "Content":
                return false;
            case "Px":
                return false;
            case "Min":
                var l = len.b;
                var $temp$len = l;
                len = $temp$len;
                continue isFill;
            default:
                var l = len.b;
                var $temp$len = l;
                len = $temp$len;
                continue isFill;
        }
    };
    var $mdgriffith$elm_ui$Element$Input$isPixel = function(len) {
        isPixel: while(true)switch(len.$){
            case "Content":
                return false;
            case "Px":
                return true;
            case "Fill":
                return false;
            case "Min":
                var l = len.b;
                var $temp$len = l;
                len = $temp$len;
                continue isPixel;
            default:
                var l = len.b;
                var $temp$len = l;
                len = $temp$len;
                continue isPixel;
        }
    };
    var $mdgriffith$elm_ui$Element$Input$redistributeOver = F4(function(isMultiline, stacked, attr, els) {
        switch(attr.$){
            case "Nearby":
                return _Utils_update(els, {
                    parent: A2($elm$core$List$cons, attr, els.parent)
                });
            case "Width":
                var width = attr.a;
                return $mdgriffith$elm_ui$Element$Input$isFill(width) ? _Utils_update(els, {
                    fullParent: A2($elm$core$List$cons, attr, els.fullParent),
                    input: A2($elm$core$List$cons, attr, els.input),
                    parent: A2($elm$core$List$cons, attr, els.parent)
                }) : stacked ? _Utils_update(els, {
                    fullParent: A2($elm$core$List$cons, attr, els.fullParent)
                }) : _Utils_update(els, {
                    parent: A2($elm$core$List$cons, attr, els.parent)
                });
            case "Height":
                var height = attr.a;
                return !stacked ? _Utils_update(els, {
                    fullParent: A2($elm$core$List$cons, attr, els.fullParent),
                    parent: A2($elm$core$List$cons, attr, els.parent)
                }) : $mdgriffith$elm_ui$Element$Input$isFill(height) ? _Utils_update(els, {
                    fullParent: A2($elm$core$List$cons, attr, els.fullParent),
                    parent: A2($elm$core$List$cons, attr, els.parent)
                }) : $mdgriffith$elm_ui$Element$Input$isPixel(height) ? _Utils_update(els, {
                    parent: A2($elm$core$List$cons, attr, els.parent)
                }) : _Utils_update(els, {
                    parent: A2($elm$core$List$cons, attr, els.parent)
                });
            case "AlignX":
                return _Utils_update(els, {
                    fullParent: A2($elm$core$List$cons, attr, els.fullParent)
                });
            case "AlignY":
                return _Utils_update(els, {
                    fullParent: A2($elm$core$List$cons, attr, els.fullParent)
                });
            case "StyleClass":
                switch(attr.b.$){
                    case "SpacingStyle":
                        var _v1 = attr.b;
                        return _Utils_update(els, {
                            fullParent: A2($elm$core$List$cons, attr, els.fullParent),
                            input: A2($elm$core$List$cons, attr, els.input),
                            parent: A2($elm$core$List$cons, attr, els.parent),
                            wrapper: A2($elm$core$List$cons, attr, els.wrapper)
                        });
                    case "PaddingStyle":
                        var cls = attr.a;
                        var _v2 = attr.b;
                        var pad = _v2.a;
                        var t = _v2.b;
                        var r = _v2.c;
                        var b = _v2.d;
                        var l = _v2.e;
                        if (isMultiline) return _Utils_update(els, {
                            cover: A2($elm$core$List$cons, attr, els.cover),
                            parent: A2($elm$core$List$cons, attr, els.parent)
                        });
                        else {
                            var newTop = t - A2($elm$core$Basics$min, t, b);
                            var newLineHeight = $mdgriffith$elm_ui$Element$htmlAttribute(A2($elm$html$Html$Attributes$style, "line-height", "calc(1.0em + " + ($elm$core$String$fromFloat(2 * A2($elm$core$Basics$min, t, b)) + "px)")));
                            var newHeight = $mdgriffith$elm_ui$Element$htmlAttribute(A2($elm$html$Html$Attributes$style, "height", "calc(1.0em + " + ($elm$core$String$fromFloat(2 * A2($elm$core$Basics$min, t, b)) + "px)")));
                            var newBottom = b - A2($elm$core$Basics$min, t, b);
                            var reducedVerticalPadding = A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$padding, A5($mdgriffith$elm_ui$Internal$Model$PaddingStyle, A4($mdgriffith$elm_ui$Internal$Model$paddingNameFloat, newTop, r, newBottom, l), newTop, r, newBottom, l));
                            return _Utils_update(els, {
                                cover: A2($elm$core$List$cons, attr, els.cover),
                                input: A2($elm$core$List$cons, newHeight, A2($elm$core$List$cons, newLineHeight, els.input)),
                                parent: A2($elm$core$List$cons, reducedVerticalPadding, els.parent)
                            });
                        }
                    case "BorderWidth":
                        var _v3 = attr.b;
                        return _Utils_update(els, {
                            cover: A2($elm$core$List$cons, attr, els.cover),
                            parent: A2($elm$core$List$cons, attr, els.parent)
                        });
                    case "Transform":
                        return _Utils_update(els, {
                            cover: A2($elm$core$List$cons, attr, els.cover),
                            parent: A2($elm$core$List$cons, attr, els.parent)
                        });
                    case "FontSize":
                        return _Utils_update(els, {
                            fullParent: A2($elm$core$List$cons, attr, els.fullParent)
                        });
                    case "FontFamily":
                        var _v4 = attr.b;
                        return _Utils_update(els, {
                            fullParent: A2($elm$core$List$cons, attr, els.fullParent)
                        });
                    default:
                        var flag = attr.a;
                        var cls = attr.b;
                        return _Utils_update(els, {
                            parent: A2($elm$core$List$cons, attr, els.parent)
                        });
                }
            case "NoAttribute":
                return els;
            case "Attr":
                var a = attr.a;
                return _Utils_update(els, {
                    input: A2($elm$core$List$cons, attr, els.input)
                });
            case "Describe":
                return _Utils_update(els, {
                    input: A2($elm$core$List$cons, attr, els.input)
                });
            case "Class":
                return _Utils_update(els, {
                    parent: A2($elm$core$List$cons, attr, els.parent)
                });
            default:
                return _Utils_update(els, {
                    input: A2($elm$core$List$cons, attr, els.input)
                });
        }
    });
    var $mdgriffith$elm_ui$Element$Input$redistribute = F3(function(isMultiline, stacked, attrs) {
        return function(redist) {
            return {
                cover: $elm$core$List$reverse(redist.cover),
                fullParent: $elm$core$List$reverse(redist.fullParent),
                input: $elm$core$List$reverse(redist.input),
                parent: $elm$core$List$reverse(redist.parent),
                wrapper: $elm$core$List$reverse(redist.wrapper)
            };
        }(A3($elm$core$List$foldl, A2($mdgriffith$elm_ui$Element$Input$redistributeOver, isMultiline, stacked), {
            cover: _List_Nil,
            fullParent: _List_Nil,
            input: _List_Nil,
            parent: _List_Nil,
            wrapper: _List_Nil
        }, attrs));
    });
    var $mdgriffith$elm_ui$Element$Input$renderBox = function(_v0) {
        var top = _v0.top;
        var right = _v0.right;
        var bottom = _v0.bottom;
        var left = _v0.left;
        return $elm$core$String$fromInt(top) + ("px " + ($elm$core$String$fromInt(right) + ("px " + ($elm$core$String$fromInt(bottom) + ("px " + ($elm$core$String$fromInt(left) + "px"))))));
    };
    var $mdgriffith$elm_ui$Internal$Model$Transparency = F2(function(a, b) {
        return {
            $: "Transparency",
            a: a,
            b: b
        };
    });
    var $mdgriffith$elm_ui$Internal$Flag$transparency = $mdgriffith$elm_ui$Internal$Flag$flag(0);
    var $mdgriffith$elm_ui$Element$alpha = function(o) {
        var transparency = function(x) {
            return 1 - x;
        }(A2($elm$core$Basics$min, 1.0, A2($elm$core$Basics$max, 0.0, o)));
        return A2($mdgriffith$elm_ui$Internal$Model$StyleClass, $mdgriffith$elm_ui$Internal$Flag$transparency, A2($mdgriffith$elm_ui$Internal$Model$Transparency, "transparency-" + $mdgriffith$elm_ui$Internal$Model$floatClass(transparency), transparency));
    };
    var $mdgriffith$elm_ui$Element$Input$charcoal = A3($mdgriffith$elm_ui$Element$rgb, 136 / 255, 138 / 255, 133 / 255);
    var $mdgriffith$elm_ui$Element$Input$renderPlaceholder = F3(function(_v0, forPlaceholder, on) {
        var placeholderAttrs = _v0.a;
        var placeholderEl = _v0.b;
        return A2($mdgriffith$elm_ui$Element$el, _Utils_ap(forPlaceholder, _Utils_ap(_List_fromArray([
            $mdgriffith$elm_ui$Element$Font$color($mdgriffith$elm_ui$Element$Input$charcoal),
            $mdgriffith$elm_ui$Internal$Model$htmlClass($mdgriffith$elm_ui$Internal$Style$classes.noTextSelection + (" " + $mdgriffith$elm_ui$Internal$Style$classes.passPointerEvents)),
            $mdgriffith$elm_ui$Element$clip,
            $mdgriffith$elm_ui$Element$Border$color(A4($mdgriffith$elm_ui$Element$rgba, 0, 0, 0, 0)),
            $mdgriffith$elm_ui$Element$Background$color(A4($mdgriffith$elm_ui$Element$rgba, 0, 0, 0, 0)),
            $mdgriffith$elm_ui$Element$height($mdgriffith$elm_ui$Element$fill),
            $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill),
            $mdgriffith$elm_ui$Element$alpha(on ? 1 : 0)
        ]), placeholderAttrs)), placeholderEl);
    });
    var $mdgriffith$elm_ui$Element$scrollbarY = A2($mdgriffith$elm_ui$Internal$Model$Class, $mdgriffith$elm_ui$Internal$Flag$overflow, $mdgriffith$elm_ui$Internal$Style$classes.scrollbarsY);
    var $elm$html$Html$Attributes$spellcheck = $elm$html$Html$Attributes$boolProperty("spellcheck");
    var $mdgriffith$elm_ui$Element$Input$spellcheck = A2($elm$core$Basics$composeL, $mdgriffith$elm_ui$Internal$Model$Attr, $elm$html$Html$Attributes$spellcheck);
    var $mdgriffith$elm_ui$Internal$Model$unstyled = A2($elm$core$Basics$composeL, $mdgriffith$elm_ui$Internal$Model$Unstyled, $elm$core$Basics$always);
    var $mdgriffith$elm_ui$Element$Input$value = A2($elm$core$Basics$composeL, $mdgriffith$elm_ui$Internal$Model$Attr, $elm$html$Html$Attributes$value);
    var $mdgriffith$elm_ui$Element$Input$textHelper = F3(function(textInput, attrs, textOptions) {
        var withDefaults = _Utils_ap($mdgriffith$elm_ui$Element$Input$defaultTextBoxStyle, attrs);
        var redistributed = A3($mdgriffith$elm_ui$Element$Input$redistribute, _Utils_eq(textInput.type_, $mdgriffith$elm_ui$Element$Input$TextArea), $mdgriffith$elm_ui$Element$Input$isStacked(textOptions.label), withDefaults);
        var onlySpacing = function(attr) {
            if (attr.$ === "StyleClass" && attr.b.$ === "SpacingStyle") {
                var _v9 = attr.b;
                return true;
            } else return false;
        };
        var heightConstrained = function() {
            var _v7 = textInput.type_;
            if (_v7.$ === "TextInputNode") {
                var inputType = _v7.a;
                return false;
            } else return A2($elm$core$Maybe$withDefault, false, A2($elm$core$Maybe$map, $mdgriffith$elm_ui$Element$Input$isConstrained, $elm$core$List$head($elm$core$List$reverse(A2($elm$core$List$filterMap, $mdgriffith$elm_ui$Element$Input$getHeight, withDefaults)))));
        }();
        var getPadding = function(attr) {
            if (attr.$ === "StyleClass" && attr.b.$ === "PaddingStyle") {
                var cls = attr.a;
                var _v6 = attr.b;
                var pad = _v6.a;
                var t = _v6.b;
                var r = _v6.c;
                var b = _v6.d;
                var l = _v6.e;
                return $elm$core$Maybe$Just({
                    bottom: A2($elm$core$Basics$max, 0, $elm$core$Basics$floor(b - 3)),
                    left: A2($elm$core$Basics$max, 0, $elm$core$Basics$floor(l - 3)),
                    right: A2($elm$core$Basics$max, 0, $elm$core$Basics$floor(r - 3)),
                    top: A2($elm$core$Basics$max, 0, $elm$core$Basics$floor(t - 3))
                });
            } else return $elm$core$Maybe$Nothing;
        };
        var parentPadding = A2($elm$core$Maybe$withDefault, {
            bottom: 0,
            left: 0,
            right: 0,
            top: 0
        }, $elm$core$List$head($elm$core$List$reverse(A2($elm$core$List$filterMap, getPadding, withDefaults))));
        var inputElement = A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asEl, function() {
            var _v3 = textInput.type_;
            if (_v3.$ === "TextInputNode") {
                var inputType = _v3.a;
                return $mdgriffith$elm_ui$Internal$Model$NodeName("input");
            } else return $mdgriffith$elm_ui$Internal$Model$NodeName("textarea");
        }(), _Utils_ap(function() {
            var _v4 = textInput.type_;
            if (_v4.$ === "TextInputNode") {
                var inputType = _v4.a;
                return _List_fromArray([
                    $mdgriffith$elm_ui$Internal$Model$Attr($elm$html$Html$Attributes$type_(inputType)),
                    $mdgriffith$elm_ui$Internal$Model$htmlClass($mdgriffith$elm_ui$Internal$Style$classes.inputText)
                ]);
            } else return _List_fromArray([
                $mdgriffith$elm_ui$Element$clip,
                $mdgriffith$elm_ui$Element$height($mdgriffith$elm_ui$Element$fill),
                $mdgriffith$elm_ui$Internal$Model$htmlClass($mdgriffith$elm_ui$Internal$Style$classes.inputMultiline),
                $mdgriffith$elm_ui$Element$Input$calcMoveToCompensateForPadding(withDefaults),
                $mdgriffith$elm_ui$Element$paddingEach(parentPadding),
                $mdgriffith$elm_ui$Internal$Model$Attr(A2($elm$html$Html$Attributes$style, "margin", $mdgriffith$elm_ui$Element$Input$renderBox($mdgriffith$elm_ui$Element$Input$negateBox(parentPadding)))),
                $mdgriffith$elm_ui$Internal$Model$Attr(A2($elm$html$Html$Attributes$style, "box-sizing", "content-box"))
            ]);
        }(), _Utils_ap(_List_fromArray([
            $mdgriffith$elm_ui$Element$Input$value(textOptions.text),
            $mdgriffith$elm_ui$Internal$Model$Attr($elm$html$Html$Events$onInput(textOptions.onChange)),
            $mdgriffith$elm_ui$Element$Input$hiddenLabelAttribute(textOptions.label),
            $mdgriffith$elm_ui$Element$Input$spellcheck(textInput.spellchecked),
            A2($elm$core$Maybe$withDefault, $mdgriffith$elm_ui$Internal$Model$NoAttribute, A2($elm$core$Maybe$map, $mdgriffith$elm_ui$Element$Input$autofill, textInput.autofill))
        ]), redistributed.input)), $mdgriffith$elm_ui$Internal$Model$Unkeyed(_List_Nil));
        var wrappedInput = function() {
            var _v0 = textInput.type_;
            if (_v0.$ === "TextArea") return A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asEl, $mdgriffith$elm_ui$Internal$Model$div, _Utils_ap((heightConstrained ? $elm$core$List$cons($mdgriffith$elm_ui$Element$scrollbarY) : $elm$core$Basics$identity)(_List_fromArray([
                $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill),
                A2($elm$core$List$any, $mdgriffith$elm_ui$Element$Input$hasFocusStyle, withDefaults) ? $mdgriffith$elm_ui$Internal$Model$NoAttribute : $mdgriffith$elm_ui$Internal$Model$htmlClass($mdgriffith$elm_ui$Internal$Style$classes.focusedWithin),
                $mdgriffith$elm_ui$Internal$Model$htmlClass($mdgriffith$elm_ui$Internal$Style$classes.inputMultilineWrapper)
            ])), redistributed.parent), $mdgriffith$elm_ui$Internal$Model$Unkeyed(_List_fromArray([
                A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asParagraph, $mdgriffith$elm_ui$Internal$Model$div, A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill), A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$height($mdgriffith$elm_ui$Element$fill), A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$inFront(inputElement), A2($elm$core$List$cons, $mdgriffith$elm_ui$Internal$Model$htmlClass($mdgriffith$elm_ui$Internal$Style$classes.inputMultilineParent), redistributed.wrapper)))), $mdgriffith$elm_ui$Internal$Model$Unkeyed(function() {
                    if (textOptions.text === "") {
                        var _v1 = textOptions.placeholder;
                        if (_v1.$ === "Nothing") return _List_fromArray([
                            $mdgriffith$elm_ui$Element$text("\xa0")
                        ]);
                        else {
                            var place = _v1.a;
                            return _List_fromArray([
                                A3($mdgriffith$elm_ui$Element$Input$renderPlaceholder, place, _List_Nil, textOptions.text === "")
                            ]);
                        }
                    } else return _List_fromArray([
                        $mdgriffith$elm_ui$Internal$Model$unstyled(A2($elm$html$Html$span, _List_fromArray([
                            $elm$html$Html$Attributes$class($mdgriffith$elm_ui$Internal$Style$classes.inputMultilineFiller)
                        ]), _List_fromArray([
                            $elm$html$Html$text(textOptions.text + "\xa0")
                        ])))
                    ]);
                }()))
            ])));
            else {
                var inputType = _v0.a;
                return A4($mdgriffith$elm_ui$Internal$Model$element, $mdgriffith$elm_ui$Internal$Model$asEl, $mdgriffith$elm_ui$Internal$Model$div, A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill), A2($elm$core$List$cons, A2($elm$core$List$any, $mdgriffith$elm_ui$Element$Input$hasFocusStyle, withDefaults) ? $mdgriffith$elm_ui$Internal$Model$NoAttribute : $mdgriffith$elm_ui$Internal$Model$htmlClass($mdgriffith$elm_ui$Internal$Style$classes.focusedWithin), $elm$core$List$concat(_List_fromArray([
                    redistributed.parent,
                    function() {
                        var _v2 = textOptions.placeholder;
                        if (_v2.$ === "Nothing") return _List_Nil;
                        else {
                            var place = _v2.a;
                            return _List_fromArray([
                                $mdgriffith$elm_ui$Element$behindContent(A3($mdgriffith$elm_ui$Element$Input$renderPlaceholder, place, redistributed.cover, textOptions.text === ""))
                            ]);
                        }
                    }()
                ])))), $mdgriffith$elm_ui$Internal$Model$Unkeyed(_List_fromArray([
                    inputElement
                ])));
            }
        }();
        return A3($mdgriffith$elm_ui$Element$Input$applyLabel, A2($elm$core$List$cons, A2($mdgriffith$elm_ui$Internal$Model$Class, $mdgriffith$elm_ui$Internal$Flag$cursor, $mdgriffith$elm_ui$Internal$Style$classes.cursorText), A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$Input$isHiddenLabel(textOptions.label) ? $mdgriffith$elm_ui$Internal$Model$NoAttribute : $mdgriffith$elm_ui$Element$spacing(5), A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$Region$announce, redistributed.fullParent))), textOptions.label, wrappedInput);
    });
    var $mdgriffith$elm_ui$Element$Input$text = $mdgriffith$elm_ui$Element$Input$textHelper({
        autofill: $elm$core$Maybe$Nothing,
        spellchecked: false,
        type_: $mdgriffith$elm_ui$Element$Input$TextInputNode("text")
    });
    var $author$project$Pages$Hardware$createLadderView = F2(function(userInfo, ranking) {
        return A2($Orasund$elm_ui_framework$Framework$responsiveLayout, _List_Nil, A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$section, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h5, $mdgriffith$elm_ui$Element$text(userInfo.nickname + " - Please Enter Your Ladder \nDetails And Click 'Create' below:")),
            A2($mdgriffith$elm_ui$Element$wrappedRow, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$fill, $Orasund$elm_ui_framework$Framework$Grid$simple), _List_fromArray([
                A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$simple, _List_fromArray([
                    A2($mdgriffith$elm_ui$Element$Input$text, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$simple, _List_fromArray([
                        $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("RankingName"))
                    ])), {
                        label: A2($mdgriffith$elm_ui$Element$Input$labelLeft, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$label, _List_fromArray([
                            $mdgriffith$elm_ui$Element$moveLeft(11.0)
                        ])), $mdgriffith$elm_ui$Element$text("Ranking name*")),
                        onChange: $author$project$Pages$Hardware$RankingNameChg,
                        placeholder: $elm$core$Maybe$Just(A2($mdgriffith$elm_ui$Element$Input$placeholder, _List_Nil, $mdgriffith$elm_ui$Element$text("Ranking name*"))),
                        text: ranking.name
                    }),
                    $author$project$SR$Elements$ladderNameValidation(ranking),
                    A2($mdgriffith$elm_ui$Element$Input$text, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$simple, _List_fromArray([
                        $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("Street"))
                    ])), {
                        label: A2($mdgriffith$elm_ui$Element$Input$labelLeft, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$label, _List_fromArray([
                            $mdgriffith$elm_ui$Element$moveLeft(11.0)
                        ])), $mdgriffith$elm_ui$Element$text("Street")),
                        onChange: $author$project$Pages$Hardware$StreetAddressChg,
                        placeholder: $elm$core$Maybe$Just(A2($mdgriffith$elm_ui$Element$Input$placeholder, _List_Nil, $mdgriffith$elm_ui$Element$text("Street"))),
                        text: ranking.baseaddress.street
                    }),
                    $author$project$SR$Elements$ladderStreetValidation(ranking),
                    A2($mdgriffith$elm_ui$Element$Input$text, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$simple, _List_fromArray([
                        $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("City"))
                    ])), {
                        label: A2($mdgriffith$elm_ui$Element$Input$labelLeft, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$label, _List_fromArray([
                            $mdgriffith$elm_ui$Element$moveLeft(11.0)
                        ])), $mdgriffith$elm_ui$Element$text("City")),
                        onChange: $author$project$Pages$Hardware$CityAddressChg,
                        placeholder: $elm$core$Maybe$Just(A2($mdgriffith$elm_ui$Element$Input$placeholder, _List_Nil, $mdgriffith$elm_ui$Element$text("City"))),
                        text: ranking.baseaddress.city
                    }),
                    $author$project$SR$Elements$ladderCityValidation(ranking)
                ]))
            ])),
            $mdgriffith$elm_ui$Element$text("* required"),
            A2($author$project$Pages$Hardware$rankingDetailsConfirmPanel, ranking, userInfo)
        ])));
    });
    var $author$project$SR$Elements$ownedSelectedRankingHeaderEl = function(r) {
        return A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h5, $mdgriffith$elm_ui$Element$text(r.owner_name + (" this your owned ranking" + (" - " + (r.name + (" . \n Id is: " + r.id))))));
    };
    var $author$project$Pages$Hardware$dialogueConfirmChallengeView = F3(function(uinfo, rank, ranking) {
        return A2($Orasund$elm_ui_framework$Framework$responsiveLayout, _List_Nil, A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$container, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h5, $mdgriffith$elm_ui$Element$text(ranking.owner_name + (" - Are you sure you want to challenge " + (rank.player.nickname + "?")))),
            A2($mdgriffith$elm_ui$Element$wrappedRow, _List_Nil, _List_fromArray([
                $author$project$SR$Elements$ownedSelectedRankingHeaderEl(ranking)
            ])),
            A2($mdgriffith$elm_ui$Element$column, A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill), _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple)), _List_fromArray([
                A2($author$project$Pages$Hardware$infoBtn, "Confirm", A2($author$project$Pages$Hardware$ConfirmChallenge, ranking, rank)),
                A2($author$project$Pages$Hardware$infoBtn, "Cancel", $author$project$Pages$Hardware$Cancel)
            ]))
        ])));
    });
    var $author$project$Pages$Hardware$DeleteOwnedRanking = {
        $: "DeleteOwnedRanking"
    };
    var $author$project$Pages$Hardware$dialogueDeleteOwnedView = F2(function(uinfo, ranking) {
        return A2($Orasund$elm_ui_framework$Framework$responsiveLayout, _List_Nil, A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$container, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h6, $mdgriffith$elm_ui$Element$text(ranking.owner_name + " - Are you sure you want to delete this ranking?\n            Please note that this will delete all your AND THE \n            RANKING MEMBER'S rankings and is IRREVERSIBLE!\n            (You may wish to inform them before deleting)")),
            A2($mdgriffith$elm_ui$Element$wrappedRow, _List_Nil, _List_fromArray([
                $author$project$SR$Elements$ownedSelectedRankingHeaderEl(ranking)
            ])),
            A2($mdgriffith$elm_ui$Element$column, A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill), _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple)), _List_fromArray([
                A2($author$project$Pages$Hardware$infoBtn, "Delete", $author$project$Pages$Hardware$DeleteOwnedRanking),
                A2($author$project$Pages$Hardware$infoBtn, "Cancel", $author$project$Pages$Hardware$Cancel)
            ]))
        ])));
    });
    var $author$project$Pages$Hardware$CancelDialoguePrepareResultView = {
        $: "CancelDialoguePrepareResultView"
    };
    var $author$project$Pages$Hardware$ConfirmResult = function(a) {
        return {
            $: "ConfirmResult",
            a: a
        };
    };
    var $author$project$Data$Hardware$Lost = {
        $: "Lost"
    };
    var $author$project$Data$Hardware$Won = {
        $: "Won"
    };
    var $author$project$Data$Hardware$isUserOwnerOfRankning = F2(function(userid, ranking) {
        return _Utils_eq(ranking.owner_id, userid) ? true : false;
    });
    var $author$project$Pages$Hardware$dialoguePrepareResultView = F3(function(uinfo, rank, ranking) {
        return A2($Orasund$elm_ui_framework$Framework$responsiveLayout, _List_Nil, A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$container, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h5, $mdgriffith$elm_ui$Element$text(uinfo.nickname + (" - Are you ready to enter your result vs " + (rank.challenger.nickname + "?")))),
            A2($author$project$Data$Hardware$isUserOwnerOfRankning, uinfo.userid, ranking) ? A2($mdgriffith$elm_ui$Element$wrappedRow, _List_Nil, _List_fromArray([
                A2($author$project$SR$Elements$memberSelectedRankingHeaderEl, uinfo, ranking)
            ])) : A2($mdgriffith$elm_ui$Element$wrappedRow, _List_Nil, _List_fromArray([
                A2($author$project$SR$Elements$memberSelectedRankingHeaderEl, uinfo, ranking)
            ])),
            A2($mdgriffith$elm_ui$Element$column, A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill), _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple)), _List_fromArray([
                A2($author$project$Pages$Hardware$infoBtn, "Win", $author$project$Pages$Hardware$ConfirmResult($author$project$Data$Hardware$Won)),
                A2($author$project$Pages$Hardware$infoBtn, "Lose", $author$project$Pages$Hardware$ConfirmResult($author$project$Data$Hardware$Lost)),
                A2($author$project$Pages$Hardware$infoBtn, "Abandon Challenge", $author$project$Pages$Hardware$ConfirmResult($author$project$Data$Hardware$Undecided)),
                A2($author$project$Pages$Hardware$infoBtn, "Cancel", $author$project$Pages$Hardware$CancelDialoguePrepareResultView)
            ]))
        ])));
    });
    var $author$project$Pages$Hardware$ClickedHardwareDeviceConnect = {
        $: "ClickedHardwareDeviceConnect"
    };
    var $author$project$Pages$Hardware$ClickedXMRInitiateTransaction = function(a) {
        return {
            $: "ClickedXMRInitiateTransaction",
            a: a
        };
    };
    var $author$project$Pages$Hardware$ClickedXMRWalletConnect = {
        $: "ClickedXMRWalletConnect"
    };
    var $author$project$Pages$Hardware$hardwareWalletView = function(model) {
        return A2($Orasund$elm_ui_framework$Framework$responsiveLayout, _List_Nil, A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$container, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h5, $mdgriffith$elm_ui$Element$text("Haveno-Web")),
            $mdgriffith$elm_ui$Element$text("\n"),
            A2($author$project$Pages$Hardware$infoBtn, "Connect Hardware Device", $author$project$Pages$Hardware$ClickedHardwareDeviceConnect),
            $mdgriffith$elm_ui$Element$text("\n"),
            A2($author$project$Pages$Hardware$infoBtn, "Connect XMR Wallet", $author$project$Pages$Hardware$ClickedXMRWalletConnect),
            $mdgriffith$elm_ui$Element$text("\n"),
            A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h6, $mdgriffith$elm_ui$Element$text(model.isHardwareLNSConnected ? "Nano S Connected" : model.isHardwareLNXConnected ? "Nano X Connected" : model.isXMRWalletConnected ? "XMR Wallet Connected" : "Not connected yet")),
            $mdgriffith$elm_ui$Element$text("\n"),
            A2($author$project$Pages$Hardware$infoBtn, "Connect XMR Wallet", $author$project$Pages$Hardware$ClickedXMRInitiateTransaction("0.01")),
            function() {
                var _v0 = model.errors;
                if (!_v0.b) return $mdgriffith$elm_ui$Element$text("");
                else return A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$section, A2($elm$core$List$map, function(error) {
                    return A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h6, $mdgriffith$elm_ui$Element$text(error));
                }, model.errors));
            }()
        ])));
    };
    var $author$project$Pages$Hardware$DialogueConfirmLeaveView = {
        $: "DialogueConfirmLeaveView"
    };
    var $author$project$Pages$Hardware$ViewRank = function(a) {
        return {
            $: "ViewRank",
            a: a
        };
    };
    var $author$project$Pages$Hardware$challengeInProgressBtnDisabled = function(r) {
        return A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$simple, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$Input$button, _Utils_ap($Orasund$elm_ui_framework$Framework$Button$fill, $author$project$Pages$Hardware$enableButton(false)), {
                label: $mdgriffith$elm_ui$Element$text($elm$core$String$fromInt(r.rank) + (". " + (r.player.nickname + (" vs " + r.challenger.nickname)))),
                onPress: $elm$core$Maybe$Just($author$project$Pages$Hardware$ViewRank(r))
            })
        ]));
    };
    var $Orasund$elm_ui_framework$Framework$Color$primary = _List_fromArray([
        $mdgriffith$elm_ui$Element$Background$color($Orasund$elm_ui_framework$Framework$Color$turquoise),
        $mdgriffith$elm_ui$Element$Border$color($Orasund$elm_ui_framework$Framework$Color$turquoise)
    ]);
    var $author$project$Pages$Hardware$challengeInProgressBtnEnabled = function(r) {
        return A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$simple, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$Input$button, _Utils_ap($Orasund$elm_ui_framework$Framework$Button$fill, $Orasund$elm_ui_framework$Framework$Color$primary), {
                label: $mdgriffith$elm_ui$Element$text($elm$core$String$fromInt(r.rank) + (". " + (r.player.nickname + (" vs " + r.challenger.nickname)))),
                onPress: $elm$core$Maybe$Just($author$project$Pages$Hardware$ViewRank(r))
            })
        ]));
    };
    var $author$project$Pages$Hardware$determineButtonType = F2(function(loggedInUsersRank, rankBeingIterated) {
        var rankBeingIteratedIsInAChallenge = !_Utils_eq(rankBeingIterated.challenger.id, $author$project$Extras$Constants$noCurrentChallengerId);
        var loggedInUserIsInAChallenge = !_Utils_eq(loggedInUsersRank.challenger.id, $author$project$Extras$Constants$noCurrentChallengerId);
        return loggedInUserIsInAChallenge ? _Utils_eq(loggedInUsersRank.player.id, rankBeingIterated.player.id) ? 1 : _Utils_eq(loggedInUsersRank.player.id, rankBeingIterated.challenger.id) ? 2 : 4 : rankBeingIteratedIsInAChallenge ? _Utils_eq(loggedInUsersRank.player.id, rankBeingIterated.player.id) ? 1 : 2 : _Utils_eq(loggedInUsersRank.rank - 1, rankBeingIterated.rank) ? 3 : 4;
    });
    var $author$project$Pages$Hardware$singlePlayerBtnDisabled = function(r) {
        return A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$simple, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$Input$button, _Utils_ap($Orasund$elm_ui_framework$Framework$Button$fill, $author$project$Pages$Hardware$enableButton(false)), {
                label: $mdgriffith$elm_ui$Element$text($elm$core$String$fromInt(r.rank) + (". " + r.player.nickname)),
                onPress: $elm$core$Maybe$Just($author$project$Pages$Hardware$ViewRank(r))
            })
        ]));
    };
    var $author$project$Pages$Hardware$singlePlayerBtnEnabled = function(r) {
        return A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$simple, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$Input$button, _Utils_ap($Orasund$elm_ui_framework$Framework$Button$fill, $Orasund$elm_ui_framework$Framework$Color$primary), {
                label: $mdgriffith$elm_ui$Element$text($elm$core$String$fromInt(r.rank) + (". " + r.player.nickname)),
                onPress: $elm$core$Maybe$Just($author$project$Pages$Hardware$ViewRank(r))
            })
        ]));
    };
    var $author$project$Pages$Hardware$configureThenAddPlayerRankingBtns = F2(function(currentUserRank, rank) {
        var elementMsg = A2($author$project$Pages$Hardware$determineButtonType, currentUserRank, rank) === 1 ? $author$project$Pages$Hardware$challengeInProgressBtnEnabled(rank) : A2($author$project$Pages$Hardware$determineButtonType, currentUserRank, rank) === 2 ? $author$project$Pages$Hardware$challengeInProgressBtnDisabled(rank) : A2($author$project$Pages$Hardware$determineButtonType, currentUserRank, rank) === 3 ? $author$project$Pages$Hardware$singlePlayerBtnEnabled(rank) : $author$project$Pages$Hardware$singlePlayerBtnDisabled(rank);
        return elementMsg;
    });
    var $author$project$Pages$Hardware$findUserRank = F2(function(userid, ladder) {
        return $elm$core$List$head(A2($elm$core$List$filter, function(r) {
            return _Utils_eq(r.player.id, userid);
        }, ladder));
    });
    var $author$project$Pages$Hardware$playerbuttons = F2(function(r, u) {
        var currentUserRank = A2($elm$core$Maybe$withDefault, $author$project$Data$Hardware$emptyRank, A2($author$project$Pages$Hardware$findUserRank, u.userid, r.ladder));
        return A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$section, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$column, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple), A2($elm$core$List$map, $author$project$Pages$Hardware$configureThenAddPlayerRankingBtns(currentUserRank), r.ladder))
        ]));
    });
    var $author$project$Pages$Hardware$memberSelectedView = F2(function(u, r) {
        return A2($Orasund$elm_ui_framework$Framework$responsiveLayout, _List_Nil, A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$container, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$wrappedRow, _List_Nil, _List_fromArray([
                A2($author$project$SR$Elements$memberSelectedRankingHeaderEl, u, r)
            ])),
            A2($mdgriffith$elm_ui$Element$column, A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill), _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple)), _List_fromArray([
                A2($author$project$Pages$Hardware$infoBtn, "Leave", $author$project$Pages$Hardware$DialogueConfirmLeaveView),
                A2($author$project$Pages$Hardware$infoBtn, "Cancel", $author$project$Pages$Hardware$CancelFetchedMember),
                A2($author$project$Pages$Hardware$playerbuttons, r, u)
            ]))
        ])));
    });
    var $author$project$Pages$Hardware$CancelFetchedOwned = function(a) {
        return {
            $: "CancelFetchedOwned",
            a: a
        };
    };
    var $author$project$Pages$Hardware$DialogDeleteOwnedRanking = {
        $: "DialogDeleteOwnedRanking"
    };
    var $author$project$Pages$Hardware$ownedSelectedView = F2(function(u, r) {
        return A2($Orasund$elm_ui_framework$Framework$responsiveLayout, _List_Nil, A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$container, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$wrappedRow, _List_Nil, _List_fromArray([
                $author$project$SR$Elements$ownedSelectedRankingHeaderEl(r)
            ])),
            A2($mdgriffith$elm_ui$Element$column, A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill), _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple)), _List_fromArray([
                A2($author$project$Pages$Hardware$infoBtn, "Delete", $author$project$Pages$Hardware$DialogDeleteOwnedRanking),
                A2($author$project$Pages$Hardware$infoBtn, "Cancel", $author$project$Pages$Hardware$CancelFetchedOwned(u)),
                A2($author$project$Pages$Hardware$playerbuttons, r, u)
            ]))
        ])));
    });
    var $mdgriffith$elm_ui$Element$Input$email = $mdgriffith$elm_ui$Element$Input$textHelper({
        autofill: $elm$core$Maybe$Just("email"),
        spellchecked: false,
        type_: $mdgriffith$elm_ui$Element$Input$TextInputNode("email")
    });
    var $author$project$Utils$Validation$Validate$isEmailValid = function(newEmail) {
        return A2($elm$regex$Regex$contains, A2($elm$core$Maybe$withDefault, $elm$regex$Regex$never, $elm$regex$Regex$fromString("[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?")), newEmail);
    };
    var $author$project$Pages$Hardware$emailValidationErr = function(str) {
        return $author$project$Utils$Validation$Validate$isEmailValid(str) && !!$elm$core$String$length(str) ? A2($mdgriffith$elm_ui$Element$el, A2($elm$core$List$append, _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$color($author$project$SR$Elements$colors.green),
            $mdgriffith$elm_ui$Element$Font$alignLeft
        ]), _List_fromArray([
            $mdgriffith$elm_ui$Element$moveLeft(1.0)
        ])), $mdgriffith$elm_ui$Element$text("Email OK!")) : A2($mdgriffith$elm_ui$Element$el, A2($elm$core$List$append, _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$color($author$project$SR$Elements$colors.red),
            $mdgriffith$elm_ui$Element$Font$alignLeft
        ]), _List_fromArray([
            $mdgriffith$elm_ui$Element$moveLeft(7.0)
        ])), $mdgriffith$elm_ui$Element$text(" Please enter \n a valid email"));
    };
    var $elm$html$Html$Attributes$autofocus = $elm$html$Html$Attributes$boolProperty("autofocus");
    var $mdgriffith$elm_ui$Element$Input$focusedOnLoad = $mdgriffith$elm_ui$Internal$Model$Attr($elm$html$Html$Attributes$autofocus(true));
    var $author$project$SR$Elements$justParasimpleUserInfoText = A2($mdgriffith$elm_ui$Element$paragraph, _List_Nil, $elm$core$List$singleton($mdgriffith$elm_ui$Element$text("Can your challengers reach you if you don't submit contact details?")));
    var $author$project$Utils$Validation$Validate$isMobileValid = function(newMobile) {
        return newMobile === "" ? true : A2($elm$regex$Regex$contains, A2($elm$core$Maybe$withDefault, $elm$regex$Regex$never, $elm$regex$Regex$fromString("^\\+((?:9[679]|8[035789]|6[789]|5[90]|42|3[578]|2[1-689])|9[0-58]|8[1246]|6[0-6]|5[1-8]|4[013-9]|3[0-469]|2[70]|7|1)(?:\\W*\\d){0,13}\\d$")), newMobile);
    };
    var $author$project$Pages$Hardware$mobileValidationErr = function(str) {
        return $author$project$Utils$Validation$Validate$isMobileValid(str) ? A2($mdgriffith$elm_ui$Element$el, A2($elm$core$List$append, _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$color($author$project$SR$Elements$colors.green),
            $mdgriffith$elm_ui$Element$Font$alignLeft
        ]), _List_fromArray([
            $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("userMobileValid"))
        ])), $mdgriffith$elm_ui$Element$text("Mobile OK!")) : $elm$core$String$length(str) > 0 ? A2($mdgriffith$elm_ui$Element$el, _Utils_ap(A2($elm$core$List$append, _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$color($author$project$SR$Elements$colors.red),
            $mdgriffith$elm_ui$Element$Font$alignLeft
        ]), _List_fromArray([
            $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("userMobileInvalid"))
        ])), _List_fromArray([
            $mdgriffith$elm_ui$Element$moveLeft(5.0)
        ])), $mdgriffith$elm_ui$Element$text(" Mobile number, if\n entered, must be valid (+ not 00)")) : A2($mdgriffith$elm_ui$Element$el, _List_Nil, $mdgriffith$elm_ui$Element$text(""));
    };
    var $author$project$Utils$Validation$Validate$isValid4to8Chars = function(str) {
        return A2($elm$regex$Regex$contains, A2($elm$core$Maybe$withDefault, $elm$regex$Regex$never, $elm$regex$Regex$fromString("(?!.*[\\.\\-\\_]{2,})^[a-zA-Z0-9\\.\\-\\_]{4,8}$")), str);
    };
    var $author$project$SR$Elements$nameValidView = function(userInfo) {
        return !$elm$core$String$length(userInfo.nickname) ? A2($mdgriffith$elm_ui$Element$el, _Utils_ap(A2($elm$core$List$append, _List_fromArray([
            $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("usernameValidMsg"))
        ]), _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$color($author$project$SR$Elements$colors.green),
            $mdgriffith$elm_ui$Element$Font$alignLeft
        ])), _List_fromArray([
            $mdgriffith$elm_ui$Element$moveLeft(1.0)
        ])), $mdgriffith$elm_ui$Element$text("Anon OK!")) : $author$project$Utils$Validation$Validate$isValid4to8Chars(userInfo.nickname) ? A2($mdgriffith$elm_ui$Element$el, _Utils_ap(A2($elm$core$List$append, _List_fromArray([
            $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("usernameValidMsg"))
        ]), _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$color($author$project$SR$Elements$colors.green),
            $mdgriffith$elm_ui$Element$Font$alignLeft
        ])), _List_fromArray([
            $mdgriffith$elm_ui$Element$moveLeft(1.0)
        ])), $mdgriffith$elm_ui$Element$text("Nickname OK!")) : A2($mdgriffith$elm_ui$Element$el, _Utils_ap(A2($elm$core$List$append, _List_fromArray([
            $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("usernameValidMsg"))
        ]), _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$color($author$project$SR$Elements$colors.red),
            $mdgriffith$elm_ui$Element$Font$alignLeft
        ])), _List_fromArray([
            $mdgriffith$elm_ui$Element$moveLeft(0.0)
        ])), $mdgriffith$elm_ui$Element$text("If entered please make \nunique and 5-8 continuous chars"));
    };
    var $mdgriffith$elm_ui$Element$Input$newPassword = F2(function(attrs, pass) {
        return A3($mdgriffith$elm_ui$Element$Input$textHelper, {
            autofill: $elm$core$Maybe$Just("new-password"),
            spellchecked: false,
            type_: $mdgriffith$elm_ui$Element$Input$TextInputNode(pass.show ? "text" : "password")
        }, attrs, {
            label: pass.label,
            onChange: pass.onChange,
            placeholder: pass.placeholder,
            text: pass.text
        });
    });
    var $author$project$SR$Elements$passwordValidView = function(userInfo) {
        return $author$project$Utils$Validation$Validate$isValid4to8Chars(userInfo.password) ? A2($mdgriffith$elm_ui$Element$el, _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$color($author$project$SR$Elements$colors.green),
            $mdgriffith$elm_ui$Element$Font$alignLeft,
            $mdgriffith$elm_ui$Element$moveLeft(1.0)
        ]), $mdgriffith$elm_ui$Element$text("Password OK!")) : A2($mdgriffith$elm_ui$Element$el, _List_fromArray([
            $mdgriffith$elm_ui$Element$Font$color($author$project$SR$Elements$colors.red),
            $mdgriffith$elm_ui$Element$Font$alignLeft,
            $mdgriffith$elm_ui$Element$moveLeft(0.0)
        ]), $mdgriffith$elm_ui$Element$text("5-8 continuous chars"));
    };
    var $author$project$Pages$Hardware$CancelRegistration = {
        $: "CancelRegistration"
    };
    var $author$project$Pages$Hardware$RegisUser = function(a) {
        return {
            $: "RegisUser",
            a: a
        };
    };
    var $author$project$Utils$Validation$Validate$is20CharMax = function(str) {
        return $elm$core$String$length(str) <= 20 ? true : false;
    };
    var $author$project$Pages$Hardware$isValidatedForAllUserDetailsInput = function(userInfo) {
        return $author$project$Utils$Validation$Validate$isEmailValid(A2($elm$core$Maybe$withDefault, "", userInfo.email)) && $author$project$Utils$Validation$Validate$isValid4to8Chars(userInfo.nickname) && $author$project$Utils$Validation$Validate$is20CharMax("") && $author$project$Utils$Validation$Validate$isEmailValid(A2($elm$core$Maybe$withDefault, "", userInfo.email)) && $author$project$Utils$Validation$Validate$isMobileValid(A2($elm$core$Maybe$withDefault, "", userInfo.mobile)) ? true : false;
    };
    var $author$project$Pages$Hardware$userDetailsConfirmPanel = function(userInfo) {
        return $author$project$Utils$Validation$Validate$isEmailValid(A2($elm$core$Maybe$withDefault, "", userInfo.email)) && $elm$core$String$length(A2($elm$core$Maybe$withDefault, "", userInfo.email)) > 0 && $author$project$Utils$Validation$Validate$isValid4to8Chars(userInfo.password) && $elm$core$String$length(userInfo.password) > 0 && (userInfo.nickname === "" || $author$project$Utils$Validation$Validate$isValid4to8Chars(userInfo.nickname)) ? A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$section, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h6, $mdgriffith$elm_ui$Element$text("Click to continue ...")),
            A2($mdgriffith$elm_ui$Element$column, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple), _List_fromArray([
                A2($mdgriffith$elm_ui$Element$wrappedRow, $Orasund$elm_ui_framework$Framework$Grid$simple, _List_fromArray([
                    A2($mdgriffith$elm_ui$Element$Input$button, _Utils_ap($Orasund$elm_ui_framework$Framework$Button$simple, $Orasund$elm_ui_framework$Framework$Color$info), {
                        label: $mdgriffith$elm_ui$Element$text("Cancel"),
                        onPress: $elm$core$Maybe$Just($author$project$Pages$Hardware$CancelRegistration)
                    }),
                    A2($mdgriffith$elm_ui$Element$Input$button, _Utils_ap($Orasund$elm_ui_framework$Framework$Button$simple, $author$project$Pages$Hardware$enableButton($author$project$Pages$Hardware$isValidatedForAllUserDetailsInput(userInfo))), {
                        label: $mdgriffith$elm_ui$Element$text("Register"),
                        onPress: $elm$core$Maybe$Just($author$project$Pages$Hardware$RegisUser(userInfo))
                    })
                ]))
            ]))
        ])) : A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$section, _List_fromArray([
            $author$project$SR$Elements$missingDataPara,
            A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h6, $mdgriffith$elm_ui$Element$text("Click to continue ...")),
            A2($mdgriffith$elm_ui$Element$column, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple), _List_fromArray([
                A2($mdgriffith$elm_ui$Element$wrappedRow, $Orasund$elm_ui_framework$Framework$Grid$simple, _List_fromArray([
                    A2($mdgriffith$elm_ui$Element$Input$button, _Utils_ap($Orasund$elm_ui_framework$Framework$Button$simple, $Orasund$elm_ui_framework$Framework$Color$info), {
                        label: $mdgriffith$elm_ui$Element$text("Cancel"),
                        onPress: $elm$core$Maybe$Just($author$project$Pages$Hardware$CancelRegistration)
                    })
                ]))
            ]))
        ]));
    };
    var $elm$core$String$dropRight = F2(function(n, string) {
        return n < 1 ? string : A3($elm$core$String$slice, 0, -n, string);
    });
    var $author$project$Utils$Validation$Validate$validatedMaxTextLength = F2(function(str, maxLength) {
        return _Utils_cmp($elm$core$String$length(str), maxLength) > 0 ? A2($elm$core$String$dropRight, 1, str) : str;
    });
    var $author$project$Pages$Hardware$registerView = function(userInfo) {
        return A2($Orasund$elm_ui_framework$Framework$responsiveLayout, _List_Nil, A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$section, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h5, $mdgriffith$elm_ui$Element$text("Please Enter Your User \nDetails And Click 'Register' below:")),
            A2($mdgriffith$elm_ui$Element$wrappedRow, _Utils_ap($Orasund$elm_ui_framework$Framework$Card$fill, $Orasund$elm_ui_framework$Framework$Grid$simple), _List_fromArray([
                A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$Grid$simple, _List_fromArray([
                    A2($mdgriffith$elm_ui$Element$Input$email, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$simple, _List_fromArray([
                        $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("userEmail")),
                        $mdgriffith$elm_ui$Element$Input$focusedOnLoad
                    ])), {
                        label: A2($mdgriffith$elm_ui$Element$Input$labelLeft, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$label, _List_fromArray([
                            $mdgriffith$elm_ui$Element$moveLeft(11.0)
                        ])), $mdgriffith$elm_ui$Element$text("Email*")),
                        onChange: $author$project$Pages$Hardware$UpdateEmail,
                        placeholder: $elm$core$Maybe$Just(A2($mdgriffith$elm_ui$Element$Input$placeholder, _List_Nil, $mdgriffith$elm_ui$Element$text("Email"))),
                        text: A2($elm$core$Maybe$withDefault, "", userInfo.email)
                    }),
                    $author$project$Pages$Hardware$emailValidationErr(A2($elm$core$Maybe$withDefault, "", userInfo.email)),
                    A2($mdgriffith$elm_ui$Element$Input$newPassword, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$simple, _List_fromArray([
                        $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("Password"))
                    ])), {
                        label: A2($mdgriffith$elm_ui$Element$Input$labelLeft, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$label, _List_fromArray([
                            $mdgriffith$elm_ui$Element$moveLeft(11.0)
                        ])), $mdgriffith$elm_ui$Element$text("Password*")),
                        onChange: $author$project$Pages$Hardware$UpdatePassword,
                        placeholder: $elm$core$Maybe$Just(A2($mdgriffith$elm_ui$Element$Input$placeholder, _List_Nil, $mdgriffith$elm_ui$Element$text("Password"))),
                        show: false,
                        text: userInfo.password
                    }),
                    $author$project$SR$Elements$passwordValidView(userInfo),
                    A2($mdgriffith$elm_ui$Element$Input$text, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$simple, _List_fromArray([
                        $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("nickName"))
                    ])), {
                        label: A2($mdgriffith$elm_ui$Element$Input$labelLeft, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$label, _List_fromArray([
                            $mdgriffith$elm_ui$Element$moveLeft(11.0)
                        ])), $mdgriffith$elm_ui$Element$text("Nickname")),
                        onChange: $author$project$Pages$Hardware$UpdateNickName,
                        placeholder: $elm$core$Maybe$Just(A2($mdgriffith$elm_ui$Element$Input$placeholder, _List_Nil, $mdgriffith$elm_ui$Element$text("Nickname"))),
                        text: userInfo.nickname
                    }),
                    $author$project$SR$Elements$nameValidView(userInfo),
                    A2($mdgriffith$elm_ui$Element$Input$text, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$simple, _List_fromArray([
                        $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("Level"))
                    ])), {
                        label: A2($mdgriffith$elm_ui$Element$Input$labelLeft, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$label, _List_fromArray([
                            $mdgriffith$elm_ui$Element$moveLeft(11.0)
                        ])), $mdgriffith$elm_ui$Element$text("Level")),
                        onChange: $author$project$Pages$Hardware$UpdateLevel,
                        placeholder: $elm$core$Maybe$Just(A2($mdgriffith$elm_ui$Element$Input$placeholder, _List_Nil, $mdgriffith$elm_ui$Element$text("Level"))),
                        text: userInfo.description.level
                    }),
                    A2($mdgriffith$elm_ui$Element$Input$text, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$simple, _List_fromArray([
                        $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("Comment"))
                    ])), {
                        label: A2($mdgriffith$elm_ui$Element$Input$labelLeft, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$label, _List_fromArray([
                            $mdgriffith$elm_ui$Element$moveLeft(11.0)
                        ])), $mdgriffith$elm_ui$Element$text("Comment")),
                        onChange: $author$project$Pages$Hardware$UpdateComment,
                        placeholder: $elm$core$Maybe$Just(A2($mdgriffith$elm_ui$Element$Input$placeholder, _List_Nil, $mdgriffith$elm_ui$Element$text("Comment"))),
                        text: userInfo.description.comment
                    }),
                    A2($mdgriffith$elm_ui$Element$Input$text, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$simple, _List_fromArray([
                        $mdgriffith$elm_ui$Element$htmlAttribute($elm$html$Html$Attributes$id("userMobile"))
                    ])), {
                        label: A2($mdgriffith$elm_ui$Element$Input$labelLeft, _Utils_ap($Orasund$elm_ui_framework$Framework$Input$label, _List_fromArray([
                            $mdgriffith$elm_ui$Element$moveLeft(11.0)
                        ])), $mdgriffith$elm_ui$Element$text("Mobile \n(inc. Int code\neg.+65)")),
                        onChange: $author$project$Pages$Hardware$UpdateMobile,
                        placeholder: $elm$core$Maybe$Just(A2($mdgriffith$elm_ui$Element$Input$placeholder, _List_Nil, $mdgriffith$elm_ui$Element$text("Mobile"))),
                        text: A2($author$project$Utils$Validation$Validate$validatedMaxTextLength, A2($elm$core$Maybe$withDefault, "", userInfo.mobile), 25)
                    }),
                    $author$project$Pages$Hardware$mobileValidationErr(A2($elm$core$Maybe$withDefault, "", userInfo.mobile))
                ]))
            ])),
            $mdgriffith$elm_ui$Element$text("* required"),
            $author$project$SR$Elements$justParasimpleUserInfoText,
            $author$project$Pages$Hardware$userDetailsConfirmPanel(userInfo),
            $mdgriffith$elm_ui$Element$text("\n")
        ])));
    };
    var $author$project$Pages$Hardware$SpectatorJoin = {
        $: "SpectatorJoin"
    };
    var $author$project$Pages$Hardware$spectatorSelectedView = F2(function(u, r) {
        return A2($Orasund$elm_ui_framework$Framework$responsiveLayout, _List_Nil, A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$container, _List_fromArray([
            A2($mdgriffith$elm_ui$Element$wrappedRow, _List_Nil, _List_fromArray([
                A2($author$project$SR$Elements$spectatorSelectedRankingHeaderEl, u, r)
            ])),
            A2($mdgriffith$elm_ui$Element$column, A2($elm$core$List$cons, $mdgriffith$elm_ui$Element$width($mdgriffith$elm_ui$Element$fill), _Utils_ap($Orasund$elm_ui_framework$Framework$Card$simple, $Orasund$elm_ui_framework$Framework$Grid$simple)), _List_fromArray([
                A2($author$project$Pages$Hardware$infoBtn, "Join This Ladder?", $author$project$Pages$Hardware$SpectatorJoin),
                A2($author$project$Pages$Hardware$infoBtn, "Cancel", $author$project$Pages$Hardware$CancelFetchedSpectator),
                A2($author$project$Pages$Hardware$playerbuttons, r, u)
            ]))
        ])));
    });
    var $author$project$Pages$Hardware$content = function(model) {
        return A2($elm$html$Html$section, _List_fromArray([
            $elm$html$Html$Attributes$id("page"),
            $elm$html$Html$Attributes$class("section-background"),
            $elm$html$Html$Attributes$class("text-center")
        ]), _List_fromArray([
            A2($elm$html$Html$div, _List_fromArray([
                $elm$html$Html$Attributes$class("split")
            ]), _List_fromArray([
                A2($elm$html$Html$div, _List_fromArray([
                    $elm$html$Html$Attributes$class("split-col")
                ]), _List_Nil),
                function() {
                    var _v0 = model.status;
                    switch(_v0.$){
                        case "Loading":
                            return A2($elm$html$Html$div, _List_Nil, _List_fromArray([
                                A2($elm$html$Html$div, _List_fromArray([
                                    $elm$html$Html$Attributes$class("spinner")
                                ]), _List_Nil)
                            ]));
                        case "Errored":
                            return A2($elm$html$Html$div, _List_Nil, _List_fromArray([
                                $elm$html$Html$text("error")
                            ]));
                        default:
                            return A2($elm$html$Html$div, _List_fromArray([
                                $elm$html$Html$Attributes$class("split-col")
                            ]), _List_fromArray([
                                function() {
                                    var _v1 = model.queryType;
                                    switch(_v1.$){
                                        case "RefreshTknQP":
                                            return A2($elm$html$Html$ul, _List_Nil, _List_fromArray([
                                                A2($Orasund$elm_ui_framework$Framework$responsiveLayout, _List_Nil, A2($mdgriffith$elm_ui$Element$column, $Orasund$elm_ui_framework$Framework$container, _List_fromArray([
                                                    A2($mdgriffith$elm_ui$Element$el, $Orasund$elm_ui_framework$Framework$Heading$h5, $mdgriffith$elm_ui$Element$text("RefreshTknQP - Error!"))
                                                ])))
                                            ]));
                                        case "Login":
                                            return $author$project$Pages$Hardware$hardwareWalletView(model);
                                        case "Spectator":
                                            return $author$project$Pages$Hardware$hardwareWalletView(model);
                                        case "RegisterUser":
                                            var newUser = _v1.a;
                                            return $author$project$Pages$Hardware$registerView(newUser);
                                        case "LoggedInUser":
                                            return $author$project$Pages$Hardware$hardwareWalletView(model);
                                        case "CreatingNewLadder":
                                            var userInfo = _v1.a;
                                            return A2($author$project$Pages$Hardware$createLadderView, userInfo, $author$project$Data$Hardware$gotRanking(model.selectedranking));
                                        case "OwnedSelectedView":
                                            var userInfo = function() {
                                                var _v2 = model.user;
                                                if (_v2.$ === "Registered") {
                                                    var usrInfo = _v2.a;
                                                    return usrInfo;
                                                } else return $author$project$Data$User$emptyUserInfo;
                                            }();
                                            return A2($author$project$Pages$Hardware$ownedSelectedView, userInfo, $author$project$Data$Hardware$gotRanking(model.selectedranking));
                                        case "MemberSelectedView":
                                            var userInfo = function() {
                                                var _v3 = model.user;
                                                if (_v3.$ === "Registered") {
                                                    var usrInfo = _v3.a;
                                                    return usrInfo;
                                                } else return $author$project$Data$User$emptyUserInfo;
                                            }();
                                            return A2($author$project$Pages$Hardware$memberSelectedView, userInfo, $author$project$Data$Hardware$gotRanking(model.selectedranking));
                                        case "SpectatorSelectedView":
                                            var userInfo = function() {
                                                var _v5 = model.user;
                                                if (_v5.$ === "Registered") {
                                                    var usrInfo = _v5.a;
                                                    return usrInfo;
                                                } else return $author$project$Data$User$emptyUserInfo;
                                            }();
                                            var ranking = function() {
                                                var _v4 = model.selectedranking;
                                                if (_v4.$ === "Spectator") {
                                                    var rankng = _v4.a;
                                                    return rankng;
                                                } else return $author$project$Data$Hardware$emptyRanking;
                                            }();
                                            return A2($author$project$Pages$Hardware$spectatorSelectedView, userInfo, ranking);
                                        case "ConfirmDeleteOwnedRanking":
                                            var userInfo = function() {
                                                var _v6 = model.user;
                                                if (_v6.$ === "Registered") {
                                                    var usrInfo = _v6.a;
                                                    return usrInfo;
                                                } else return $author$project$Data$User$emptyUserInfo;
                                            }();
                                            return A2($author$project$Pages$Hardware$dialogueDeleteOwnedView, userInfo, $author$project$Data$Hardware$gotRanking(model.selectedranking));
                                        case "CreateChallengeView":
                                            var rank = _v1.a;
                                            var ranking = _v1.b;
                                            var userInfo = function() {
                                                var _v7 = model.user;
                                                if (_v7.$ === "Registered") {
                                                    var usrInfo = _v7.a;
                                                    return usrInfo;
                                                } else return $author$project$Data$User$emptyUserInfo;
                                            }();
                                            return A3($author$project$Pages$Hardware$createChallengeView, userInfo, rank, ranking);
                                        case "ConfirmChallengeView":
                                            var rank = _v1.a;
                                            var ranking = _v1.b;
                                            var userInfo = function() {
                                                var _v8 = model.user;
                                                if (_v8.$ === "Registered") {
                                                    var usrInfo = _v8.a;
                                                    return usrInfo;
                                                } else return $author$project$Data$User$emptyUserInfo;
                                            }();
                                            return A3($author$project$Pages$Hardware$dialogueConfirmChallengeView, userInfo, rank, ranking);
                                        case "ConfirmJoinMemberView":
                                            var userInfo = function() {
                                                var _v9 = model.user;
                                                if (_v9.$ === "Registered") {
                                                    var usrInfo = _v9.a;
                                                    return usrInfo;
                                                } else return $author$project$Data$User$emptyUserInfo;
                                            }();
                                            return A2($author$project$Pages$Hardware$confirmJoinView, userInfo, $author$project$Data$Hardware$gotRanking(model.selectedranking));
                                        case "ConfirmLeaveMemberView":
                                            var userInfo = function() {
                                                var _v10 = model.user;
                                                if (_v10.$ === "Registered") {
                                                    var usrInfo = _v10.a;
                                                    return usrInfo;
                                                } else return $author$project$Data$User$emptyUserInfo;
                                            }();
                                            return A2($author$project$Pages$Hardware$confirmLeaveView, userInfo, $author$project$Data$Hardware$gotRanking(model.selectedranking));
                                        case "ConfirmDeleteUserView":
                                            var userInfo = function() {
                                                var _v11 = model.user;
                                                if (_v11.$ === "Registered") {
                                                    var usrInfo = _v11.a;
                                                    return usrInfo;
                                                } else return $author$project$Data$User$emptyUserInfo;
                                            }();
                                            return $author$project$Pages$Hardware$confirmDeleteUserView(userInfo);
                                        case "PrepareResult":
                                            return A3($author$project$Pages$Hardware$dialoguePrepareResultView, $author$project$Data$User$gotUserInfo(model.user), model.selectedSingleRank, $author$project$Data$Hardware$gotRanking(model.selectedranking));
                                        default:
                                            return A2($elm$html$Html$ul, _List_Nil, _List_fromArray([
                                                $elm$html$Html$text("error")
                                            ]));
                                    }
                                }()
                            ]));
                    }
                }(),
                A2($elm$html$Html$div, _List_fromArray([
                    $elm$html$Html$Attributes$class("split-col")
                ]), _List_Nil)
            ]))
        ]));
    };
    var $author$project$Pages$Hardware$view = function(model) {
        return $author$project$Pages$Hardware$content(model);
    };
    var $elm$html$Html$h3 = _VirtualDom_node("h3");
    var $elm$html$Html$h6 = _VirtualDom_node("h6");
    var $author$project$Pages$Market$content = A2($elm$html$Html$section, _List_fromArray([
        $elm$html$Html$Attributes$id("page"),
        $elm$html$Html$Attributes$class("section-background")
    ]), _List_fromArray([
        A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$class("split")
        ]), _List_fromArray([
            A2($elm$html$Html$div, _List_fromArray([
                $elm$html$Html$Attributes$class("split-col")
            ]), _List_fromArray([
                A2($elm$html$Html$h6, _List_Nil, _List_fromArray([
                    $elm$html$Html$text("")
                ]))
            ])),
            A2($elm$html$Html$div, _List_fromArray([
                $elm$html$Html$Attributes$class("split-col")
            ]), _List_fromArray([
                A2($elm$html$Html$h1, _List_fromArray([
                    $elm$html$Html$Attributes$class("text-center")
                ]), _List_fromArray([
                    $elm$html$Html$text("Market")
                ])),
                A2($elm$html$Html$h3, _List_fromArray([
                    $elm$html$Html$Attributes$class("text-center")
                ]), _List_fromArray([
                    $elm$html$Html$text("")
                ])),
                $author$project$Buttons$Default$defaultButton("hardware")
            ])),
            A2($elm$html$Html$div, _List_fromArray([
                $elm$html$Html$Attributes$class("split-col")
            ]), _List_fromArray([
                A2($elm$html$Html$h6, _List_Nil, _List_fromArray([
                    $elm$html$Html$text("")
                ]))
            ]))
        ]))
    ]));
    var $author$project$Pages$Market$view = function(_v0) {
        return $author$project$Pages$Market$content;
    };
    var $author$project$Pages$PingPong$Send = {
        $: "Send"
    };
    var $author$project$Pages$PingPong$view = function(model) {
        var _v0 = model.root;
        var name = _v0.a.name;
        return A2($elm$html$Html$div, _List_Nil, _List_fromArray([
            $elm$html$Html$text(name),
            A2($elm$html$Html$button, _List_fromArray([
                $elm$html$Html$Events$onClick($author$project$Pages$PingPong$Send)
            ]), _List_fromArray([
                $elm$html$Html$text("Send Ping")
            ]))
        ]));
    };
    var $author$project$Pages$Portfolio$htmlContent = A2($elm$html$Html$section, _List_fromArray([
        $elm$html$Html$Attributes$id("page"),
        $elm$html$Html$Attributes$class("section-background"),
        $elm$html$Html$Attributes$class("text-center"),
        $elm$html$Html$Attributes$class("split")
    ]), _List_fromArray([
        A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$class("split-col")
        ]), _List_fromArray([
            A2($elm$html$Html$h1, _List_Nil, _List_fromArray([
                $elm$html$Html$text("")
            ]))
        ])),
        A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$class("split-col")
        ]), _List_fromArray([
            A2($elm$html$Html$h1, _List_Nil, _List_fromArray([
                $elm$html$Html$text("Portfolio")
            ])),
            A2($elm$html$Html$h3, _List_Nil, _List_fromArray([
                $elm$html$Html$text("Info ")
            ])),
            $author$project$Buttons$Default$defaultButton("hardware"),
            A2($elm$html$Html$p, _List_Nil, _List_fromArray([
                $elm$html$Html$text("Any text              ")
            ]))
        ])),
        A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$class("split-col")
        ]), _List_fromArray([
            A2($elm$html$Html$h1, _List_Nil, _List_fromArray([
                $elm$html$Html$text("")
            ]))
        ]))
    ]));
    var $author$project$Pages$Portfolio$content = A2($elm$html$Html$div, _List_fromArray([
        $elm$html$Html$Attributes$id("page")
    ]), _List_fromArray([
        A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$id("content"),
            $elm$html$Html$Attributes$class("col3-column")
        ]), _List_fromArray([
            $author$project$Pages$Portfolio$htmlContent
        ]))
    ]));
    var $author$project$Pages$Portfolio$view = function(_v0) {
        return $author$project$Pages$Portfolio$content;
    };
    var $elm$html$Html$h4 = _VirtualDom_node("h4");
    var $author$project$Pages$Sell$content = A2($elm$html$Html$section, _List_fromArray([
        $elm$html$Html$Attributes$class("section-background"),
        $elm$html$Html$Attributes$id("page")
    ]), _List_fromArray([
        A2($elm$html$Html$h1, _List_fromArray([
            $elm$html$Html$Attributes$classList(_List_fromArray([
                _Utils_Tuple2("text-center", true),
                _Utils_Tuple2("testimonial", true)
            ]))
        ]), _List_fromArray([
            $elm$html$Html$text("Sell")
        ])),
        A2($elm$html$Html$h4, _List_fromArray([
            $elm$html$Html$Attributes$class("text-center")
        ]), _List_fromArray([
            $elm$html$Html$text("Sell your crypto here"),
            A2($elm$html$Html$div, _List_fromArray([
                $elm$html$Html$Attributes$class("text-center"),
                A2($elm$html$Html$Attributes$style, "margin-top", "1rem")
            ]), _List_fromArray([
                $author$project$Buttons$Default$defaultButton("hardware")
            ]))
        ]))
    ]));
    var $author$project$Pages$Sell$view = function(_v0) {
        return $author$project$Pages$Sell$content;
    };
    var $author$project$Pages$Support$content = A2($elm$html$Html$section, _List_fromArray([
        $elm$html$Html$Attributes$class("section-background"),
        $elm$html$Html$Attributes$id("page")
    ]), _List_fromArray([
        A2($elm$html$Html$div, _List_fromArray([
            $elm$html$Html$Attributes$class("split")
        ]), _List_fromArray([
            A2($elm$html$Html$div, _List_fromArray([
                $elm$html$Html$Attributes$class("split-col")
            ]), _List_Nil),
            A2($elm$html$Html$div, _List_fromArray([
                $elm$html$Html$Attributes$class("split-col")
            ]), _List_fromArray([
                A2($elm$html$Html$h1, _List_fromArray([
                    $elm$html$Html$Attributes$class("text-center")
                ]), _List_fromArray([
                    $elm$html$Html$text("Support")
                ])),
                A2($elm$html$Html$p, _List_fromArray([
                    $elm$html$Html$Attributes$class("text-center")
                ]), _List_fromArray([
                    $elm$html$Html$text("We're here to help you with any issues you may have.")
                ])),
                $author$project$Buttons$Default$defaultButton("hardware")
            ])),
            A2($elm$html$Html$div, _List_fromArray([
                $elm$html$Html$Attributes$class("split-col")
            ]), _List_Nil)
        ]))
    ]));
    var $author$project$Pages$Support$view = function(_v0) {
        return $author$project$Pages$Support$content;
    };
    var $author$project$Main$view = function(model) {
        var contentByPage = function() {
            var _v0 = model.page;
            switch(_v0.$){
                case "DashboardPage":
                    var dashboard = _v0.a;
                    return A2($elm$html$Html$map, $author$project$Main$GotDashboardMsg, $author$project$Pages$Dashboard$view(dashboard));
                case "SellPage":
                    var dashboard = _v0.a;
                    return A2($elm$html$Html$map, $author$project$Main$GotSellMsg, $author$project$Pages$Sell$view(dashboard));
                case "PortfolioPage":
                    var terms = _v0.a;
                    return A2($elm$html$Html$map, $author$project$Main$GotPortfolioMsg, $author$project$Pages$Portfolio$view(terms));
                case "FundsPage":
                    var privacy = _v0.a;
                    return A2($elm$html$Html$map, $author$project$Main$GotFundsMsg, $author$project$Pages$Funds$view(privacy));
                case "SupportPage":
                    var support = _v0.a;
                    return A2($elm$html$Html$map, $author$project$Main$GotSupportMsg, $author$project$Pages$Support$view(support));
                case "PingPongPage":
                    var pingpong = _v0.a;
                    return A2($elm$html$Html$map, $author$project$Main$GotPingPongMsg, $author$project$Pages$PingPong$view(pingpong));
                case "BuyPage":
                    var buy = _v0.a;
                    return A2($elm$html$Html$map, $author$project$Main$GotBuyMsg, $author$project$Pages$Buy$view(buy));
                case "MarketPage":
                    var market = _v0.a;
                    return A2($elm$html$Html$map, $author$project$Main$GotMarketMsg, $author$project$Pages$Market$view(market));
                case "HardwarePage":
                    var hardware = _v0.a;
                    return A2($elm$html$Html$map, $author$project$Main$GotHardwareMsg, $author$project$Pages$Hardware$view(hardware));
                default:
                    return $elm$html$Html$text("Not Found");
            }
        }();
        return {
            body: _List_fromArray([
                $author$project$Main$pageHeader(model.page),
                $author$project$Main$showVideoOrBanner(model.page),
                contentByPage,
                $author$project$Main$footerContent
            ]),
            title: "Haveno-Web"
        };
    };
    var $author$project$Main$main = $elm$browser$Browser$application({
        init: $author$project$Main$init,
        onUrlChange: $author$project$Main$ChangedUrl,
        onUrlRequest: $author$project$Main$ClickedLink,
        subscriptions: $author$project$Main$subscriptions,
        update: $author$project$Main$update,
        view: $author$project$Main$view
    });
    _Platform_export({
        "Main": {
            "init": $author$project$Main$main($elm$json$Json$Decode$string)({
                "versions": {
                    "elm": "0.19.1"
                },
                "types": {
                    "message": "Main.Msg",
                    "aliases": {
                        "Url.Url": {
                            "args": [],
                            "type": "{ protocol : Url.Protocol, host : String.String, port_ : Maybe.Maybe Basics.Int, path : String.String, query : Maybe.Maybe String.String, fragment : Maybe.Maybe String.String }"
                        },
                        "Json.Decode.Value": {
                            "args": [],
                            "type": "Json.Encode.Value"
                        },
                        "Data.Hardware.BaseAddress": {
                            "args": [],
                            "type": "{ street : String.String, city : String.String }"
                        },
                        "Data.User.Description": {
                            "args": [],
                            "type": "{ level : String.String, comment : String.String }"
                        },
                        "Time.Era": {
                            "args": [],
                            "type": "{ start : Basics.Int, offset : Basics.Int }"
                        },
                        "Proto.Io.Haveno.Protobuffer.GetVersionReply": {
                            "args": [],
                            "type": "Proto.Io.Haveno.Protobuffer.Internals_.Proto__Io__Haveno__Protobuffer__GetVersionReply"
                        },
                        "Pages.Dashboard.HavenoAPKHttpRequest": {
                            "args": [],
                            "type": "{ method : String.String, headers : List.List Http.Header, url : String.String, body : Http.Body, timeout : Maybe.Maybe Basics.Float, tracker : Maybe.Maybe String.String }"
                        },
                        "Pages.Hardware.Identities": {
                            "args": [],
                            "type": "{ id : String.String, provider_type : String.String, provider_id : String.String, provider_data : Pages.Hardware.ProviderData }"
                        },
                        "Data.User.MemberRanking": {
                            "args": [],
                            "type": "{ id : String.String, name : String.String }"
                        },
                        "Pages.Buy.Model": {
                            "args": [],
                            "type": "{ status : Pages.Buy.Status, title : String.String, root : Pages.Buy.Buy }"
                        },
                        "Pages.Dashboard.Model": {
                            "args": [],
                            "type": "{ status : Pages.Dashboard.Status, title : String.String, root : Pages.Dashboard.Dashboard, balance : String.String, flagUrl : Url.Url, havenoAPKHttpRequest : Maybe.Maybe Pages.Dashboard.HavenoAPKHttpRequest, version : Maybe.Maybe Proto.Io.Haveno.Protobuffer.GetVersionReply, errors : List.List String.String }"
                        },
                        "Pages.Funds.Model": {
                            "args": [],
                            "type": "{ status : Pages.Funds.Status, title : String.String, root : Pages.Funds.Funds }"
                        },
                        "Pages.Market.Model": {
                            "args": [],
                            "type": "{ status : Pages.Market.Status, title : String.String, root : Pages.Market.Market }"
                        },
                        "Pages.PingPong.Model": {
                            "args": [],
                            "type": "{ status : Pages.PingPong.Status, title : String.String, root : Pages.PingPong.PingPong }"
                        },
                        "Pages.Portfolio.Model": {
                            "args": [],
                            "type": "{ status : Pages.Portfolio.Status, title : String.String, root : Pages.Portfolio.Portfolio }"
                        },
                        "Pages.Sell.Model": {
                            "args": [],
                            "type": "{ status : Pages.Sell.Status, title : String.String, root : Pages.Sell.Sell }"
                        },
                        "Pages.Support.Model": {
                            "args": [],
                            "type": "{ status : Pages.Support.Status, title : String.String, root : Pages.Support.Support }"
                        },
                        "Data.User.NickName": {
                            "args": [],
                            "type": "String.String"
                        },
                        "Data.User.Password": {
                            "args": [],
                            "type": "String.String"
                        },
                        "Data.Hardware.Player": {
                            "args": [],
                            "type": "{ id : String.String, nickname : String.String }"
                        },
                        "Pages.PingPong.PongResponse": {
                            "args": [],
                            "type": "{ message : String.String }"
                        },
                        "Proto.Io.Haveno.Protobuffer.Internals_.Proto__Io__Haveno__Protobuffer__GetVersionReply": {
                            "args": [],
                            "type": "{ version : String.String }"
                        },
                        "Pages.Hardware.ProviderData": {
                            "args": [],
                            "type": "{ email : String.String }"
                        },
                        "Data.Hardware.Rank": {
                            "args": [],
                            "type": "{ rank : Basics.Int, player : Data.Hardware.Player, challenger : Data.Hardware.Player }"
                        },
                        "Data.Hardware.Ranking": {
                            "args": [],
                            "type": "{ id : String.String, active : Basics.Bool, name : String.String, owner_id : String.String, baseaddress : Data.Hardware.BaseAddress, ladder : List.List Data.Hardware.Rank, player_count : Basics.Int, owner_name : String.String }"
                        },
                        "Data.Hardware.RankingSearchResult": {
                            "args": [],
                            "type": "{ id : String.String, name : String.String }"
                        },
                        "Pages.Hardware.RegisterUserDetails": {
                            "args": [],
                            "type": "{ resource_id : String.String, user_details : Data.User.User, additional_fields : String.String }"
                        },
                        "Pages.Hardware.SuccessfulLoginResult": {
                            "args": [],
                            "type": "{ access_token : String.String, refresh_token : String.String, user_id : String.String, device_id : String.String }"
                        },
                        "Pages.Dashboard.SuccessfullBalanceResult": {
                            "args": [],
                            "type": "{ deployment_model : String.String, location : String.String, hostname : String.String, ws_hostname : String.String }"
                        },
                        "Pages.Hardware.SuccessfullLNSConnectResult": {
                            "args": [],
                            "type": "{ function : String.String, date : String.String, id : String.String, message : String.String, transport_type : String.String }"
                        },
                        "Pages.Hardware.SuccessfullProfileResult": {
                            "args": [],
                            "type": "{ user_id : String.String, domain_id : String.String, identities : List.List Pages.Hardware.Identities, data : Pages.Hardware.ProviderData, typeOfData : String.String }"
                        },
                        "Data.User.Token": {
                            "args": [],
                            "type": "String.String"
                        },
                        "Data.User.UserInfo": {
                            "args": [],
                            "type": "{ userid : String.String, password : Data.User.Password, passwordValidationError : String.String, token : Maybe.Maybe Data.User.Token, nickname : Data.User.NickName, isNameInputFocused : Basics.Bool, nameValidationError : String.String, age : Basics.Int, gender : Data.User.Gender, email : Maybe.Maybe String.String, isEmailInputFocused : Basics.Bool, emailValidationError : String.String, mobile : Maybe.Maybe String.String, isMobileInputFocused : Basics.Bool, mobileValidationError : String.String, datestamp : Basics.Int, active : Basics.Bool, ownedRankings : List.List Data.Hardware.Ranking, memberRankings : List.List Data.Hardware.Ranking, updatetext : String.String, description : Data.User.Description, credits : Basics.Int, addInfo : String.String }"
                        },
                        "Http.Metadata": {
                            "args": [],
                            "type": "{ url : String.String, statusCode : Basics.Int, statusText : String.String, headers : Dict.Dict String.String String.String }"
                        }
                    },
                    "unions": {
                        "Main.Msg": {
                            "args": [],
                            "tags": {
                                "ClickedLink": [
                                    "Browser.UrlRequest"
                                ],
                                "GotDashboardMsg": [
                                    "Pages.Dashboard.Msg"
                                ],
                                "GotSellMsg": [
                                    "Pages.Sell.Msg"
                                ],
                                "GotPortfolioMsg": [
                                    "Pages.Portfolio.Msg"
                                ],
                                "GotFundsMsg": [
                                    "Pages.Funds.Msg"
                                ],
                                "GotSupportMsg": [
                                    "Pages.Support.Msg"
                                ],
                                "GotPingPongMsg": [
                                    "Pages.PingPong.Msg"
                                ],
                                "GotBuyMsg": [
                                    "Pages.Buy.Msg"
                                ],
                                "GotMarketMsg": [
                                    "Pages.Market.Msg"
                                ],
                                "GotHardwareMsg": [
                                    "Pages.Hardware.Msg"
                                ],
                                "ChangedUrl": [
                                    "Url.Url"
                                ],
                                "Tick": [
                                    "Time.Posix"
                                ],
                                "AdjustTimeZone": [
                                    "Time.Zone"
                                ],
                                "Recv": [
                                    "Json.Decode.Value"
                                ],
                                "RecvText": [
                                    "String.String"
                                ]
                            }
                        },
                        "Basics.Int": {
                            "args": [],
                            "tags": {
                                "Int": []
                            }
                        },
                        "Maybe.Maybe": {
                            "args": [
                                "a"
                            ],
                            "tags": {
                                "Just": [
                                    "a"
                                ],
                                "Nothing": []
                            }
                        },
                        "Pages.Buy.Msg": {
                            "args": [],
                            "tags": {
                                "GotInitialModel": [
                                    "Pages.Buy.Model"
                                ]
                            }
                        },
                        "Pages.Dashboard.Msg": {
                            "args": [],
                            "tags": {
                                "GotInitialModel": [
                                    "Pages.Dashboard.Model"
                                ],
                                "BalanceResponse": [
                                    "Result.Result Http.Error Pages.Dashboard.SuccessfullBalanceResult"
                                ],
                                "GotVersion": [
                                    "Result.Result Grpc.Error Proto.Io.Haveno.Protobuffer.GetVersionReply"
                                ]
                            }
                        },
                        "Pages.Funds.Msg": {
                            "args": [],
                            "tags": {
                                "GotInitialModel": [
                                    "Pages.Funds.Model"
                                ]
                            }
                        },
                        "Pages.Hardware.Msg": {
                            "args": [],
                            "tags": {
                                "BookingForm": [
                                    "Pages.Hardware.RegisterUserDetails"
                                ],
                                "UpdateAge": [
                                    "Basics.Int"
                                ],
                                "UpdateGender": [
                                    "String.String"
                                ],
                                "UpdateEmail": [
                                    "String.String"
                                ],
                                "UpdatePassword": [
                                    "String.String"
                                ],
                                "UpdateNickName": [
                                    "String.String"
                                ],
                                "UpdateLevel": [
                                    "String.String"
                                ],
                                "UpdateComment": [
                                    "String.String"
                                ],
                                "UpdateMobile": [
                                    "String.String"
                                ],
                                "UpdatePhone": [
                                    "String.String"
                                ],
                                "CondoNameInput": [
                                    "String.String"
                                ],
                                "CondoAddressInput": [
                                    "String.String"
                                ],
                                "AddInfoInput": [
                                    "String.String"
                                ],
                                "ConfirmBookingForm": [],
                                "NoOp": [],
                                "DismissErrors": [],
                                "Tick": [
                                    "Time.Posix"
                                ],
                                "InputFocused": [
                                    "String.String"
                                ],
                                "InputBlurred": [
                                    "String.String"
                                ],
                                "SelDateTime": [
                                    "String.String"
                                ],
                                "ToggleReturnUser": [],
                                "UserLoginEmailInputChg": [
                                    "String.String"
                                ],
                                "UserLoginPasswordInputChg": [
                                    "String.String"
                                ],
                                "ClickedHardwareDeviceConnect": [],
                                "ClickedXMRWalletConnect": [],
                                "ClickedXMRInitiateTransaction": [
                                    "String.String"
                                ],
                                "ResponseDataFromMain": [
                                    "Json.Decode.Value"
                                ],
                                "LogOut": [],
                                "Create": [],
                                "CreateNewRanking": [
                                    "Data.User.UserInfo"
                                ],
                                "Cancel": [],
                                "CancelFetchedOwned": [
                                    "Data.User.UserInfo"
                                ],
                                "CancelFetchedMember": [],
                                "CancelFetchedSpectator": [],
                                "CancelCreateNewRanking": [],
                                "CancelRegistration": [],
                                "Confirm": [],
                                "FetchOwned": [
                                    "Data.Hardware.Ranking"
                                ],
                                "FetchMember": [
                                    "Data.Hardware.Ranking"
                                ],
                                "ListSpectator": [
                                    "Data.Hardware.RankingSearchResult"
                                ],
                                "ViewMember": [
                                    "Data.User.MemberRanking"
                                ],
                                "RegisUser": [
                                    "Data.User.UserInfo"
                                ],
                                "RankingNameChg": [
                                    "String.String"
                                ],
                                "StreetAddressChg": [
                                    "String.String"
                                ],
                                "CityAddressChg": [
                                    "String.String"
                                ],
                                "ConfirmNewRanking": [
                                    "Data.Hardware.Ranking",
                                    "Data.User.User"
                                ],
                                "DialogDeleteOwnedRanking": [],
                                "DeleteOwnedRanking": [],
                                "ViewRank": [
                                    "Data.Hardware.Rank"
                                ],
                                "ConfirmChallenge": [
                                    "Data.Hardware.Ranking",
                                    "Data.Hardware.Rank"
                                ],
                                "ConfirmResult": [
                                    "Data.Hardware.ResultOfMatch"
                                ],
                                "CancelDialoguePrepareResultView": [],
                                "SearchInputChg": [
                                    "String.String"
                                ],
                                "FetchSpectatorRanking": [
                                    "String.String"
                                ],
                                "SpectatorRankingResponse": [
                                    "Result.Result Http.Error Data.Hardware.Ranking"
                                ],
                                "SpectatorJoin": [],
                                "RegisteredUserJoin": [],
                                "ConfirmJoin": [
                                    "Data.Hardware.Ranking",
                                    "String.String",
                                    "Basics.Int"
                                ],
                                "ConfirmLeaveMemberRanking": [
                                    "Data.Hardware.Ranking",
                                    "String.String"
                                ],
                                "DialogueConfirmJoinView": [],
                                "DialogueConfirmLeaveView": [],
                                "DialogueConfirmDeleteAccount": [],
                                "DeleteAccount": [],
                                "LoginResponse": [
                                    "Result.Result Http.Error Pages.Hardware.SuccessfulLoginResult"
                                ],
                                "LNSConnectResponse": [
                                    "Result.Result Http.Error Pages.Hardware.SuccessfullLNSConnectResult"
                                ],
                                "ProfileResponse": [
                                    "Result.Result Http.Error Pages.Hardware.SuccessfullProfileResult"
                                ],
                                "CallResponse": [
                                    "Result.Result Http.Error Data.User.UserInfo"
                                ]
                            }
                        },
                        "Pages.Market.Msg": {
                            "args": [],
                            "tags": {
                                "GotInitialModel": [
                                    "Pages.Market.Model"
                                ]
                            }
                        },
                        "Pages.PingPong.Msg": {
                            "args": [],
                            "tags": {
                                "Send": [],
                                "Receive": [
                                    "Result.Result Http.Error Pages.PingPong.PongResponse"
                                ],
                                "GotInitialModel": [
                                    "Pages.PingPong.Model"
                                ]
                            }
                        },
                        "Pages.Portfolio.Msg": {
                            "args": [],
                            "tags": {
                                "GotInitialModel": [
                                    "Pages.Portfolio.Model"
                                ]
                            }
                        },
                        "Pages.Sell.Msg": {
                            "args": [],
                            "tags": {
                                "GotInitialModel": [
                                    "Pages.Sell.Model"
                                ]
                            }
                        },
                        "Pages.Support.Msg": {
                            "args": [],
                            "tags": {
                                "GotInitialModel": [
                                    "Pages.Support.Model"
                                ]
                            }
                        },
                        "Time.Posix": {
                            "args": [],
                            "tags": {
                                "Posix": [
                                    "Basics.Int"
                                ]
                            }
                        },
                        "Url.Protocol": {
                            "args": [],
                            "tags": {
                                "Http": [],
                                "Https": []
                            }
                        },
                        "String.String": {
                            "args": [],
                            "tags": {
                                "String": []
                            }
                        },
                        "Browser.UrlRequest": {
                            "args": [],
                            "tags": {
                                "Internal": [
                                    "Url.Url"
                                ],
                                "External": [
                                    "String.String"
                                ]
                            }
                        },
                        "Json.Encode.Value": {
                            "args": [],
                            "tags": {
                                "Value": []
                            }
                        },
                        "Time.Zone": {
                            "args": [],
                            "tags": {
                                "Zone": [
                                    "Basics.Int",
                                    "List.List Time.Era"
                                ]
                            }
                        },
                        "Http.Body": {
                            "args": [],
                            "tags": {
                                "Body": []
                            }
                        },
                        "Basics.Bool": {
                            "args": [],
                            "tags": {
                                "True": [],
                                "False": []
                            }
                        },
                        "Pages.Buy.Buy": {
                            "args": [],
                            "tags": {
                                "Buy": [
                                    "{ name : String.String }"
                                ]
                            }
                        },
                        "Pages.Dashboard.Dashboard": {
                            "args": [],
                            "tags": {
                                "Dashboard": [
                                    "{ name : String.String }"
                                ]
                            }
                        },
                        "Grpc.Error": {
                            "args": [],
                            "tags": {
                                "BadUrl": [
                                    "String.String"
                                ],
                                "Timeout": [],
                                "NetworkError": [],
                                "BadStatus": [
                                    "{ metadata : Http.Metadata, response : Bytes.Bytes, errMessage : String.String, status : Grpc.GrpcStatus }"
                                ],
                                "BadBody": [
                                    "Bytes.Bytes"
                                ],
                                "UnknownGrpcStatus": [
                                    "String.String"
                                ]
                            }
                        },
                        "Http.Error": {
                            "args": [],
                            "tags": {
                                "BadUrl": [
                                    "String.String"
                                ],
                                "Timeout": [],
                                "NetworkError": [],
                                "BadStatus": [
                                    "Basics.Int"
                                ],
                                "BadBody": [
                                    "String.String"
                                ]
                            }
                        },
                        "Basics.Float": {
                            "args": [],
                            "tags": {
                                "Float": []
                            }
                        },
                        "Pages.Funds.Funds": {
                            "args": [],
                            "tags": {
                                "Funds": [
                                    "{ name : String.String }"
                                ]
                            }
                        },
                        "Data.User.Gender": {
                            "args": [],
                            "tags": {
                                "Male": [],
                                "Female": []
                            }
                        },
                        "Http.Header": {
                            "args": [],
                            "tags": {
                                "Header": [
                                    "String.String",
                                    "String.String"
                                ]
                            }
                        },
                        "List.List": {
                            "args": [
                                "a"
                            ],
                            "tags": {}
                        },
                        "Pages.Market.Market": {
                            "args": [],
                            "tags": {
                                "Market": [
                                    "{ name : String.String }"
                                ]
                            }
                        },
                        "Pages.PingPong.PingPong": {
                            "args": [],
                            "tags": {
                                "PingPong": [
                                    "{ name : String.String }"
                                ]
                            }
                        },
                        "Pages.Portfolio.Portfolio": {
                            "args": [],
                            "tags": {
                                "Portfolio": [
                                    "{ name : String.String }"
                                ]
                            }
                        },
                        "Result.Result": {
                            "args": [
                                "error",
                                "value"
                            ],
                            "tags": {
                                "Ok": [
                                    "value"
                                ],
                                "Err": [
                                    "error"
                                ]
                            }
                        },
                        "Data.Hardware.ResultOfMatch": {
                            "args": [],
                            "tags": {
                                "Won": [],
                                "Lost": [],
                                "Undecided": []
                            }
                        },
                        "Pages.Sell.Sell": {
                            "args": [],
                            "tags": {
                                "Sell": [
                                    "{ name : String.String }"
                                ]
                            }
                        },
                        "Pages.Buy.Status": {
                            "args": [],
                            "tags": {
                                "Loading": []
                            }
                        },
                        "Pages.Dashboard.Status": {
                            "args": [],
                            "tags": {
                                "Loading": []
                            }
                        },
                        "Pages.Funds.Status": {
                            "args": [],
                            "tags": {
                                "Loading": []
                            }
                        },
                        "Pages.Market.Status": {
                            "args": [],
                            "tags": {
                                "Loading": []
                            }
                        },
                        "Pages.PingPong.Status": {
                            "args": [],
                            "tags": {
                                "Loading": []
                            }
                        },
                        "Pages.Portfolio.Status": {
                            "args": [],
                            "tags": {
                                "Loading": []
                            }
                        },
                        "Pages.Sell.Status": {
                            "args": [],
                            "tags": {
                                "Loading": []
                            }
                        },
                        "Pages.Support.Status": {
                            "args": [],
                            "tags": {
                                "Loading": []
                            }
                        },
                        "Pages.Support.Support": {
                            "args": [],
                            "tags": {
                                "Support": [
                                    "{ name : String.String }"
                                ]
                            }
                        },
                        "Data.User.User": {
                            "args": [],
                            "tags": {
                                "Spectator": [
                                    "Data.User.UserInfo"
                                ],
                                "Registered": [
                                    "Data.User.UserInfo"
                                ]
                            }
                        },
                        "Bytes.Bytes": {
                            "args": [],
                            "tags": {
                                "Bytes": []
                            }
                        },
                        "Dict.Dict": {
                            "args": [
                                "k",
                                "v"
                            ],
                            "tags": {
                                "RBNode_elm_builtin": [
                                    "Dict.NColor",
                                    "k",
                                    "v",
                                    "Dict.Dict k v",
                                    "Dict.Dict k v"
                                ],
                                "RBEmpty_elm_builtin": []
                            }
                        },
                        "Grpc.GrpcStatus": {
                            "args": [],
                            "tags": {
                                "Ok_": [],
                                "Cancelled": [],
                                "Unknown": [],
                                "InvalidArgument": [],
                                "DeadlineExceeded": [],
                                "NotFound": [],
                                "AlreadyExists": [],
                                "PermissionDenied": [],
                                "ResourceExhausted": [],
                                "FailedPrecondition": [],
                                "Aborted": [],
                                "OutOfRange": [],
                                "Unimplemented": [],
                                "Internal": [],
                                "Unavailable": [],
                                "DataLoss": [],
                                "Unauthenticated": []
                            }
                        },
                        "Dict.NColor": {
                            "args": [],
                            "tags": {
                                "Red": [],
                                "Black": []
                            }
                        }
                    }
                }
            })
        }
    });
    //////////////////// HMR BEGIN ////////////////////
    /*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Original Author: Flux Xu @fluxxu
*/ /*
    A note about the environment that this code runs in...

    assumed globals:
        - `module` (from Node.js module system and webpack)

    assumed in scope after injection into the Elm IIFE:
        - `scope` (has an 'Elm' property which contains the public Elm API)
        - various functions defined by Elm which we have to hook such as `_Platform_initialize` and `_Scheduler_binding`
 */ if (module.hot) {
        (function() {
            "use strict";
            //polyfill for IE: https://github.com/fluxxu/elm-hot-loader/issues/16
            if (typeof Object.assign != "function") Object.assign = function(target) {
                "use strict";
                if (target == null) throw new TypeError("Cannot convert undefined or null to object");
                target = Object(target);
                for(var index = 1; index < arguments.length; index++){
                    var source = arguments[index];
                    if (source != null) {
                        for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
                    }
                }
                return target;
            };
            // Elm 0.19.1 introduced a '$' prefix at the beginning of the symbols it emits,
            // and we check for `Maybe.Just` because we expect it to be present in all Elm programs.
            var elmVersion;
            if (typeof elm$core$Maybe$Just !== "undefined") elmVersion = "0.19.0";
            else if (typeof $elm$core$Maybe$Just !== "undefined") elmVersion = "0.19.1";
            else throw new Error("Could not determine Elm version");
            function elmSymbol(symbol) {
                try {
                    switch(elmVersion){
                        case "0.19.0":
                            return eval(symbol);
                        case "0.19.1":
                            return eval("$" + symbol);
                        default:
                            throw new Error("Cannot resolve " + symbol + ". Elm version unknown!");
                    }
                } catch (e) {
                    if (e instanceof ReferenceError) return undefined;
                    else throw e;
                }
            }
            var instances = module.hot.data ? module.hot.data.instances || {} : {};
            var uid = module.hot.data ? module.hot.data.uid || 0 : 0;
            if (Object.keys(instances).length === 0) log("[elm-hot] Enabled");
            var cancellers = [];
            // These 2 variables act as dynamically-scoped variables which are set only when the
            // Elm module's hooked init function is called.
            var initializingInstance = null;
            var swappingInstance = null;
            module.hot.accept();
            module.hot.dispose(function(data) {
                data.instances = instances;
                data.uid = uid;
                // Cleanup pending async tasks
                // First, make sure that no new tasks can be started until we finish replacing the code
                _Scheduler_binding = function() {
                    return _Scheduler_fail(new Error("[elm-hot] Inactive Elm instance."));
                };
                // Second, kill pending tasks belonging to the old instance
                if (cancellers.length) {
                    log("[elm-hot] Killing " + cancellers.length + " running processes...");
                    try {
                        cancellers.forEach(function(cancel) {
                            cancel();
                        });
                    } catch (e) {
                        console.warn("[elm-hot] Kill process error: " + e.message);
                    }
                }
            });
            function log(message) {
                if (module.hot.verbose) console.log(message);
            }
            function getId() {
                return ++uid;
            }
            function findPublicModules(parent, path) {
                var modules = [];
                for(var key in parent){
                    var child = parent[key];
                    var currentPath = path ? path + "." + key : key;
                    if ("init" in child) modules.push({
                        path: currentPath,
                        module: child
                    });
                    else modules = modules.concat(findPublicModules(child, currentPath));
                }
                return modules;
            }
            function registerInstance(domNode, flags, path, portSubscribes, portSends) {
                var id = getId();
                var instance = {
                    id: id,
                    path: path,
                    domNode: domNode,
                    flags: flags,
                    portSubscribes: portSubscribes,
                    portSends: portSends,
                    lastState: null // last Elm app state (root model)
                };
                return instances[id] = instance;
            }
            function isFullscreenApp() {
                // Returns true if the Elm app will take over the entire DOM body.
                return typeof elmSymbol("elm$browser$Browser$application") !== "undefined" || typeof elmSymbol("elm$browser$Browser$document") !== "undefined";
            }
            function wrapDomNode(node) {
                // When embedding an Elm app into a specific DOM node, Elm will replace the provided
                // DOM node with the Elm app's content. When the Elm app is compiled normally, the
                // original DOM node is reused (its attributes and content changes, but the object
                // in memory remains the same). But when compiled using `--debug`, Elm will completely
                // destroy the original DOM node and instead replace it with 2 brand new nodes: one
                // for your Elm app's content and the other for the Elm debugger UI. In this case,
                // if you held a reference to the DOM node provided for embedding, it would be orphaned
                // after Elm module initialization.
                //
                // So in order to make both cases consistent and isolate us from changes in how Elm
                // does this, we will insert a dummy node to wrap the node for embedding and hold
                // a reference to the dummy node.
                //
                // We will also put a tag on the dummy node so that the Elm developer knows who went
                // behind their back and rudely put stuff in their DOM.
                var dummyNode = document.createElement("div");
                dummyNode.setAttribute("data-elm-hot", "true");
                dummyNode.style.height = "inherit";
                var parentNode = node.parentNode;
                parentNode.replaceChild(dummyNode, node);
                dummyNode.appendChild(node);
                return dummyNode;
            }
            function wrapPublicModule(path, module1) {
                var originalInit = module1.init;
                if (originalInit) module1.init = function(args) {
                    var elm;
                    var portSubscribes = {};
                    var portSends = {};
                    var domNode = null;
                    var flags = null;
                    if (typeof args !== "undefined") {
                        // normal case
                        domNode = args["node"] && !isFullscreenApp() ? wrapDomNode(args["node"]) : document.body;
                        flags = args["flags"];
                    } else {
                        // rare case: Elm allows init to be called without any arguments at all
                        domNode = document.body;
                        flags = undefined;
                    }
                    initializingInstance = registerInstance(domNode, flags, path, portSubscribes, portSends);
                    elm = originalInit(args);
                    wrapPorts(elm, portSubscribes, portSends);
                    initializingInstance = null;
                    return elm;
                };
                else console.error("Could not find a public module to wrap at path " + path);
            }
            function swap(Elm, instance) {
                log("[elm-hot] Hot-swapping module: " + instance.path);
                swappingInstance = instance;
                // remove from the DOM everything that had been created by the old Elm app
                var containerNode = instance.domNode;
                while(containerNode.lastChild)containerNode.removeChild(containerNode.lastChild);
                var m = getAt(instance.path.split("."), Elm);
                var elm;
                if (m) {
                    // prepare to initialize the new Elm module
                    var args = {
                        flags: instance.flags
                    };
                    if (containerNode === document.body) ;
                    else {
                        // embed case: provide a new node for Elm to use
                        var nodeForEmbed = document.createElement("div");
                        containerNode.appendChild(nodeForEmbed);
                        args["node"] = nodeForEmbed;
                    }
                    elm = m.init(args);
                    Object.keys(instance.portSubscribes).forEach(function(portName) {
                        if (portName in elm.ports && "subscribe" in elm.ports[portName]) {
                            var handlers = instance.portSubscribes[portName];
                            if (!handlers.length) return;
                            log("[elm-hot] Reconnect " + handlers.length + " handler(s) to port '" + portName + "' (" + instance.path + ").");
                            handlers.forEach(function(handler) {
                                elm.ports[portName].subscribe(handler);
                            });
                        } else {
                            delete instance.portSubscribes[portName];
                            log("[elm-hot] Port was removed: " + portName);
                        }
                    });
                    Object.keys(instance.portSends).forEach(function(portName) {
                        if (portName in elm.ports && "send" in elm.ports[portName]) {
                            log("[elm-hot] Replace old port send with the new send");
                            instance.portSends[portName] = elm.ports[portName].send;
                        } else {
                            delete instance.portSends[portName];
                            log("[elm-hot] Port was removed: " + portName);
                        }
                    });
                } else log("[elm-hot] Module was removed: " + instance.path);
                swappingInstance = null;
            }
            function wrapPorts(elm, portSubscribes, portSends) {
                var portNames = Object.keys(elm.ports || {});
                //hook ports
                if (portNames.length) {
                    // hook outgoing ports
                    portNames.filter(function(name) {
                        return "subscribe" in elm.ports[name];
                    }).forEach(function(portName) {
                        var port = elm.ports[portName];
                        var subscribe = port.subscribe;
                        var unsubscribe = port.unsubscribe;
                        elm.ports[portName] = Object.assign(port, {
                            subscribe: function(handler) {
                                log("[elm-hot] ports." + portName + ".subscribe called.");
                                if (!portSubscribes[portName]) portSubscribes[portName] = [
                                    handler
                                ];
                                else //TODO handle subscribing to single handler more than once?
                                portSubscribes[portName].push(handler);
                                return subscribe.call(port, handler);
                            },
                            unsubscribe: function(handler) {
                                log("[elm-hot] ports." + portName + ".unsubscribe called.");
                                var list = portSubscribes[portName];
                                if (list && list.indexOf(handler) !== -1) list.splice(list.lastIndexOf(handler), 1);
                                else console.warn("[elm-hot] ports." + portName + ".unsubscribe: handler not subscribed");
                                return unsubscribe.call(port, handler);
                            }
                        });
                    });
                    // hook incoming ports
                    portNames.filter(function(name) {
                        return "send" in elm.ports[name];
                    }).forEach(function(portName) {
                        var port = elm.ports[portName];
                        portSends[portName] = port.send;
                        elm.ports[portName] = Object.assign(port, {
                            send: function(val) {
                                return portSends[portName].call(port, val);
                            }
                        });
                    });
                }
                return portSubscribes;
            }
            /*
        Breadth-first search for a `Browser.Navigation.Key` in the user's app model.
        Returns the key and keypath or null if not found.
        */ function findNavKey(rootModel) {
                var queue = [];
                if (isDebuggerModel(rootModel)) /*
                 Extract the user's app model from the Elm Debugger's model. The Elm debugger
                 can hold multiple references to the user's model (e.g. in its "history"). So
                 we must be careful to only search within the "state" part of the Debugger.
                */ queue.push({
                    value: rootModel["state"],
                    keypath: [
                        "state"
                    ]
                });
                else queue.push({
                    value: rootModel,
                    keypath: []
                });
                while(queue.length !== 0){
                    var item = queue.shift();
                    if (typeof item.value === "undefined" || item.value === null) continue;
                    // The nav key is identified by a runtime tag added by the elm-hot injector.
                    if (item.value.hasOwnProperty("elm-hot-nav-key")) // found it!
                    return item;
                    if (typeof item.value !== "object") continue;
                    for(var propName in item.value){
                        if (!item.value.hasOwnProperty(propName)) continue;
                        var newKeypath = item.keypath.slice();
                        newKeypath.push(propName);
                        queue.push({
                            value: item.value[propName],
                            keypath: newKeypath
                        });
                    }
                }
                return null;
            }
            function isDebuggerModel(model) {
                // Up until elm/browser 1.0.2, the Elm debugger could be identified by a
                // property named "expando". But in version 1.0.2 that was renamed to "expandoModel"
                return model && (model.hasOwnProperty("expando") || model.hasOwnProperty("expandoModel")) && model.hasOwnProperty("state");
            }
            function getAt(keyPath, obj) {
                return keyPath.reduce(function(xs, x) {
                    return xs && xs[x] ? xs[x] : null;
                }, obj);
            }
            function removeNavKeyListeners(navKey) {
                window.removeEventListener("popstate", navKey.value);
                window.navigator.userAgent.indexOf("Trident") < 0 || window.removeEventListener("hashchange", navKey.value);
            }
            // hook program creation
            var initialize = _Platform_initialize;
            _Platform_initialize = function(flagDecoder, args, init, update, subscriptions, stepperBuilder) {
                var instance = initializingInstance || swappingInstance;
                var tryFirstRender = !!swappingInstance;
                var hookedInit = function(args) {
                    var initialStateTuple = init(args);
                    if (swappingInstance) {
                        var oldModel = swappingInstance.lastState;
                        var newModel = initialStateTuple.a;
                        if (typeof elmSymbol("elm$browser$Browser$application") !== "undefined") {
                            var oldKeyLoc = findNavKey(oldModel);
                            // attempt to find the Browser.Navigation.Key in the newly-constructed model
                            // and bring it along with the rest of the old data.
                            var newKeyLoc = findNavKey(newModel);
                            var error = null;
                            if (newKeyLoc === null) error = "could not find Browser.Navigation.Key in the new app model";
                            else if (oldKeyLoc === null) error = "could not find Browser.Navigation.Key in the old app model.";
                            else if (newKeyLoc.keypath.toString() !== oldKeyLoc.keypath.toString()) error = "the location of the Browser.Navigation.Key in the model has changed.";
                            else {
                                // remove event listeners attached to the old nav key
                                removeNavKeyListeners(oldKeyLoc.value);
                                // insert the new nav key into the old model in the exact same location
                                var parentKeyPath = oldKeyLoc.keypath.slice(0, -1);
                                var lastSegment = oldKeyLoc.keypath.slice(-1)[0];
                                var oldParent = getAt(parentKeyPath, oldModel);
                                oldParent[lastSegment] = newKeyLoc.value;
                            }
                            if (error !== null) {
                                console.error("[elm-hot] Hot-swapping " + instance.path + " not possible: " + error);
                                oldModel = newModel;
                            }
                        }
                        // the heart of the app state hot-swap
                        initialStateTuple.a = oldModel;
                        // ignore any Cmds returned by the init during hot-swap
                        initialStateTuple.b = elmSymbol("elm$core$Platform$Cmd$none");
                    } else // capture the initial state for later
                    initializingInstance.lastState = initialStateTuple.a;
                    return initialStateTuple;
                };
                var hookedStepperBuilder = function(sendToApp, model) {
                    var result;
                    // first render may fail if shape of model changed too much
                    if (tryFirstRender) {
                        tryFirstRender = false;
                        try {
                            result = stepperBuilder(sendToApp, model);
                        } catch (e) {
                            throw new Error("[elm-hot] Hot-swapping " + instance.path + " is not possible, please reload page. Error: " + e.message);
                        }
                    } else result = stepperBuilder(sendToApp, model);
                    return function(nextModel, isSync) {
                        if (instance) // capture the state after every step so that later we can restore from it during a hot-swap
                        instance.lastState = nextModel;
                        return result(nextModel, isSync);
                    };
                };
                return initialize(flagDecoder, args, hookedInit, update, subscriptions, hookedStepperBuilder);
            };
            // hook process creation
            var originalBinding = _Scheduler_binding;
            _Scheduler_binding = function(originalCallback) {
                return originalBinding(function() {
                    // start the scheduled process, which may return a cancellation function.
                    var cancel = originalCallback.apply(this, arguments);
                    if (cancel) {
                        cancellers.push(cancel);
                        return function() {
                            cancellers.splice(cancellers.indexOf(cancel), 1);
                            return cancel();
                        };
                    }
                    return cancel;
                });
            };
            scope["_elm_hot_loader_init"] = function(Elm) {
                // swap instances
                var removedInstances = [];
                for(var id in instances){
                    var instance = instances[id];
                    if (instance.domNode.parentNode) swap(Elm, instance);
                    else removedInstances.push(id);
                }
                removedInstances.forEach(function(id) {
                    delete instance[id];
                });
                // wrap all public modules
                var publicModules = findPublicModules(Elm);
                publicModules.forEach(function(m) {
                    wrapPublicModule(m.path, m.module);
                });
            };
        })();
        scope["_elm_hot_loader_init"](scope["Elm"]);
    }
//////////////////// HMR END ////////////////////
})(this);

},{}],"2AsAh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// NOTE: This is the main file for communicating with Elm. It receives messages from Elm and
// then calls the relevant function in the relevant .js file to communicate with the hardware device
// NOTE: This file is imported in setupElm.mjs
// NOTE: Messages from the Elm 'sendMessageToJs' port are received and parsed here to determine
// which function (in the relevant .js file) to use to communicate with the hardware device
parcelHelpers.export(exports, "handleMessageFromElm", ()=>handleMessageFromElm);
var _ledgerInteropJs = require("./hardware/ledgerInterop.js");
var _checkDeviceConnectJs = require("./hardware/checkDeviceConnect.js");
var _xmrHardwareInteropJs = require("./hardware/xmrHardwareInterop.js");
async function handleMessageFromElm(message, app) {
    console.log("here in handle : ", message);
    // NOTE: Use FF debugger to view 'message'
    // HACK: This will need to be more robust. It must be something that will never appear in the json:
    const messageArr = message.split("~^&");
    //NOTE: Switch on the message label (element[0]), then handle the , separated params
    switch(messageArr[0]){
        case "connectLNS":
            (0, _ledgerInteropJs.connectLNS)(app);
            break;
        case "getMoneroAddress":
            //connectLNS(app)
            try {
                // Perform further actions with the device
                (0, _xmrHardwareInteropJs.getMoneroAddress)();
            } catch (error) {
                console.error("Device connection error:", error);
            }
            break;
        case "initiateXMRToBTCTrans":
            //connectLNS(app)
            try {
                // Perform further actions with the device
                hwinterop.initiateXMRToBTCTrans(messageArr[1]);
            } catch (error) {
                console.error("Device connection error:", error);
            }
            break;
        //NOTE: We're going to talk to mongodb via the node application
        // to do searches, so we can do them anonymously
        // We will make http requests from within Elm to the node application
        //NOTE: Adding a new function? Added it to index.html?
        default:
            console.log(`Sorry, problem:  ${message}.`);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","./hardware/ledgerInterop.js":"8DXR1","./hardware/xmrHardwareInterop.js":"2JAI7","./hardware/checkDeviceConnect.js":"2sLhv"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"8DXR1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "connectLNS", ()=>connectLNS);
parcelHelpers.export(exports, "setupElmPorts", ()=>setupElmPorts);
var _esnextMapGroupByJs = require("core-js/modules/esnext.map.group-by.js");
var _esnextSymbolDisposeJs = require("core-js/modules/esnext.symbol.dispose.js");
var _webImmediateJs = require("core-js/modules/web.immediate.js");
var _logs = require("@ledgerhq/logs");
var _hwAppBtc = require("@ledgerhq/hw-app-btc");
var _hwAppBtcDefault = parcelHelpers.interopDefault(_hwAppBtc);
var _hwTransportWebusb = require("@ledgerhq/hw-transport-webusb");
var _hwTransportWebusbDefault = parcelHelpers.interopDefault(_hwTransportWebusb);
async function connectLNS(app) {
    try {
        // Keep if you chose the USB protocol
        const transport = await (0, _hwTransportWebusbDefault.default).create();
        //listen to the events which are sent by the Ledger packages in order to debug the app
        (0, _logs.listen)((log)=>console.log(log));
        //When the Ledger device connected it is trying to display the bitcoin address
        const appBtc = new (0, _hwAppBtcDefault.default)({
            transport,
            currency: "bitcoin"
        });
        const { bitcoinAddress } = await appBtc.getWalletPublicKey("44'/0'/0'/0/0", {
            verify: false,
            format: "legacy"
        });
        console.log("Btc address: ", bitcoinAddress);
        //app.ports.receiveMessageFromJs.send({ operationEventMsg: bitcoinAddress });
        try {
            const message = {
                operationEventMsg: bitcoinAddress
            };
            console.log("Sending message:", message);
            app.ports.receiveMessageFromJs.send(message);
        } catch (error) {
            const errorMessage = {
                Err: error.message
            };
            console.log("Sending error message:", errorMessage);
            app.ports.receiveMessageFromJs.send(errorMessage);
        }
        //Display the address on the Ledger device and ask to verify the address
        await appBtc.getWalletPublicKey("44'/0'/0'/0/0", {
            format: "legacy",
            verify: true
        });
        transport.disconnect();
    } catch (e) {
        //Catch any error thrown and displays it on the screen
        const $err = document.createElement("code");
        $err.style.color = "#f66";
        $err.textContent = String(e.message || e);
        console.log("connectLNS errors:", e.message);
    }
}
function setupElmPorts(app) {
    jsonMsgToElm = {
        operationEventMsg: operationEvent,
        //NOTE: dataFromMongo is what we originally sent to Elm alone
        // Now it is sent with these other fields for added context
        dataFromMongo: userData,
        //NOTE: Each 'additionalDataFromJs' will have it's own decoder in Elm 
        // Which decoder will be determined by the 'msg' type above
        additionalDataFromJs: additionalDataObjExtendibleIfRequired
    };
}

},{"core-js/modules/esnext.map.group-by.js":"3AR1K","core-js/modules/esnext.symbol.dispose.js":"b9ez5","core-js/modules/web.immediate.js":"49tUX","@ledgerhq/logs":"i4OI0","@ledgerhq/hw-app-btc":"f39ni","@ledgerhq/hw-transport-webusb":"9zmIA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3AR1K":[function(require,module,exports) {
"use strict";
// TODO: Remove from `core-js@4`
require("4d92d9132913bacd");

},{"4d92d9132913bacd":"c4yOM"}],"c4yOM":[function(require,module,exports) {
"use strict";
var $ = require("6567f4dade5d8960");
var uncurryThis = require("f35d7393646ad055");
var aCallable = require("c4503f7eb1018306");
var requireObjectCoercible = require("d7c6ba4f404b5360");
var iterate = require("ff883ec9010d6328");
var MapHelpers = require("f9f796f22480c881");
var IS_PURE = require("dc5cfe657d3f962b");
var fails = require("59f5d275c85c76");
var Map = MapHelpers.Map;
var has = MapHelpers.has;
var get = MapHelpers.get;
var set = MapHelpers.set;
var push = uncurryThis([].push);
var DOES_NOT_WORK_WITH_PRIMITIVES = IS_PURE || fails(function() {
    return Map.groupBy("ab", function(it) {
        return it;
    }).get("a").length !== 1;
});
// `Map.groupBy` method
// https://github.com/tc39/proposal-array-grouping
$({
    target: "Map",
    stat: true,
    forced: IS_PURE || DOES_NOT_WORK_WITH_PRIMITIVES
}, {
    groupBy: function groupBy(items, callbackfn) {
        requireObjectCoercible(items);
        aCallable(callbackfn);
        var map = new Map();
        var k = 0;
        iterate(items, function(value) {
            var key = callbackfn(value, k++);
            if (!has(map, key)) set(map, key, [
                value
            ]);
            else push(get(map, key), value);
        });
        return map;
    }
});

},{"6567f4dade5d8960":"dIGt4","f35d7393646ad055":"7GlkT","c4503f7eb1018306":"gOMir","d7c6ba4f404b5360":"fOR0B","ff883ec9010d6328":"4OXGm","f9f796f22480c881":"f9Wim","dc5cfe657d3f962b":"5ZsyC","59f5d275c85c76":"hL6D2"}],"dIGt4":[function(require,module,exports) {
"use strict";
var globalThis = require("23dea28abc8414d1");
var getOwnPropertyDescriptor = require("2ec751f39e500b85").f;
var createNonEnumerableProperty = require("b4567636b28a3b3a");
var defineBuiltIn = require("50460aa43dd4048a");
var defineGlobalProperty = require("581238c99f8c2c30");
var copyConstructorProperties = require("566a383894c688bc");
var isForced = require("f0e2e697f04e8ad9");
/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/ module.exports = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) target = globalThis;
    else if (STATIC) target = globalThis[TARGET] || defineGlobalProperty(TARGET, {});
    else target = globalThis[TARGET] && globalThis[TARGET].prototype;
    if (target) for(key in source){
        sourceProperty = source[key];
        if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor(target, key);
            targetProperty = descriptor && descriptor.value;
        } else targetProperty = target[key];
        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
        // contained in target
        if (!FORCED && targetProperty !== undefined) {
            if (typeof sourceProperty == typeof targetProperty) continue;
            copyConstructorProperties(sourceProperty, targetProperty);
        }
        // add a flag to not completely full polyfills
        if (options.sham || targetProperty && targetProperty.sham) createNonEnumerableProperty(sourceProperty, "sham", true);
        defineBuiltIn(target, key, sourceProperty, options);
    }
};

},{"23dea28abc8414d1":"9fY7y","2ec751f39e500b85":"lk5NI","b4567636b28a3b3a":"8CL42","50460aa43dd4048a":"6XwEX","581238c99f8c2c30":"ggjnO","566a383894c688bc":"9Z12i","f0e2e697f04e8ad9":"6uTCZ"}],"9fY7y":[function(require,module,exports) {
var global = arguments[3];
"use strict";
var check = function(it) {
    return it && it.Math === Math && it;
};
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports = // eslint-disable-next-line es/no-global-this -- safe
check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
check(typeof self == "object" && self) || check(typeof global == "object" && global) || check(typeof this == "object" && this) || // eslint-disable-next-line no-new-func -- fallback
function() {
    return this;
}() || Function("return this")();

},{}],"lk5NI":[function(require,module,exports) {
"use strict";
var DESCRIPTORS = require("c04e6fb248689dba");
var call = require("553ec943aa2a4554");
var propertyIsEnumerableModule = require("bbc5e69071aa2fbd");
var createPropertyDescriptor = require("1d2ffbfd99e01f41");
var toIndexedObject = require("c4ea69a78a643d87");
var toPropertyKey = require("8ab18ff766aa2ab9");
var hasOwn = require("3761c5d34b7aa48f");
var IE8_DOM_DEFINE = require("c4dfcc26308f1b4a");
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject(O);
    P = toPropertyKey(P);
    if (IE8_DOM_DEFINE) try {
        return $getOwnPropertyDescriptor(O, P);
    } catch (error) {}
    if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};

},{"c04e6fb248689dba":"92ZIi","553ec943aa2a4554":"d7JlP","bbc5e69071aa2fbd":"7SuiS","1d2ffbfd99e01f41":"1lpav","c4ea69a78a643d87":"jLWwQ","8ab18ff766aa2ab9":"5XWKd","3761c5d34b7aa48f":"gC2Q5","c4dfcc26308f1b4a":"qS9uN"}],"92ZIi":[function(require,module,exports) {
"use strict";
var fails = require("735b783268fd06c0");
// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function() {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty({}, 1, {
        get: function() {
            return 7;
        }
    })[1] !== 7;
});

},{"735b783268fd06c0":"hL6D2"}],"hL6D2":[function(require,module,exports) {
"use strict";
module.exports = function(exec) {
    try {
        return !!exec();
    } catch (error) {
        return true;
    }
};

},{}],"d7JlP":[function(require,module,exports) {
"use strict";
var NATIVE_BIND = require("44e025d030d66023");
var call = Function.prototype.call;
module.exports = NATIVE_BIND ? call.bind(call) : function() {
    return call.apply(call, arguments);
};

},{"44e025d030d66023":"i16Dq"}],"i16Dq":[function(require,module,exports) {
"use strict";
var fails = require("2642aa7619056f20");
module.exports = !fails(function() {
    // eslint-disable-next-line es/no-function-prototype-bind -- safe
    var test = (function() {}).bind();
    // eslint-disable-next-line no-prototype-builtins -- safe
    return typeof test != "function" || test.hasOwnProperty("prototype");
});

},{"2642aa7619056f20":"hL6D2"}],"7SuiS":[function(require,module,exports) {
"use strict";
var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({
    1: 2
}, 1);
// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor(this, V);
    return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;

},{}],"1lpav":[function(require,module,exports) {
"use strict";
module.exports = function(bitmap, value) {
    return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
    };
};

},{}],"jLWwQ":[function(require,module,exports) {
"use strict";
// toObject with fallback for non-array-like ES3 strings
var IndexedObject = require("9d8f8f50ac9468eb");
var requireObjectCoercible = require("f7224aed72953ac4");
module.exports = function(it) {
    return IndexedObject(requireObjectCoercible(it));
};

},{"9d8f8f50ac9468eb":"kPk5h","f7224aed72953ac4":"fOR0B"}],"kPk5h":[function(require,module,exports) {
"use strict";
var uncurryThis = require("7ba7e65983d7b662");
var fails = require("df551e12a7c872dd");
var classof = require("1d34ea813cebff9c");
var $Object = Object;
var split = uncurryThis("".split);
// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function() {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins -- safe
    return !$Object("z").propertyIsEnumerable(0);
}) ? function(it) {
    return classof(it) === "String" ? split(it, "") : $Object(it);
} : $Object;

},{"7ba7e65983d7b662":"7GlkT","df551e12a7c872dd":"hL6D2","1d34ea813cebff9c":"bdfmm"}],"7GlkT":[function(require,module,exports) {
"use strict";
var NATIVE_BIND = require("829dd7a4e960cf9e");
var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
    return function() {
        return call.apply(fn, arguments);
    };
};

},{"829dd7a4e960cf9e":"i16Dq"}],"bdfmm":[function(require,module,exports) {
"use strict";
var uncurryThis = require("1c71c3f6daac476c");
var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis("".slice);
module.exports = function(it) {
    return stringSlice(toString(it), 8, -1);
};

},{"1c71c3f6daac476c":"7GlkT"}],"fOR0B":[function(require,module,exports) {
"use strict";
var isNullOrUndefined = require("74607922ed30019f");
var $TypeError = TypeError;
// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function(it) {
    if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
    return it;
};

},{"74607922ed30019f":"gM5ar"}],"gM5ar":[function(require,module,exports) {
"use strict";
// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function(it) {
    return it === null || it === undefined;
};

},{}],"5XWKd":[function(require,module,exports) {
"use strict";
var toPrimitive = require("53a3a67ac381c4e8");
var isSymbol = require("b992ca9cdcf7937b");
// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function(argument) {
    var key = toPrimitive(argument, "string");
    return isSymbol(key) ? key : key + "";
};

},{"53a3a67ac381c4e8":"a2mK1","b992ca9cdcf7937b":"4aV4F"}],"a2mK1":[function(require,module,exports) {
"use strict";
var call = require("70235907dc93b4b0");
var isObject = require("46fb53dace408c8e");
var isSymbol = require("677bdc4d74d2f983");
var getMethod = require("80395bcde336a28b");
var ordinaryToPrimitive = require("49552a7324952190");
var wellKnownSymbol = require("aea01c71276624bf");
var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function(input, pref) {
    if (!isObject(input) || isSymbol(input)) return input;
    var exoticToPrim = getMethod(input, TO_PRIMITIVE);
    var result;
    if (exoticToPrim) {
        if (pref === undefined) pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject(result) || isSymbol(result)) return result;
        throw new $TypeError("Can't convert object to primitive value");
    }
    if (pref === undefined) pref = "number";
    return ordinaryToPrimitive(input, pref);
};

},{"70235907dc93b4b0":"d7JlP","46fb53dace408c8e":"Z0pBo","677bdc4d74d2f983":"4aV4F","80395bcde336a28b":"9Zfiw","49552a7324952190":"7MME2","aea01c71276624bf":"gTwyA"}],"Z0pBo":[function(require,module,exports) {
"use strict";
var isCallable = require("f87cee1cb79cbcca");
module.exports = function(it) {
    return typeof it == "object" ? it !== null : isCallable(it);
};

},{"f87cee1cb79cbcca":"l3Kyn"}],"l3Kyn":[function(require,module,exports) {
"use strict";
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == "object" && document.all;
// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == "undefined" && documentAll !== undefined ? function(argument) {
    return typeof argument == "function" || argument === documentAll;
} : function(argument) {
    return typeof argument == "function";
};

},{}],"4aV4F":[function(require,module,exports) {
"use strict";
var getBuiltIn = require("6b6c481cdfb7df35");
var isCallable = require("2af44fcbdbf14c83");
var isPrototypeOf = require("76e903e830c40e7c");
var USE_SYMBOL_AS_UID = require("7e2fe930b3598e22");
var $Object = Object;
module.exports = USE_SYMBOL_AS_UID ? function(it) {
    return typeof it == "symbol";
} : function(it) {
    var $Symbol = getBuiltIn("Symbol");
    return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};

},{"6b6c481cdfb7df35":"6ZUSY","2af44fcbdbf14c83":"l3Kyn","76e903e830c40e7c":"3jtKQ","7e2fe930b3598e22":"2Ye8Q"}],"6ZUSY":[function(require,module,exports) {
"use strict";
var globalThis = require("e057fc33d60763c1");
var isCallable = require("f1d62079325906cb");
var aFunction = function(argument) {
    return isCallable(argument) ? argument : undefined;
};
module.exports = function(namespace, method) {
    return arguments.length < 2 ? aFunction(globalThis[namespace]) : globalThis[namespace] && globalThis[namespace][method];
};

},{"e057fc33d60763c1":"9fY7y","f1d62079325906cb":"l3Kyn"}],"3jtKQ":[function(require,module,exports) {
"use strict";
var uncurryThis = require("83f14842ef67e16a");
module.exports = uncurryThis({}.isPrototypeOf);

},{"83f14842ef67e16a":"7GlkT"}],"2Ye8Q":[function(require,module,exports) {
"use strict";
/* eslint-disable es/no-symbol -- required for testing */ var NATIVE_SYMBOL = require("da4a972af0214ea0");
module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";

},{"da4a972af0214ea0":"8KyTD"}],"8KyTD":[function(require,module,exports) {
"use strict";
/* eslint-disable es/no-symbol -- required for testing */ var V8_VERSION = require("53b951dfb9de4d22");
var fails = require("b37df495bcdc1d99");
var globalThis = require("e5929e9affd2affc");
var $String = globalThis.String;
// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
    var symbol = Symbol("symbol detection");
    // Chrome 38 Symbol has incorrect toString conversion
    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
    // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
    // of course, fail.
    return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});

},{"53b951dfb9de4d22":"8UQPO","b37df495bcdc1d99":"hL6D2","e5929e9affd2affc":"9fY7y"}],"8UQPO":[function(require,module,exports) {
"use strict";
var globalThis = require("d049c1c2aa0eee5b");
var userAgent = require("4eb5796bbafe334d");
var process = globalThis.process;
var Deno = globalThis.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;
if (v8) {
    match = v8.split(".");
    // in old Chrome, versions of V8 isn't V8 = Chrome / 10
    // but their correct versions are not interesting for us
    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}
// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match) version = +match[1];
    }
}
module.exports = version;

},{"d049c1c2aa0eee5b":"9fY7y","4eb5796bbafe334d":"lApyY"}],"lApyY":[function(require,module,exports) {
"use strict";
var globalThis = require("888bcb4c75dc4ad");
var navigator = globalThis.navigator;
var userAgent = navigator && navigator.userAgent;
module.exports = userAgent ? String(userAgent) : "";

},{"888bcb4c75dc4ad":"9fY7y"}],"9Zfiw":[function(require,module,exports) {
"use strict";
var aCallable = require("bbfed17b24e215f4");
var isNullOrUndefined = require("492a86e2970f6a26");
// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function(V, P) {
    var func = V[P];
    return isNullOrUndefined(func) ? undefined : aCallable(func);
};

},{"bbfed17b24e215f4":"gOMir","492a86e2970f6a26":"gM5ar"}],"gOMir":[function(require,module,exports) {
"use strict";
var isCallable = require("4094667126ecac05");
var tryToString = require("fce2a7573db493fa");
var $TypeError = TypeError;
// `Assert: IsCallable(argument) is true`
module.exports = function(argument) {
    if (isCallable(argument)) return argument;
    throw new $TypeError(tryToString(argument) + " is not a function");
};

},{"4094667126ecac05":"l3Kyn","fce2a7573db493fa":"4O7d7"}],"4O7d7":[function(require,module,exports) {
"use strict";
var $String = String;
module.exports = function(argument) {
    try {
        return $String(argument);
    } catch (error) {
        return "Object";
    }
};

},{}],"7MME2":[function(require,module,exports) {
"use strict";
var call = require("abe9ca006f56626e");
var isCallable = require("c96b3a89fec6248a");
var isObject = require("551615fda0214f1b");
var $TypeError = TypeError;
// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function(input, pref) {
    var fn, val;
    if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
    if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
    if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
    throw new $TypeError("Can't convert object to primitive value");
};

},{"abe9ca006f56626e":"d7JlP","c96b3a89fec6248a":"l3Kyn","551615fda0214f1b":"Z0pBo"}],"gTwyA":[function(require,module,exports) {
"use strict";
var globalThis = require("ad5ef4474219c101");
var shared = require("6a2cda01df6b4c79");
var hasOwn = require("dccc28ffa5beeb54");
var uid = require("48d6af1225853d44");
var NATIVE_SYMBOL = require("9f762329148684");
var USE_SYMBOL_AS_UID = require("1ce268781e409df2");
var Symbol = globalThis.Symbol;
var WellKnownSymbolsStore = shared("wks");
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol["for"] || Symbol : Symbol && Symbol.withoutSetter || uid;
module.exports = function(name) {
    if (!hasOwn(WellKnownSymbolsStore, name)) WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name) ? Symbol[name] : createWellKnownSymbol("Symbol." + name);
    return WellKnownSymbolsStore[name];
};

},{"ad5ef4474219c101":"9fY7y","6a2cda01df6b4c79":"i1mHK","dccc28ffa5beeb54":"gC2Q5","48d6af1225853d44":"a3SEE","9f762329148684":"8KyTD","1ce268781e409df2":"2Ye8Q"}],"i1mHK":[function(require,module,exports) {
"use strict";
var store = require("84eeed9891aafe14");
module.exports = function(key, value) {
    return store[key] || (store[key] = value || {});
};

},{"84eeed9891aafe14":"l4ncH"}],"l4ncH":[function(require,module,exports) {
"use strict";
var IS_PURE = require("7b43004672b1879f");
var globalThis = require("bc8329e77dc2c1cc");
var defineGlobalProperty = require("dfb72a1d809f7b02");
var SHARED = "__core-js_shared__";
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});
(store.versions || (store.versions = [])).push({
    version: "3.38.1",
    mode: IS_PURE ? "pure" : "global",
    copyright: "\xa9 2014-2024 Denis Pushkarev (zloirock.ru)",
    license: "https://github.com/zloirock/core-js/blob/v3.38.1/LICENSE",
    source: "https://github.com/zloirock/core-js"
});

},{"7b43004672b1879f":"5ZsyC","bc8329e77dc2c1cc":"9fY7y","dfb72a1d809f7b02":"ggjnO"}],"5ZsyC":[function(require,module,exports) {
"use strict";
module.exports = false;

},{}],"ggjnO":[function(require,module,exports) {
"use strict";
var globalThis = require("2d1c29655635b9ea");
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
module.exports = function(key, value) {
    try {
        defineProperty(globalThis, key, {
            value: value,
            configurable: true,
            writable: true
        });
    } catch (error) {
        globalThis[key] = value;
    }
    return value;
};

},{"2d1c29655635b9ea":"9fY7y"}],"gC2Q5":[function(require,module,exports) {
"use strict";
var uncurryThis = require("f5dcaa60a713971f");
var toObject = require("ab17c4f45fcf0841");
var hasOwnProperty = uncurryThis({}.hasOwnProperty);
// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
    return hasOwnProperty(toObject(it), key);
};

},{"f5dcaa60a713971f":"7GlkT","ab17c4f45fcf0841":"5cb35"}],"5cb35":[function(require,module,exports) {
"use strict";
var requireObjectCoercible = require("f45a7b5dcdc4a410");
var $Object = Object;
// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function(argument) {
    return $Object(requireObjectCoercible(argument));
};

},{"f45a7b5dcdc4a410":"fOR0B"}],"a3SEE":[function(require,module,exports) {
"use strict";
var uncurryThis = require("5da0fe4507da20a3");
var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);
module.exports = function(key) {
    return "Symbol(" + (key === undefined ? "" : key) + ")_" + toString(++id + postfix, 36);
};

},{"5da0fe4507da20a3":"7GlkT"}],"qS9uN":[function(require,module,exports) {
"use strict";
var DESCRIPTORS = require("9b4278b13c076bf");
var fails = require("8aee5d88a5f9b6b5");
var createElement = require("1db4d60148afcf21");
// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function() {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(createElement("div"), "a", {
        get: function() {
            return 7;
        }
    }).a !== 7;
});

},{"9b4278b13c076bf":"92ZIi","8aee5d88a5f9b6b5":"hL6D2","1db4d60148afcf21":"4bOHl"}],"4bOHl":[function(require,module,exports) {
"use strict";
var globalThis = require("845bcece0e6d354");
var isObject = require("824df78b2e007250");
var document = globalThis.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);
module.exports = function(it) {
    return EXISTS ? document.createElement(it) : {};
};

},{"845bcece0e6d354":"9fY7y","824df78b2e007250":"Z0pBo"}],"8CL42":[function(require,module,exports) {
"use strict";
var DESCRIPTORS = require("a8753383ef98ee18");
var definePropertyModule = require("189ab650b8f71085");
var createPropertyDescriptor = require("1168c8162aa30435");
module.exports = DESCRIPTORS ? function(object, key, value) {
    return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function(object, key, value) {
    object[key] = value;
    return object;
};

},{"a8753383ef98ee18":"92ZIi","189ab650b8f71085":"iJR4w","1168c8162aa30435":"1lpav"}],"iJR4w":[function(require,module,exports) {
"use strict";
var DESCRIPTORS = require("ca50eb9163928400");
var IE8_DOM_DEFINE = require("d482f9e5478795e8");
var V8_PROTOTYPE_DEFINE_BUG = require("b6ad7537efb06f4b");
var anObject = require("16365a73399e7fe7");
var toPropertyKey = require("fab1d366c47796d9");
var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE = "configurable";
var WRITABLE = "writable";
// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPropertyKey(P);
    anObject(Attributes);
    if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
            O[P] = Attributes.value;
            Attributes = {
                configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                writable: false
            };
        }
    }
    return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPropertyKey(P);
    anObject(Attributes);
    if (IE8_DOM_DEFINE) try {
        return $defineProperty(O, P, Attributes);
    } catch (error) {}
    if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
    if ("value" in Attributes) O[P] = Attributes.value;
    return O;
};

},{"ca50eb9163928400":"92ZIi","d482f9e5478795e8":"qS9uN","b6ad7537efb06f4b":"ka1Un","16365a73399e7fe7":"4isCr","fab1d366c47796d9":"5XWKd"}],"ka1Un":[function(require,module,exports) {
"use strict";
var DESCRIPTORS = require("b22a5a2de93e3ad2");
var fails = require("249a5b857c2dfccd");
// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function() {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(function() {}, "prototype", {
        value: 42,
        writable: false
    }).prototype !== 42;
});

},{"b22a5a2de93e3ad2":"92ZIi","249a5b857c2dfccd":"hL6D2"}],"4isCr":[function(require,module,exports) {
"use strict";
var isObject = require("2b6c6258a0a6082f");
var $String = String;
var $TypeError = TypeError;
// `Assert: Type(argument) is Object`
module.exports = function(argument) {
    if (isObject(argument)) return argument;
    throw new $TypeError($String(argument) + " is not an object");
};

},{"2b6c6258a0a6082f":"Z0pBo"}],"6XwEX":[function(require,module,exports) {
"use strict";
var isCallable = require("99ee13632b3fa68");
var definePropertyModule = require("9ebb3e3004fccc0a");
var makeBuiltIn = require("f10cc812a3094053");
var defineGlobalProperty = require("d354802d852d9c2b");
module.exports = function(O, key, value, options) {
    if (!options) options = {};
    var simple = options.enumerable;
    var name = options.name !== undefined ? options.name : key;
    if (isCallable(value)) makeBuiltIn(value, name, options);
    if (options.global) {
        if (simple) O[key] = value;
        else defineGlobalProperty(key, value);
    } else {
        try {
            if (!options.unsafe) delete O[key];
            else if (O[key]) simple = true;
        } catch (error) {}
        if (simple) O[key] = value;
        else definePropertyModule.f(O, key, {
            value: value,
            enumerable: false,
            configurable: !options.nonConfigurable,
            writable: !options.nonWritable
        });
    }
    return O;
};

},{"99ee13632b3fa68":"l3Kyn","9ebb3e3004fccc0a":"iJR4w","f10cc812a3094053":"cTB4k","d354802d852d9c2b":"ggjnO"}],"cTB4k":[function(require,module,exports) {
"use strict";
var uncurryThis = require("ca84677f1ebd1804");
var fails = require("13360f2842eba261");
var isCallable = require("103e488c0928755a");
var hasOwn = require("cbf9b0e0779cc368");
var DESCRIPTORS = require("3f2eb7efeae2f72b");
var CONFIGURABLE_FUNCTION_NAME = require("548b10f284264c72").CONFIGURABLE;
var inspectSource = require("358f00f3103bd55b");
var InternalStateModule = require("9b2ce14119fd2412");
var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis("".slice);
var replace = uncurryThis("".replace);
var join = uncurryThis([].join);
var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
    return defineProperty(function() {}, "length", {
        value: 8
    }).length !== 8;
});
var TEMPLATE = String(String).split("String");
var makeBuiltIn = module.exports = function(value, name, options) {
    if (stringSlice($String(name), 0, 7) === "Symbol(") name = "[" + replace($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
    if (options && options.getter) name = "get " + name;
    if (options && options.setter) name = "set " + name;
    if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
        if (DESCRIPTORS) defineProperty(value, "name", {
            value: name,
            configurable: true
        });
        else value.name = name;
    }
    if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) defineProperty(value, "length", {
        value: options.arity
    });
    try {
        if (options && hasOwn(options, "constructor") && options.constructor) {
            if (DESCRIPTORS) defineProperty(value, "prototype", {
                writable: false
            });
        } else if (value.prototype) value.prototype = undefined;
    } catch (error) {}
    var state = enforceInternalState(value);
    if (!hasOwn(state, "source")) state.source = join(TEMPLATE, typeof name == "string" ? name : "");
    return value;
};
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
    return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, "toString");

},{"ca84677f1ebd1804":"7GlkT","13360f2842eba261":"hL6D2","103e488c0928755a":"l3Kyn","cbf9b0e0779cc368":"gC2Q5","3f2eb7efeae2f72b":"92ZIi","548b10f284264c72":"l6Kgd","358f00f3103bd55b":"9jh7O","9b2ce14119fd2412":"7AMlF"}],"l6Kgd":[function(require,module,exports) {
"use strict";
var DESCRIPTORS = require("8ad2bacb0e20b95c");
var hasOwn = require("4eabfd8f83afc9d5");
var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn(FunctionPrototype, "name");
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() {}).name === "something";
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
module.exports = {
    EXISTS: EXISTS,
    PROPER: PROPER,
    CONFIGURABLE: CONFIGURABLE
};

},{"8ad2bacb0e20b95c":"92ZIi","4eabfd8f83afc9d5":"gC2Q5"}],"9jh7O":[function(require,module,exports) {
"use strict";
var uncurryThis = require("26e26db98367212e");
var isCallable = require("40ed9a4f6ae66648");
var store = require("485d48d6f4c6739e");
var functionToString = uncurryThis(Function.toString);
// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) store.inspectSource = function(it) {
    return functionToString(it);
};
module.exports = store.inspectSource;

},{"26e26db98367212e":"7GlkT","40ed9a4f6ae66648":"l3Kyn","485d48d6f4c6739e":"l4ncH"}],"7AMlF":[function(require,module,exports) {
"use strict";
var NATIVE_WEAK_MAP = require("d3f0c9f3327b2fd6");
var globalThis = require("28c3574d0c39fe7e");
var isObject = require("f82e6cc0ac249fa5");
var createNonEnumerableProperty = require("c0ae163eea4ef97");
var hasOwn = require("6dea7358344877bb");
var shared = require("3e035a1241da2f0");
var sharedKey = require("88d6ccc27e779e5a");
var hiddenKeys = require("d40b9b3abdbb956e");
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError = globalThis.TypeError;
var WeakMap = globalThis.WeakMap;
var set, get, has;
var enforce = function(it) {
    return has(it) ? get(it) : set(it, {});
};
var getterFor = function(TYPE) {
    return function(it) {
        var state;
        if (!isObject(it) || (state = get(it)).type !== TYPE) throw new TypeError("Incompatible receiver, " + TYPE + " required");
        return state;
    };
};
if (NATIVE_WEAK_MAP || shared.state) {
    var store = shared.state || (shared.state = new WeakMap());
    /* eslint-disable no-self-assign -- prototype methods protection */ store.get = store.get;
    store.has = store.has;
    store.set = store.set;
    /* eslint-enable no-self-assign -- prototype methods protection */ set = function(it, metadata) {
        if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
    };
    get = function(it) {
        return store.get(it) || {};
    };
    has = function(it) {
        return store.has(it);
    };
} else {
    var STATE = sharedKey("state");
    hiddenKeys[STATE] = true;
    set = function(it, metadata) {
        if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
    };
    get = function(it) {
        return hasOwn(it, STATE) ? it[STATE] : {};
    };
    has = function(it) {
        return hasOwn(it, STATE);
    };
}
module.exports = {
    set: set,
    get: get,
    has: has,
    enforce: enforce,
    getterFor: getterFor
};

},{"d3f0c9f3327b2fd6":"2PZTl","28c3574d0c39fe7e":"9fY7y","f82e6cc0ac249fa5":"Z0pBo","c0ae163eea4ef97":"8CL42","6dea7358344877bb":"gC2Q5","3e035a1241da2f0":"l4ncH","88d6ccc27e779e5a":"eAjGz","d40b9b3abdbb956e":"661m4"}],"2PZTl":[function(require,module,exports) {
"use strict";
var globalThis = require("8b1a8c1dbfd18eb5");
var isCallable = require("aa77fff8d5ef0565");
var WeakMap = globalThis.WeakMap;
module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));

},{"8b1a8c1dbfd18eb5":"9fY7y","aa77fff8d5ef0565":"l3Kyn"}],"eAjGz":[function(require,module,exports) {
"use strict";
var shared = require("dbc8182adeb8c92f");
var uid = require("90b4ffb58508a6e5");
var keys = shared("keys");
module.exports = function(key) {
    return keys[key] || (keys[key] = uid(key));
};

},{"dbc8182adeb8c92f":"i1mHK","90b4ffb58508a6e5":"a3SEE"}],"661m4":[function(require,module,exports) {
"use strict";
module.exports = {};

},{}],"9Z12i":[function(require,module,exports) {
"use strict";
var hasOwn = require("d91d786cc71453ce");
var ownKeys = require("88cb809f98beddc6");
var getOwnPropertyDescriptorModule = require("10ea642aad5f7c21");
var definePropertyModule = require("39ff598ce822187e");
module.exports = function(target, source, exceptions) {
    var keys = ownKeys(source);
    var defineProperty = definePropertyModule.f;
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
};

},{"d91d786cc71453ce":"gC2Q5","88cb809f98beddc6":"1CX1A","10ea642aad5f7c21":"lk5NI","39ff598ce822187e":"iJR4w"}],"1CX1A":[function(require,module,exports) {
"use strict";
var getBuiltIn = require("3cc1e4329d869e34");
var uncurryThis = require("2b8e77cbdbe3db7a");
var getOwnPropertyNamesModule = require("d703bcb62fcda216");
var getOwnPropertySymbolsModule = require("157674bad2772c6d");
var anObject = require("a09e060b9cae3c6c");
var concat = uncurryThis([].concat);
// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
    var keys = getOwnPropertyNamesModule.f(anObject(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};

},{"3cc1e4329d869e34":"6ZUSY","2b8e77cbdbe3db7a":"7GlkT","d703bcb62fcda216":"fjY04","157674bad2772c6d":"4DWO3","a09e060b9cae3c6c":"4isCr"}],"fjY04":[function(require,module,exports) {
"use strict";
var internalObjectKeys = require("6d8591e17a49376c");
var enumBugKeys = require("2c933f93dd98f385");
var hiddenKeys = enumBugKeys.concat("length", "prototype");
// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys);
};

},{"6d8591e17a49376c":"hl5T1","2c933f93dd98f385":"9RnJm"}],"hl5T1":[function(require,module,exports) {
"use strict";
var uncurryThis = require("363ee0e6bb4f46a7");
var hasOwn = require("3183fe0b0bf6f6ac");
var toIndexedObject = require("28192ac12e934672");
var indexOf = require("a5f9c5d8e993ccd6").indexOf;
var hiddenKeys = require("57775908f1581bc6");
var push = uncurryThis([].push);
module.exports = function(object, names) {
    var O = toIndexedObject(object);
    var i = 0;
    var result = [];
    var key;
    for(key in O)!hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
    // Don't enum bug & hidden keys
    while(names.length > i)if (hasOwn(O, key = names[i++])) ~indexOf(result, key) || push(result, key);
    return result;
};

},{"363ee0e6bb4f46a7":"7GlkT","3183fe0b0bf6f6ac":"gC2Q5","28192ac12e934672":"jLWwQ","a5f9c5d8e993ccd6":"n5IsC","57775908f1581bc6":"661m4"}],"n5IsC":[function(require,module,exports) {
"use strict";
var toIndexedObject = require("d5dcbcd68ac5acd0");
var toAbsoluteIndex = require("212b13aecfa48226");
var lengthOfArrayLike = require("e5a8b3e1da4c5637");
// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = lengthOfArrayLike(O);
        if (length === 0) return !IS_INCLUDES && -1;
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        // Array#includes uses SameValueZero equality algorithm
        // eslint-disable-next-line no-self-compare -- NaN check
        if (IS_INCLUDES && el !== el) while(length > index){
            value = O[index++];
            // eslint-disable-next-line no-self-compare -- NaN check
            if (value !== value) return true;
        // Array#indexOf ignores holes, Array#includes - not
        }
        else for(; length > index; index++){
            if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
    };
};
module.exports = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
};

},{"d5dcbcd68ac5acd0":"jLWwQ","212b13aecfa48226":"5yh27","e5a8b3e1da4c5637":"lY4mS"}],"5yh27":[function(require,module,exports) {
"use strict";
var toIntegerOrInfinity = require("72fe0a53ad43912c");
var max = Math.max;
var min = Math.min;
// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function(index, length) {
    var integer = toIntegerOrInfinity(index);
    return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

},{"72fe0a53ad43912c":"kLXGe"}],"kLXGe":[function(require,module,exports) {
"use strict";
var trunc = require("3403cba02b5f61d8");
// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function(argument) {
    var number = +argument;
    // eslint-disable-next-line no-self-compare -- NaN check
    return number !== number || number === 0 ? 0 : trunc(number);
};

},{"3403cba02b5f61d8":"7O8gb"}],"7O8gb":[function(require,module,exports) {
"use strict";
var ceil = Math.ceil;
var floor = Math.floor;
// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
    var n = +x;
    return (n > 0 ? floor : ceil)(n);
};

},{}],"lY4mS":[function(require,module,exports) {
"use strict";
var toLength = require("23d9716c54a2ab90");
// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function(obj) {
    return toLength(obj.length);
};

},{"23d9716c54a2ab90":"fU04N"}],"fU04N":[function(require,module,exports) {
"use strict";
var toIntegerOrInfinity = require("c48d3a8b8ac52b0b");
var min = Math.min;
// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function(argument) {
    var len = toIntegerOrInfinity(argument);
    return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

},{"c48d3a8b8ac52b0b":"kLXGe"}],"9RnJm":[function(require,module,exports) {
"use strict";
// IE8- don't enum bug keys
module.exports = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
];

},{}],"4DWO3":[function(require,module,exports) {
"use strict";
// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;

},{}],"6uTCZ":[function(require,module,exports) {
"use strict";
var fails = require("10299561ea0c7870");
var isCallable = require("8b1ecdaf59f07210");
var replacement = /#|\.prototype\./;
var isForced = function(feature, detection) {
    var value = data[normalize(feature)];
    return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
};
var normalize = isForced.normalize = function(string) {
    return String(string).replace(replacement, ".").toLowerCase();
};
var data = isForced.data = {};
var NATIVE = isForced.NATIVE = "N";
var POLYFILL = isForced.POLYFILL = "P";
module.exports = isForced;

},{"10299561ea0c7870":"hL6D2","8b1ecdaf59f07210":"l3Kyn"}],"4OXGm":[function(require,module,exports) {
"use strict";
var bind = require("2f267ed50e670495");
var call = require("c0af58bb1ef1cc62");
var anObject = require("7fa6542c03ca9239");
var tryToString = require("fa596d1a4c07b72a");
var isArrayIteratorMethod = require("fd753cc641a6f10a");
var lengthOfArrayLike = require("2a15dee148d3db96");
var isPrototypeOf = require("417f9a13deeb58a6");
var getIterator = require("43af53be1b24dae5");
var getIteratorMethod = require("bf7ad32b21aed0b4");
var iteratorClose = require("5241389e1d6eeb73");
var $TypeError = TypeError;
var Result = function(stopped, result) {
    this.stopped = stopped;
    this.result = result;
};
var ResultPrototype = Result.prototype;
module.exports = function(iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_RECORD = !!(options && options.IS_RECORD);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = bind(unboundFunction, that);
    var iterator, iterFn, index, length, result, next, step;
    var stop = function(condition) {
        if (iterator) iteratorClose(iterator, "normal", condition);
        return new Result(true, condition);
    };
    var callFn = function(value) {
        if (AS_ENTRIES) {
            anObject(value);
            return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
    };
    if (IS_RECORD) iterator = iterable.iterator;
    else if (IS_ITERATOR) iterator = iterable;
    else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn) throw new $TypeError(tryToString(iterable) + " is not iterable");
        // optimisation for array iterators
        if (isArrayIteratorMethod(iterFn)) {
            for(index = 0, length = lengthOfArrayLike(iterable); length > index; index++){
                result = callFn(iterable[index]);
                if (result && isPrototypeOf(ResultPrototype, result)) return result;
            }
            return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
    }
    next = IS_RECORD ? iterable.next : iterator.next;
    while(!(step = call(next, iterator)).done){
        try {
            result = callFn(step.value);
        } catch (error) {
            iteratorClose(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result)) return result;
    }
    return new Result(false);
};

},{"2f267ed50e670495":"7vpmS","c0af58bb1ef1cc62":"d7JlP","7fa6542c03ca9239":"4isCr","fa596d1a4c07b72a":"4O7d7","fd753cc641a6f10a":"l33Z9","2a15dee148d3db96":"lY4mS","417f9a13deeb58a6":"3jtKQ","43af53be1b24dae5":"hjwee","bf7ad32b21aed0b4":"d8BiC","5241389e1d6eeb73":"hs7nW"}],"7vpmS":[function(require,module,exports) {
"use strict";
var uncurryThis = require("92f6f475baa85665");
var aCallable = require("547ee4f9dab0cc76");
var NATIVE_BIND = require("5acd31cba656d393");
var bind = uncurryThis(uncurryThis.bind);
// optional / simple context binding
module.exports = function(fn, that) {
    aCallable(fn);
    return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function() {
        return fn.apply(that, arguments);
    };
};

},{"92f6f475baa85665":"5Hioa","547ee4f9dab0cc76":"gOMir","5acd31cba656d393":"i16Dq"}],"5Hioa":[function(require,module,exports) {
"use strict";
var classofRaw = require("8e77093015e1e67f");
var uncurryThis = require("9daa4dbbca634c9e");
module.exports = function(fn) {
    // Nashorn bug:
    //   https://github.com/zloirock/core-js/issues/1128
    //   https://github.com/zloirock/core-js/issues/1130
    if (classofRaw(fn) === "Function") return uncurryThis(fn);
};

},{"8e77093015e1e67f":"bdfmm","9daa4dbbca634c9e":"7GlkT"}],"l33Z9":[function(require,module,exports) {
"use strict";
var wellKnownSymbol = require("85b004b6ab4bc5da");
var Iterators = require("6de391ad2976ca02");
var ITERATOR = wellKnownSymbol("iterator");
var ArrayPrototype = Array.prototype;
// check on default Array iterator
module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};

},{"85b004b6ab4bc5da":"gTwyA","6de391ad2976ca02":"30XHR"}],"30XHR":[function(require,module,exports) {
"use strict";
module.exports = {};

},{}],"hjwee":[function(require,module,exports) {
"use strict";
var call = require("132ebf774107ae29");
var aCallable = require("e248489b4825ceb7");
var anObject = require("18a343d2ef625577");
var tryToString = require("7e576a1564cef99e");
var getIteratorMethod = require("4a7b0311be0471b2");
var $TypeError = TypeError;
module.exports = function(argument, usingIterator) {
    var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
    if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
    throw new $TypeError(tryToString(argument) + " is not iterable");
};

},{"132ebf774107ae29":"d7JlP","e248489b4825ceb7":"gOMir","18a343d2ef625577":"4isCr","7e576a1564cef99e":"4O7d7","4a7b0311be0471b2":"d8BiC"}],"d8BiC":[function(require,module,exports) {
"use strict";
var classof = require("32d61dafd81dde78");
var getMethod = require("84e24a6ac7559d3a");
var isNullOrUndefined = require("f0707282c0d93eeb");
var Iterators = require("1c181d5c49efd5d1");
var wellKnownSymbol = require("d10d0e0ae49498c5");
var ITERATOR = wellKnownSymbol("iterator");
module.exports = function(it) {
    if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
};

},{"32d61dafd81dde78":"dKT7A","84e24a6ac7559d3a":"9Zfiw","f0707282c0d93eeb":"gM5ar","1c181d5c49efd5d1":"30XHR","d10d0e0ae49498c5":"gTwyA"}],"dKT7A":[function(require,module,exports) {
"use strict";
var TO_STRING_TAG_SUPPORT = require("397e535b3976d304");
var isCallable = require("eebd8012c2d2c3ae");
var classofRaw = require("8da113eeaf06c4ba");
var wellKnownSymbol = require("df252844008f634");
var TO_STRING_TAG = wellKnownSymbol("toStringTag");
var $Object = Object;
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function() {
    return arguments;
}()) === "Arguments";
// fallback for IE11 Script Access Denied error
var tryGet = function(it, key) {
    try {
        return it[key];
    } catch (error) {}
};
// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
    var O, tag, result;
    return it === undefined ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable(O.callee) ? "Arguments" : result;
};

},{"397e535b3976d304":"3Do6Z","eebd8012c2d2c3ae":"l3Kyn","8da113eeaf06c4ba":"bdfmm","df252844008f634":"gTwyA"}],"3Do6Z":[function(require,module,exports) {
"use strict";
var wellKnownSymbol = require("6306cd4835715127");
var TO_STRING_TAG = wellKnownSymbol("toStringTag");
var test = {};
test[TO_STRING_TAG] = "z";
module.exports = String(test) === "[object z]";

},{"6306cd4835715127":"gTwyA"}],"hs7nW":[function(require,module,exports) {
"use strict";
var call = require("a4a3a7d4a45c4219");
var anObject = require("feb876e7da2df7bd");
var getMethod = require("2e660cdfabd9c61f");
module.exports = function(iterator, kind, value) {
    var innerResult, innerError;
    anObject(iterator);
    try {
        innerResult = getMethod(iterator, "return");
        if (!innerResult) {
            if (kind === "throw") throw value;
            return value;
        }
        innerResult = call(innerResult, iterator);
    } catch (error) {
        innerError = true;
        innerResult = error;
    }
    if (kind === "throw") throw value;
    if (innerError) throw innerResult;
    anObject(innerResult);
    return value;
};

},{"a4a3a7d4a45c4219":"d7JlP","feb876e7da2df7bd":"4isCr","2e660cdfabd9c61f":"9Zfiw"}],"f9Wim":[function(require,module,exports) {
"use strict";
var uncurryThis = require("89734044d2e98b8d");
// eslint-disable-next-line es/no-map -- safe
var MapPrototype = Map.prototype;
module.exports = {
    // eslint-disable-next-line es/no-map -- safe
    Map: Map,
    set: uncurryThis(MapPrototype.set),
    get: uncurryThis(MapPrototype.get),
    has: uncurryThis(MapPrototype.has),
    remove: uncurryThis(MapPrototype["delete"]),
    proto: MapPrototype
};

},{"89734044d2e98b8d":"7GlkT"}],"b9ez5":[function(require,module,exports) {
"use strict";
var globalThis = require("3efb7a023fcb5137");
var defineWellKnownSymbol = require("efe796c38aca437b");
var defineProperty = require("d6dbf5d754dc3607").f;
var getOwnPropertyDescriptor = require("9075339d618418b3").f;
var Symbol = globalThis.Symbol;
// `Symbol.dispose` well-known symbol
// https://github.com/tc39/proposal-explicit-resource-management
defineWellKnownSymbol("dispose");
if (Symbol) {
    var descriptor = getOwnPropertyDescriptor(Symbol, "dispose");
    // workaround of NodeJS 20.4 bug
    // https://github.com/nodejs/node/issues/48699
    // and incorrect descriptor from some transpilers and userland helpers
    if (descriptor.enumerable && descriptor.configurable && descriptor.writable) defineProperty(Symbol, "dispose", {
        value: descriptor.value,
        enumerable: false,
        configurable: false,
        writable: false
    });
}

},{"3efb7a023fcb5137":"9fY7y","efe796c38aca437b":"en5fF","d6dbf5d754dc3607":"iJR4w","9075339d618418b3":"lk5NI"}],"en5fF":[function(require,module,exports) {
"use strict";
var path = require("8d5159b7d317832f");
var hasOwn = require("42a3ea18819bfbb");
var wrappedWellKnownSymbolModule = require("7ec639749e279eeb");
var defineProperty = require("cbbe4becefd5c21c").f;
module.exports = function(NAME) {
    var Symbol = path.Symbol || (path.Symbol = {});
    if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
        value: wrappedWellKnownSymbolModule.f(NAME)
    });
};

},{"8d5159b7d317832f":"gKjqB","42a3ea18819bfbb":"gC2Q5","7ec639749e279eeb":"9TrPc","cbbe4becefd5c21c":"iJR4w"}],"gKjqB":[function(require,module,exports) {
"use strict";
var globalThis = require("34c09090b9638032");
module.exports = globalThis;

},{"34c09090b9638032":"9fY7y"}],"9TrPc":[function(require,module,exports) {
"use strict";
var wellKnownSymbol = require("2e34ececd06658d9");
exports.f = wellKnownSymbol;

},{"2e34ececd06658d9":"gTwyA"}],"49tUX":[function(require,module,exports) {
"use strict";
// TODO: Remove this module from `core-js@4` since it's split to modules listed below
require("52e9b3eefbbce1ed");
require("292fa64716f5b39e");

},{"52e9b3eefbbce1ed":"fOGFr","292fa64716f5b39e":"l7FDS"}],"fOGFr":[function(require,module,exports) {
"use strict";
var $ = require("79389288a80b279c");
var globalThis = require("e4d64249a0133d14");
var clearImmediate = require("84ba5ca62b8b14c9").clear;
// `clearImmediate` method
// http://w3c.github.io/setImmediate/#si-clearImmediate
$({
    global: true,
    bind: true,
    enumerable: true,
    forced: globalThis.clearImmediate !== clearImmediate
}, {
    clearImmediate: clearImmediate
});

},{"79389288a80b279c":"dIGt4","e4d64249a0133d14":"9fY7y","84ba5ca62b8b14c9":"7jDg7"}],"7jDg7":[function(require,module,exports) {
"use strict";
var globalThis = require("629a4d99f4fe5b2e");
var apply = require("e574be68c288c7c8");
var bind = require("df212787338802d3");
var isCallable = require("afdf018c2d01bbc6");
var hasOwn = require("35a3e849940fd612");
var fails = require("b8bf5434d2248ca7");
var html = require("731f9370cc21fc3b");
var arraySlice = require("ec358060964e4bde");
var createElement = require("907adb6d219da7a3");
var validateArgumentsLength = require("f398561ebd49a798");
var IS_IOS = require("8a8e342aaad83bb");
var IS_NODE = require("6eef8b4e43dd6731");
var set = globalThis.setImmediate;
var clear = globalThis.clearImmediate;
var process = globalThis.process;
var Dispatch = globalThis.Dispatch;
var Function = globalThis.Function;
var MessageChannel = globalThis.MessageChannel;
var String = globalThis.String;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = "onreadystatechange";
var $location, defer, channel, port;
fails(function() {
    // Deno throws a ReferenceError on `location` access without `--location` flag
    $location = globalThis.location;
});
var run = function(id) {
    if (hasOwn(queue, id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
    }
};
var runner = function(id) {
    return function() {
        run(id);
    };
};
var eventListener = function(event) {
    run(event.data);
};
var globalPostMessageDefer = function(id) {
    // old engines have not location.origin
    globalThis.postMessage(String(id), $location.protocol + "//" + $location.host);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
    set = function setImmediate(handler) {
        validateArgumentsLength(arguments.length, 1);
        var fn = isCallable(handler) ? handler : Function(handler);
        var args = arraySlice(arguments, 1);
        queue[++counter] = function() {
            apply(fn, undefined, args);
        };
        defer(counter);
        return counter;
    };
    clear = function clearImmediate(id) {
        delete queue[id];
    };
    // Node.js 0.8-
    if (IS_NODE) defer = function(id) {
        process.nextTick(runner(id));
    };
    else if (Dispatch && Dispatch.now) defer = function(id) {
        Dispatch.now(runner(id));
    };
    else if (MessageChannel && !IS_IOS) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = eventListener;
        defer = bind(port.postMessage, port);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (globalThis.addEventListener && isCallable(globalThis.postMessage) && !globalThis.importScripts && $location && $location.protocol !== "file:" && !fails(globalPostMessageDefer)) {
        defer = globalPostMessageDefer;
        globalThis.addEventListener("message", eventListener, false);
    // IE8-
    } else if (ONREADYSTATECHANGE in createElement("script")) defer = function(id) {
        html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run(id);
        };
    };
    else defer = function(id) {
        setTimeout(runner(id), 0);
    };
}
module.exports = {
    set: set,
    clear: clear
};

},{"629a4d99f4fe5b2e":"9fY7y","e574be68c288c7c8":"148ka","df212787338802d3":"7vpmS","afdf018c2d01bbc6":"l3Kyn","35a3e849940fd612":"gC2Q5","b8bf5434d2248ca7":"hL6D2","731f9370cc21fc3b":"2pze4","ec358060964e4bde":"RsFXo","907adb6d219da7a3":"4bOHl","f398561ebd49a798":"b9O3D","8a8e342aaad83bb":"cGUFx","6eef8b4e43dd6731":"35LXH"}],"148ka":[function(require,module,exports) {
"use strict";
var NATIVE_BIND = require("d07466971ded2aca");
var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;
// eslint-disable-next-line es/no-reflect -- safe
module.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
    return call.apply(apply, arguments);
});

},{"d07466971ded2aca":"i16Dq"}],"2pze4":[function(require,module,exports) {
"use strict";
var getBuiltIn = require("14cb391fa4a0dda8");
module.exports = getBuiltIn("document", "documentElement");

},{"14cb391fa4a0dda8":"6ZUSY"}],"RsFXo":[function(require,module,exports) {
"use strict";
var uncurryThis = require("5250b5c9324ccbe");
module.exports = uncurryThis([].slice);

},{"5250b5c9324ccbe":"7GlkT"}],"b9O3D":[function(require,module,exports) {
"use strict";
var $TypeError = TypeError;
module.exports = function(passed, required) {
    if (passed < required) throw new $TypeError("Not enough arguments");
    return passed;
};

},{}],"cGUFx":[function(require,module,exports) {
"use strict";
var userAgent = require("88313d0d5d3e28c");
// eslint-disable-next-line redos/no-vulnerable -- safe
module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);

},{"88313d0d5d3e28c":"lApyY"}],"35LXH":[function(require,module,exports) {
"use strict";
var ENVIRONMENT = require("5fac34e3c4c0e043");
module.exports = ENVIRONMENT === "NODE";

},{"5fac34e3c4c0e043":"888a9"}],"888a9":[function(require,module,exports) {
"use strict";
/* global Bun, Deno -- detection */ var globalThis = require("7dc361f46ecde901");
var userAgent = require("9f6e24ecbba66a9e");
var classof = require("a008a59fdc341842");
var userAgentStartsWith = function(string) {
    return userAgent.slice(0, string.length) === string;
};
module.exports = function() {
    if (userAgentStartsWith("Bun/")) return "BUN";
    if (userAgentStartsWith("Cloudflare-Workers")) return "CLOUDFLARE";
    if (userAgentStartsWith("Deno/")) return "DENO";
    if (userAgentStartsWith("Node.js/")) return "NODE";
    if (globalThis.Bun && typeof Bun.version == "string") return "BUN";
    if (globalThis.Deno && typeof Deno.version == "object") return "DENO";
    if (classof(globalThis.process) === "process") return "NODE";
    if (globalThis.window && globalThis.document) return "BROWSER";
    return "REST";
}();

},{"7dc361f46ecde901":"9fY7y","9f6e24ecbba66a9e":"lApyY","a008a59fdc341842":"bdfmm"}],"l7FDS":[function(require,module,exports) {
"use strict";
var $ = require("33581c362196ed1f");
var globalThis = require("503bb555249cad41");
var setTask = require("4219ce460223bd08").set;
var schedulersFix = require("738dc378e6a94c64");
// https://github.com/oven-sh/bun/issues/1633
var setImmediate = globalThis.setImmediate ? schedulersFix(setTask, false) : setTask;
// `setImmediate` method
// http://w3c.github.io/setImmediate/#si-setImmediate
$({
    global: true,
    bind: true,
    enumerable: true,
    forced: globalThis.setImmediate !== setImmediate
}, {
    setImmediate: setImmediate
});

},{"33581c362196ed1f":"dIGt4","503bb555249cad41":"9fY7y","4219ce460223bd08":"7jDg7","738dc378e6a94c64":"cAPb6"}],"cAPb6":[function(require,module,exports) {
"use strict";
var globalThis = require("aa6765693e58a0fe");
var apply = require("a68ecfcbf29c46f6");
var isCallable = require("7087588d33667af2");
var ENVIRONMENT = require("864edee099e8affb");
var USER_AGENT = require("3a3a5a2cfab86f21");
var arraySlice = require("cff2c830bdea4f24");
var validateArgumentsLength = require("58a74f00cee1ac64");
var Function = globalThis.Function;
// dirty IE9- and Bun 0.3.0- checks
var WRAP = /MSIE .\./.test(USER_AGENT) || ENVIRONMENT === "BUN" && function() {
    var version = globalThis.Bun.version.split(".");
    return version.length < 3 || version[0] === "0" && (version[1] < 3 || version[1] === "3" && version[2] === "0");
}();
// IE9- / Bun 0.3.0- setTimeout / setInterval / setImmediate additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
// https://github.com/oven-sh/bun/issues/1633
module.exports = function(scheduler, hasTimeArg) {
    var firstParamIndex = hasTimeArg ? 2 : 1;
    return WRAP ? function(handler, timeout /* , ...arguments */ ) {
        var boundArgs = validateArgumentsLength(arguments.length, 1) > firstParamIndex;
        var fn = isCallable(handler) ? handler : Function(handler);
        var params = boundArgs ? arraySlice(arguments, firstParamIndex) : [];
        var callback = boundArgs ? function() {
            apply(fn, this, params);
        } : fn;
        return hasTimeArg ? scheduler(callback, timeout) : scheduler(callback);
    } : scheduler;
};

},{"aa6765693e58a0fe":"9fY7y","a68ecfcbf29c46f6":"148ka","7087588d33667af2":"l3Kyn","864edee099e8affb":"888a9","3a3a5a2cfab86f21":"lApyY","cff2c830bdea4f24":"RsFXo","58a74f00cee1ac64":"b9O3D"}],"i4OI0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "log", ()=>log);
parcelHelpers.export(exports, "trace", ()=>trace);
/**
 * A simple tracer class, that can be used to avoid repetition when using the `trace` function
 *
 * Its goal is to capture more context than a log function.
 * This is simple for now, but can be improved later.
 *
 * @param type A given type (not level) for the current local tracer ("hw", "withDevice", etc.)
 * @param context Anything representing the context where the log occurred
 */ parcelHelpers.export(exports, "LocalTracer", ()=>LocalTracer);
parcelHelpers.export(exports, "listen", ()=>listen);
let id = 0;
const subscribers = [];
const log = (type, message, data)=>{
    const obj = {
        type,
        id: String(++id),
        date: new Date()
    };
    if (message) obj.message = message;
    if (data) obj.data = data;
    dispatch(obj);
};
const trace = ({ type, message, data, context })=>{
    const obj = {
        type,
        id: String(++id),
        date: new Date()
    };
    if (message) obj.message = message;
    if (data) obj.data = data;
    if (context) obj.context = context;
    dispatch(obj);
};
class LocalTracer {
    constructor(type, context){
        this.type = type;
        this.context = context;
    }
    trace(message, data) {
        trace({
            type: this.type,
            message,
            data,
            context: this.context
        });
    }
    getContext() {
        return this.context;
    }
    setContext(context) {
        this.context = context;
    }
    updateContext(contextToAdd) {
        this.context = Object.assign(Object.assign({}, this.context), contextToAdd);
    }
    getType() {
        return this.type;
    }
    setType(type) {
        this.type = type;
    }
    /**
     * Create a new instance of the LocalTracer with an updated `type`
     *
     * It does not mutate the calling instance, but returns a new LocalTracer,
     * following a simple builder pattern.
     */ withType(type) {
        return new LocalTracer(type, this.context);
    }
    /**
     * Create a new instance of the LocalTracer with a new `context`
     *
     * It does not mutate the calling instance, but returns a new LocalTracer,
     * following a simple builder pattern.
     *
     * @param context A TraceContext, that can undefined to reset the context
     */ withContext(context) {
        return new LocalTracer(this.type, context);
    }
    /**
     * Create a new instance of the LocalTracer with an updated `context`,
     * on which an additional context is merged with the existing one.
     *
     * It does not mutate the calling instance, but returns a new LocalTracer,
     * following a simple builder pattern.
     */ withUpdatedContext(contextToAdd) {
        return new LocalTracer(this.type, Object.assign(Object.assign({}, this.context), contextToAdd));
    }
}
const listen = (cb)=>{
    subscribers.push(cb);
    return ()=>{
        const i = subscribers.indexOf(cb);
        if (i !== -1) {
            // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952
            subscribers[i] = subscribers[subscribers.length - 1];
            subscribers.pop();
        }
    };
};
function dispatch(log) {
    for(let i = 0; i < subscribers.length; i++)try {
        subscribers[i](log);
    } catch (e) {
        console.error(e);
    }
}
if (typeof window !== "undefined") window.__ledgerLogsListen = listen;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f39ni":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _semver = require("semver");
var _semverDefault = parcelHelpers.interopDefault(_semver);
var _btcNew = require("./BtcNew");
var _btcNewDefault = parcelHelpers.interopDefault(_btcNew);
var _btcOld = require("./BtcOld");
var _btcOldDefault = parcelHelpers.interopDefault(_btcOld);
var _getTrustedInput = require("./getTrustedInput");
var _getTrustedInputBIP143 = require("./getTrustedInputBIP143");
var _appClient = require("./newops/appClient");
var _serializeTransaction = require("./serializeTransaction");
var _splitTransaction = require("./splitTransaction");
var _signP2SHTransaction = require("./signP2SHTransaction");
var _getAppAndVersion = require("./getAppAndVersion");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Btc {
    constructor({ transport, scrambleKey = "BTC", currency = "bitcoin" }){
        this._transport = transport;
        this._transport.decorateAppAPIMethods(this, [
            "getWalletXpub",
            "getWalletPublicKey",
            "signP2SHTransaction",
            "signMessage",
            "createPaymentTransaction",
            "getTrustedInput",
            "getTrustedInputBIP143"
        ], scrambleKey);
        this._impl = (()=>{
            switch(currency){
                case "bitcoin":
                case "bitcoin_testnet":
                case "qtum":
                    // new APDU (nano app API) for currencies using app-bitcoin-new implementation
                    return new (0, _btcNewDefault.default)(new (0, _appClient.AppClient)(this._transport));
                default:
                    // old APDU (legacy API) for currencies using legacy bitcoin app implementation
                    return new (0, _btcOldDefault.default)(this._transport);
            }
        })();
    }
    /**
     * Get an XPUB with a ledger device
     * @param arg derivation parameter
     * - path: a BIP 32 path of the account level. (e.g. The derivation path `84'/0'/0'`
     * follows the `purpose' / coin_type' / account'` standard, with purpose=84, coin_type=0, account=0)
     * - xpubVersion: the XPUBVersion of the coin used. (refer to ledgerjs/packages/cryptoassets/src/currencies.ts
     * for the XPUBVersion value if needed)
     * @returns XPUB of the account
     */ getWalletXpub(arg) {
        return this.changeImplIfNecessary().then((impl)=>{
            return impl.getWalletXpub(arg);
        });
    }
    /**
     * @param path a BIP 32 path (i.e. the `purpose / coin_type / account / change / address_index` standard)
     * @param options an object with optional these fields:
     *
     * - verify (boolean) whether ask user to confirm the address on the device
     *
     * - format ("legacy" | "p2sh" | "bech32" | "bech32m" | "cashaddr") to use different bitcoin address formatter.
     *
     * NB The normal usage is to use:
     *
     * - legacy format with 44' paths
     *
     * - p2sh format with 49' paths
     *
     * - bech32 format with 84' paths
     *
     * - bech32m format with 86' paths
     *
     * - cashaddr in case of Bitcoin Cash
     *
     * @example
     * btc.getWalletPublicKey("44'/0'/0'/0/0").then(o => o.bitcoinAddress)
     * btc.getWalletPublicKey("49'/0'/0'/0/0", { format: "p2sh" }).then(o => o.bitcoinAddress)
     */ getWalletPublicKey(path, opts) {
        let options;
        if (arguments.length > 2 || typeof opts === "boolean") {
            console.warn("btc.getWalletPublicKey deprecated signature used. Please switch to getWalletPublicKey(path, { format, verify })");
            options = {
                verify: !!opts,
                // eslint-disable-next-line prefer-rest-params
                format: arguments[2] ? "p2sh" : "legacy"
            };
        } else options = opts || {};
        return this.changeImplIfNecessary().then((impl)=>{
            return impl.getWalletPublicKey(path, options);
        });
    }
    /**
     * You can sign a message according to the Bitcoin Signature format and retrieve v, r, s given the message and the BIP 32 path of the account to sign.
     * @example
     btc.signMessage("44'/60'/0'/0'/0", Buffer.from("test").toString("hex")).then(function(result) {
       var v = result['v'] + 27 + 4;
       var signature = Buffer.from(v.toString(16) + result['r'] + result['s'], 'hex').toString('base64');
       console.log("Signature : " + signature);
     }).catch(function(ex) {console.log(ex);});
     */ signMessage(path, messageHex) {
        return this.changeImplIfNecessary().then((impl)=>{
            return impl.signMessage({
                path,
                messageHex
            });
        });
    }
    /**
     * To sign a transaction involving standard (P2PKH) inputs, call createTransaction with the following parameters
     * @param inputs is an array of [ transaction, output_index, optional redeem script, optional sequence ] where
     *
     * * transaction is the previously computed transaction object for this UTXO
     * * output_index is the output in the transaction used as input for this UTXO (counting from 0)
     * * redeem script is the optional redeem script to use when consuming a Segregated Witness input
     * * sequence is the sequence number to use for this input (when using RBF), or non present
     * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO
     * @param changePath is an optional BIP 32 path pointing to the path to the public key used to compute the change address
     * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign, including leading vararg voutCount
     * @param lockTime is the optional lockTime of the transaction to sign, or default (0)
     * @param sigHashType is the hash type of the transaction to sign, or default (all)
     * @param segwit is an optional boolean indicating wether to use segwit or not. This includes wrapped segwit.
     * @param additionals list of additionnal options
     *
     * - "bech32" for spending native segwit outputs
     * - "bech32m" for spending segwit v1+ outputs
     * - "abc" for bch
     * - "gold" for btg
     * - "decred" for decred
     * - "zcash" for zcash
     * - "bipxxx" for using BIPxxx
     * - "sapling" to indicate a zec transaction is supporting sapling (to be set over block 419200)
     * @param expiryHeight is an optional Buffer for zec overwinter / sapling Txs
     * @param useTrustedInputForSegwit trust inputs for segwit transactions. If app version >= 1.4.0 this should be true.
     * @return the signed transaction ready to be broadcast
     * @example
    btc.createTransaction({
     inputs: [ [tx1, 1] ],
     associatedKeysets: ["0'/0/0"],
     outputScriptHex: "01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac"
    }).then(res => ...);
     */ createPaymentTransaction(arg) {
        if (arguments.length > 1) throw new Error("@ledgerhq/hw-app-btc: createPaymentTransaction multi argument signature is deprecated. please switch to named parameters.");
        return this.changeImplIfNecessary().then((impl)=>{
            return impl.createPaymentTransaction(arg);
        });
    }
    /**
     * To obtain the signature of multisignature (P2SH) inputs, call signP2SHTransaction_async with the folowing parameters
     * @param inputs is an array of [ transaction, output_index, redeem script, optional sequence ] where
     * * transaction is the previously computed transaction object for this UTXO
     * * output_index is the output in the transaction used as input for this UTXO (counting from 0)
     * * redeem script is the mandatory redeem script associated to the current P2SH input
     * * sequence is the sequence number to use for this input (when using RBF), or non present
     * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO
     * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign
     * @param lockTime is the optional lockTime of the transaction to sign, or default (0)
     * @param sigHashType is the hash type of the transaction to sign, or default (all)
     * @return the signed transaction ready to be broadcast
     * @example
    btc.signP2SHTransaction({
    inputs: [ [tx, 1, "52210289b4a3ad52a919abd2bdd6920d8a6879b1e788c38aa76f0440a6f32a9f1996d02103a3393b1439d1693b063482c04bd40142db97bdf139eedd1b51ffb7070a37eac321030b9a409a1e476b0d5d17b804fcdb81cf30f9b99c6f3ae1178206e08bc500639853ae"] ],
    associatedKeysets: ["0'/0/0"],
    outputScriptHex: "01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac"
    }).then(result => ...);
     */ signP2SHTransaction(arg) {
        return (0, _signP2SHTransaction.signP2SHTransaction)(this._transport, arg);
    }
    /**
     * For each UTXO included in your transaction, create a transaction object from the raw serialized version of the transaction used in this UTXO.
     * @param transactionHex a raw hexadecimal serialized transaction
     * @param isSegwitSupported is a boolean indicating if the segwit is supported
     * @param hasExtraData is a boolean (komodo, zencash and zcash include extraData in their transactions, others don't)
     * @param additionals list of additionnal options
     * @return the transaction object deserialized from the raw hexadecimal transaction
     * @example
    const tx1 = btc.splitTransaction("01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000");
     */ splitTransaction(transactionHex, isSegwitSupported = false, hasExtraData = false, additionals = []) {
        return (0, _splitTransaction.splitTransaction)(transactionHex, isSegwitSupported, hasExtraData, additionals);
    }
    /**
     * Serialize a transaction's outputs to hexadecimal
     * @example
    const tx1 = btc.splitTransaction("01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000");
    const outputScript = btc.serializeTransactionOutputs(tx1).toString('hex');
    */ serializeTransactionOutputs(t) {
        return (0, _serializeTransaction.serializeTransactionOutputs)(t);
    }
    /**
     * Trusted input is the hash of a UTXO that needs to be signed
     * For Legacy transactions, the app has some APDUs flows that do the amount check for an UTXO,
     * by parsing the transaction that created this UTXO
     */ getTrustedInput(indexLookup, transaction, additionals = []) {
        return (0, _getTrustedInput.getTrustedInput)(this._transport, indexLookup, transaction, additionals);
    }
    /**
     * Trusted input is the hash of a UTXO that needs to be signed. BIP143 is used for Segwit inputs.
     */ getTrustedInputBIP143(indexLookup, transaction, additionals = []) {
        return (0, _getTrustedInputBIP143.getTrustedInputBIP143)(this._transport, indexLookup, transaction, additionals);
    }
    changeImplIfNecessary() {
        return __awaiter(this, void 0, void 0, function*() {
            // if BtcOld was instantiated, stick with it
            if (this._impl instanceof (0, _btcOldDefault.default)) return this._impl;
            const { name, version } = yield (0, _getAppAndVersion.getAppAndVersion)(this._transport);
            const isBtcLegacy = yield (()=>__awaiter(this, void 0, void 0, function*() {
                    switch(name){
                        case "Bitcoin":
                        case "Bitcoin Test":
                            // we use the legacy protocol for versions below 2.1.0 of the Bitcoin app.
                            return (0, _semverDefault.default).lt(version, "2.1.0");
                        case "Bitcoin Legacy":
                        case "Bitcoin Test Legacy":
                            // the "Bitcoin Legacy" and "Bitcoin Testnet Legacy" app use the legacy protocol, regardless of the version
                            return true;
                        case "Exchange":
                            // We can't query the version of the Bitcoin app if we're coming from Exchange;
                            // therefore, we use a workaround to distinguish legacy and new versions.
                            // This can be removed once Ledger Live enforces minimum bitcoin version >= 2.1.0.
                            return yield (0, _getAppAndVersion.checkIsBtcLegacy)(this._transport);
                        case "Qtum":
                            // we use the legacy protocol for versions below 3.0.0 of the Qtum app.
                            return (0, _semverDefault.default).lt(version, "3.0.0");
                        default:
                            return true;
                    }
                }))();
            if (isBtcLegacy) this._impl = new (0, _btcOldDefault.default)(this._transport);
            return this._impl;
        });
    }
}
exports.default = Btc;

},{"semver":"3th7M","./BtcNew":"bGXU5","./BtcOld":"fRGXe","./getTrustedInput":"lWTUu","./getTrustedInputBIP143":"1HcMu","./newops/appClient":"04eej","./serializeTransaction":"c5bE0","./splitTransaction":"8pUNG","./signP2SHTransaction":"6cHcv","./getAppAndVersion":"1B9q9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3th7M":[function(require,module,exports) {
// just pre-load all the stuff that index.js lazily exports
const internalRe = require("2ef367e729437dbf");
const constants = require("15796d6f714ec7ac");
const SemVer = require("784948b06600d9b2");
const identifiers = require("70f963db887a798c");
const parse = require("3f445ade66470b21");
const valid = require("f44378b7de87a0b4");
const clean = require("7742c78cf22bae39");
const inc = require("a751dd1df28d6bbb");
const diff = require("e000803318fe9f2f");
const major = require("d290038a9a954b0a");
const minor = require("c5e4bbab325a5aae");
const patch = require("5c0bb8d32de60bb3");
const prerelease = require("323f12e5af5ebd1e");
const compare = require("29cf114a56181e64");
const rcompare = require("827db0815bb2f2cd");
const compareLoose = require("b644f26560ec8124");
const compareBuild = require("606d0e43dd66a24c");
const sort = require("1560ed361cfa42e6");
const rsort = require("f9e1f00918a8cfd7");
const gt = require("3694a9720f15d6ac");
const lt = require("4559dbda8a777185");
const eq = require("14a4b88a0b1fd3a5");
const neq = require("416d9b63c3df2ead");
const gte = require("d39630b19344a843");
const lte = require("3fb74c9a41c1cef6");
const cmp = require("3435ca1bbec7b99");
const coerce = require("d67409238c8fc031");
const Comparator = require("1d07035d00450bca");
const Range = require("b280ab3e26924ac1");
const satisfies = require("ba9d0d2a3e49b569");
const toComparators = require("e6b2802b2233287d");
const maxSatisfying = require("2bfdfb0adcbcb71b");
const minSatisfying = require("264df1ba0d261fad");
const minVersion = require("cd4980125683761f");
const validRange = require("a0319a4a98954087");
const outside = require("fc457e2bda4345b2");
const gtr = require("c885d2b556186a1a");
const ltr = require("58740c779f187b15");
const intersects = require("22421cf146448c92");
const simplifyRange = require("439ddbc649d6486");
const subset = require("f1e57a2c808f532d");
module.exports = {
    parse,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
};

},{"2ef367e729437dbf":"3aKaA","15796d6f714ec7ac":"kfqYl","784948b06600d9b2":"7HV8v","70f963db887a798c":"3Ushi","3f445ade66470b21":"fKLuB","f44378b7de87a0b4":"fONiE","7742c78cf22bae39":"lDszQ","a751dd1df28d6bbb":"knExV","e000803318fe9f2f":"gd8W5","d290038a9a954b0a":"aQdxS","c5e4bbab325a5aae":"5Jk7e","5c0bb8d32de60bb3":"k27vv","323f12e5af5ebd1e":"53tgW","29cf114a56181e64":"d0byB","827db0815bb2f2cd":"aVRRy","b644f26560ec8124":"cRDDp","606d0e43dd66a24c":"8IgjV","1560ed361cfa42e6":"uRtcB","f9e1f00918a8cfd7":"faT9h","3694a9720f15d6ac":"4Ummg","4559dbda8a777185":"cevz4","14a4b88a0b1fd3a5":"g8cVO","416d9b63c3df2ead":"6pfyl","d39630b19344a843":"10dKg","3fb74c9a41c1cef6":"g8gHq","3435ca1bbec7b99":"duXdn","d67409238c8fc031":"mfbCy","1d07035d00450bca":"gVFDT","b280ab3e26924ac1":"iSOAN","ba9d0d2a3e49b569":"4GGCq","e6b2802b2233287d":"h7PG2","2bfdfb0adcbcb71b":"k7Iyh","264df1ba0d261fad":"gedPT","cd4980125683761f":"bD9nR","a0319a4a98954087":"hrqD8","fc457e2bda4345b2":"WXkQN","c885d2b556186a1a":"3m3un","58740c779f187b15":"lVkgp","22421cf146448c92":"3twh6","439ddbc649d6486":"2hxzT","f1e57a2c808f532d":"f8DRU"}],"3aKaA":[function(require,module,exports) {
const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } = require("9328c2484f003df4");
const debug = require("9075cfb365332427");
exports = module.exports = {};
// The actual regexps go on exports.re
const re = exports.re = [];
const safeRe = exports.safeRe = [];
const src = exports.src = [];
const t = exports.t = {};
let R = 0;
const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
const safeRegexReplacements = [
    [
        "\\s",
        1
    ],
    [
        "\\d",
        MAX_LENGTH
    ],
    [
        LETTERDASHNUMBER,
        MAX_SAFE_BUILD_LENGTH
    ]
];
const makeSafeRegex = (value)=>{
    for (const [token, max] of safeRegexReplacements)value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    return value;
};
const createToken = (name, value, isGlobal)=>{
    const safe = makeSafeRegex(value);
    const index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
};
// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.
createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.
createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
// ## Main Version
// Three dot-separated numeric identifiers.
createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.
createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.
createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.
createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.
createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.
createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
createToken("FULL", `^${src[t.FULLPLAIN]}$`);
// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
createToken("GTLT", "((?:<|>)?=?)");
// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:$|[^\\d])`);
createToken("COERCERTL", src[t.COERCE], true);
createToken("COERCERTLFULL", src[t.COERCEFULL], true);
// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken("LONETILDE", "(?:~>?)");
createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
exports.tildeTrimReplace = "$1~";
createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken("LONECARET", "(?:\\^)");
createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
exports.caretTrimReplace = "$1^";
createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
exports.comparatorTrimReplace = "$1$2$3";
// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
// Star ranges basically just allow anything at all.
createToken("STAR", "(<|>)?=?\\s*\\*");
// >=0.0.0 is like a star
createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");

},{"9328c2484f003df4":"kfqYl","9075cfb365332427":"bFCt8"}],"kfqYl":[function(require,module,exports) {
// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH = 256;
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991;
// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16;
// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
const RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
];
module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
};

},{}],"bFCt8":[function(require,module,exports) {
var process = require("3e9ec50def946db3");
const debug = (typeof process === "object" && process.env && undefined, ()=>{});
module.exports = debug;

},{"3e9ec50def946db3":"d5jf4"}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"7HV8v":[function(require,module,exports) {
const debug = require("595c172e7d863d06");
const { MAX_LENGTH, MAX_SAFE_INTEGER } = require("bd8d57fbca62978a");
const { safeRe: re, t } = require("2b364a26e67d9817");
const parseOptions = require("f1a723539d6cc9b5");
const { compareIdentifiers } = require("2451a15946a38fcd");
class SemVer {
    constructor(version, options){
        options = parseOptions(options);
        if (version instanceof SemVer) {
            if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) return version;
            else version = version.version;
        } else if (typeof version !== "string") throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        if (version.length > MAX_LENGTH) throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        // this isn't actually relevant for versions, but keep it so that we
        // don't run into trouble passing this.options around.
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) throw new TypeError(`Invalid Version: ${version}`);
        this.raw = version;
        // these are actually numbers
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
        // numberify any prerelease numeric ids
        if (!m[4]) this.prerelease = [];
        else this.prerelease = m[4].split(".").map((id)=>{
            if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
            }
            return id;
        });
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
    }
    format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) this.version += `-${this.prerelease.join(".")}`;
        return this.version;
    }
    toString() {
        return this.version;
    }
    compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
            if (typeof other === "string" && other === this.version) return 0;
            other = new SemVer(other, this.options);
        }
        if (other.version === this.version) return 0;
        return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
        if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
        if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
        // NOT having a prerelease is > having one
        if (this.prerelease.length && !other.prerelease.length) return -1;
        else if (!this.prerelease.length && other.prerelease.length) return 1;
        else if (!this.prerelease.length && !other.prerelease.length) return 0;
        let i = 0;
        do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug("prerelease compare", i, a, b);
            if (a === undefined && b === undefined) return 0;
            else if (b === undefined) return 1;
            else if (a === undefined) return -1;
            else if (a === b) continue;
            else return compareIdentifiers(a, b);
        }while (++i);
    }
    compareBuild(other) {
        if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
        let i = 0;
        do {
            const a = this.build[i];
            const b = other.build[i];
            debug("build compare", i, a, b);
            if (a === undefined && b === undefined) return 0;
            else if (b === undefined) return 1;
            else if (a === undefined) return -1;
            else if (a === b) continue;
            else return compareIdentifiers(a, b);
        }while (++i);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
        switch(release){
            case "premajor":
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor = 0;
                this.major++;
                this.inc("pre", identifier, identifierBase);
                break;
            case "preminor":
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor++;
                this.inc("pre", identifier, identifierBase);
                break;
            case "prepatch":
                // If this is already a prerelease, it will bump to the next version
                // drop any prereleases that might already exist, since they are not
                // relevant at this point.
                this.prerelease.length = 0;
                this.inc("patch", identifier, identifierBase);
                this.inc("pre", identifier, identifierBase);
                break;
            // If the input is a non-prerelease version, this acts the same as
            // prepatch.
            case "prerelease":
                if (this.prerelease.length === 0) this.inc("patch", identifier, identifierBase);
                this.inc("pre", identifier, identifierBase);
                break;
            case "major":
                // If this is a pre-major version, bump up to the same major version.
                // Otherwise increment major.
                // 1.0.0-5 bumps to 1.0.0
                // 1.1.0 bumps to 2.0.0
                if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++;
                this.minor = 0;
                this.patch = 0;
                this.prerelease = [];
                break;
            case "minor":
                // If this is a pre-minor version, bump up to the same minor version.
                // Otherwise increment minor.
                // 1.2.0-5 bumps to 1.2.0
                // 1.2.1 bumps to 1.3.0
                if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
                this.patch = 0;
                this.prerelease = [];
                break;
            case "patch":
                // If this is not a pre-release version, it will increment the patch.
                // If it is a pre-release it will bump up to the same patch version.
                // 1.2.0-5 patches to 1.2.0
                // 1.2.0 patches to 1.2.1
                if (this.prerelease.length === 0) this.patch++;
                this.prerelease = [];
                break;
            // This probably shouldn't be used publicly.
            // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
            case "pre":
                {
                    const base = Number(identifierBase) ? 1 : 0;
                    if (!identifier && identifierBase === false) throw new Error("invalid increment argument: identifier is empty");
                    if (this.prerelease.length === 0) this.prerelease = [
                        base
                    ];
                    else {
                        let i = this.prerelease.length;
                        while(--i >= 0)if (typeof this.prerelease[i] === "number") {
                            this.prerelease[i]++;
                            i = -2;
                        }
                        if (i === -1) {
                            // didn't increment anything
                            if (identifier === this.prerelease.join(".") && identifierBase === false) throw new Error("invalid increment argument: identifier already exists");
                            this.prerelease.push(base);
                        }
                    }
                    if (identifier) {
                        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
                        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
                        let prerelease = [
                            identifier,
                            base
                        ];
                        if (identifierBase === false) prerelease = [
                            identifier
                        ];
                        if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                            if (isNaN(this.prerelease[1])) this.prerelease = prerelease;
                        } else this.prerelease = prerelease;
                    }
                    break;
                }
            default:
                throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) this.raw += `+${this.build.join(".")}`;
        return this;
    }
}
module.exports = SemVer;

},{"595c172e7d863d06":"bFCt8","bd8d57fbca62978a":"kfqYl","2b364a26e67d9817":"3aKaA","f1a723539d6cc9b5":"1qAg7","2451a15946a38fcd":"3Ushi"}],"1qAg7":[function(require,module,exports) {
// parse out just the options we care about
const looseOption = Object.freeze({
    loose: true
});
const emptyOpts = Object.freeze({});
const parseOptions = (options)=>{
    if (!options) return emptyOpts;
    if (typeof options !== "object") return looseOption;
    return options;
};
module.exports = parseOptions;

},{}],"3Ushi":[function(require,module,exports) {
const numeric = /^[0-9]+$/;
const compareIdentifiers = (a, b)=>{
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
        a = +a;
        b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b)=>compareIdentifiers(b, a);
module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
};

},{}],"fKLuB":[function(require,module,exports) {
const SemVer = require("575e97778d3944c0");
const parse = (version, options, throwErrors = false)=>{
    if (version instanceof SemVer) return version;
    try {
        return new SemVer(version, options);
    } catch (er) {
        if (!throwErrors) return null;
        throw er;
    }
};
module.exports = parse;

},{"575e97778d3944c0":"7HV8v"}],"fONiE":[function(require,module,exports) {
const parse = require("6a6e19c11f3ced24");
const valid = (version, options)=>{
    const v = parse(version, options);
    return v ? v.version : null;
};
module.exports = valid;

},{"6a6e19c11f3ced24":"fKLuB"}],"lDszQ":[function(require,module,exports) {
const parse = require("661ff2c6ff41830b");
const clean = (version, options)=>{
    const s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
};
module.exports = clean;

},{"661ff2c6ff41830b":"fKLuB"}],"knExV":[function(require,module,exports) {
const SemVer = require("9a4ed023da196604");
const inc = (version, release, options, identifier, identifierBase)=>{
    if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = undefined;
    }
    try {
        return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
        return null;
    }
};
module.exports = inc;

},{"9a4ed023da196604":"7HV8v"}],"gd8W5":[function(require,module,exports) {
const parse = require("3b6d0e3ec696b30a");
const diff = (version1, version2)=>{
    const v1 = parse(version1, null, true);
    const v2 = parse(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) return null;
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
        // Going from prerelease -> no prerelease requires some special casing
        // If the low version has only a major, then it will always be a major
        // Some examples:
        // 1.0.0-1 -> 1.0.0
        // 1.0.0-1 -> 1.1.1
        // 1.0.0-1 -> 2.0.0
        if (!lowVersion.patch && !lowVersion.minor) return "major";
        // Otherwise it can be determined by checking the high version
        if (highVersion.patch) // anything higher than a patch bump would result in the wrong version
        return "patch";
        if (highVersion.minor) // anything higher than a minor bump would result in the wrong version
        return "minor";
        // bumping major/minor/patch all have same result
        return "major";
    }
    // add the `pre` prefix if we are going to a prerelease version
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) return prefix + "major";
    if (v1.minor !== v2.minor) return prefix + "minor";
    if (v1.patch !== v2.patch) return prefix + "patch";
    // high and low are preleases
    return "prerelease";
};
module.exports = diff;

},{"3b6d0e3ec696b30a":"fKLuB"}],"aQdxS":[function(require,module,exports) {
const SemVer = require("53a097ab5c27a647");
const major = (a, loose)=>new SemVer(a, loose).major;
module.exports = major;

},{"53a097ab5c27a647":"7HV8v"}],"5Jk7e":[function(require,module,exports) {
const SemVer = require("f130a90acb01ac10");
const minor = (a, loose)=>new SemVer(a, loose).minor;
module.exports = minor;

},{"f130a90acb01ac10":"7HV8v"}],"k27vv":[function(require,module,exports) {
const SemVer = require("54b9ac3bbdf83b31");
const patch = (a, loose)=>new SemVer(a, loose).patch;
module.exports = patch;

},{"54b9ac3bbdf83b31":"7HV8v"}],"53tgW":[function(require,module,exports) {
const parse = require("ff5ab55da1933db3");
const prerelease = (version, options)=>{
    const parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
module.exports = prerelease;

},{"ff5ab55da1933db3":"fKLuB"}],"d0byB":[function(require,module,exports) {
const SemVer = require("f16c9f4397244ee0");
const compare = (a, b, loose)=>new SemVer(a, loose).compare(new SemVer(b, loose));
module.exports = compare;

},{"f16c9f4397244ee0":"7HV8v"}],"aVRRy":[function(require,module,exports) {
const compare = require("4bfcc14a9711a47b");
const rcompare = (a, b, loose)=>compare(b, a, loose);
module.exports = rcompare;

},{"4bfcc14a9711a47b":"d0byB"}],"cRDDp":[function(require,module,exports) {
const compare = require("95c8404dc369c13b");
const compareLoose = (a, b)=>compare(a, b, true);
module.exports = compareLoose;

},{"95c8404dc369c13b":"d0byB"}],"8IgjV":[function(require,module,exports) {
const SemVer = require("3659675d95d38f3");
const compareBuild = (a, b, loose)=>{
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
module.exports = compareBuild;

},{"3659675d95d38f3":"7HV8v"}],"uRtcB":[function(require,module,exports) {
const compareBuild = require("7c22e552e691e157");
const sort = (list, loose)=>list.sort((a, b)=>compareBuild(a, b, loose));
module.exports = sort;

},{"7c22e552e691e157":"8IgjV"}],"faT9h":[function(require,module,exports) {
const compareBuild = require("468f4992c854a69a");
const rsort = (list, loose)=>list.sort((a, b)=>compareBuild(b, a, loose));
module.exports = rsort;

},{"468f4992c854a69a":"8IgjV"}],"4Ummg":[function(require,module,exports) {
const compare = require("85515ef2889f4f89");
const gt = (a, b, loose)=>compare(a, b, loose) > 0;
module.exports = gt;

},{"85515ef2889f4f89":"d0byB"}],"cevz4":[function(require,module,exports) {
const compare = require("9d2d7734c37f90e6");
const lt = (a, b, loose)=>compare(a, b, loose) < 0;
module.exports = lt;

},{"9d2d7734c37f90e6":"d0byB"}],"g8cVO":[function(require,module,exports) {
const compare = require("d6abf8ed12ec38c1");
const eq = (a, b, loose)=>compare(a, b, loose) === 0;
module.exports = eq;

},{"d6abf8ed12ec38c1":"d0byB"}],"6pfyl":[function(require,module,exports) {
const compare = require("5232df27c4c4faa9");
const neq = (a, b, loose)=>compare(a, b, loose) !== 0;
module.exports = neq;

},{"5232df27c4c4faa9":"d0byB"}],"10dKg":[function(require,module,exports) {
const compare = require("9183f7fbecba58ae");
const gte = (a, b, loose)=>compare(a, b, loose) >= 0;
module.exports = gte;

},{"9183f7fbecba58ae":"d0byB"}],"g8gHq":[function(require,module,exports) {
const compare = require("e55eadc974580af5");
const lte = (a, b, loose)=>compare(a, b, loose) <= 0;
module.exports = lte;

},{"e55eadc974580af5":"d0byB"}],"duXdn":[function(require,module,exports) {
const eq = require("bff7f16298b8dbaa");
const neq = require("6a1bb69c2d499261");
const gt = require("dca4b9c05150a919");
const gte = require("7b5dc70556970d6c");
const lt = require("a3a3bcc6e4d6bbdf");
const lte = require("5f1835ee4d0596f3");
const cmp = (a, op, b, loose)=>{
    switch(op){
        case "===":
            if (typeof a === "object") a = a.version;
            if (typeof b === "object") b = b.version;
            return a === b;
        case "!==":
            if (typeof a === "object") a = a.version;
            if (typeof b === "object") b = b.version;
            return a !== b;
        case "":
        case "=":
        case "==":
            return eq(a, b, loose);
        case "!=":
            return neq(a, b, loose);
        case ">":
            return gt(a, b, loose);
        case ">=":
            return gte(a, b, loose);
        case "<":
            return lt(a, b, loose);
        case "<=":
            return lte(a, b, loose);
        default:
            throw new TypeError(`Invalid operator: ${op}`);
    }
};
module.exports = cmp;

},{"bff7f16298b8dbaa":"g8cVO","6a1bb69c2d499261":"6pfyl","dca4b9c05150a919":"4Ummg","7b5dc70556970d6c":"10dKg","a3a3bcc6e4d6bbdf":"cevz4","5f1835ee4d0596f3":"g8gHq"}],"mfbCy":[function(require,module,exports) {
const SemVer = require("25529d97ade3ccdf");
const parse = require("90724e3140f56906");
const { safeRe: re, t } = require("49971e907f1359e9");
const coerce = (version, options)=>{
    if (version instanceof SemVer) return version;
    if (typeof version === "number") version = String(version);
    if (typeof version !== "string") return null;
    options = options || {};
    let match = null;
    if (!options.rtl) match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    else {
        // Find the right-most coercible string that does not share
        // a terminus with a more left-ward coercible string.
        // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
        // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
        //
        // Walk through the string checking with a /g regexp
        // Manually set the index so as to pick up overlapping matches.
        // Stop when we get a match that ends at the string end, since no
        // coercible string can be more right-ward without the same terminus.
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)){
            if (!match || next.index + next[0].length !== match.index + match[0].length) match = next;
            coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        // leave it in a clean state
        coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) return null;
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
};
module.exports = coerce;

},{"25529d97ade3ccdf":"7HV8v","90724e3140f56906":"fKLuB","49971e907f1359e9":"3aKaA"}],"gVFDT":[function(require,module,exports) {
const ANY = Symbol("SemVer ANY");
// hoisted class for cyclic dependency
class Comparator {
    static get ANY() {
        return ANY;
    }
    constructor(comp, options){
        options = parseOptions(options);
        if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) return comp;
            else comp = comp.value;
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) this.value = "";
        else this.value = this.operator + this.semver.version;
        debug("comp", this);
    }
    parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) throw new TypeError(`Invalid comparator: ${comp}`);
        this.operator = m[1] !== undefined ? m[1] : "";
        if (this.operator === "=") this.operator = "";
        // if it literally is just '>' or '' then allow anything.
        if (!m[2]) this.semver = ANY;
        else this.semver = new SemVer(m[2], this.options.loose);
    }
    toString() {
        return this.value;
    }
    test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) return true;
        if (typeof version === "string") try {
            version = new SemVer(version, this.options);
        } catch (er) {
            return false;
        }
        return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
        if (!(comp instanceof Comparator)) throw new TypeError("a Comparator is required");
        if (this.operator === "") {
            if (this.value === "") return true;
            return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
            if (comp.value === "") return true;
            return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        // Special cases where nothing can possibly be lower
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) return false;
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) return false;
        // Same direction increasing (> or >=)
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) return true;
        // Same direction decreasing (< or <=)
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) return true;
        // same SemVer and both sides are inclusive (<= or >=)
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) return true;
        // opposite directions less than
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) return true;
        // opposite directions greater than
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) return true;
        return false;
    }
}
module.exports = Comparator;
const parseOptions = require("b6563e9809bd921f");
const { safeRe: re, t } = require("f844ee6695e23038");
const cmp = require("e62b495d112b67cb");
const debug = require("13b490d953a8241f");
const SemVer = require("f688b7fbae163ad8");
const Range = require("b8839ba12a91a5c9");

},{"b6563e9809bd921f":"1qAg7","f844ee6695e23038":"3aKaA","e62b495d112b67cb":"duXdn","13b490d953a8241f":"bFCt8","f688b7fbae163ad8":"7HV8v","b8839ba12a91a5c9":"iSOAN"}],"iSOAN":[function(require,module,exports) {
const SPACE_CHARACTERS = /\s+/g;
// hoisted class for cyclic dependency
class Range {
    constructor(range, options){
        options = parseOptions(options);
        if (range instanceof Range) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) return range;
            else return new Range(range.raw, options);
        }
        if (range instanceof Comparator) {
            // just put it in the set and return
            this.raw = range.value;
            this.set = [
                [
                    range
                ]
            ];
            this.formatted = undefined;
            return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        // First reduce all whitespace as much as possible so we do not have to rely
        // on potentially slow regexes like \s*. This is then stored and used for
        // future error messages as well.
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        // First, split on ||
        this.set = this.raw.split("||")// map the range to a 2d array of comparators
        .map((r)=>this.parseRange(r.trim()))// throw out any comparator lists that are empty
        // this generally means that it was not a valid range, which is allowed
        // in loose mode, but will still throw if the WHOLE range is invalid.
        .filter((c)=>c.length);
        if (!this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        // if we have any that are not the null set, throw out null sets.
        if (this.set.length > 1) {
            // keep the first one, in case they're all null sets
            const first = this.set[0];
            this.set = this.set.filter((c)=>!isNullSet(c[0]));
            if (this.set.length === 0) this.set = [
                first
            ];
            else if (this.set.length > 1) {
                // if we have any that are *, then the range is just *
                for (const c of this.set)if (c.length === 1 && isAny(c[0])) {
                    this.set = [
                        c
                    ];
                    break;
                }
            }
        }
        this.formatted = undefined;
    }
    get range() {
        if (this.formatted === undefined) {
            this.formatted = "";
            for(let i = 0; i < this.set.length; i++){
                if (i > 0) this.formatted += "||";
                const comps = this.set[i];
                for(let k = 0; k < comps.length; k++){
                    if (k > 0) this.formatted += " ";
                    this.formatted += comps[k].toString().trim();
                }
            }
        }
        return this.formatted;
    }
    format() {
        return this.range;
    }
    toString() {
        return this.range;
    }
    parseRange(range) {
        // memoize range parsing for performance.
        // this is a very hot path, and fully deterministic.
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) return cached;
        const loose = this.options.loose;
        // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        // `~ 1.2.3` => `~1.2.3`
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        // `^ 1.2.3` => `^1.2.3`
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        // At this point, the range is completely trimmed and
        // ready to be split into comparators.
        let rangeList = range.split(" ").map((comp)=>parseComparator(comp, this.options)).join(" ").split(/\s+/)// >=0.0.0 is equivalent to *
        .map((comp)=>replaceGTE0(comp, this.options));
        if (loose) // in loose mode, throw out any that are not valid comparators
        rangeList = rangeList.filter((comp)=>{
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
        });
        debug("range list", rangeList);
        // if any comparators are the null set, then replace with JUST null set
        // if more than one comparator, remove any * comparators
        // also, don't include the same comparator more than once
        const rangeMap = new Map();
        const comparators = rangeList.map((comp)=>new Comparator(comp, this.options));
        for (const comp of comparators){
            if (isNullSet(comp)) return [
                comp
            ];
            rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) rangeMap.delete("");
        const result = [
            ...rangeMap.values()
        ];
        cache.set(memoKey, result);
        return result;
    }
    intersects(range, options) {
        if (!(range instanceof Range)) throw new TypeError("a Range is required");
        return this.set.some((thisComparators)=>{
            return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators)=>{
                return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator)=>{
                    return rangeComparators.every((rangeComparator)=>{
                        return thisComparator.intersects(rangeComparator, options);
                    });
                });
            });
        });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
        if (!version) return false;
        if (typeof version === "string") try {
            version = new SemVer(version, this.options);
        } catch (er) {
            return false;
        }
        for(let i = 0; i < this.set.length; i++){
            if (testSet(this.set[i], version, this.options)) return true;
        }
        return false;
    }
}
module.exports = Range;
const LRU = require("96f33215aad25ada");
const cache = new LRU();
const parseOptions = require("17bb122b9b0740d9");
const Comparator = require("df9131adcc191f91");
const debug = require("1c7c6c8abfe9bd3b");
const SemVer = require("d77fd978650b507f");
const { safeRe: re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = require("9bd5ca5276add1c4");
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require("8c8074dc7fc46964");
const isNullSet = (c)=>c.value === "<0.0.0-0";
const isAny = (c)=>c.value === "";
// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options)=>{
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while(result && remainingComparators.length){
        result = remainingComparators.every((otherComparator)=>{
            return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
    }
    return result;
};
// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options)=>{
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
};
const isX = (id)=>!id || id.toLowerCase() === "x" || id === "*";
// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options)=>{
    return comp.trim().split(/\s+/).map((c)=>replaceTilde(c, options)).join(" ");
};
const replaceTilde = (comp, options)=>{
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr)=>{
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) ret = "";
        else if (isX(m)) ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        else if (isX(p)) // ~1.2 == >=1.2.0 <1.3.0-0
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        else if (pr) {
            debug("replaceTilde pr", pr);
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else // ~1.2.3 == >=1.2.3 <1.3.0-0
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        debug("tilde return", ret);
        return ret;
    });
};
// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options)=>{
    return comp.trim().split(/\s+/).map((c)=>replaceCaret(c, options)).join(" ");
};
const replaceCaret = (comp, options)=>{
    debug("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr)=>{
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) ret = "";
        else if (isX(m)) ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        else if (isX(p)) {
            if (M === "0") ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
            else ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        } else if (pr) {
            debug("replaceCaret pr", pr);
            if (M === "0") {
                if (m === "0") ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
                else ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            } else ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        } else {
            debug("no pr");
            if (M === "0") {
                if (m === "0") ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
                else ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            } else ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
        debug("caret return", ret);
        return ret;
    });
};
const replaceXRanges = (comp, options)=>{
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c)=>replaceXRange(c, options)).join(" ");
};
const replaceXRange = (comp, options)=>{
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr)=>{
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) gtlt = "";
        // if we're including prereleases in the match, then we need
        // to fix this to -0, the lowest possible prerelease value
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
            if (gtlt === ">" || gtlt === "<") // nothing is allowed
            ret = "<0.0.0-0";
            else // nothing is forbidden
            ret = "*";
        } else if (gtlt && anyX) {
            // we know patch is an x, because we have any x at all.
            // replace X with 0
            if (xm) m = 0;
            p = 0;
            if (gtlt === ">") {
                // >1 => >=2.0.0
                // >1.2 => >=1.3.0
                gtlt = ">=";
                if (xm) {
                    M = +M + 1;
                    m = 0;
                    p = 0;
                } else {
                    m = +m + 1;
                    p = 0;
                }
            } else if (gtlt === "<=") {
                // <=0.7.x is actually <0.8.0, since any 0.7.x should
                // pass.  Similarly, <=7.x is actually <8.0.0, etc.
                gtlt = "<";
                if (xm) M = +M + 1;
                else m = +m + 1;
            }
            if (gtlt === "<") pr = "-0";
            ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        else if (xp) ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        debug("xRange return", ret);
        return ret;
    });
};
// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options)=>{
    debug("replaceStars", comp, options);
    // Looseness is ignored here.  star is always as loose as it gets!
    return comp.trim().replace(re[t.STAR], "");
};
const replaceGTE0 = (comp, options)=>{
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
};
// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
// TODO build?
const hyphenReplace = (incPr)=>($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr)=>{
        if (isX(fM)) from = "";
        else if (isX(fm)) from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
        else if (isX(fp)) from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
        else if (fpr) from = `>=${from}`;
        else from = `>=${from}${incPr ? "-0" : ""}`;
        if (isX(tM)) to = "";
        else if (isX(tm)) to = `<${+tM + 1}.0.0-0`;
        else if (isX(tp)) to = `<${tM}.${+tm + 1}.0-0`;
        else if (tpr) to = `<=${tM}.${tm}.${tp}-${tpr}`;
        else if (incPr) to = `<${tM}.${tm}.${+tp + 1}-0`;
        else to = `<=${to}`;
        return `${from} ${to}`.trim();
    };
const testSet = (set, version, options)=>{
    for(let i = 0; i < set.length; i++){
        if (!set[i].test(version)) return false;
    }
    if (version.prerelease.length && !options.includePrerelease) {
        // Find the set of versions that are allowed to have prereleases
        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
        // That should allow `1.2.3-pr.2` to pass.
        // However, `1.2.4-alpha.notready` should NOT be allowed,
        // even though it's within the range set by the comparators.
        for(let i = 0; i < set.length; i++){
            debug(set[i].semver);
            if (set[i].semver === Comparator.ANY) continue;
            if (set[i].semver.prerelease.length > 0) {
                const allowed = set[i].semver;
                if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return true;
            }
        }
        // Version has a -pre, but it's not one of the ones we like.
        return false;
    }
    return true;
};

},{"96f33215aad25ada":"kQNrn","17bb122b9b0740d9":"1qAg7","df9131adcc191f91":"gVFDT","1c7c6c8abfe9bd3b":"bFCt8","d77fd978650b507f":"7HV8v","9bd5ca5276add1c4":"3aKaA","8c8074dc7fc46964":"kfqYl"}],"kQNrn":[function(require,module,exports) {
class LRUCache {
    constructor(){
        this.max = 1000;
        this.map = new Map();
    }
    get(key) {
        const value = this.map.get(key);
        if (value === undefined) return undefined;
        else {
            // Remove the key from the map and add it to the end
            this.map.delete(key);
            this.map.set(key, value);
            return value;
        }
    }
    delete(key) {
        return this.map.delete(key);
    }
    set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== undefined) {
            // If cache is full, delete the least recently used item
            if (this.map.size >= this.max) {
                const firstKey = this.map.keys().next().value;
                this.delete(firstKey);
            }
            this.map.set(key, value);
        }
        return this;
    }
}
module.exports = LRUCache;

},{}],"4GGCq":[function(require,module,exports) {
const Range = require("b60a47303a13d107");
const satisfies = (version, range, options)=>{
    try {
        range = new Range(range, options);
    } catch (er) {
        return false;
    }
    return range.test(version);
};
module.exports = satisfies;

},{"b60a47303a13d107":"iSOAN"}],"h7PG2":[function(require,module,exports) {
const Range = require("f497be9904aac7c0");
// Mostly just for testing and legacy API reasons
const toComparators = (range, options)=>new Range(range, options).set.map((comp)=>comp.map((c)=>c.value).join(" ").trim().split(" "));
module.exports = toComparators;

},{"f497be9904aac7c0":"iSOAN"}],"k7Iyh":[function(require,module,exports) {
const SemVer = require("96d622a81d57358d");
const Range = require("f2865e94142488ab");
const maxSatisfying = (versions, range, options)=>{
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
        rangeObj = new Range(range, options);
    } catch (er) {
        return null;
    }
    versions.forEach((v)=>{
        if (rangeObj.test(v)) // satisfies(v, range, options)
        {
            if (!max || maxSV.compare(v) === -1) {
                // compare(max, v, true)
                max = v;
                maxSV = new SemVer(max, options);
            }
        }
    });
    return max;
};
module.exports = maxSatisfying;

},{"96d622a81d57358d":"7HV8v","f2865e94142488ab":"iSOAN"}],"gedPT":[function(require,module,exports) {
const SemVer = require("fea3851ba09d8834");
const Range = require("9d2799b098b5c4c7");
const minSatisfying = (versions, range, options)=>{
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
        rangeObj = new Range(range, options);
    } catch (er) {
        return null;
    }
    versions.forEach((v)=>{
        if (rangeObj.test(v)) // satisfies(v, range, options)
        {
            if (!min || minSV.compare(v) === 1) {
                // compare(min, v, true)
                min = v;
                minSV = new SemVer(min, options);
            }
        }
    });
    return min;
};
module.exports = minSatisfying;

},{"fea3851ba09d8834":"7HV8v","9d2799b098b5c4c7":"iSOAN"}],"bD9nR":[function(require,module,exports) {
const SemVer = require("4c531b1d555da497");
const Range = require("76327127dc36ed58");
const gt = require("a5ac47b45ae8684c");
const minVersion = (range, loose)=>{
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) return minver;
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) return minver;
    minver = null;
    for(let i = 0; i < range.set.length; ++i){
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator)=>{
            // Clone to avoid manipulating the comparator's semver object.
            const compver = new SemVer(comparator.semver.version);
            switch(comparator.operator){
                case ">":
                    if (compver.prerelease.length === 0) compver.patch++;
                    else compver.prerelease.push(0);
                    compver.raw = compver.format();
                /* fallthrough */ case "":
                case ">=":
                    if (!setMin || gt(compver, setMin)) setMin = compver;
                    break;
                case "<":
                case "<=":
                    break;
                /* istanbul ignore next */ default:
                    throw new Error(`Unexpected operation: ${comparator.operator}`);
            }
        });
        if (setMin && (!minver || gt(minver, setMin))) minver = setMin;
    }
    if (minver && range.test(minver)) return minver;
    return null;
};
module.exports = minVersion;

},{"4c531b1d555da497":"7HV8v","76327127dc36ed58":"iSOAN","a5ac47b45ae8684c":"4Ummg"}],"hrqD8":[function(require,module,exports) {
const Range = require("fd2c35053245b1fd");
const validRange = (range, options)=>{
    try {
        // Return '*' instead of '' so that truthiness works.
        // This will throw if it's invalid anyway
        return new Range(range, options).range || "*";
    } catch (er) {
        return null;
    }
};
module.exports = validRange;

},{"fd2c35053245b1fd":"iSOAN"}],"WXkQN":[function(require,module,exports) {
const SemVer = require("65977c6c7fab41e0");
const Comparator = require("8b0890ac7a0294ed");
const { ANY } = Comparator;
const Range = require("9baad77301d611e2");
const satisfies = require("1a3d276234841886");
const gt = require("8f784c6ef2cd1972");
const lt = require("3c234e2ddd9db68a");
const lte = require("88893a74cd9f934");
const gte = require("6cccfcce37ef6329");
const outside = (version, range, hilo, options)=>{
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch(hilo){
        case ">":
            gtfn = gt;
            ltefn = lte;
            ltfn = lt;
            comp = ">";
            ecomp = ">=";
            break;
        case "<":
            gtfn = lt;
            ltefn = gte;
            ltfn = gt;
            comp = "<";
            ecomp = "<=";
            break;
        default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    // If it satisfies the range it is not outside
    if (satisfies(version, range, options)) return false;
    // From now on, variable terms are as if we're in "gtr" mode.
    // but note that everything is flipped for the "ltr" function.
    for(let i = 0; i < range.set.length; ++i){
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator)=>{
            if (comparator.semver === ANY) comparator = new Comparator(">=0.0.0");
            high = high || comparator;
            low = low || comparator;
            if (gtfn(comparator.semver, high.semver, options)) high = comparator;
            else if (ltfn(comparator.semver, low.semver, options)) low = comparator;
        });
        // If the edge version comparator has a operator then our version
        // isn't outside it
        if (high.operator === comp || high.operator === ecomp) return false;
        // If the lowest version comparator has an operator and our version
        // is less than it then it isn't higher than the range
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) return false;
        else if (low.operator === ecomp && ltfn(version, low.semver)) return false;
    }
    return true;
};
module.exports = outside;

},{"65977c6c7fab41e0":"7HV8v","8b0890ac7a0294ed":"gVFDT","9baad77301d611e2":"iSOAN","1a3d276234841886":"4GGCq","8f784c6ef2cd1972":"4Ummg","3c234e2ddd9db68a":"cevz4","88893a74cd9f934":"g8gHq","6cccfcce37ef6329":"10dKg"}],"3m3un":[function(require,module,exports) {
// Determine if version is greater than all the versions possible in the range.
const outside = require("be5e984e16e512b9");
const gtr = (version, range, options)=>outside(version, range, ">", options);
module.exports = gtr;

},{"be5e984e16e512b9":"WXkQN"}],"lVkgp":[function(require,module,exports) {
const outside = require("b7f00e21a32b75a5");
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options)=>outside(version, range, "<", options);
module.exports = ltr;

},{"b7f00e21a32b75a5":"WXkQN"}],"3twh6":[function(require,module,exports) {
const Range = require("5205f80872e81710");
const intersects = (r1, r2, options)=>{
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
};
module.exports = intersects;

},{"5205f80872e81710":"iSOAN"}],"2hxzT":[function(require,module,exports) {
// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = require("e72123f17434788");
const compare = require("3eb9817061c82995");
module.exports = (versions, range, options)=>{
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b)=>compare(a, b, options));
    for (const version of v){
        const included = satisfies(version, range, options);
        if (included) {
            prev = version;
            if (!first) first = version;
        } else {
            if (prev) set.push([
                first,
                prev
            ]);
            prev = null;
            first = null;
        }
    }
    if (first) set.push([
        first,
        null
    ]);
    const ranges = [];
    for (const [min, max] of set){
        if (min === max) ranges.push(min);
        else if (!max && min === v[0]) ranges.push("*");
        else if (!max) ranges.push(`>=${min}`);
        else if (min === v[0]) ranges.push(`<=${max}`);
        else ranges.push(`${min} - ${max}`);
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
};

},{"e72123f17434788":"4GGCq","3eb9817061c82995":"d0byB"}],"f8DRU":[function(require,module,exports) {
const Range = require("c141b0432e6ae71b");
const Comparator = require("94bed966a1054073");
const { ANY } = Comparator;
const satisfies = require("acfaf6445a9794b");
const compare = require("d9ed82a69c119cf4");
// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true
const subset = (sub, dom, options = {})=>{
    if (sub === dom) return true;
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER: for (const simpleSub of sub.set){
        for (const simpleDom of dom.set){
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) continue OUTER;
        }
        // the null set is a subset of everything, but null simple ranges in
        // a complex range should be ignored.  so if we saw a non-null range,
        // then we know this isn't a subset, but if EVERY simple range was null,
        // then it is a subset.
        if (sawNonNull) return false;
    }
    return true;
};
const minimumVersionWithPreRelease = [
    new Comparator(">=0.0.0-0")
];
const minimumVersion = [
    new Comparator(">=0.0.0")
];
const simpleSubset = (sub, dom, options)=>{
    if (sub === dom) return true;
    if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) return true;
        else if (options.includePrerelease) sub = minimumVersionWithPreRelease;
        else sub = minimumVersion;
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) return true;
        else dom = minimumVersion;
    }
    const eqSet = new Set();
    let gt, lt;
    for (const c of sub){
        if (c.operator === ">" || c.operator === ">=") gt = higherGT(gt, c, options);
        else if (c.operator === "<" || c.operator === "<=") lt = lowerLT(lt, c, options);
        else eqSet.add(c.semver);
    }
    if (eqSet.size > 1) return null;
    let gtltComp;
    if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) return null;
        else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) return null;
    }
    // will iterate one or zero times
    for (const eq of eqSet){
        if (gt && !satisfies(eq, String(gt), options)) return null;
        if (lt && !satisfies(eq, String(lt), options)) return null;
        for (const c of dom){
            if (!satisfies(eq, String(c), options)) return false;
        }
        return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    // if the subset has a prerelease, we need a comparator in the superset
    // with the same tuple and a prerelease, or it's not a subset
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    // exception: <1.2.3-0 is the same as <1.2.3
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) needDomLTPre = false;
    for (const c of dom){
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
            if (needDomGTPre) {
                if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) needDomGTPre = false;
            }
            if (c.operator === ">" || c.operator === ">=") {
                higher = higherGT(gt, c, options);
                if (higher === c && higher !== gt) return false;
            } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) return false;
        }
        if (lt) {
            if (needDomLTPre) {
                if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) needDomLTPre = false;
            }
            if (c.operator === "<" || c.operator === "<=") {
                lower = lowerLT(lt, c, options);
                if (lower === c && lower !== lt) return false;
            } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) return false;
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) return false;
    }
    // if there was a < or >, and nothing in the dom, then must be false
    // UNLESS it was limited by another range in the other direction.
    // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
    if (gt && hasDomLT && !lt && gtltComp !== 0) return false;
    if (lt && hasDomGT && !gt && gtltComp !== 0) return false;
    // we needed a prerelease range in a specific tuple, but didn't get one
    // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
    // because it includes prereleases in the 1.2.3 tuple
    if (needDomGTPre || needDomLTPre) return false;
    return true;
};
// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options)=>{
    if (!a) return b;
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options)=>{
    if (!a) return b;
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
module.exports = subset;

},{"c141b0432e6ae71b":"iSOAN","94bed966a1054073":"gVFDT","acfaf6445a9794b":"4GGCq","d9ed82a69c119cf4":"d0byB"}],"bGXU5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isPathNormal", ()=>isPathNormal);
var _bitcoinjsLib = require("bitcoinjs-lib");
var _tinySecp256K1 = require("tiny-secp256k1");
var _bip32 = require("./bip32");
var _buffertools = require("./buffertools");
var _accounttype = require("./newops/accounttype");
var _policy = require("./newops/policy");
var _psbtExtractor = require("./newops/psbtExtractor");
var _psbtFinalizer = require("./newops/psbtFinalizer");
var _psbtv2 = require("./newops/psbtv2");
var _serializeTransaction = require("./serializeTransaction");
var Buffer = require("4f9d6f069b552aa3").Buffer;
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class BtcNew {
    constructor(client){
        this.client = client;
    }
    /**
     * This is a new method that allow users to get an xpub at a standard path.
     * Standard paths are described at
     * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md#description
     *
     * This boils down to paths (N=0 for Bitcoin, N=1 for Testnet):
     * M/44'/N'/x'/**
     * M/48'/N'/x'/y'/**
     * M/49'/N'/x'/**
     * M/84'/N'/x'/**
     * M/86'/N'/x'/**
     *
     * The method was added because of added security in the hardware app v2+. The
     * new hardware app will allow export of any xpub up to and including the
     * deepest hardened key of standard derivation paths, whereas the old app
     * would allow export of any key.
     *
     * This caused an issue for callers of this class, who only had
     * getWalletPublicKey() to call which means they have to constuct xpub
     * themselves:
     *
     * Suppose a user of this class wants to create an account xpub on a standard
     * path, M/44'/0'/Z'. The user must get the parent key fingerprint (see BIP32)
     * by requesting the parent key M/44'/0'. The new app won't allow that, because
     * it only allows exporting deepest level hardened path. So the options are to
     * allow requesting M/44'/0' from the app, or to add a new function
     * "getWalletXpub".
     *
     * We opted for adding a new function, which can greatly simplify client code.
     */ getWalletXpub(_a) {
        return __awaiter(this, arguments, void 0, function*({ path, xpubVersion }) {
            const pathElements = (0, _bip32.pathStringToArray)(path);
            const xpub = yield this.client.getExtendedPubkey(false, pathElements);
            const xpubComponents = (0, _bip32.getXpubComponents)(xpub);
            if (xpubComponents.version != xpubVersion) throw new Error(`Expected xpub version ${xpubVersion} doesn't match the xpub version from the device ${xpubComponents.version}`);
            return xpub;
        });
    }
    /**
     * This method returns a public key, a bitcoin address, and and a chaincode
     * for a specific derivation path.
     *
     * Limitation: If the path is not a leaf node of a standard path, the address
     * will be the empty string "", see this.getWalletAddress() for details.
     */ getWalletPublicKey(path, opts) {
        return __awaiter(this, void 0, void 0, function*() {
            var _a, _b;
            if (!isPathNormal(path)) throw Error(`non-standard path: ${path}`);
            const pathElements = (0, _bip32.pathStringToArray)(path);
            const xpub = yield this.client.getExtendedPubkey(false, pathElements);
            const display = (_a = opts === null || opts === void 0 ? void 0 : opts.verify) !== null && _a !== void 0 ? _a : false;
            const address = yield this.getWalletAddress(pathElements, descrTemplFrom((_b = opts === null || opts === void 0 ? void 0 : opts.format) !== null && _b !== void 0 ? _b : "legacy"), display);
            const components = (0, _bip32.getXpubComponents)(xpub);
            const uncompressedPubkey = Buffer.from((0, _tinySecp256K1.pointCompress)(components.pubkey, false));
            return {
                publicKey: uncompressedPubkey.toString("hex"),
                bitcoinAddress: address,
                chainCode: components.chaincode.toString("hex")
            };
        });
    }
    /**
     * Get an address for the specified path.
     *
     * If display is true, we must get the address from the device, which would require
     * us to determine WalletPolicy. This requires two *extra* queries to the device, one
     * for the account xpub and one for master key fingerprint.
     *
     * If display is false we *could* generate the address ourselves, but chose to
     * get it from the device to save development time. However, it shouldn't take
     * too much time to implement local address generation.
     *
     * Moreover, if the path is not for a leaf, ie accountPath+/X/Y, there is no
     * way to get the address from the device. In this case we have to create it
     * ourselves, but we don't at this time, and instead return an empty ("") address.
     */ getWalletAddress(pathElements, descrTempl, display) {
        return __awaiter(this, void 0, void 0, function*() {
            const accountPath = (0, _bip32.hardenedPathOf)(pathElements);
            if (accountPath.length + 2 != pathElements.length) return "";
            const accountXpub = yield this.client.getExtendedPubkey(false, accountPath);
            const masterFingerprint = yield this.client.getMasterFingerprint();
            const policy = new (0, _policy.WalletPolicy)(descrTempl, (0, _policy.createKey)(masterFingerprint, accountPath, accountXpub));
            const changeAndIndex = pathElements.slice(-2, pathElements.length);
            return this.client.getWalletAddress(policy, Buffer.alloc(32, 0), changeAndIndex[0], changeAndIndex[1], display);
        });
    }
    /**
     * Build and sign a transaction. See Btc.createPaymentTransaction for
     * details on how to use this method.
     *
     * This method will convert the legacy arguments, CreateTransactionArg, into
     * a psbt which is finally signed and finalized, and the extracted fully signed
     * transaction is returned.
     */ createPaymentTransaction(arg) {
        return __awaiter(this, void 0, void 0, function*() {
            const inputCount = arg.inputs.length;
            if (inputCount == 0) throw Error("No inputs");
            const psbt = new (0, _psbtv2.PsbtV2)();
            // The master fingerprint is needed when adding BIP32 derivation paths on
            // the psbt.
            const masterFp = yield this.client.getMasterFingerprint();
            const accountType = accountTypeFromArg(arg, psbt, masterFp);
            if (arg.lockTime != undefined) // The signer will assume locktime 0 if unset
            psbt.setGlobalFallbackLocktime(arg.lockTime);
            psbt.setGlobalInputCount(inputCount);
            psbt.setGlobalPsbtVersion(2);
            psbt.setGlobalTxVersion(2);
            let notifyCount = 0;
            const progress = ()=>{
                if (!arg.onDeviceStreaming) return;
                arg.onDeviceStreaming({
                    total: 2 * inputCount,
                    index: notifyCount,
                    progress: ++notifyCount / (2 * inputCount)
                });
            };
            let accountXpub = "";
            let accountPath = [];
            for(let i = 0; i < inputCount; i++){
                progress();
                const pathElems = (0, _bip32.pathStringToArray)(arg.associatedKeysets[i]);
                if (accountXpub == "") {
                    // We assume all inputs belong to the same account so we set
                    // the account xpub and path based on the first input.
                    accountPath = pathElems.slice(0, -2);
                    accountXpub = yield this.client.getExtendedPubkey(false, accountPath);
                }
                yield this.setInput(psbt, i, arg.inputs[i], pathElems, accountType, masterFp, arg.sigHashType);
            }
            const outputsConcat = Buffer.from(arg.outputScriptHex, "hex");
            const outputsBufferReader = new (0, _buffertools.BufferReader)(outputsConcat);
            const outputCount = outputsBufferReader.readVarInt();
            psbt.setGlobalOutputCount(outputCount);
            const changeData = yield this.outputScriptAt(accountPath, accountType, arg.changePath);
            // If the caller supplied a changePath, we must make sure there actually is
            // a change output. If no change output found, we'll throw an error.
            let changeFound = !changeData;
            for(let i = 0; i < outputCount; i++){
                const amount = Number(outputsBufferReader.readUInt64());
                const outputScript = outputsBufferReader.readVarSlice();
                psbt.setOutputAmount(i, amount);
                psbt.setOutputScript(i, outputScript);
                // We won't know if we're paying to ourselves, because there's no
                // information in arg to support multiple "change paths". One exception is
                // if there are multiple outputs to the change address.
                const isChange = changeData && outputScript.equals(changeData === null || changeData === void 0 ? void 0 : changeData.cond.scriptPubKey);
                if (isChange) {
                    changeFound = true;
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const changePath = (0, _bip32.pathStringToArray)(arg.changePath);
                    const pubkey = changeData.pubkey;
                    accountType.setOwnOutput(i, changeData.cond, [
                        pubkey
                    ], [
                        changePath
                    ]);
                }
            }
            if (!changeFound) throw new Error("Change script not found among outputs! " + (changeData === null || changeData === void 0 ? void 0 : changeData.cond.scriptPubKey.toString("hex")));
            const key = (0, _policy.createKey)(masterFp, accountPath, accountXpub);
            const p = new (0, _policy.WalletPolicy)(accountType.getDescriptorTemplate(), key);
            // This is cheating, because it's not actually requested on the
            // device yet, but it will be, soonish.
            if (arg.onDeviceSignatureRequested) arg.onDeviceSignatureRequested();
            let firstSigned = false;
            // This callback will be called once for each signature yielded.
            const progressCallback = ()=>{
                if (!firstSigned) {
                    firstSigned = true;
                    arg.onDeviceSignatureGranted && arg.onDeviceSignatureGranted();
                }
                progress();
            };
            yield this.signPsbt(psbt, p, progressCallback);
            (0, _psbtFinalizer.finalize)(psbt);
            const serializedTx = (0, _psbtExtractor.extract)(psbt);
            return serializedTx.toString("hex");
        });
    }
    /**
     * Signs an arbitrary hex-formatted message with the private key at
     * the provided derivation path according to the Bitcoin Signature format
     * and returns v, r, s.
     */ signMessage(_a) {
        return __awaiter(this, arguments, void 0, function*({ path, messageHex }) {
            const pathElements = (0, _bip32.pathStringToArray)(path);
            const message = Buffer.from(messageHex, "hex");
            const sig = yield this.client.signMessage(message, pathElements);
            const buf = Buffer.from(sig, "base64");
            const v = buf.readUInt8() - 27 - 4;
            const r = buf.slice(1, 33).toString("hex");
            const s = buf.slice(33, 65).toString("hex");
            return {
                v,
                r,
                s
            };
        });
    }
    /**
     * Calculates an output script along with public key and possible redeemScript
     * from a path and accountType. The accountPath must be a prefix of path.
     *
     * @returns an object with output script (property "script"), redeemScript (if
     * wrapped p2wpkh), and pubkey at provided path. The values of these three
     * properties depend on the accountType used.
     */ outputScriptAt(accountPath, accountType, path) {
        return __awaiter(this, void 0, void 0, function*() {
            if (!path) return undefined;
            const pathElems = (0, _bip32.pathStringToArray)(path);
            // Make sure path is in our account, otherwise something fishy is probably
            // going on.
            for(let i = 0; i < accountPath.length; i++){
                if (accountPath[i] != pathElems[i]) throw new Error(`Path ${path} not in account ${(0, _bip32.pathArrayToString)(accountPath)}`);
            }
            const xpub = yield this.client.getExtendedPubkey(false, pathElems);
            const pubkey = (0, _bip32.pubkeyFromXpub)(xpub);
            const cond = accountType.spendingCondition([
                pubkey
            ]);
            return {
                cond,
                pubkey
            };
        });
    }
    /**
     * Adds relevant data about an input to the psbt. This includes sequence,
     * previous txid, output index, spent UTXO, redeem script for wrapped p2wpkh,
     * public key and its derivation path.
     */ setInput(psbt, i, input, pathElements, accountType, masterFP, sigHashType) {
        return __awaiter(this, void 0, void 0, function*() {
            const inputTx = input[0];
            const spentOutputIndex = input[1];
            // redeemScript will be null for wrapped p2wpkh, we need to create it
            // ourselves. But if set, it should be used.
            const redeemScript = input[2] ? Buffer.from(input[2], "hex") : undefined;
            const sequence = input[3];
            if (sequence != undefined) psbt.setInputSequence(i, sequence);
            if (sigHashType != undefined) psbt.setInputSighashType(i, sigHashType);
            const inputTxBuffer = (0, _serializeTransaction.serializeTransaction)(inputTx, true);
            const inputTxid = (0, _bitcoinjsLib.crypto).hash256(inputTxBuffer);
            const xpubBase58 = yield this.client.getExtendedPubkey(false, pathElements);
            const pubkey = (0, _bip32.pubkeyFromXpub)(xpubBase58);
            if (!inputTx.outputs) throw Error("Missing outputs array in transaction to sign");
            const spentTxOutput = inputTx.outputs[spentOutputIndex];
            const spendCondition = {
                scriptPubKey: spentTxOutput.script,
                redeemScript: redeemScript
            };
            const spentOutput = {
                cond: spendCondition,
                amount: spentTxOutput.amount
            };
            accountType.setInput(i, inputTxBuffer, spentOutput, [
                pubkey
            ], [
                pathElements
            ]);
            psbt.setInputPreviousTxId(i, inputTxid);
            psbt.setInputOutputIndex(i, spentOutputIndex);
        });
    }
    /**
     * This implements the "Signer" role of the BIP370 transaction signing
     * process.
     *
     * It ssks the hardware device to sign the a psbt using the specified wallet
     * policy. This method assumes BIP32 derived keys are used for all inputs, see
     * comment in-line. The signatures returned from the hardware device is added
     * to the appropriate input fields of the PSBT.
     */ signPsbt(psbt, walletPolicy, progressCallback) {
        return __awaiter(this, void 0, void 0, function*() {
            const sigs = yield this.client.signPsbt(psbt, walletPolicy, Buffer.alloc(32, 0), progressCallback);
            sigs.forEach((v, k)=>{
                // Note: Looking at BIP32 derivation does not work in the generic case,
                // since some inputs might not have a BIP32-derived pubkey.
                const pubkeys = psbt.getInputKeyDatas(k, (0, _psbtv2.psbtIn).BIP32_DERIVATION);
                let pubkey;
                if (pubkeys.length != 1) {
                    // No legacy BIP32_DERIVATION, assume we're using taproot.
                    pubkey = psbt.getInputKeyDatas(k, (0, _psbtv2.psbtIn).TAP_BIP32_DERIVATION);
                    if (pubkey.length == 0) throw Error(`Missing pubkey derivation for input ${k}`);
                    psbt.setInputTapKeySig(k, v);
                } else {
                    pubkey = pubkeys[0];
                    psbt.setInputPartialSig(k, pubkey, v);
                }
            });
        });
    }
}
exports.default = BtcNew;
/**
 * This function returns a descriptor template based on the address format.
 * See https://github.com/LedgerHQ/app-bitcoin-new/blob/develop/doc/wallet.md for details of
 * the bitcoin descriptor template.
 */ function descrTemplFrom(addressFormat) {
    if (addressFormat == "legacy") return "pkh(@0)";
    if (addressFormat == "p2sh") return "sh(wpkh(@0))";
    if (addressFormat == "bech32") return "wpkh(@0)";
    if (addressFormat == "bech32m") return "tr(@0)";
    throw new Error("Unsupported address format " + addressFormat);
}
function accountTypeFromArg(arg, psbt, masterFp) {
    if (arg.additionals.includes("bech32m")) return new (0, _accounttype.p2tr)(psbt, masterFp);
    if (arg.additionals.includes("bech32")) return new (0, _accounttype.p2wpkh)(psbt, masterFp);
    if (arg.segwit) return new (0, _accounttype.p2wpkhWrapped)(psbt, masterFp);
    return new (0, _accounttype.p2pkh)(psbt, masterFp);
}
/*
  The new protocol only allows standard path.
  Standard paths are (currently):
  M/44'/(1|0|88)'/X'
  M/49'/(1|0|88)'/X'
  M/84'/(1|0|88)'/X'
  M/86'/(1|0|88)'/X'
  M/48'/(1|0|88)'/X'/Y'
  followed by "", "(0|1)", or "(0|1)/b", where a and b are
  non-hardened. For example, the following paths are standard
  M/48'/1'/99'/7'
  M/86'/1'/99'/0
  M/48'/0'/99'/7'/1/17
  The following paths are non-standard
  M/48'/0'/99'           // Not deepest hardened path
  M/48'/0'/99'/7'/1/17/2 // Too many non-hardened derivation steps
  M/199'/0'/1'/0/88      // Not a known purpose 199
  M/86'/1'/99'/2         // Change path item must be 0 or 1

  Useful resource on derivation paths: https://learnmeabitcoin.com/technical/derivation-paths
*/ //path is not deepest hardened node of a standard path or deeper, use BtcOld
const H = 0x80000000; //HARDENED from bip32
const VALID_COIN_TYPES = [
    0,
    1,
    88
];
const VALID_SINGLE_SIG_PURPOSES = [
    44,
    49,
    84,
    86
];
const VALID_MULTISIG_PURPOSES = [
    48
];
const hard = (n)=>n >= H;
const soft = (n)=>n === undefined || n < H;
const change = (n)=>n === undefined || n === 0 || n === 1;
const validCoinPathPartsSet = new Set(VALID_COIN_TYPES.map((t)=>t + H));
const validSingleSigPurposePathPartsSet = new Set(VALID_SINGLE_SIG_PURPOSES.map((t)=>t + H));
const validMultiSigPurposePathPartsSet = new Set(VALID_MULTISIG_PURPOSES.map((t)=>t + H));
function isPathNormal(path) {
    const pathElems = (0, _bip32.pathStringToArray)(path);
    // Single sig
    if (pathElems.length >= 3 && pathElems.length <= 5 && validSingleSigPurposePathPartsSet.has(pathElems[0]) && validCoinPathPartsSet.has(pathElems[1]) && hard(pathElems[2]) && change(pathElems[3]) && soft(pathElems[4])) return true;
    // Multi sig
    if (pathElems.length >= 4 && pathElems.length <= 6 && validMultiSigPurposePathPartsSet.has(pathElems[0]) && validCoinPathPartsSet.has(pathElems[1]) && hard(pathElems[2]) && hard(pathElems[3]) && change(pathElems[4]) && soft(pathElems[5])) return true;
    return false;
}

},{"4f9d6f069b552aa3":"bwvMq","bitcoinjs-lib":"cl7fJ","tiny-secp256k1":"aaqVm","./bip32":"hSMer","./buffertools":"fvT7D","./newops/accounttype":"iMehs","./newops/policy":"jcnpd","./newops/psbtExtractor":"468CX","./newops/psbtFinalizer":"82GTK","./newops/psbtv2":"hOmf5","./serializeTransaction":"c5bE0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bwvMq":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
var base64 = require("c0c4ccd62345e942");
var ieee754 = require("17af44d17d72d12");
var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) Buffer.from(buf).copy(buffer, pos);
            else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(var i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(var i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(var i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = "";
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    var loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = "";
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = "";
    for(var i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(var i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();

},{"c0c4ccd62345e942":"RRIdj","17af44d17d72d12":"dB87t"}],"RRIdj":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"dB87t":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"cl7fJ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bip32 = require("68c4041ff43785c3");
exports.bip32 = bip32;
const address = require("5643100429fa5d74");
exports.address = address;
const crypto = require("790c4706ffe25527");
exports.crypto = crypto;
const ECPair = require("6d4b8e62b09e08b8");
exports.ECPair = ECPair;
const networks = require("fa51fa857ffe212b");
exports.networks = networks;
const payments = require("43bcb140f2c17c1");
exports.payments = payments;
const script = require("d287e37abbb1c4b0");
exports.script = script;
var block_1 = require("4d774d5b9486e7e7");
exports.Block = block_1.Block;
var psbt_1 = require("d4f805da50a40f81");
exports.Psbt = psbt_1.Psbt;
var script_1 = require("d287e37abbb1c4b0");
exports.opcodes = script_1.OPS;
var transaction_1 = require("f703c4ccf6feb539");
exports.Transaction = transaction_1.Transaction;
var transaction_builder_1 = require("4a03df80f5855069");
exports.TransactionBuilder = transaction_builder_1.TransactionBuilder;

},{"68c4041ff43785c3":"4aFrZ","5643100429fa5d74":"2Me89","790c4706ffe25527":"4BCCF","6d4b8e62b09e08b8":"aiXsq","fa51fa857ffe212b":"hpO0s","43bcb140f2c17c1":"g5Tn6","d287e37abbb1c4b0":"28LFb","4d774d5b9486e7e7":"aVKx9","d4f805da50a40f81":"90Km1","f703c4ccf6feb539":"arhmj","4a03df80f5855069":"ivOLs"}],"4aFrZ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var bip32_1 = require("5ccd265ceb18923c");
exports.fromSeed = bip32_1.fromSeed;
exports.fromBase58 = bip32_1.fromBase58;
exports.fromPublicKey = bip32_1.fromPublicKey;
exports.fromPrivateKey = bip32_1.fromPrivateKey;

},{"5ccd265ceb18923c":"4Z8HE"}],"4Z8HE":[function(require,module,exports) {
var Buffer = require("42e5d43ee9aee513").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const crypto = require("95952e8f0adda786");
const bs58check = require("5bdc33e3f4886ee4");
const ecc = require("94a4dbaa640b1aa9");
const typeforce = require("9a19d0b6b447724e");
const wif = require("8f23340f049c623e");
const UINT256_TYPE = typeforce.BufferN(32);
const NETWORK_TYPE = typeforce.compile({
    wif: typeforce.UInt8,
    bip32: {
        public: typeforce.UInt32,
        private: typeforce.UInt32
    }
});
const BITCOIN = {
    messagePrefix: "\x18Bitcoin Signed Message:\n",
    bech32: "bc",
    bip32: {
        public: 0x0488b21e,
        private: 0x0488ade4
    },
    pubKeyHash: 0x00,
    scriptHash: 0x05,
    wif: 0x80
};
const HIGHEST_BIT = 0x80000000;
const UINT31_MAX = Math.pow(2, 31) - 1;
function BIP32Path(value) {
    return typeforce.String(value) && value.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null;
}
function UInt31(value) {
    return typeforce.UInt32(value) && value <= UINT31_MAX;
}
class BIP32 {
    constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000){
        this.__D = __D;
        this.__Q = __Q;
        this.chainCode = chainCode;
        this.network = network;
        this.__DEPTH = __DEPTH;
        this.__INDEX = __INDEX;
        this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
        typeforce(NETWORK_TYPE, network);
        this.lowR = false;
    }
    get depth() {
        return this.__DEPTH;
    }
    get index() {
        return this.__INDEX;
    }
    get parentFingerprint() {
        return this.__PARENT_FINGERPRINT;
    }
    get publicKey() {
        if (this.__Q === undefined) this.__Q = ecc.pointFromScalar(this.__D, true);
        return this.__Q;
    }
    get privateKey() {
        return this.__D;
    }
    get identifier() {
        return crypto.hash160(this.publicKey);
    }
    get fingerprint() {
        return this.identifier.slice(0, 4);
    }
    get compressed() {
        return true;
    }
    // Private === not neutered
    // Public === neutered
    isNeutered() {
        return this.__D === undefined;
    }
    neutered() {
        return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
    }
    toBase58() {
        const network = this.network;
        const version = !this.isNeutered() ? network.bip32.private : network.bip32.public;
        const buffer = Buffer.allocUnsafe(78);
        // 4 bytes: version bytes
        buffer.writeUInt32BE(version, 0);
        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....
        buffer.writeUInt8(this.depth, 4);
        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
        buffer.writeUInt32BE(this.parentFingerprint, 5);
        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
        // This is encoded in big endian. (0x00000000 if master key)
        buffer.writeUInt32BE(this.index, 9);
        // 32 bytes: the chain code
        this.chainCode.copy(buffer, 13);
        // 33 bytes: the public key or private key data
        if (!this.isNeutered()) {
            // 0x00 + k for private keys
            buffer.writeUInt8(0, 45);
            this.privateKey.copy(buffer, 46);
        // 33 bytes: the public key
        } else // X9.62 encoding for public keys
        this.publicKey.copy(buffer, 45);
        return bs58check.encode(buffer);
    }
    toWIF() {
        if (!this.privateKey) throw new TypeError("Missing private key");
        return wif.encode(this.network.wif, this.privateKey, true);
    }
    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
    derive(index) {
        typeforce(typeforce.UInt32, index);
        const isHardened = index >= HIGHEST_BIT;
        const data = Buffer.allocUnsafe(37);
        // Hardened child
        if (isHardened) {
            if (this.isNeutered()) throw new TypeError("Missing private key for hardened child key");
            // data = 0x00 || ser256(kpar) || ser32(index)
            data[0] = 0x00;
            this.privateKey.copy(data, 1);
            data.writeUInt32BE(index, 33);
        // Normal child
        } else {
            // data = serP(point(kpar)) || ser32(index)
            //      = serP(Kpar) || ser32(index)
            this.publicKey.copy(data, 0);
            data.writeUInt32BE(index, 33);
        }
        const I = crypto.hmacSHA512(this.chainCode, data);
        const IL = I.slice(0, 32);
        const IR = I.slice(32);
        // if parse256(IL) >= n, proceed with the next value for i
        if (!ecc.isPrivate(IL)) return this.derive(index + 1);
        // Private parent key -> private child key
        let hd;
        if (!this.isNeutered()) {
            // ki = parse256(IL) + kpar (mod n)
            const ki = ecc.privateAdd(this.privateKey, IL);
            // In case ki == 0, proceed with the next value for i
            if (ki == null) return this.derive(index + 1);
            hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
        // Public parent key -> public child key
        } else {
            // Ki = point(parse256(IL)) + Kpar
            //    = G*IL + Kpar
            const Ki = ecc.pointAddScalar(this.publicKey, IL, true);
            // In case Ki is the point at infinity, proceed with the next value for i
            if (Ki === null) return this.derive(index + 1);
            hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
        }
        return hd;
    }
    deriveHardened(index) {
        typeforce(UInt31, index);
        // Only derives hardened private keys by default
        return this.derive(index + HIGHEST_BIT);
    }
    derivePath(path) {
        typeforce(BIP32Path, path);
        let splitPath = path.split("/");
        if (splitPath[0] === "m") {
            if (this.parentFingerprint) throw new TypeError("Expected master, got child");
            splitPath = splitPath.slice(1);
        }
        return splitPath.reduce((prevHd, indexStr)=>{
            let index;
            if (indexStr.slice(-1) === `'`) {
                index = parseInt(indexStr.slice(0, -1), 10);
                return prevHd.deriveHardened(index);
            } else {
                index = parseInt(indexStr, 10);
                return prevHd.derive(index);
            }
        }, this);
    }
    sign(hash, lowR) {
        if (!this.privateKey) throw new Error("Missing private key");
        if (lowR === undefined) lowR = this.lowR;
        if (lowR === false) return ecc.sign(hash, this.privateKey);
        else {
            let sig = ecc.sign(hash, this.privateKey);
            const extraData = Buffer.alloc(32, 0);
            let counter = 0;
            // if first try is lowR, skip the loop
            // for second try and on, add extra entropy counting up
            while(sig[0] > 0x7f){
                counter++;
                extraData.writeUIntLE(counter, 0, 6);
                sig = ecc.signWithEntropy(hash, this.privateKey, extraData);
            }
            return sig;
        }
    }
    verify(hash, signature) {
        return ecc.verify(hash, this.publicKey, signature);
    }
}
function fromBase58(inString, network) {
    const buffer = bs58check.decode(inString);
    if (buffer.length !== 78) throw new TypeError("Invalid buffer length");
    network = network || BITCOIN;
    // 4 bytes: version bytes
    const version = buffer.readUInt32BE(0);
    if (version !== network.bip32.private && version !== network.bip32.public) throw new TypeError("Invalid network version");
    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...
    const depth = buffer[4];
    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
    const parentFingerprint = buffer.readUInt32BE(5);
    if (depth === 0) {
        if (parentFingerprint !== 0x00000000) throw new TypeError("Invalid parent fingerprint");
    }
    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
    // This is encoded in MSB order. (0x00000000 if master key)
    const index = buffer.readUInt32BE(9);
    if (depth === 0 && index !== 0) throw new TypeError("Invalid index");
    // 32 bytes: the chain code
    const chainCode = buffer.slice(13, 45);
    let hd;
    // 33 bytes: private key data (0x00 + k)
    if (version === network.bip32.private) {
        if (buffer.readUInt8(45) !== 0x00) throw new TypeError("Invalid private key");
        const k = buffer.slice(46, 78);
        hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);
    // 33 bytes: public key data (0x02 + X or 0x03 + X)
    } else {
        const X = buffer.slice(45, 78);
        hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);
    }
    return hd;
}
exports.fromBase58 = fromBase58;
function fromPrivateKey(privateKey, chainCode, network) {
    return fromPrivateKeyLocal(privateKey, chainCode, network);
}
exports.fromPrivateKey = fromPrivateKey;
function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
    typeforce({
        privateKey: UINT256_TYPE,
        chainCode: UINT256_TYPE
    }, {
        privateKey,
        chainCode
    });
    network = network || BITCOIN;
    if (!ecc.isPrivate(privateKey)) throw new TypeError("Private key not in range [1, n)");
    return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);
}
function fromPublicKey(publicKey, chainCode, network) {
    return fromPublicKeyLocal(publicKey, chainCode, network);
}
exports.fromPublicKey = fromPublicKey;
function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
    typeforce({
        publicKey: typeforce.BufferN(33),
        chainCode: UINT256_TYPE
    }, {
        publicKey,
        chainCode
    });
    network = network || BITCOIN;
    // verify the X coordinate is a point on the curve
    if (!ecc.isPoint(publicKey)) throw new TypeError("Point is not on the curve");
    return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);
}
function fromSeed(seed, network) {
    typeforce(typeforce.Buffer, seed);
    if (seed.length < 16) throw new TypeError("Seed should be at least 128 bits");
    if (seed.length > 64) throw new TypeError("Seed should be at most 512 bits");
    network = network || BITCOIN;
    const I = crypto.hmacSHA512(Buffer.from("Bitcoin seed", "utf8"), seed);
    const IL = I.slice(0, 32);
    const IR = I.slice(32);
    return fromPrivateKey(IL, IR, network);
}
exports.fromSeed = fromSeed;

},{"42e5d43ee9aee513":"bwvMq","95952e8f0adda786":"26Ger","5bdc33e3f4886ee4":"d8uT8","94a4dbaa640b1aa9":"aaqVm","9a19d0b6b447724e":"86sQP","8f23340f049c623e":"89Dvm"}],"26Ger":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const createHash = require("69b69ffd566a471c");
const createHmac = require("88643b13ac035bf2");
function hash160(buffer) {
    const sha256Hash = createHash("sha256").update(buffer).digest();
    try {
        return createHash("rmd160").update(sha256Hash).digest();
    } catch (err) {
        return createHash("ripemd160").update(sha256Hash).digest();
    }
}
exports.hash160 = hash160;
function hmacSHA512(key, data) {
    return createHmac("sha512", key).update(data).digest();
}
exports.hmacSHA512 = hmacSHA512;

},{"69b69ffd566a471c":"2WyL8","88643b13ac035bf2":"k1utz"}],"2WyL8":[function(require,module,exports) {
"use strict";
var inherits = require("45ce174cec337471");
var MD5 = require("4170b0039f3b4aab");
var RIPEMD160 = require("efcc6ede1fda4d98");
var sha = require("65b1a51ddac82548");
var Base = require("ac5a46c0f3b4d769");
function Hash(hash) {
    Base.call(this, "digest");
    this._hash = hash;
}
inherits(Hash, Base);
Hash.prototype._update = function(data) {
    this._hash.update(data);
};
Hash.prototype._final = function() {
    return this._hash.digest();
};
module.exports = function createHash(alg) {
    alg = alg.toLowerCase();
    if (alg === "md5") return new MD5();
    if (alg === "rmd160" || alg === "ripemd160") return new RIPEMD160();
    return new Hash(sha(alg));
};

},{"45ce174cec337471":"bRL3M","4170b0039f3b4aab":"45VeE","efcc6ede1fda4d98":"bFDDq","65b1a51ddac82548":"jkn7m","ac5a46c0f3b4d769":"g5fTz"}],"bRL3M":[function(require,module,exports) {
if (typeof Object.create === "function") // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

},{}],"45VeE":[function(require,module,exports) {
"use strict";
var inherits = require("634114d48656c754");
var HashBase = require("4b170874b4cb8d4e");
var Buffer = require("72d4e45c6a42a2da").Buffer;
var ARRAY16 = new Array(16);
function MD5() {
    HashBase.call(this, 64);
    // state
    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
}
inherits(MD5, HashBase);
MD5.prototype._update = function() {
    var M = ARRAY16;
    for(var i = 0; i < 16; ++i)M[i] = this._block.readInt32LE(i * 4);
    var a = this._a;
    var b = this._b;
    var c = this._c;
    var d = this._d;
    a = fnF(a, b, c, d, M[0], 0xd76aa478, 7);
    d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12);
    c = fnF(c, d, a, b, M[2], 0x242070db, 17);
    b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22);
    a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7);
    d = fnF(d, a, b, c, M[5], 0x4787c62a, 12);
    c = fnF(c, d, a, b, M[6], 0xa8304613, 17);
    b = fnF(b, c, d, a, M[7], 0xfd469501, 22);
    a = fnF(a, b, c, d, M[8], 0x698098d8, 7);
    d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12);
    c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17);
    b = fnF(b, c, d, a, M[11], 0x895cd7be, 22);
    a = fnF(a, b, c, d, M[12], 0x6b901122, 7);
    d = fnF(d, a, b, c, M[13], 0xfd987193, 12);
    c = fnF(c, d, a, b, M[14], 0xa679438e, 17);
    b = fnF(b, c, d, a, M[15], 0x49b40821, 22);
    a = fnG(a, b, c, d, M[1], 0xf61e2562, 5);
    d = fnG(d, a, b, c, M[6], 0xc040b340, 9);
    c = fnG(c, d, a, b, M[11], 0x265e5a51, 14);
    b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20);
    a = fnG(a, b, c, d, M[5], 0xd62f105d, 5);
    d = fnG(d, a, b, c, M[10], 0x02441453, 9);
    c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14);
    b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20);
    a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5);
    d = fnG(d, a, b, c, M[14], 0xc33707d6, 9);
    c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14);
    b = fnG(b, c, d, a, M[8], 0x455a14ed, 20);
    a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5);
    d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9);
    c = fnG(c, d, a, b, M[7], 0x676f02d9, 14);
    b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20);
    a = fnH(a, b, c, d, M[5], 0xfffa3942, 4);
    d = fnH(d, a, b, c, M[8], 0x8771f681, 11);
    c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16);
    b = fnH(b, c, d, a, M[14], 0xfde5380c, 23);
    a = fnH(a, b, c, d, M[1], 0xa4beea44, 4);
    d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11);
    c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16);
    b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23);
    a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4);
    d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11);
    c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16);
    b = fnH(b, c, d, a, M[6], 0x04881d05, 23);
    a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4);
    d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11);
    c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16);
    b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23);
    a = fnI(a, b, c, d, M[0], 0xf4292244, 6);
    d = fnI(d, a, b, c, M[7], 0x432aff97, 10);
    c = fnI(c, d, a, b, M[14], 0xab9423a7, 15);
    b = fnI(b, c, d, a, M[5], 0xfc93a039, 21);
    a = fnI(a, b, c, d, M[12], 0x655b59c3, 6);
    d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10);
    c = fnI(c, d, a, b, M[10], 0xffeff47d, 15);
    b = fnI(b, c, d, a, M[1], 0x85845dd1, 21);
    a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6);
    d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10);
    c = fnI(c, d, a, b, M[6], 0xa3014314, 15);
    b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21);
    a = fnI(a, b, c, d, M[4], 0xf7537e82, 6);
    d = fnI(d, a, b, c, M[11], 0xbd3af235, 10);
    c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15);
    b = fnI(b, c, d, a, M[9], 0xeb86d391, 21);
    this._a = this._a + a | 0;
    this._b = this._b + b | 0;
    this._c = this._c + c | 0;
    this._d = this._d + d | 0;
};
MD5.prototype._digest = function() {
    // create padding and handle blocks
    this._block[this._blockOffset++] = 0x80;
    if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
    }
    this._block.fill(0, this._blockOffset, 56);
    this._block.writeUInt32LE(this._length[0], 56);
    this._block.writeUInt32LE(this._length[1], 60);
    this._update();
    // produce result
    var buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32LE(this._a, 0);
    buffer.writeInt32LE(this._b, 4);
    buffer.writeInt32LE(this._c, 8);
    buffer.writeInt32LE(this._d, 12);
    return buffer;
};
function rotl(x, n) {
    return x << n | x >>> 32 - n;
}
function fnF(a, b, c, d, m, k, s) {
    return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
}
function fnG(a, b, c, d, m, k, s) {
    return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
}
function fnH(a, b, c, d, m, k, s) {
    return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
}
function fnI(a, b, c, d, m, k, s) {
    return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
}
module.exports = MD5;

},{"634114d48656c754":"bRL3M","4b170874b4cb8d4e":"51qBP","72d4e45c6a42a2da":"eW7r9"}],"51qBP":[function(require,module,exports) {
"use strict";
var Buffer = require("27eaec8a721206a5").Buffer;
var Transform = require("c5aab47d8f1d340a").Transform;
var inherits = require("91e9fa68d440541e");
function throwIfNotStringOrBuffer(val, prefix) {
    if (!Buffer.isBuffer(val) && typeof val !== "string") throw new TypeError(prefix + " must be a string or a buffer");
}
function HashBase(blockSize) {
    Transform.call(this);
    this._block = Buffer.allocUnsafe(blockSize);
    this._blockSize = blockSize;
    this._blockOffset = 0;
    this._length = [
        0,
        0,
        0,
        0
    ];
    this._finalized = false;
}
inherits(HashBase, Transform);
HashBase.prototype._transform = function(chunk, encoding, callback) {
    var error = null;
    try {
        this.update(chunk, encoding);
    } catch (err) {
        error = err;
    }
    callback(error);
};
HashBase.prototype._flush = function(callback) {
    var error = null;
    try {
        this.push(this.digest());
    } catch (err) {
        error = err;
    }
    callback(error);
};
HashBase.prototype.update = function(data, encoding) {
    throwIfNotStringOrBuffer(data, "Data");
    if (this._finalized) throw new Error("Digest already called");
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding);
    // consume data
    var block = this._block;
    var offset = 0;
    while(this._blockOffset + data.length - offset >= this._blockSize){
        for(var i = this._blockOffset; i < this._blockSize;)block[i++] = data[offset++];
        this._update();
        this._blockOffset = 0;
    }
    while(offset < data.length)block[this._blockOffset++] = data[offset++];
    // update length
    for(var j = 0, carry = data.length * 8; carry > 0; ++j){
        this._length[j] += carry;
        carry = this._length[j] / 0x0100000000 | 0;
        if (carry > 0) this._length[j] -= 0x0100000000 * carry;
    }
    return this;
};
HashBase.prototype._update = function() {
    throw new Error("_update is not implemented");
};
HashBase.prototype.digest = function(encoding) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = true;
    var digest = this._digest();
    if (encoding !== undefined) digest = digest.toString(encoding);
    // reset state
    this._block.fill(0);
    this._blockOffset = 0;
    for(var i = 0; i < 4; ++i)this._length[i] = 0;
    return digest;
};
HashBase.prototype._digest = function() {
    throw new Error("_digest is not implemented");
};
module.exports = HashBase;

},{"27eaec8a721206a5":"eW7r9","c5aab47d8f1d340a":"jXNWE","91e9fa68d440541e":"bRL3M"}],"eW7r9":[function(require,module,exports) {
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = require("7e0d6ecd698c3ca6");
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src)dst[key] = src[key];
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) module.exports = buffer;
else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") throw new TypeError("Argument must not be a number");
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === "string") buf.fill(fill, encoding);
        else buf.fill(fill);
    } else buf.fill(0);
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return buffer.SlowBuffer(size);
};

},{"7e0d6ecd698c3ca6":"bwvMq"}],"jXNWE":[function(require,module,exports) {
exports = module.exports = require("68bb3bdae87803ec");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require("74167f79b688eaf7");
exports.Duplex = require("84600f6783428a47");
exports.Transform = require("23bee5f697448a0");
exports.PassThrough = require("e0ec4b8e438dbbd");
exports.finished = require("6cc0f9af7147cdbc");
exports.pipeline = require("f90db22d01d3c3d1");

},{"68bb3bdae87803ec":"6NdbQ","74167f79b688eaf7":"gTkcq","84600f6783428a47":"kKNA3","23bee5f697448a0":"ba8Mr","e0ec4b8e438dbbd":"2xP98","6cc0f9af7147cdbc":"aOMy2","f90db22d01d3c3d1":"fyp4t"}],"6NdbQ":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var global = arguments[3];
var process = require("896ff8d56553f7a");
"use strict";
module.exports = Readable;
/*<replacement>*/ var Duplex;
/*</replacement>*/ Readable.ReadableState = ReadableState;
/*<replacement>*/ var EE = require("16782d660ac22e0c").EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
};
/*</replacement>*/ /*<replacement>*/ var Stream = require("9a34f23fa53f83f7");
/*</replacement>*/ var Buffer = require("fb95ecaa88342eae").Buffer;
var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/ var debugUtil = require("a4a723b7297c7152");
var debug;
if (debugUtil && debugUtil.debuglog) debug = debugUtil.debuglog("stream");
else debug = function debug() {};
/*</replacement>*/ var BufferList = require("7a14cc1689b8c63e");
var destroyImpl = require("efa8155386cc4283");
var _require = require("994c984d08c7bbf2"), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require("8de60461b822641b").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
require("19affa8ce41f090d")(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = [
    "error",
    "close",
    "destroy",
    "pause",
    "resume"
];
function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}
function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require("f1c95f846e94e4eb");
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true;
    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'end' (and potentially 'finish')
    this.autoDestroy = !!options.autoDestroy;
    // has it been destroyed
    this.destroyed = false;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;
    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!StringDecoder) StringDecoder = require("6392acd10886f115").StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    Duplex = Duplex || require("f1c95f846e94e4eb");
    if (!(this instanceof Readable)) return new Readable(options);
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
}
Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined) return false;
        return this._readableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
    cb(err);
};
// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = "";
            }
            skipChunkCheck = true;
        }
    } else skipChunkCheck = true;
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};
// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) errorOrDestroy(stream, er);
        else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) chunk = _uint8ArrayToBuffer(chunk);
            if (addToFront) {
                if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                else addChunk(stream, state, chunk, true);
            } else if (state.ended) errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            else if (state.destroyed) return false;
            else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                    else maybeReadMore(stream, state);
                } else addChunk(stream, state, chunk, false);
            }
        } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
        }
    }
    // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) er = new ERR_INVALID_ARG_TYPE("chunk", [
        "string",
        "Buffer",
        "Uint8Array"
    ], chunk);
    return er;
}
Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
};
// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = require("6392acd10886f115").StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    // If setEncoding(null), decoder.encoding equals utf8
    this._readableState.encoding = this._readableState.decoder.encoding;
    // Iterate over current buffer to convert already stored Buffers:
    var p = this._readableState.buffer.head;
    var content = "";
    while(p !== null){
        content += decoder.write(p.data);
        p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
};
// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
    else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
}
// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false;
    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
    }
    n = howMuchToRead(n, state);
    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
    }
    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug("need readable", doRead);
    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
    } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        state.awaitDrain = 0;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;
        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
};
function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
    else {
        // emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;
        if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
        }
    }
}
// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
    }
    // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
}
// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) break;
    }
    state.readingMore = false;
}
// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        // cleanup event handlers once the pipe is broken
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug("false write response, pause", state.awaitDrain);
                state.awaitDrain++;
            }
            src.pause();
        }
    }
    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    // Make sure our error handler is attached before userland ones.
    prependListener(dest, "error", onerror);
    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    // tell the dest that it's being piped to
    dest.emit("pipe", src);
    // start the flow if it hasn't been started already.
    if (!state.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    };
    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;
    // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
    }
    // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++)dests[i].emit("unpipe", this, {
            hasUnpiped: false
        });
        return this;
    }
    // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
        // update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount("readable") > 0;
        // Try start flowing on next tick if stream isn't explicitly paused
        if (state.flowing !== false) this.resume();
    } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) emitReadable(this);
            else if (!state.reading) process.nextTick(nReadingNextTick, this);
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
    return res;
};
Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
    return res;
};
function updateReadableListening(self1) {
    var state = self1._readableState;
    state.readableListening = self1.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;
    else if (self1.listenerCount("data") > 0) self1.resume();
}
function nReadingNextTick(self1) {
    debug("readable nexttick read 0");
    self1.read(0);
}
// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        debug("resume");
        // we flow only if there is no one listening
        // for readable, but we still have to call
        // resume()
        state.flowing = !state.readableListening;
        resume(this, state);
    }
    state.paused = false;
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) stream.read(0);
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
};
function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null);
}
// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    });
    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream)if (this[i] === undefined && typeof stream[i] === "function") this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
        };
    }(i);
    // proxy certain important events.
    for(var n = 0; n < kProxyEvents.length; n++)stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};
if (typeof Symbol === "function") Readable.prototype[Symbol.asyncIterator] = function() {
    if (createReadableStreamAsyncIterator === undefined) createReadableStreamAsyncIterator = require("830c56f840811f05");
    return createReadableStreamAsyncIterator(this);
};
Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.highWaterMark;
    }
});
Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState && this._readableState.buffer;
    }
});
Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.flowing;
    },
    set: function set(state) {
        if (this._readableState) this._readableState.flowing = state;
    }
});
// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.length;
    }
});
// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else // read part of list
    ret = state.buffer.consume(n, state.decoder);
    return ret;
}
function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the writable side is ready for autoDestroy as well
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) stream.destroy();
        }
    }
}
if (typeof Symbol === "function") Readable.from = function(iterable, opts) {
    if (from === undefined) from = require("7451b8c4bf72370");
    return from(Readable, iterable, opts);
};
function indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}

},{"896ff8d56553f7a":"d5jf4","16782d660ac22e0c":"1VQLm","9a34f23fa53f83f7":"60BLS","fb95ecaa88342eae":"bwvMq","a4a723b7297c7152":"jhUEF","7a14cc1689b8c63e":"hf3P2","efa8155386cc4283":"YI8DF","994c984d08c7bbf2":"61BRN","8de60461b822641b":"aJlwj","19affa8ce41f090d":"bRL3M","f1c95f846e94e4eb":"kKNA3","6392acd10886f115":"3vmkr","830c56f840811f05":"k019Y","7451b8c4bf72370":"ak0YH"}],"1VQLm":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") ReflectOwnKeys = R.ownKeys;
else if (Object.getOwnPropertySymbols) ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
};
else ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
};
function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function EventEmitter() {
    EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;
// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
    if (typeof listener !== "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        defaultMaxListeners = arg;
    }
});
EventEmitter.init = function() {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);
    var doError = type === "error";
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;
    else if (!doError) return false;
    // If there is no 'error' event listener then throw.
    if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) // Note: The comments on the `throw` lines are intentional, they show
        // up in Node's output if this results in an unhandled exception.
        throw er; // Unhandled 'error' event
        // At least give some kind of context to the user
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err; // Unhandled 'error' event
    }
    var handler = events[type];
    if (handler === undefined) return false;
    if (typeof handler === "function") ReflectApply(handler, this, args);
    else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
            target.emit("newListener", type, listener.listener ? listener.listener : listener);
            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [
            listener,
            existing
        ] : [
            existing,
            listener
        ];
        else if (prepend) existing.unshift(listener);
        else existing.push(listener);
        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners " + "added. Use emitter.setMaxListeners() to " + "increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    var state = {
        fired: false,
        wrapFn: undefined,
        target: target,
        type: type,
        listener: listener
    };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = Object.create(null);
        else {
            delete events[type];
            if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
        }
    } else if (typeof list !== "function") {
        position = -1;
        for(i = list.length - 1; i >= 0; i--)if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else spliceOne(list, position);
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== undefined) this.emit("removeListener", type, originalListener || listener);
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this;
    // not listening for removeListener, no need to emit
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);
            else delete events[type];
        }
        return this;
    }
    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for(i = 0; i < keys.length; ++i){
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    listeners = events[type];
    if (typeof listeners === "function") this.removeListener(type, listeners);
    else if (listeners !== undefined) // LIFO order
    for(i = listeners.length - 1; i >= 0; i--)this.removeListener(type, listeners[i]);
    return this;
};
function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === "function") return unwrap ? [
        evlistener.listener || evlistener
    ] : [
        evlistener
    ];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") return emitter.listenerCount(type);
    else return listenerCount.call(emitter, type);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === "function") return 1;
        else if (evlistener !== undefined) return evlistener.length;
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
    var copy = new Array(n);
    for(var i = 0; i < n; ++i)copy[i] = arr[i];
    return copy;
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for(var i = 0; i < ret.length; ++i)ret[i] = arr[i].listener || arr[i];
    return ret;
}
function once(emitter, name) {
    return new Promise(function(resolve, reject) {
        function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
        }
        function resolver() {
            if (typeof emitter.removeListener === "function") emitter.removeListener("error", errorListener);
            resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== "error") addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true
        });
    });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") eventTargetAgnosticAddListener(emitter, "error", handler, flags);
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags.once) emitter.once(name, listener);
        else emitter.on(name, listener);
    } else if (typeof emitter.addEventListener === "function") // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
        // IE does not have builtin `{ once: true }` support so we
        // have to do it manually.
        if (flags.once) emitter.removeEventListener(name, wrapListener);
        listener(arg);
    });
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
}

},{}],"60BLS":[function(require,module,exports) {
module.exports = require("ed88fc9aa73f911").EventEmitter;

},{"ed88fc9aa73f911":"1VQLm"}],"jhUEF":[function(require,module,exports) {
"use strict";

},{}],"hf3P2":[function(require,module,exports) {
"use strict";
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var _require = require("59f5d0111b7fa075"), Buffer = _require.Buffer;
var _require2 = require("eef6a677577349b8"), inspect = _require2.inspect;
var custom = inspect && inspect.custom || "inspect";
function copyBuffer(src, target, offset) {
    Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/ function() {
    function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    _createClass(BufferList, [
        {
            key: "push",
            value: function push(v) {
                var entry = {
                    data: v,
                    next: null
                };
                if (this.length > 0) this.tail.next = entry;
                else this.head = entry;
                this.tail = entry;
                ++this.length;
            }
        },
        {
            key: "unshift",
            value: function unshift(v) {
                var entry = {
                    data: v,
                    next: this.head
                };
                if (this.length === 0) this.tail = entry;
                this.head = entry;
                ++this.length;
            }
        },
        {
            key: "shift",
            value: function shift() {
                if (this.length === 0) return;
                var ret = this.head.data;
                if (this.length === 1) this.head = this.tail = null;
                else this.head = this.head.next;
                --this.length;
                return ret;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.head = this.tail = null;
                this.length = 0;
            }
        },
        {
            key: "join",
            value: function join(s) {
                if (this.length === 0) return "";
                var p = this.head;
                var ret = "" + p.data;
                while(p = p.next)ret += s + p.data;
                return ret;
            }
        },
        {
            key: "concat",
            value: function concat(n) {
                if (this.length === 0) return Buffer.alloc(0);
                var ret = Buffer.allocUnsafe(n >>> 0);
                var p = this.head;
                var i = 0;
                while(p){
                    copyBuffer(p.data, ret, i);
                    i += p.data.length;
                    p = p.next;
                }
                return ret;
            }
        },
        {
            key: "consume",
            value: function consume(n, hasStrings) {
                var ret;
                if (n < this.head.data.length) {
                    // `slice` is the same for buffers and strings.
                    ret = this.head.data.slice(0, n);
                    this.head.data = this.head.data.slice(n);
                } else if (n === this.head.data.length) // First chunk is a perfect match.
                ret = this.shift();
                else // Result spans more than one buffer.
                ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                return ret;
            }
        },
        {
            key: "first",
            value: function first() {
                return this.head.data;
            }
        },
        {
            key: "_getString",
            value: function _getString(n) {
                var p = this.head;
                var c = 1;
                var ret = p.data;
                n -= ret.length;
                while(p = p.next){
                    var str = p.data;
                    var nb = n > str.length ? str.length : n;
                    if (nb === str.length) ret += str;
                    else ret += str.slice(0, n);
                    n -= nb;
                    if (n === 0) {
                        if (nb === str.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = str.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: "_getBuffer",
            value: function _getBuffer(n) {
                var ret = Buffer.allocUnsafe(n);
                var p = this.head;
                var c = 1;
                p.data.copy(ret);
                n -= p.data.length;
                while(p = p.next){
                    var buf = p.data;
                    var nb = n > buf.length ? buf.length : n;
                    buf.copy(ret, ret.length - n, 0, nb);
                    n -= nb;
                    if (n === 0) {
                        if (nb === buf.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = buf.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: custom,
            value: function value(_, options) {
                return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
                    // Only inspect one level.
                    depth: 0,
                    // It should not recurse.
                    customInspect: false
                }));
            }
        }
    ]);
    return BufferList;
}();

},{"59f5d0111b7fa075":"bwvMq","eef6a677577349b8":"jhUEF"}],"YI8DF":[function(require,module,exports) {
var process = require("4284522496af5dfb");
"use strict";
// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) cb(err);
        else if (err) {
            if (!this._writableState) process.nextTick(emitErrorNT, this, err);
            else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                process.nextTick(emitErrorNT, this, err);
            }
        }
        return this;
    }
    // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) this._readableState.destroyed = true;
    // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) this._writableState.destroyed = true;
    this._destroy(err || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) process.nextTick(emitErrorAndCloseNT, _this, err);
            else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                process.nextTick(emitErrorAndCloseNT, _this, err);
            } else process.nextTick(emitCloseNT, _this);
        } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err);
        } else process.nextTick(emitCloseNT, _this);
    });
    return this;
}
function emitErrorAndCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose) return;
    if (self._readableState && !self._readableState.emitClose) return;
    self.emit("close");
}
function undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function emitErrorNT(self, err) {
    self.emit("error", err);
}
function errorOrDestroy(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
}
module.exports = {
    destroy: destroy,
    undestroy: undestroy,
    errorOrDestroy: errorOrDestroy
};

},{"4284522496af5dfb":"d5jf4"}],"61BRN":[function(require,module,exports) {
"use strict";
var ERR_INVALID_OPT_VALUE = require("4e508d569e2117ef").codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    }
    // Default value
    return state.objectMode ? 16 : 16384;
}
module.exports = {
    getHighWaterMark: getHighWaterMark
};

},{"4e508d569e2117ef":"aJlwj"}],"aJlwj":[function(require,module,exports) {
"use strict";
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code, message, Base) {
    if (!Base) Base = Error;
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") return message;
        else return message(arg1, arg2, arg3);
    }
    var NodeError = /*#__PURE__*/ function(_Base) {
        _inheritsLoose(NodeError, _Base);
        function NodeError(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError;
    }(Base);
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
            return String(i);
        });
        if (len > 2) return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        else if (len === 2) return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        else return "of ".concat(thing, " ").concat(expected[0]);
    } else return "of ".concat(thing, " ").concat(String(expected));
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
    if (typeof start !== "number") start = 0;
    if (start + search.length > str.length) return false;
    else return str.indexOf(search, start) !== -1;
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
    } else determiner = "must be";
    var msg;
    if (endsWith(name, " argument")) // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
module.exports.codes = codes;

},{}],"kKNA3":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
var process = require("2ab1115635c50a9f");
"use strict";
/*<replacement>*/ var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj)keys.push(key);
    return keys;
};
/*</replacement>*/ module.exports = Duplex;
var Readable = require("68a7582259cd5865");
var Writable = require("93d042f8bb80078e");
require("aa7b11ba5bf4defc")(Duplex, Readable);
// Allow the keys array to be GC'ed.
var keys = objectKeys(Writable.prototype);
for(var v = 0; v < keys.length; v++){
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}
function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
        }
    }
}
Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
// the no-half-open enforcer
function onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return;
    // no more data can be written.
    // But allow more writes to happen in this tick.
    process.nextTick(onEndNT, this);
}
function onEndNT(self) {
    self.end();
}
Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined || this._writableState === undefined) return false;
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});

},{"2ab1115635c50a9f":"d5jf4","68a7582259cd5865":"6NdbQ","93d042f8bb80078e":"gTkcq","aa7b11ba5bf4defc":"bRL3M"}],"gTkcq":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
var global = arguments[3];
var process = require("f05a2a5a09d4d8b0");
"use strict";
module.exports = Writable;
/* <replacement> */ function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
}
// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var Duplex;
/*</replacement>*/ Writable.WritableState = WritableState;
/*<replacement>*/ var internalUtil = {
    deprecate: require("dc51171b07b54af1")
};
/*</replacement>*/ /*<replacement>*/ var Stream = require("44a3cc22ec64fcd3");
/*</replacement>*/ var Buffer = require("de8f7fb7ccda8086").Buffer;
var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = require("acf48fb5d9dc6204");
var _require = require("9d146cd974da0f53"), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require("3c574b8881abcf86").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require("10dad555ffe77dde")(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require("c5e7171d6f58d3c0");
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    // if _final has been called
    this.finalCalled = false;
    // drain event flag.
    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;
    // has it been destroyed
    this.destroyed = false;
    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;
    // a flag to see when we're in the middle of a write.
    this.writing = false;
    // when true all writes will be buffered until .uncork() call
    this.corked = 0;
    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;
    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;
    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        onwrite(stream, er);
    };
    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;
    // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;
    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;
    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'finish' (and potentially 'end')
    this.autoDestroy = !!options.autoDestroy;
    // count buffered requests
    this.bufferedRequestCount = 0;
    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
                return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
    } catch (_) {}
})();
// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
        }
    });
} else realHasInstance = function realHasInstance(object) {
    return object instanceof this;
};
function Writable(options) {
    Duplex = Duplex || require("c5e7171d6f58d3c0");
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
}
// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    // TODO: defer error events consistently everywhere, not just the cb
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
}
// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) er = new ERR_STREAM_NULL_VALUES();
    else if (typeof chunk !== "string" && !state.objectMode) er = new ERR_INVALID_ARG_TYPE("chunk", [
        "string",
        "Buffer"
    ], chunk);
    if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
    }
    return true;
}
Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) chunk = _uint8ArrayToBuffer(chunk);
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
Writable.prototype.cork = function() {
    this._writableState.corked++;
};
Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!([
        "hex",
        "utf8",
        "utf-8",
        "ascii",
        "binary",
        "base64",
        "ucs2",
        "ucs-2",
        "utf16le",
        "utf-16le",
        "raw"
    ].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") chunk = Buffer.from(chunk, encoding);
    return chunk;
}
Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) last.next = state.lastBufferedRequest;
        else state.bufferedRequest = state.lastBufferedRequest;
        state.bufferedRequestCount += 1;
    } else doWrite(stream, state, false, len, chunk, encoding, cb);
    return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        process.nextTick(cb, er);
        // this can emit finish, and it will always happen
        // after error
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        // this can emit finish, but finish must
        // always follow error
        finishMaybe(stream, state);
    }
}
function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(stream, state);
        if (sync) process.nextTick(afterWrite, stream, state, finished, cb);
        else afterWrite(stream, state, finished, cb);
    }
}
function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
}
// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
}
// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while(entry){
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else state.corkedRequestsFree = new CorkedRequest(state);
        state.bufferedRequestCount = 0;
    } else {
        // Slow case, write chunks one-by-one
        while(entry){
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) break;
        }
        if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
    // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    // ignore unnecessary end() calls.
    if (!state.ending) endWritable(this, state, cb);
    return this;
};
Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
    stream._final(function(err) {
        state.pendingcb--;
        if (err) errorOrDestroy(stream, err);
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
    });
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
                // In case of duplex streams we need a way to detect
                // if the readable side is ready for autoDestroy as well
                var rState = stream._readableState;
                if (!rState || rState.autoDestroy && rState.endEmitted) stream.destroy();
            }
        }
    }
    return need;
}
function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while(entry){
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    }
    // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._writableState === undefined) return false;
        return this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err, cb) {
    cb(err);
};

},{"f05a2a5a09d4d8b0":"d5jf4","dc51171b07b54af1":"j92NQ","44a3cc22ec64fcd3":"60BLS","de8f7fb7ccda8086":"bwvMq","acf48fb5d9dc6204":"YI8DF","9d146cd974da0f53":"61BRN","3c574b8881abcf86":"aJlwj","10dad555ffe77dde":"bRL3M","c5e7171d6f58d3c0":"kKNA3"}],"j92NQ":[function(require,module,exports) {
/**
 * Module exports.
 */ var global = arguments[3];
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */ function deprecate(fn, msg) {
    if (config("noDeprecation")) return fn;
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (config("throwDeprecation")) throw new Error(msg);
            else if (config("traceDeprecation")) console.trace(msg);
            else console.warn(msg);
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */ function config(name) {
    // accessing global.localStorage can trigger a DOMException in sandboxed iframes
    try {
        if (!global.localStorage) return false;
    } catch (_) {
        return false;
    }
    var val = global.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === "true";
}

},{}],"3vmkr":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
/*<replacement>*/ var Buffer = require("2a29807c689a070a").Buffer;
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch(encoding && encoding.toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while(true)switch(enc){
        case "utf8":
        case "utf-8":
            return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return "utf16le";
        case "latin1":
        case "binary":
            return "latin1";
        case "base64":
        case "ascii":
        case "hex":
            return enc;
        default:
            if (retried) return; // undefined
            enc = ("" + enc).toLowerCase();
            retried = true;
    }
}
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else i = 0;
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return "\uFFFD";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "\uFFFD";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return "\uFFFD";
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "\uFFFD";
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) this.lastChar[0] = buf[buf.length - 1];
    else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}

},{"2a29807c689a070a":"eW7r9"}],"k019Y":[function(require,module,exports) {
var process = require("96b869862a96261a");
"use strict";
var _Object$setPrototypeO;
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var finished = require("745a3cd8f6469ed5");
var kLastResolve = Symbol("lastResolve");
var kLastReject = Symbol("lastReject");
var kError = Symbol("error");
var kEnded = Symbol("ended");
var kLastPromise = Symbol("lastPromise");
var kHandlePromise = Symbol("handlePromise");
var kStream = Symbol("stream");
function createIterResult(value, done) {
    return {
        value: value,
        done: done
    };
}
function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
        var data = iter[kStream].read();
        // we defer if data is null
        // we can be expecting either 'end' or
        // 'error'
        if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
        }
    }
}
function onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
        lastPromise.then(function() {
            if (iter[kEnded]) {
                resolve(createIterResult(undefined, true));
                return;
            }
            iter[kHandlePromise](resolve, reject);
        }, reject);
    };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function() {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream () {
        return this[kStream];
    },
    next: function next() {
        var _this = this;
        // if we have detected an error in the meanwhile
        // reject straight away
        var error = this[kError];
        if (error !== null) return Promise.reject(error);
        if (this[kEnded]) return Promise.resolve(createIterResult(undefined, true));
        if (this[kStream].destroyed) // We need to defer via nextTick because if .destroy(err) is
        // called, the error will be emitted via nextTick, and
        // we cannot guarantee that there is no error lingering around
        // waiting to be emitted.
        return new Promise(function(resolve, reject) {
            process.nextTick(function() {
                if (_this[kError]) reject(_this[kError]);
                else resolve(createIterResult(undefined, true));
            });
        });
        // if we have multiple next() calls
        // we will wait for the previous Promise to finish
        // this logic is optimized to support for await loops,
        // where next() is only called once at a time
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) promise = new Promise(wrapForNext(lastPromise, this));
        else {
            // fast path needed to support multiple this.push()
            // without triggering the next() queue
            var data = this[kStream].read();
            if (data !== null) return Promise.resolve(createIterResult(data, false));
            promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
    }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to
    return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
            if (err) {
                reject(err);
                return;
            }
            resolve(createIterResult(undefined, true));
        });
    });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(data, false));
            } else {
                iterator[kLastResolve] = resolve;
                iterator[kLastReject] = reject;
            }
        },
        writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            // reject if we are waiting for data in the Promise
            // returned by next() and store the error
            if (reject !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                reject(err);
            }
            iterator[kError] = err;
            return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(undefined, true));
        }
        iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
};
module.exports = createReadableStreamAsyncIterator;

},{"96b869862a96261a":"d5jf4","745a3cd8f6469ed5":"aOMy2"}],"aOMy2":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
"use strict";
var ERR_STREAM_PREMATURE_CLOSE = require("d35458f585bdd360").codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        callback.apply(this, args);
    };
}
function noop() {}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
        if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
    };
    var onerror = function onerror(err) {
        callback.call(stream, err);
    };
    var onclose = function onclose() {
        var err;
        if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
    };
    var onrequest = function onrequest() {
        stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
        // legacy streams
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
}
module.exports = eos;

},{"d35458f585bdd360":"aJlwj"}],"ak0YH":[function(require,module,exports) {
module.exports = function() {
    throw new Error("Readable.from is not available in the browser");
};

},{}],"ba8Mr":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
"use strict";
module.exports = Transform;
var _require$codes = require("baab47252aa06434").codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require("db11ebf938e536ed");
require("82049677fa603d40")(Transform, Duplex);
function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
}
function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
    };
    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;
    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
    }
    // When the writable side finishes, then flush out anything remaining.
    this.on("prefinish", prefinish);
}
function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) this._flush(function(er, data) {
        done(_this, er, data);
    });
    else done(this, null, null);
}
Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
};
// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
};
// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
};
Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
    });
};
function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);
    // TODO(BridgeAR): Write a test for these two error cases
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
}

},{"baab47252aa06434":"aJlwj","db11ebf938e536ed":"kKNA3","82049677fa603d40":"bRL3M"}],"2xP98":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
"use strict";
module.exports = PassThrough;
var Transform = require("7ab21291895ec3d2");
require("f24ec1883eef5e9b")(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};

},{"7ab21291895ec3d2":"ba8Mr","f24ec1883eef5e9b":"bRL3M"}],"fyp4t":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
"use strict";
var eos;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
    };
}
var _require$codes = require("6ba21bd580ac7d57").codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
    // Rethrow the error if it exists to avoid swallowing it
    if (err) throw err;
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
        closed = true;
    });
    if (eos === undefined) eos = require("dd7fd89dd81b8674");
    eos(stream, {
        readable: reading,
        writable: writing
    }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
    });
    var destroyed = false;
    return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        // request.destroy just do .end - .abort is what we want
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
}
function call(fn) {
    fn();
}
function pipe(from, to) {
    return from.pipe(to);
}
function popCallback(streams) {
    if (!streams.length) return noop;
    if (typeof streams[streams.length - 1] !== "function") return noop;
    return streams.pop();
}
function pipeline() {
    for(var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++)streams[_key] = arguments[_key];
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) throw new ERR_MISSING_ARGS("streams");
    var error;
    var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
        });
    });
    return streams.reduce(pipe);
}
module.exports = pipeline;

},{"6ba21bd580ac7d57":"aJlwj","dd7fd89dd81b8674":"aOMy2"}],"bFDDq":[function(require,module,exports) {
"use strict";
var Buffer = require("c813c8075bcf823e").Buffer;
var inherits = require("84928993e7c3934b");
var HashBase = require("4b3519823770a56d");
var ARRAY16 = new Array(16);
var zl = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
];
var zr = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
];
var sl = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
];
var sr = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
];
var hl = [
    0x00000000,
    0x5a827999,
    0x6ed9eba1,
    0x8f1bbcdc,
    0xa953fd4e
];
var hr = [
    0x50a28be6,
    0x5c4dd124,
    0x6d703ef3,
    0x7a6d76e9,
    0x00000000
];
function RIPEMD160() {
    HashBase.call(this, 64);
    // state
    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
    this._e = 0xc3d2e1f0;
}
inherits(RIPEMD160, HashBase);
RIPEMD160.prototype._update = function() {
    var words = ARRAY16;
    for(var j = 0; j < 16; ++j)words[j] = this._block.readInt32LE(j * 4);
    var al = this._a | 0;
    var bl = this._b | 0;
    var cl = this._c | 0;
    var dl = this._d | 0;
    var el = this._e | 0;
    var ar = this._a | 0;
    var br = this._b | 0;
    var cr = this._c | 0;
    var dr = this._d | 0;
    var er = this._e | 0;
    // computation
    for(var i = 0; i < 80; i += 1){
        var tl;
        var tr;
        if (i < 16) {
            tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
            tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
        } else if (i < 32) {
            tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
            tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
        } else if (i < 48) {
            tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
            tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
        } else if (i < 64) {
            tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
            tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
        } else {
            tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
            tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
        }
        al = el;
        el = dl;
        dl = rotl(cl, 10);
        cl = bl;
        bl = tl;
        ar = er;
        er = dr;
        dr = rotl(cr, 10);
        cr = br;
        br = tr;
    }
    // update state
    var t = this._b + cl + dr | 0;
    this._b = this._c + dl + er | 0;
    this._c = this._d + el + ar | 0;
    this._d = this._e + al + br | 0;
    this._e = this._a + bl + cr | 0;
    this._a = t;
};
RIPEMD160.prototype._digest = function() {
    // create padding and handle blocks
    this._block[this._blockOffset++] = 0x80;
    if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
    }
    this._block.fill(0, this._blockOffset, 56);
    this._block.writeUInt32LE(this._length[0], 56);
    this._block.writeUInt32LE(this._length[1], 60);
    this._update();
    // produce result
    var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20);
    buffer.writeInt32LE(this._a, 0);
    buffer.writeInt32LE(this._b, 4);
    buffer.writeInt32LE(this._c, 8);
    buffer.writeInt32LE(this._d, 12);
    buffer.writeInt32LE(this._e, 16);
    return buffer;
};
function rotl(x, n) {
    return x << n | x >>> 32 - n;
}
function fn1(a, b, c, d, e, m, k, s) {
    return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
}
function fn2(a, b, c, d, e, m, k, s) {
    return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
}
function fn3(a, b, c, d, e, m, k, s) {
    return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
}
function fn4(a, b, c, d, e, m, k, s) {
    return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
}
function fn5(a, b, c, d, e, m, k, s) {
    return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
}
module.exports = RIPEMD160;

},{"c813c8075bcf823e":"bwvMq","84928993e7c3934b":"bRL3M","4b3519823770a56d":"51qBP"}],"jkn7m":[function(require,module,exports) {
var exports = module.exports = function SHA(algorithm) {
    algorithm = algorithm.toLowerCase();
    var Algorithm = exports[algorithm];
    if (!Algorithm) throw new Error(algorithm + " is not supported (we accept pull requests)");
    return new Algorithm();
};
exports.sha = require("54c9313943368ce2");
exports.sha1 = require("6e6f42e0b6fe29ef");
exports.sha224 = require("cefe70c6f9f68940");
exports.sha256 = require("3b4e2aa73bc3fef5");
exports.sha384 = require("be7da8b8e5a0fd78");
exports.sha512 = require("25610a4ba83316a4");

},{"54c9313943368ce2":"6PecA","6e6f42e0b6fe29ef":"iCEYJ","cefe70c6f9f68940":"7e0O2","3b4e2aa73bc3fef5":"kVAym","be7da8b8e5a0fd78":"bWRvM","25610a4ba83316a4":"aZK4H"}],"6PecA":[function(require,module,exports) {
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */ var inherits = require("55404b425acd1c6f");
var Hash = require("457bc9c7737d761f");
var Buffer = require("44759e57eb2992a").Buffer;
var K = [
    0x5a827999,
    0x6ed9eba1,
    -1894007588,
    -899497514
];
var W = new Array(80);
function Sha() {
    this.init();
    this._w = W;
    Hash.call(this, 64, 56);
}
inherits(Sha, Hash);
Sha.prototype.init = function() {
    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
    this._e = 0xc3d2e1f0;
    return this;
};
function rotl5(num) {
    return num << 5 | num >>> 27;
}
function rotl30(num) {
    return num << 30 | num >>> 2;
}
function ft(s, b, c, d) {
    if (s === 0) return b & c | ~b & d;
    if (s === 2) return b & c | b & d | c & d;
    return b ^ c ^ d;
}
Sha.prototype._update = function(M) {
    var W = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    for(var i = 0; i < 16; ++i)W[i] = M.readInt32BE(i * 4);
    for(; i < 80; ++i)W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
    for(var j = 0; j < 80; ++j){
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
};
Sha.prototype._hash = function() {
    var H = Buffer.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
};
module.exports = Sha;

},{"55404b425acd1c6f":"bRL3M","457bc9c7737d761f":"7wpAR","44759e57eb2992a":"eW7r9"}],"7wpAR":[function(require,module,exports) {
var Buffer = require("fe67468afd3c1b91").Buffer;
// prototype class for hash functions
function Hash(blockSize, finalSize) {
    this._block = Buffer.alloc(blockSize);
    this._finalSize = finalSize;
    this._blockSize = blockSize;
    this._len = 0;
}
Hash.prototype.update = function(data, enc) {
    if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer.from(data, enc);
    }
    var block = this._block;
    var blockSize = this._blockSize;
    var length = data.length;
    var accum = this._len;
    for(var offset = 0; offset < length;){
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for(var i = 0; i < remainder; i++)block[assigned + i] = data[offset + i];
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) this._update(block);
    }
    this._len += length;
    return this;
};
Hash.prototype.digest = function(enc) {
    var rem = this._len % this._blockSize;
    this._block[rem] = 0x80;
    // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
    // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
    this._block.fill(0, rem + 1);
    if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
    }
    var bits = this._len * 8;
    // uint32
    if (bits <= 0xffffffff) this._block.writeUInt32BE(bits, this._blockSize - 4);
    else {
        var lowBits = (bits & 0xffffffff) >>> 0;
        var highBits = (bits - lowBits) / 0x100000000;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
    }
    this._update(this._block);
    var hash = this._hash();
    return enc ? hash.toString(enc) : hash;
};
Hash.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
};
module.exports = Hash;

},{"fe67468afd3c1b91":"eW7r9"}],"iCEYJ":[function(require,module,exports) {
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */ var inherits = require("bf0dcaa2121c06d3");
var Hash = require("788f05b1f9753762");
var Buffer = require("ee7c2a3e649d259f").Buffer;
var K = [
    0x5a827999,
    0x6ed9eba1,
    -1894007588,
    -899497514
];
var W = new Array(80);
function Sha1() {
    this.init();
    this._w = W;
    Hash.call(this, 64, 56);
}
inherits(Sha1, Hash);
Sha1.prototype.init = function() {
    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
    this._e = 0xc3d2e1f0;
    return this;
};
function rotl1(num) {
    return num << 1 | num >>> 31;
}
function rotl5(num) {
    return num << 5 | num >>> 27;
}
function rotl30(num) {
    return num << 30 | num >>> 2;
}
function ft(s, b, c, d) {
    if (s === 0) return b & c | ~b & d;
    if (s === 2) return b & c | b & d | c & d;
    return b ^ c ^ d;
}
Sha1.prototype._update = function(M) {
    var W = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    for(var i = 0; i < 16; ++i)W[i] = M.readInt32BE(i * 4);
    for(; i < 80; ++i)W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);
    for(var j = 0; j < 80; ++j){
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
};
Sha1.prototype._hash = function() {
    var H = Buffer.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
};
module.exports = Sha1;

},{"bf0dcaa2121c06d3":"bRL3M","788f05b1f9753762":"7wpAR","ee7c2a3e649d259f":"eW7r9"}],"7e0O2":[function(require,module,exports) {
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */ var inherits = require("1759318dd61b32af");
var Sha256 = require("5a24a8ff4dc414f6");
var Hash = require("377596dd27739a66");
var Buffer = require("381289f917f16a20").Buffer;
var W = new Array(64);
function Sha224() {
    this.init();
    this._w = W // new Array(64)
    ;
    Hash.call(this, 64, 56);
}
inherits(Sha224, Sha256);
Sha224.prototype.init = function() {
    this._a = 0xc1059ed8;
    this._b = 0x367cd507;
    this._c = 0x3070dd17;
    this._d = 0xf70e5939;
    this._e = 0xffc00b31;
    this._f = 0x68581511;
    this._g = 0x64f98fa7;
    this._h = 0xbefa4fa4;
    return this;
};
Sha224.prototype._hash = function() {
    var H = Buffer.allocUnsafe(28);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    return H;
};
module.exports = Sha224;

},{"1759318dd61b32af":"bRL3M","5a24a8ff4dc414f6":"kVAym","377596dd27739a66":"7wpAR","381289f917f16a20":"eW7r9"}],"kVAym":[function(require,module,exports) {
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */ var inherits = require("682a6716eeab42dd");
var Hash = require("f062bd789841a9ce");
var Buffer = require("1d47643a8adb8c1b").Buffer;
var K = [
    0x428A2F98,
    0x71374491,
    0xB5C0FBCF,
    0xE9B5DBA5,
    0x3956C25B,
    0x59F111F1,
    0x923F82A4,
    0xAB1C5ED5,
    0xD807AA98,
    0x12835B01,
    0x243185BE,
    0x550C7DC3,
    0x72BE5D74,
    0x80DEB1FE,
    0x9BDC06A7,
    0xC19BF174,
    0xE49B69C1,
    0xEFBE4786,
    0x0FC19DC6,
    0x240CA1CC,
    0x2DE92C6F,
    0x4A7484AA,
    0x5CB0A9DC,
    0x76F988DA,
    0x983E5152,
    0xA831C66D,
    0xB00327C8,
    0xBF597FC7,
    0xC6E00BF3,
    0xD5A79147,
    0x06CA6351,
    0x14292967,
    0x27B70A85,
    0x2E1B2138,
    0x4D2C6DFC,
    0x53380D13,
    0x650A7354,
    0x766A0ABB,
    0x81C2C92E,
    0x92722C85,
    0xA2BFE8A1,
    0xA81A664B,
    0xC24B8B70,
    0xC76C51A3,
    0xD192E819,
    0xD6990624,
    0xF40E3585,
    0x106AA070,
    0x19A4C116,
    0x1E376C08,
    0x2748774C,
    0x34B0BCB5,
    0x391C0CB3,
    0x4ED8AA4A,
    0x5B9CCA4F,
    0x682E6FF3,
    0x748F82EE,
    0x78A5636F,
    0x84C87814,
    0x8CC70208,
    0x90BEFFFA,
    0xA4506CEB,
    0xBEF9A3F7,
    0xC67178F2
];
var W = new Array(64);
function Sha256() {
    this.init();
    this._w = W // new Array(64)
    ;
    Hash.call(this, 64, 56);
}
inherits(Sha256, Hash);
Sha256.prototype.init = function() {
    this._a = 0x6a09e667;
    this._b = 0xbb67ae85;
    this._c = 0x3c6ef372;
    this._d = 0xa54ff53a;
    this._e = 0x510e527f;
    this._f = 0x9b05688c;
    this._g = 0x1f83d9ab;
    this._h = 0x5be0cd19;
    return this;
};
function ch(x, y, z) {
    return z ^ x & (y ^ z);
}
function maj(x, y, z) {
    return x & y | z & (x | y);
}
function sigma0(x) {
    return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
}
function sigma1(x) {
    return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
}
function gamma0(x) {
    return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
}
function gamma1(x) {
    return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
}
Sha256.prototype._update = function(M) {
    var W = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    var f = this._f | 0;
    var g = this._g | 0;
    var h = this._h | 0;
    for(var i = 0; i < 16; ++i)W[i] = M.readInt32BE(i * 4);
    for(; i < 64; ++i)W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;
    for(var j = 0; j < 64; ++j){
        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
    this._f = f + this._f | 0;
    this._g = g + this._g | 0;
    this._h = h + this._h | 0;
};
Sha256.prototype._hash = function() {
    var H = Buffer.allocUnsafe(32);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    H.writeInt32BE(this._h, 28);
    return H;
};
module.exports = Sha256;

},{"682a6716eeab42dd":"bRL3M","f062bd789841a9ce":"7wpAR","1d47643a8adb8c1b":"eW7r9"}],"bWRvM":[function(require,module,exports) {
var inherits = require("2a5cbb73fedd61b");
var SHA512 = require("fdb4d0946b31cdb5");
var Hash = require("50aa04d4bd2df0e1");
var Buffer = require("3d3bcc84ec383b74").Buffer;
var W = new Array(160);
function Sha384() {
    this.init();
    this._w = W;
    Hash.call(this, 128, 112);
}
inherits(Sha384, SHA512);
Sha384.prototype.init = function() {
    this._ah = 0xcbbb9d5d;
    this._bh = 0x629a292a;
    this._ch = 0x9159015a;
    this._dh = 0x152fecd8;
    this._eh = 0x67332667;
    this._fh = 0x8eb44a87;
    this._gh = 0xdb0c2e0d;
    this._hh = 0x47b5481d;
    this._al = 0xc1059ed8;
    this._bl = 0x367cd507;
    this._cl = 0x3070dd17;
    this._dl = 0xf70e5939;
    this._el = 0xffc00b31;
    this._fl = 0x68581511;
    this._gl = 0x64f98fa7;
    this._hl = 0xbefa4fa4;
    return this;
};
Sha384.prototype._hash = function() {
    var H = Buffer.allocUnsafe(48);
    function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    return H;
};
module.exports = Sha384;

},{"2a5cbb73fedd61b":"bRL3M","fdb4d0946b31cdb5":"aZK4H","50aa04d4bd2df0e1":"7wpAR","3d3bcc84ec383b74":"eW7r9"}],"aZK4H":[function(require,module,exports) {
var inherits = require("8d87c82d5ce5743");
var Hash = require("27d0146c4419ba93");
var Buffer = require("602d9c7256ca6bf7").Buffer;
var K = [
    0x428a2f98,
    0xd728ae22,
    0x71374491,
    0x23ef65cd,
    0xb5c0fbcf,
    0xec4d3b2f,
    0xe9b5dba5,
    0x8189dbbc,
    0x3956c25b,
    0xf348b538,
    0x59f111f1,
    0xb605d019,
    0x923f82a4,
    0xaf194f9b,
    0xab1c5ed5,
    0xda6d8118,
    0xd807aa98,
    0xa3030242,
    0x12835b01,
    0x45706fbe,
    0x243185be,
    0x4ee4b28c,
    0x550c7dc3,
    0xd5ffb4e2,
    0x72be5d74,
    0xf27b896f,
    0x80deb1fe,
    0x3b1696b1,
    0x9bdc06a7,
    0x25c71235,
    0xc19bf174,
    0xcf692694,
    0xe49b69c1,
    0x9ef14ad2,
    0xefbe4786,
    0x384f25e3,
    0x0fc19dc6,
    0x8b8cd5b5,
    0x240ca1cc,
    0x77ac9c65,
    0x2de92c6f,
    0x592b0275,
    0x4a7484aa,
    0x6ea6e483,
    0x5cb0a9dc,
    0xbd41fbd4,
    0x76f988da,
    0x831153b5,
    0x983e5152,
    0xee66dfab,
    0xa831c66d,
    0x2db43210,
    0xb00327c8,
    0x98fb213f,
    0xbf597fc7,
    0xbeef0ee4,
    0xc6e00bf3,
    0x3da88fc2,
    0xd5a79147,
    0x930aa725,
    0x06ca6351,
    0xe003826f,
    0x14292967,
    0x0a0e6e70,
    0x27b70a85,
    0x46d22ffc,
    0x2e1b2138,
    0x5c26c926,
    0x4d2c6dfc,
    0x5ac42aed,
    0x53380d13,
    0x9d95b3df,
    0x650a7354,
    0x8baf63de,
    0x766a0abb,
    0x3c77b2a8,
    0x81c2c92e,
    0x47edaee6,
    0x92722c85,
    0x1482353b,
    0xa2bfe8a1,
    0x4cf10364,
    0xa81a664b,
    0xbc423001,
    0xc24b8b70,
    0xd0f89791,
    0xc76c51a3,
    0x0654be30,
    0xd192e819,
    0xd6ef5218,
    0xd6990624,
    0x5565a910,
    0xf40e3585,
    0x5771202a,
    0x106aa070,
    0x32bbd1b8,
    0x19a4c116,
    0xb8d2d0c8,
    0x1e376c08,
    0x5141ab53,
    0x2748774c,
    0xdf8eeb99,
    0x34b0bcb5,
    0xe19b48a8,
    0x391c0cb3,
    0xc5c95a63,
    0x4ed8aa4a,
    0xe3418acb,
    0x5b9cca4f,
    0x7763e373,
    0x682e6ff3,
    0xd6b2b8a3,
    0x748f82ee,
    0x5defb2fc,
    0x78a5636f,
    0x43172f60,
    0x84c87814,
    0xa1f0ab72,
    0x8cc70208,
    0x1a6439ec,
    0x90befffa,
    0x23631e28,
    0xa4506ceb,
    0xde82bde9,
    0xbef9a3f7,
    0xb2c67915,
    0xc67178f2,
    0xe372532b,
    0xca273ece,
    0xea26619c,
    0xd186b8c7,
    0x21c0c207,
    0xeada7dd6,
    0xcde0eb1e,
    0xf57d4f7f,
    0xee6ed178,
    0x06f067aa,
    0x72176fba,
    0x0a637dc5,
    0xa2c898a6,
    0x113f9804,
    0xbef90dae,
    0x1b710b35,
    0x131c471b,
    0x28db77f5,
    0x23047d84,
    0x32caab7b,
    0x40c72493,
    0x3c9ebe0a,
    0x15c9bebc,
    0x431d67c4,
    0x9c100d4c,
    0x4cc5d4be,
    0xcb3e42b6,
    0x597f299c,
    0xfc657e2a,
    0x5fcb6fab,
    0x3ad6faec,
    0x6c44198c,
    0x4a475817
];
var W = new Array(160);
function Sha512() {
    this.init();
    this._w = W;
    Hash.call(this, 128, 112);
}
inherits(Sha512, Hash);
Sha512.prototype.init = function() {
    this._ah = 0x6a09e667;
    this._bh = 0xbb67ae85;
    this._ch = 0x3c6ef372;
    this._dh = 0xa54ff53a;
    this._eh = 0x510e527f;
    this._fh = 0x9b05688c;
    this._gh = 0x1f83d9ab;
    this._hh = 0x5be0cd19;
    this._al = 0xf3bcc908;
    this._bl = 0x84caa73b;
    this._cl = 0xfe94f82b;
    this._dl = 0x5f1d36f1;
    this._el = 0xade682d1;
    this._fl = 0x2b3e6c1f;
    this._gl = 0xfb41bd6b;
    this._hl = 0x137e2179;
    return this;
};
function Ch(x, y, z) {
    return z ^ x & (y ^ z);
}
function maj(x, y, z) {
    return x & y | z & (x | y);
}
function sigma0(x, xl) {
    return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
}
function sigma1(x, xl) {
    return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
}
function Gamma0(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
}
function Gamma0l(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
}
function Gamma1(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
}
function Gamma1l(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
}
function getCarry(a, b) {
    return a >>> 0 < b >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(M) {
    var W = this._w;
    var ah = this._ah | 0;
    var bh = this._bh | 0;
    var ch = this._ch | 0;
    var dh = this._dh | 0;
    var eh = this._eh | 0;
    var fh = this._fh | 0;
    var gh = this._gh | 0;
    var hh = this._hh | 0;
    var al = this._al | 0;
    var bl = this._bl | 0;
    var cl = this._cl | 0;
    var dl = this._dl | 0;
    var el = this._el | 0;
    var fl = this._fl | 0;
    var gl = this._gl | 0;
    var hl = this._hl | 0;
    for(var i = 0; i < 32; i += 2){
        W[i] = M.readInt32BE(i * 4);
        W[i + 1] = M.readInt32BE(i * 4 + 4);
    }
    for(; i < 160; i += 2){
        var xh = W[i - 30];
        var xl = W[i - 30 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W[i - 4];
        xl = W[i - 4 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
        var Wi7h = W[i - 14];
        var Wi7l = W[i - 14 + 1];
        var Wi16h = W[i - 32];
        var Wi16l = W[i - 32 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W[i] = Wih;
        W[i + 1] = Wil;
    }
    for(var j = 0; j < 160; j += 2){
        Wih = W[j];
        Wil = W[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        // t1 = h + sigma1 + ch + K[j] + W[j]
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        // t2 = sigma0 + maj
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
    }
    this._al = this._al + al | 0;
    this._bl = this._bl + bl | 0;
    this._cl = this._cl + cl | 0;
    this._dl = this._dl + dl | 0;
    this._el = this._el + el | 0;
    this._fl = this._fl + fl | 0;
    this._gl = this._gl + gl | 0;
    this._hl = this._hl + hl | 0;
    this._ah = this._ah + ah + getCarry(this._al, al) | 0;
    this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
    this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
    this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
    this._eh = this._eh + eh + getCarry(this._el, el) | 0;
    this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
    this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
    this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
};
Sha512.prototype._hash = function() {
    var H = Buffer.allocUnsafe(64);
    function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    writeInt64BE(this._gh, this._gl, 48);
    writeInt64BE(this._hh, this._hl, 56);
    return H;
};
module.exports = Sha512;

},{"8d87c82d5ce5743":"bRL3M","27d0146c4419ba93":"7wpAR","602d9c7256ca6bf7":"eW7r9"}],"g5fTz":[function(require,module,exports) {
var Buffer = require("631f7eb12d35b579").Buffer;
var Transform = require("5b378a2a05398c5").Transform;
var StringDecoder = require("d42da7de127e1c4b").StringDecoder;
var inherits = require("7a0f2f27fe0a389b");
function CipherBase(hashMode) {
    Transform.call(this);
    this.hashMode = typeof hashMode === "string";
    if (this.hashMode) this[hashMode] = this._finalOrDigest;
    else this.final = this._finalOrDigest;
    if (this._final) {
        this.__final = this._final;
        this._final = null;
    }
    this._decoder = null;
    this._encoding = null;
}
inherits(CipherBase, Transform);
CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
    if (typeof data === "string") data = Buffer.from(data, inputEnc);
    var outData = this._update(data);
    if (this.hashMode) return this;
    if (outputEnc) outData = this._toString(outData, outputEnc);
    return outData;
};
CipherBase.prototype.setAutoPadding = function() {};
CipherBase.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
};
CipherBase.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
};
CipherBase.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
};
CipherBase.prototype._transform = function(data, _, next) {
    var err;
    try {
        if (this.hashMode) this._update(data);
        else this.push(this._update(data));
    } catch (e) {
        err = e;
    } finally{
        next(err);
    }
};
CipherBase.prototype._flush = function(done) {
    var err;
    try {
        this.push(this.__final());
    } catch (e) {
        err = e;
    }
    done(err);
};
CipherBase.prototype._finalOrDigest = function(outputEnc) {
    var outData = this.__final() || Buffer.alloc(0);
    if (outputEnc) outData = this._toString(outData, outputEnc, true);
    return outData;
};
CipherBase.prototype._toString = function(value, enc, fin) {
    if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
    }
    if (this._encoding !== enc) throw new Error("can't switch encodings");
    var out = this._decoder.write(value);
    if (fin) out += this._decoder.end();
    return out;
};
module.exports = CipherBase;

},{"631f7eb12d35b579":"eW7r9","5b378a2a05398c5":"j77ns","d42da7de127e1c4b":"3vmkr","7a0f2f27fe0a389b":"bRL3M"}],"j77ns":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;
var EE = require("96b62835346f84f0").EventEmitter;
var inherits = require("4a6ee9586f51c38d");
inherits(Stream, EE);
Stream.Readable = require("e6206e1f4d20abc7");
Stream.Writable = require("a3f1405f37e1dfb1");
Stream.Duplex = require("6691a72c5fc222fd");
Stream.Transform = require("43a905ce7ec6ac9e");
Stream.PassThrough = require("dd715550d7783885");
Stream.finished = require("d90a3520974ec96e");
Stream.pipeline = require("eb2779cfd287c5c9");
// Backwards-compat with node 0.4.x
Stream.Stream = Stream;
// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.
function Stream() {
    EE.call(this);
}
Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
        if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) source.pause();
        }
    }
    source.on("data", ondata);
    function ondrain() {
        if (source.readable && source.resume) source.resume();
    }
    dest.on("drain", ondrain);
    // If the 'end' option is not supplied, dest.end() will be called when
    // source gets the 'end' or 'close' events.  Only dest.end() once.
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
    }
    function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
    }
    // don't leave dangling pipes when there are errors.
    function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) throw er; // Unhandled stream error in pipe.
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    // remove all the event listeners that were added.
    function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    // Allow for unix-like usage: A.pipe(B).pipe(C)
    return dest;
};

},{"96b62835346f84f0":"1VQLm","4a6ee9586f51c38d":"bRL3M","e6206e1f4d20abc7":"6NdbQ","a3f1405f37e1dfb1":"gTkcq","6691a72c5fc222fd":"kKNA3","43a905ce7ec6ac9e":"ba8Mr","dd715550d7783885":"2xP98","d90a3520974ec96e":"aOMy2","eb2779cfd287c5c9":"fyp4t"}],"k1utz":[function(require,module,exports) {
"use strict";
var inherits = require("6a73c7c8ca6b61fa");
var Legacy = require("e1b443c27c833bc0");
var Base = require("7571755cc57fd60e");
var Buffer = require("b8ba1339feab1938").Buffer;
var md5 = require("c00fb3fd28cadeb2");
var RIPEMD160 = require("b7f8eae556813ec1");
var sha = require("40c5a912778271f7");
var ZEROS = Buffer.alloc(128);
function Hmac(alg, key) {
    Base.call(this, "digest");
    if (typeof key === "string") key = Buffer.from(key);
    var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
    this._alg = alg;
    this._key = key;
    if (key.length > blocksize) {
        var hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
        key = hash.update(key).digest();
    } else if (key.length < blocksize) key = Buffer.concat([
        key,
        ZEROS
    ], blocksize);
    var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
    var opad = this._opad = Buffer.allocUnsafe(blocksize);
    for(var i = 0; i < blocksize; i++){
        ipad[i] = key[i] ^ 0x36;
        opad[i] = key[i] ^ 0x5C;
    }
    this._hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
    this._hash.update(ipad);
}
inherits(Hmac, Base);
Hmac.prototype._update = function(data) {
    this._hash.update(data);
};
Hmac.prototype._final = function() {
    var h = this._hash.digest();
    var hash = this._alg === "rmd160" ? new RIPEMD160() : sha(this._alg);
    return hash.update(this._opad).update(h).digest();
};
module.exports = function createHmac(alg, key) {
    alg = alg.toLowerCase();
    if (alg === "rmd160" || alg === "ripemd160") return new Hmac("rmd160", key);
    if (alg === "md5") return new Legacy(md5, key);
    return new Hmac(alg, key);
};

},{"6a73c7c8ca6b61fa":"bRL3M","e1b443c27c833bc0":"kO6k7","7571755cc57fd60e":"g5fTz","b8ba1339feab1938":"eW7r9","c00fb3fd28cadeb2":"h5gRT","b7f8eae556813ec1":"bFDDq","40c5a912778271f7":"jkn7m"}],"kO6k7":[function(require,module,exports) {
"use strict";
var inherits = require("2baf2864ece10f11");
var Buffer = require("c7fb5e22d675c53c").Buffer;
var Base = require("8fdec7d6b96329ea");
var ZEROS = Buffer.alloc(128);
var blocksize = 64;
function Hmac(alg, key) {
    Base.call(this, "digest");
    if (typeof key === "string") key = Buffer.from(key);
    this._alg = alg;
    this._key = key;
    if (key.length > blocksize) key = alg(key);
    else if (key.length < blocksize) key = Buffer.concat([
        key,
        ZEROS
    ], blocksize);
    var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
    var opad = this._opad = Buffer.allocUnsafe(blocksize);
    for(var i = 0; i < blocksize; i++){
        ipad[i] = key[i] ^ 0x36;
        opad[i] = key[i] ^ 0x5C;
    }
    this._hash = [
        ipad
    ];
}
inherits(Hmac, Base);
Hmac.prototype._update = function(data) {
    this._hash.push(data);
};
Hmac.prototype._final = function() {
    var h = this._alg(Buffer.concat(this._hash));
    return this._alg(Buffer.concat([
        this._opad,
        h
    ]));
};
module.exports = Hmac;

},{"2baf2864ece10f11":"bRL3M","c7fb5e22d675c53c":"eW7r9","8fdec7d6b96329ea":"g5fTz"}],"h5gRT":[function(require,module,exports) {
var MD5 = require("f07cc93582c49804");
module.exports = function(buffer) {
    return new MD5().update(buffer).digest();
};

},{"f07cc93582c49804":"45VeE"}],"d8uT8":[function(require,module,exports) {
"use strict";
var createHash = require("2331ee914eecec1b");
var bs58checkBase = require("945e45a6bff39610");
// SHA256(SHA256(buffer))
function sha256x2(buffer) {
    var tmp = createHash("sha256").update(buffer).digest();
    return createHash("sha256").update(tmp).digest();
}
module.exports = bs58checkBase(sha256x2);

},{"2331ee914eecec1b":"2WyL8","945e45a6bff39610":"2NZjP"}],"2NZjP":[function(require,module,exports) {
"use strict";
var base58 = require("caf73c5a4abad99");
var Buffer = require("73eb26535ffb490f").Buffer;
module.exports = function(checksumFn) {
    // Encode a buffer as a base58-check encoded string
    function encode(payload) {
        var checksum = checksumFn(payload);
        return base58.encode(Buffer.concat([
            payload,
            checksum
        ], payload.length + 4));
    }
    function decodeRaw(buffer) {
        var payload = buffer.slice(0, -4);
        var checksum = buffer.slice(-4);
        var newChecksum = checksumFn(payload);
        if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
        return payload;
    }
    // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
    function decodeUnsafe(string) {
        var buffer = base58.decodeUnsafe(string);
        if (!buffer) return;
        return decodeRaw(buffer);
    }
    function decode(string) {
        var buffer = base58.decode(string);
        var payload = decodeRaw(buffer, checksumFn);
        if (!payload) throw new Error("Invalid checksum");
        return payload;
    }
    return {
        encode: encode,
        decode: decode,
        decodeUnsafe: decodeUnsafe
    };
};

},{"caf73c5a4abad99":"4ji3p","73eb26535ffb490f":"eW7r9"}],"4ji3p":[function(require,module,exports) {
var basex = require("819c30266ae09475");
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
module.exports = basex(ALPHABET);

},{"819c30266ae09475":"inVbl"}],"inVbl":[function(require,module,exports) {
"use strict";
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
// @ts-ignore
var _Buffer = require("85b264801a1b57da").Buffer;
function base(ALPHABET) {
    if (ALPHABET.length >= 255) throw new TypeError("Alphabet too long");
    var BASE_MAP = new Uint8Array(256);
    for(var j = 0; j < BASE_MAP.length; j++)BASE_MAP[j] = 255;
    for(var i = 0; i < ALPHABET.length; i++){
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) throw new TypeError(x + " is ambiguous");
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
    ;
    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
    ;
    function encode(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) source = _Buffer.from(source);
        if (!_Buffer.isBuffer(source)) throw new TypeError("Expected Buffer");
        if (source.length === 0) return "";
        // Skip & count leading zeroes.
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while(pbegin !== pend && source[pbegin] === 0){
            pbegin++;
            zeroes++;
        }
        // Allocate enough space in big-endian base58 representation.
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        // Process the bytes.
        while(pbegin !== pend){
            var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
            var i = 0;
            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){
                carry += 256 * b58[it1] >>> 0;
                b58[it1] = carry % BASE >>> 0;
                carry = carry / BASE >>> 0;
            }
            if (carry !== 0) throw new Error("Non-zero carry");
            length = i;
            pbegin++;
        }
        // Skip leading zeroes in base58 result.
        var it2 = size - length;
        while(it2 !== size && b58[it2] === 0)it2++;
        // Translate the result into a string.
        var str = LEADER.repeat(zeroes);
        for(; it2 < size; ++it2)str += ALPHABET.charAt(b58[it2]);
        return str;
    }
    function decodeUnsafe(source) {
        if (typeof source !== "string") throw new TypeError("Expected String");
        if (source.length === 0) return _Buffer.alloc(0);
        var psz = 0;
        // Skip and count leading '1's.
        var zeroes = 0;
        var length = 0;
        while(source[psz] === LEADER){
            zeroes++;
            psz++;
        }
        // Allocate enough space in big-endian base256 representation.
        var size = (source.length - psz) * FACTOR + 1 >>> 0 // log(58) / log(256), rounded up.
        ;
        var b256 = new Uint8Array(size);
        // Process the characters.
        while(psz < source.length){
            // Decode character
            var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
            if (carry === 255) return;
            var i = 0;
            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){
                carry += BASE * b256[it3] >>> 0;
                b256[it3] = carry % 256 >>> 0;
                carry = carry / 256 >>> 0;
            }
            if (carry !== 0) throw new Error("Non-zero carry");
            length = i;
            psz++;
        }
        // Skip leading zeroes in b256.
        var it4 = size - length;
        while(it4 !== size && b256[it4] === 0)it4++;
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
        vch.fill(0x00, 0, zeroes);
        var j = zeroes;
        while(it4 !== size)vch[j++] = b256[it4++];
        return vch;
    }
    function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) return buffer;
        throw new Error("Non-base" + BASE + " character");
    }
    return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
    };
}
module.exports = base;

},{"85b264801a1b57da":"eW7r9"}],"aaqVm":[function(require,module,exports) {
var Buffer = require("995d7b11bd614984").Buffer;
const BN = require("b5ae502c9c4825e7");
const EC = require("4ecf11176bc2b9a1").ec;
const secp256k1 = new EC("secp256k1");
const deterministicGenerateK = require("d64e7ab9ef7ce426");
const ZERO32 = Buffer.alloc(32, 0);
const EC_GROUP_ORDER = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex");
const EC_P = Buffer.from("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f", "hex");
const n = secp256k1.curve.n;
const nDiv2 = n.shrn(1);
const G = secp256k1.curve.g;
const THROW_BAD_PRIVATE = "Expected Private";
const THROW_BAD_POINT = "Expected Point";
const THROW_BAD_TWEAK = "Expected Tweak";
const THROW_BAD_HASH = "Expected Hash";
const THROW_BAD_SIGNATURE = "Expected Signature";
const THROW_BAD_EXTRA_DATA = "Expected Extra Data (32 bytes)";
function isScalar(x) {
    return Buffer.isBuffer(x) && x.length === 32;
}
function isOrderScalar(x) {
    if (!isScalar(x)) return false;
    return x.compare(EC_GROUP_ORDER) < 0 // < G
    ;
}
function isPoint(p) {
    if (!Buffer.isBuffer(p)) return false;
    if (p.length < 33) return false;
    const t = p[0];
    const x = p.slice(1, 33);
    if (x.compare(ZERO32) === 0) return false;
    if (x.compare(EC_P) >= 0) return false;
    if ((t === 0x02 || t === 0x03) && p.length === 33) {
        try {
            decodeFrom(p);
        } catch (e) {
            return false;
        } // TODO: temporary
        return true;
    }
    const y = p.slice(33);
    if (y.compare(ZERO32) === 0) return false;
    if (y.compare(EC_P) >= 0) return false;
    if (t === 0x04 && p.length === 65) return true;
    return false;
}
function __isPointCompressed(p) {
    return p[0] !== 0x04;
}
function isPointCompressed(p) {
    if (!isPoint(p)) return false;
    return __isPointCompressed(p);
}
function isPrivate(x) {
    if (!isScalar(x)) return false;
    return x.compare(ZERO32) > 0 && // > 0
    x.compare(EC_GROUP_ORDER) < 0 // < G
    ;
}
function isSignature(value) {
    const r = value.slice(0, 32);
    const s = value.slice(32, 64);
    return Buffer.isBuffer(value) && value.length === 64 && r.compare(EC_GROUP_ORDER) < 0 && s.compare(EC_GROUP_ORDER) < 0;
}
function assumeCompression(value, pubkey) {
    if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey);
    if (value === undefined) return true;
    return value;
}
function fromBuffer(d) {
    return new BN(d);
}
function toBuffer(d) {
    return d.toArrayLike(Buffer, "be", 32);
}
function decodeFrom(P) {
    return secp256k1.curve.decodePoint(P);
}
function getEncoded(P, compressed) {
    return Buffer.from(P._encode(compressed));
}
function pointAdd(pA, pB, __compressed) {
    if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT);
    if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT);
    const a = decodeFrom(pA);
    const b = decodeFrom(pB);
    const pp = a.add(b);
    if (pp.isInfinity()) return null;
    const compressed = assumeCompression(__compressed, pA);
    return getEncoded(pp, compressed);
}
function pointAddScalar(p, tweak, __compressed) {
    if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);
    if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
    const compressed = assumeCompression(__compressed, p);
    const pp = decodeFrom(p);
    if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed);
    const tt = fromBuffer(tweak);
    const qq = G.mul(tt);
    const uu = pp.add(qq);
    if (uu.isInfinity()) return null;
    return getEncoded(uu, compressed);
}
function pointCompress(p, __compressed) {
    if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);
    const pp = decodeFrom(p);
    if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT);
    const compressed = assumeCompression(__compressed, p);
    return getEncoded(pp, compressed);
}
function pointFromScalar(d, __compressed) {
    if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);
    const dd = fromBuffer(d);
    const pp = G.mul(dd);
    if (pp.isInfinity()) return null;
    const compressed = assumeCompression(__compressed);
    return getEncoded(pp, compressed);
}
function pointMultiply(p, tweak, __compressed) {
    if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);
    if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
    const compressed = assumeCompression(__compressed, p);
    const pp = decodeFrom(p);
    const tt = fromBuffer(tweak);
    const qq = pp.mul(tt);
    if (qq.isInfinity()) return null;
    return getEncoded(qq, compressed);
}
function privateAdd(d, tweak) {
    if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);
    if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
    const dd = fromBuffer(d);
    const tt = fromBuffer(tweak);
    const dt = toBuffer(dd.add(tt).umod(n));
    if (!isPrivate(dt)) return null;
    return dt;
}
function privateSub(d, tweak) {
    if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);
    if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
    const dd = fromBuffer(d);
    const tt = fromBuffer(tweak);
    const dt = toBuffer(dd.sub(tt).umod(n));
    if (!isPrivate(dt)) return null;
    return dt;
}
function sign(hash, x) {
    return __sign(hash, x);
}
function signWithEntropy(hash, x, addData) {
    return __sign(hash, x, addData);
}
function __sign(hash, x, addData) {
    if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH);
    if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE);
    if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA);
    const d = fromBuffer(x);
    const e = fromBuffer(hash);
    let r, s;
    const checkSig = function(k) {
        const kI = fromBuffer(k);
        const Q = G.mul(kI);
        if (Q.isInfinity()) return false;
        r = Q.x.umod(n);
        if (r.isZero() === 0) return false;
        s = kI.invm(n).mul(e.add(d.mul(r))).umod(n);
        if (s.isZero() === 0) return false;
        return true;
    };
    deterministicGenerateK(hash, x, checkSig, isPrivate, addData);
    // enforce low S values, see bip62: 'low s values in signatures'
    if (s.cmp(nDiv2) > 0) s = n.sub(s);
    const buffer = Buffer.allocUnsafe(64);
    toBuffer(r).copy(buffer, 0);
    toBuffer(s).copy(buffer, 32);
    return buffer;
}
function verify(hash, q, signature, strict) {
    if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH);
    if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT);
    // 1.4.1 Enforce r and s are both integers in the interval [1, n  1] (1, isSignature enforces '< n - 1')
    if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE);
    const Q = decodeFrom(q);
    const r = fromBuffer(signature.slice(0, 32));
    const s = fromBuffer(signature.slice(32, 64));
    if (strict && s.cmp(nDiv2) > 0) return false;
    // 1.4.1 Enforce r and s are both integers in the interval [1, n  1] (2, enforces '> 0')
    if (r.gtn(0) <= 0 /* || r.compareTo(n) >= 0 */ ) return false;
    if (s.gtn(0) <= 0 /* || s.compareTo(n) >= 0 */ ) return false;
    // 1.4.2 H = Hash(M), already done by the user
    // 1.4.3 e = H
    const e = fromBuffer(hash);
    // Compute s^-1
    const sInv = s.invm(n);
    // 1.4.4 Compute u1 = es^1 mod n
    //               u2 = rs^1 mod n
    const u1 = e.mul(sInv).umod(n);
    const u2 = r.mul(sInv).umod(n);
    // 1.4.5 Compute R = (xR, yR)
    //               R = u1G + u2Q
    const R = G.mulAdd(u1, Q, u2);
    // 1.4.5 (cont.) Enforce R is not at infinity
    if (R.isInfinity()) return false;
    // 1.4.6 Convert the field element R.x to an integer
    const xR = R.x;
    // 1.4.7 Set v = xR mod n
    const v = xR.umod(n);
    // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"
    return v.eq(r);
}
module.exports = {
    isPoint,
    isPointCompressed,
    isPrivate,
    pointAdd,
    pointAddScalar,
    pointCompress,
    pointFromScalar,
    pointMultiply,
    privateAdd,
    privateSub,
    sign,
    signWithEntropy,
    verify
};

},{"995d7b11bd614984":"bwvMq","b5ae502c9c4825e7":"VopIn","4ecf11176bc2b9a1":"1NKsH","d64e7ab9ef7ce426":"fFC9R"}],"VopIn":[function(require,module,exports) {
(function(module1, exports) {
    "use strict";
    // Utils
    function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
    }
    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
    // BN
    function BN(number, base, endian) {
        if (BN.isBN(number)) return number;
        this.negative = 0;
        this.words = null;
        this.length = 0;
        // Reduction context
        this.red = null;
        if (number !== null) {
            if (base === "le" || base === "be") {
                endian = base;
                base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
        }
    }
    if (typeof module1 === "object") module1.exports = BN;
    else exports.BN = BN;
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;
    try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") Buffer = window.Buffer;
        else Buffer = require("bd440367abe2ded7").Buffer;
    } catch (e) {}
    BN.isBN = function isBN(num) {
        if (num instanceof BN) return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
    };
    BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
    };
    BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") return this._initNumber(number, base, endian);
        if (typeof number === "object") return this._initArray(number, base, endian);
        if (base === "hex") base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
            start++;
            this.negative = 1;
        }
        if (start < number.length) {
            if (base === 16) this._parseHex(number, start, endian);
            else {
                this._parseBase(number, base, start);
                if (endian === "le") this._initArray(this.toArray(), base, endian);
            }
        }
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
            this.negative = 1;
            number = -number;
        }
        if (number < 0x4000000) {
            this.words = [
                number & 0x3ffffff
            ];
            this.length = 1;
        } else if (number < 0x10000000000000) {
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff
            ];
            this.length = 2;
        } else {
            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff,
                1
            ];
            this.length = 3;
        }
        if (endian !== "le") return;
        // Reverse the bytes
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === "number");
        if (number.length <= 0) {
            this.words = [
                0
            ];
            this.length = 1;
            return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        var j, w;
        var off = 0;
        if (endian === "be") for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        else if (endian === "le") for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        return this.strip();
    };
    function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        // 'A' - 'F'
        if (c >= 65 && c <= 70) return c - 55;
        else if (c >= 97 && c <= 102) return c - 87;
        else return c - 48 & 0xf;
    }
    function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) r |= parseHex4Bits(string, index - 1) << 4;
        return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start, endian) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        // 24-bits chunks
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") for(i = number.length - 1; i >= start; i -= 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else off += 8;
        }
        else {
            var parseLength = number.length - start;
            for(i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2){
                w = parseHexByte(number, start, i) << off;
                this.words[j] |= w & 0x3ffffff;
                if (off >= 18) {
                    off -= 18;
                    j += 1;
                    this.words[j] |= w >>> 26;
                } else off += 8;
            }
        }
        this.strip();
    };
    function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            // 'a'
            if (c >= 49) r += c - 49 + 0xa;
            else if (c >= 17) r += c - 17 + 0xa;
            else r += c;
        }
        return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [
            0
        ];
        this.length = 1;
        // Find length of limb in base
        for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)limbLen++;
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for(var i = start; i < end; i += limbLen){
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for(i = 0; i < mod; i++)pow *= base;
            this.imuln(pow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        this.strip();
    };
    BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)dest.words[i] = this.words[i];
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
    };
    BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
    };
    BN.prototype._expand = function _expand(size) {
        while(this.length < size)this.words[this.length++] = 0;
        return this;
    };
    // Remove leading `0` from `this`
    BN.prototype.strip = function strip() {
        while(this.length > 1 && this.words[this.length - 1] === 0)this.length--;
        return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
    };
    BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */ var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
    ];
    var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
    ];
    var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        10000000,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64000000,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        24300000,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for(var i = 0; i < this.length; i++){
                var w = this.words[i];
                var word = ((w << off | carry) & 0xffffff).toString(16);
                carry = w >>> 24 - off & 0xffffff;
                if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out;
                else out = word + out;
                off += 2;
                if (off >= 26) {
                    off -= 26;
                    i--;
                }
            }
            if (carry !== 0) out = carry.toString(16) + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
            var groupSize = groupSizes[base];
            // var groupBase = Math.pow(base, groupSize);
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while(!c.isZero()){
                var r = c.modn(groupBase).toString(base);
                c = c.idivn(groupBase);
                if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;
                else out = r + out;
            }
            if (this.isZero()) out = "0" + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        assert(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) ret += this.words[1] * 0x4000000;
        else if (this.length === 3 && this.words[2] === 0x01) // NOTE: at this stage it is known that the top bit is set
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
        else if (this.length > 2) assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
    };
    BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer !== "undefined");
        return this.toArrayLike(Buffer, endian, length);
    };
    BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
            // Assume big-endian
            for(i = 0; i < reqLength - byteLength; i++)res[i] = 0;
            for(i = 0; !q.isZero(); i++){
                b = q.andln(0xff);
                q.iushrn(8);
                res[reqLength - i - 1] = b;
            }
        } else {
            for(i = 0; !q.isZero(); i++){
                b = q.andln(0xff);
                q.iushrn(8);
                res[i] = b;
            }
            for(; i < reqLength; i++)res[i] = 0;
        }
        return res;
    };
    if (Math.clz32) BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
    else BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
    BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
            r += 13;
            t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
            r += 7;
            t >>>= 7;
        }
        if ((t & 0xf) === 0) {
            r += 4;
            t >>>= 4;
        }
        if ((t & 0x3) === 0) {
            r += 2;
            t >>>= 2;
        }
        if ((t & 0x1) === 0) r++;
        return r;
    };
    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
        var w = new Array(num.bitLength());
        for(var bit = 0; bit < w.length; bit++){
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
    }
    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for(var i = 0; i < this.length; i++){
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
        }
        return r;
    };
    BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);
        return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();
        return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
    };
    // Return negative clone of `this`
    BN.prototype.neg = function neg() {
        return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
    };
    // Or `num` with `this` in-place
    BN.prototype.iuor = function iuor(num) {
        while(this.length < num.length)this.words[this.length++] = 0;
        for(var i = 0; i < num.length; i++)this.words[i] = this.words[i] | num.words[i];
        return this.strip();
    };
    BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
    };
    // Or `num` with `this`
    BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
    };
    // And `num` with `this` in-place
    BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;
        if (this.length > num.length) b = num;
        else b = this;
        for(var i = 0; i < b.length; i++)this.words[i] = this.words[i] & num.words[i];
        this.length = b.length;
        return this.strip();
    };
    BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
    };
    // And `num` with `this`
    BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
    };
    // Xor `num` with `this` in-place
    BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        for(var i = 0; i < b.length; i++)this.words[i] = a.words[i] ^ b.words[i];
        if (this !== a) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = a.length;
        return this.strip();
    };
    BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
    };
    // Xor `num` with `this`
    BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
    };
    // Not ``this`` with ``width`` bitwidth
    BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        // Extend the buffer with leading zeroes
        this._expand(bytesNeeded);
        if (bitsLeft > 0) bytesNeeded--;
        // Handle complete words
        for(var i = 0; i < bytesNeeded; i++)this.words[i] = ~this.words[i] & 0x3ffffff;
        // Handle the residue
        if (bitsLeft > 0) this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        // And remove leading zeroes
        return this.strip();
    };
    BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
    };
    // Set `bit` of `this`
    BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) this.words[off] = this.words[off] | 1 << wbit;
        else this.words[off] = this.words[off] & ~(1 << wbit);
        return this.strip();
    };
    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
        var r;
        // negative + positive
        if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
        // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
        }
        // a.length > b.length
        var a, b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
        // Copy the rest of the words
        } else if (a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        return this;
    };
    // Add `num` to `this`
    BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
        } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
    };
    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
        // -this - num = -(this + num)
        } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
        }
        // At this point both numbers are positive
        var cmp = this.cmp(num);
        // Optimization - zeroify
        if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
        }
        // a > b
        var a, b;
        if (cmp > 0) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = Math.max(this.length, i);
        if (a !== this) this.negative = 1;
        return this.strip();
    };
    // Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
    };
    function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        // Peel one iteration (compiler can't do it, because of code complexity)
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;
        for(var k = 1; k < len; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = carry >>> 26;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j | 0;
                a = self.words[i] | 0;
                b = num.words[j] | 0;
                r = a * b + rword;
                ncarry += r / 0x4000000 | 0;
                rword = r & 0x3ffffff;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
        }
        if (carry !== 0) out.words[k] = carry | 0;
        else out.length--;
        return out.strip();
    }
    // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).
    var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */ lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */ lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */ lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */ lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */ lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */ lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */ lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */ lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */ lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */ lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */ lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */ lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */ lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */ lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */ lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */ lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */ lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */ lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */ lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
            o[19] = c;
            out.length++;
        }
        return out;
    };
    // Polyfill comb
    if (!Math.imul) comb10MulTo = smallMulTo;
    function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for(var k = 0; k < out.length - 1; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j;
                var a = self.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;
                var lo = r & 0x3ffffff;
                ncarry = ncarry + (r / 0x4000000 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 0x3ffffff;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 0x3ffffff;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
        }
        if (carry !== 0) out.words[k] = carry;
        else out.length--;
        return out.strip();
    }
    function jumboMulTo(self, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) res = comb10MulTo(this, num, out);
        else if (len < 63) res = smallMulTo(this, num, out);
        else if (len < 1024) res = bigMulTo(this, num, out);
        else res = jumboMulTo(this, num, out);
        return res;
    };
    // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion
    function FFTM(x, y) {
        this.x = x;
        this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for(var i = 0; i < N; i++)t[i] = this.revBin(i, l, N);
        return t;
    };
    // Returns binary-reversed representation of `x`
    FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for(var i = 0; i < l; i++){
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
        }
        return rb;
    };
    // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for(var i = 0; i < N; i++){
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
        }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for(var s = 1; s < N; s <<= 1){
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for(var p = 0; p < N; p += l){
                var rtwdf_ = rtwdf;
                var itwdf_ = itwdf;
                for(var j = 0; j < s; j++){
                    var re = rtws[p + j];
                    var ie = itws[p + j];
                    var ro = rtws[p + j + s];
                    var io = itws[p + j + s];
                    var rx = rtwdf_ * ro - itwdf_ * io;
                    io = rtwdf_ * io + itwdf_ * ro;
                    ro = rx;
                    rtws[p + j] = re + ro;
                    itws[p + j] = ie + io;
                    rtws[p + j + s] = re - ro;
                    itws[p + j + s] = ie - io;
                    /* jshint maxdepth : false */ if (j !== l) {
                        rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                        itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                        rtwdf_ = rx;
                    }
                }
            }
        }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for(N = N / 2 | 0; N; N = N >>> 1)i++;
        return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for(var i = 0; i < N / 2; i++){
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
        }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for(var i = 0; i < N / 2; i++){
            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 0x3ffffff;
            if (w < 0x4000000) carry = 0;
            else carry = w / 0x4000000 | 0;
        }
        return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for(var i = 0; i < len; i++){
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 0x1fff;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 0x1fff;
            carry = carry >>> 13;
        }
        // Pad with zeroes
        for(i = 2 * len; i < N; ++i)rws[i] = 0;
        assert(carry === 0);
        assert((carry & -8192) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for(var i = 0; i < N; i++)ph[i] = 0;
        return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for(var i = 0; i < N; i++){
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
    };
    // Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
    };
    // Multiply employing FFT
    BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
    };
    // In-place Multiplication
    BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        // Carry
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = (this.words[i] | 0) * num;
            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
            carry >>= 26;
            carry += w / 0x4000000 | 0;
            // NOTE: lo is 27bit maximum
            carry += lo >>> 26;
            this.words[i] = lo & 0x3ffffff;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
    };
    // `this` * `this`
    BN.prototype.sqr = function sqr() {
        return this.mul(this);
    };
    // `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
    };
    // Math.pow(`this`, `num`)
    BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        // Skip leading zeroes
        var res = this;
        for(var i = 0; i < w.length; i++, res = res.sqr()){
            if (w[i] !== 0) break;
        }
        if (++i < w.length) for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
        return res;
    };
    // Shift-left in-place
    BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
            var carry = 0;
            for(i = 0; i < this.length; i++){
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] | 0) - newCarry << r;
                this.words[i] = c | carry;
                carry = newCarry >>> 26 - r;
            }
            if (carry) {
                this.words[i] = carry;
                this.length++;
            }
        }
        if (s !== 0) {
            for(i = this.length - 1; i >= 0; i--)this.words[i + s] = this.words[i];
            for(i = 0; i < s; i++)this.words[i] = 0;
            this.length += s;
        }
        return this.strip();
    };
    BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
    };
    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) h = (hint - hint % 26) / 26;
        else h = 0;
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        // Extended mode, copy masked part
        if (maskedWords) {
            for(var i = 0; i < s; i++)maskedWords.words[i] = this.words[i];
            maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
            this.length -= s;
            for(i = 0; i < this.length; i++)this.words[i] = this.words[i + s];
        } else {
            this.words[0] = 0;
            this.length = 1;
        }
        var carry = 0;
        for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
        }
        // Push carried bits as a mask
        if (maskedWords && carry !== 0) maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
        }
        return this.strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
    };
    // Shift-left
    BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
    };
    // Shift-right
    BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
    };
    // Test if n bit is set
    BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) return false;
        // Check bit and return
        var w = this.words[s];
        return !!(w & q);
    };
    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) return this;
        if (r !== 0) s++;
        this.length = Math.min(s, this.length);
        if (r !== 0) {
            var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
            this.words[this.length - 1] &= mask;
        }
        return this.strip();
    };
    // Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
    };
    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num);
        // Possible sign change
        if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
        }
        // Add without checks
        return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        // Carry
        for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
            this.words[i] -= 0x4000000;
            if (i === this.length - 1) this.words[i + 1] = 1;
            else this.words[i + 1]++;
        }
        this.length = Math.max(this.length, i + 1);
        return this;
    };
    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
        } else // Carry
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
        return this.strip();
    };
    BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
    };
    BN.prototype.abs = function abs() {
        return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for(i = 0; i < num.length; i++){
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 0x3ffffff;
            carry = (w >> 26) - (right / 0x4000000 | 0);
            this.words[i + shift] = w & 0x3ffffff;
        }
        for(; i < this.length - shift; i++){
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 0x3ffffff;
        }
        if (carry === 0) return this.strip();
        // Subtraction overflow
        assert(carry === -1);
        carry = 0;
        for(i = 0; i < this.length; i++){
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
        return this.strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        // Normalize
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
        }
        // Initialize quotient
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for(var i = 0; i < q.length; i++)q.words[i] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
            a = diff;
            if (q) q.words[m] = 1;
        }
        for(var j = m - 1; j >= 0; j--){
            var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
            // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
            // (0x7ffffff)
            qj = Math.min(qj / bhi | 0, 0x3ffffff);
            a._ishlnsubmul(b, qj, j);
            while(a.negative !== 0){
                qj--;
                a.negative = 0;
                a._ishlnsubmul(b, 1, j);
                if (!a.isZero()) a.negative ^= 1;
            }
            if (q) q.words[j] = qj;
        }
        if (q) q.strip();
        a.strip();
        // Denormalize
        if (mode !== "div" && shift !== 0) a.iushrn(shift);
        return {
            div: q || null,
            mod: a
        };
    };
    // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested
    BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) return {
            div: new BN(0),
            mod: new BN(0)
        };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") div = res.div.neg();
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.iadd(num);
            }
            return {
                div: div,
                mod: mod
            };
        }
        if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") div = res.div.neg();
            return {
                div: div,
                mod: res.mod
            };
        }
        if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.isub(num);
            }
            return {
                div: res.div,
                mod: mod
            };
        }
        // Both numbers are positive at this point
        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0) return {
            div: new BN(0),
            mod: this
        };
        // Very short reduction
        if (num.length === 1) {
            if (mode === "div") return {
                div: this.divn(num.words[0]),
                mod: null
            };
            if (mode === "mod") return {
                div: null,
                mod: new BN(this.modn(num.words[0]))
            };
            return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modn(num.words[0]))
            };
        }
        return this._wordDiv(num, mode);
    };
    // Find `this` / `num`
    BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
    };
    // Find `this` % `num`
    BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
    };
    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        // Fast case - exact division
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        // Round down
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        // Round up
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modn = function modn(num) {
        assert(num <= 0x3ffffff);
        var p = 67108864 % num;
        var acc = 0;
        for(var i = this.length - 1; i >= 0; i--)acc = (p * acc + (this.words[i] | 0)) % num;
        return acc;
    };
    // In-place division by number
    BN.prototype.idivn = function idivn(num) {
        assert(num <= 0x3ffffff);
        var carry = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var w = (this.words[i] | 0) + carry * 0x4000000;
            this.words[i] = w / num | 0;
            carry = w % num;
        }
        return this.strip();
    };
    BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) x = x.umod(p);
        else x = x.clone();
        // A * x + B * y = x
        var A = new BN(1);
        var B = new BN(0);
        // C * x + D * y = y
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while(x.isEven() && y.isEven()){
            x.iushrn(1);
            y.iushrn(1);
            ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while(!x.isZero()){
            for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                x.iushrn(i);
                while(i-- > 0){
                    if (A.isOdd() || B.isOdd()) {
                        A.iadd(yp);
                        B.isub(xp);
                    }
                    A.iushrn(1);
                    B.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                y.iushrn(j);
                while(j-- > 0){
                    if (C.isOdd() || D.isOdd()) {
                        C.iadd(yp);
                        D.isub(xp);
                    }
                    C.iushrn(1);
                    D.iushrn(1);
                }
            }
            if (x.cmp(y) >= 0) {
                x.isub(y);
                A.isub(C);
                B.isub(D);
            } else {
                y.isub(x);
                C.isub(A);
                D.isub(B);
            }
        }
        return {
            a: C,
            b: D,
            gcd: y.iushln(g)
        };
    };
    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) a = a.umod(p);
        else a = a.clone();
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
            for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                a.iushrn(i);
                while(i-- > 0){
                    if (x1.isOdd()) x1.iadd(delta);
                    x1.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                b.iushrn(j);
                while(j-- > 0){
                    if (x2.isOdd()) x2.iadd(delta);
                    x2.iushrn(1);
                }
            }
            if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
            } else {
                b.isub(a);
                x2.isub(x1);
            }
        }
        var res;
        if (a.cmpn(1) === 0) res = x1;
        else res = x2;
        if (res.cmpn(0) < 0) res.iadd(p);
        return res;
    };
    BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        // Remove common factor of two
        for(var shift = 0; a.isEven() && b.isEven(); shift++){
            a.iushrn(1);
            b.iushrn(1);
        }
        do {
            while(a.isEven())a.iushrn(1);
            while(b.isEven())b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
                // Swap `a` and `b` to make `a` always bigger than `b`
                var t = a;
                a = b;
                b = t;
            } else if (r === 0 || b.cmpn(1) === 0) break;
            a.isub(b);
        }while (true);
        return b.iushln(shift);
    };
    // Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
    };
    // And first word and num
    BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
    };
    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
        }
        // Add bit and propagate, if needed
        var carry = q;
        for(var i = s; carry !== 0 && i < this.length; i++){
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 0x3ffffff;
            this.words[i] = w;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) res = 1;
        else {
            if (negative) num = -num;
            assert(num <= 0x3ffffff, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) res = -1;
            else if (a > b) res = 1;
            break;
        }
        return res;
    };
    BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
    };
    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red(num) {
        return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
    };
    // Square root over p
    BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
    };
    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
    };
    // Prime numbers with efficient reduction
    var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };
    // Pseudo-Mersenne prime
    function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;
        do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
        }while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
        } else if (cmp > 0) r.isub(this.p);
        else if (r.strip !== undefined) // r is BN v4 instance
        r.strip();
        else // r is BN v5 instance
        r._strip();
        return r;
    };
    MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
    };
    function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);
        for(var i = 0; i < outLen; i++)output.words[i] = input.words[i];
        output.length = outLen;
        if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
        }
        // Shift by 9 limbs
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for(i = 10; i < input.length; i++){
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) input.length -= 10;
        else input.length -= 9;
    };
    K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
        var lo = 0;
        for(var i = 0; i < num.length; i++){
            var w = num.words[i] | 0;
            lo += w * 0x3d1;
            num.words[i] = lo & 0x3ffffff;
            lo = w * 0x40 + (lo / 0x4000000 | 0);
        }
        // Fast length reduction
        if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) num.length--;
        }
        return num;
    };
    function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;
        for(var i = 0; i < num.length; i++){
            var hi = (num.words[i] | 0) * 0x13 + carry;
            var lo = hi & 0x3ffffff;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
        }
        if (carry !== 0) num.words[num.length++] = carry;
        return num;
    };
    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;
        if (name === "k256") prime = new K256();
        else if (name === "p224") prime = new P224();
        else if (name === "p192") prime = new P192();
        else if (name === "p25519") prime = new P25519();
        else throw new Error("Unknown prime " + name);
        primes[name] = prime;
        return prime;
    };
    //
    // Base reduction engine
    //
    function Red(m) {
        if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
        } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
        }
    }
    Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg(a) {
        if (a.isZero()) return a.clone();
        return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res;
    };
    Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res;
    };
    Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        // Fast case
        if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
        }
        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while(!q.isZero() && q.andln(1) === 0){
            s++;
            q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while(this.pow(z, lpow).cmp(nOne) !== 0)z.redIAdd(nOne);
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while(t.cmp(one) !== 0){
            var tmp = t;
            for(var i = 0; tmp.cmp(one) !== 0; i++)tmp = tmp.redSqr();
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }
        return r;
    };
    Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
        } else return this.imod(inv);
    };
    Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for(var i = 2; i < wnd.length; i++)wnd[i] = this.mul(wnd[i - 1], a);
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) start = 26;
        for(i = num.length - 1; i >= 0; i--){
            var word = num.words[i];
            for(var j = start - 1; j >= 0; j--){
                var bit = word >> j & 1;
                if (res !== wnd[0]) res = this.sqr(res);
                if (bit === 0 && current === 0) {
                    currentLen = 0;
                    continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
            }
            start = 26;
        }
        return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
    };
    //
    // Montgomery method engine
    //
    BN.mont = function mont(num) {
        return new Mont(num);
    };
    function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    };
    Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
    };
})(module, this);

},{"bd440367abe2ded7":"jhUEF"}],"1NKsH":[function(require,module,exports) {
"use strict";
var elliptic = exports;
elliptic.version = require("e6672bc3ba1c9961").version;
elliptic.utils = require("5bc72f89931ad0f5");
elliptic.rand = require("7f90d752a36f35cf");
elliptic.curve = require("d11da69c91421223");
elliptic.curves = require("6845bad4ed92c3e4");
// Protocols
elliptic.ec = require("b5f2e1f615acc4b");
elliptic.eddsa = require("79ae761761517980");

},{"e6672bc3ba1c9961":"bvED4","5bc72f89931ad0f5":"8sNT5","7f90d752a36f35cf":"8FGdh","d11da69c91421223":"72OoG","6845bad4ed92c3e4":"6yRo9","b5f2e1f615acc4b":"5gDK1","79ae761761517980":"jPbam"}],"bvED4":[function(require,module,exports) {
module.exports = JSON.parse('{"name":"elliptic","version":"6.5.7","description":"EC cryptography","main":"lib/elliptic.js","files":["lib"],"scripts":{"lint":"eslint lib test","lint:fix":"npm run lint -- --fix","unit":"istanbul test _mocha --reporter=spec test/index.js","test":"npm run lint && npm run unit","version":"grunt dist && git add dist/"},"repository":{"type":"git","url":"git@github.com:indutny/elliptic"},"keywords":["EC","Elliptic","curve","Cryptography"],"author":"Fedor Indutny <fedor@indutny.com>","license":"MIT","bugs":{"url":"https://github.com/indutny/elliptic/issues"},"homepage":"https://github.com/indutny/elliptic","devDependencies":{"brfs":"^2.0.2","coveralls":"^3.1.0","eslint":"^7.6.0","grunt":"^1.2.1","grunt-browserify":"^5.3.0","grunt-cli":"^1.3.2","grunt-contrib-connect":"^3.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^5.0.0","grunt-mocha-istanbul":"^5.0.2","grunt-saucelabs":"^9.0.1","istanbul":"^0.4.5","mocha":"^8.0.1"},"dependencies":{"bn.js":"^4.11.9","brorand":"^1.1.0","hash.js":"^1.0.0","hmac-drbg":"^1.0.1","inherits":"^2.0.4","minimalistic-assert":"^1.0.1","minimalistic-crypto-utils":"^1.0.1"}}');

},{}],"8sNT5":[function(require,module,exports) {
"use strict";
var utils = exports;
var BN = require("f4cbcf6f6eb25ca0");
var minAssert = require("d8ee30463f95a0fd");
var minUtils = require("997429d6bbd82d59");
utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;
// Represent num in a w-NAF form
function getNAF(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    var i;
    for(i = 0; i < naf.length; i += 1)naf[i] = 0;
    var ws = 1 << w + 1;
    var k = num.clone();
    for(i = 0; i < naf.length; i++){
        var z;
        var mod = k.andln(ws - 1);
        if (k.isOdd()) {
            if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;
            else z = mod;
            k.isubn(z);
        } else z = 0;
        naf[i] = z;
        k.iushrn(1);
    }
    return naf;
}
utils.getNAF = getNAF;
// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
    var jsf = [
        [],
        []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while(k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0){
        // First phase
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3) m14 = -1;
        if (m24 === 3) m24 = -1;
        var u1;
        if ((m14 & 1) === 0) u1 = 0;
        else {
            m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;
            else u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) u2 = 0;
        else {
            m8 = k2.andln(7) + d2 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;
            else u2 = m24;
        }
        jsf[1].push(u2);
        // Second phase
        if (2 * d1 === u1 + 1) d1 = 1 - d1;
        if (2 * d2 === u2 + 1) d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
    }
    return jsf;
}
utils.getJSF = getJSF;
function cachedProperty(obj, name, computer) {
    var key = "_" + name;
    obj.prototype[name] = function cachedProperty() {
        return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
    };
}
utils.cachedProperty = cachedProperty;
function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
}
utils.parseBytes = parseBytes;
function intFromLE(bytes) {
    return new BN(bytes, "hex", "le");
}
utils.intFromLE = intFromLE;

},{"f4cbcf6f6eb25ca0":"VopIn","d8ee30463f95a0fd":"8OvWh","997429d6bbd82d59":"6f39G"}],"8OvWh":[function(require,module,exports) {
module.exports = assert;
function assert(val, msg) {
    if (!val) throw new Error(msg || "Assertion failed");
}
assert.equal = function assertEqual(l, r, msg) {
    if (l != r) throw new Error(msg || "Assertion failed: " + l + " != " + r);
};

},{}],"6f39G":[function(require,module,exports) {
"use strict";
var utils = exports;
function toArray(msg, enc) {
    if (Array.isArray(msg)) return msg.slice();
    if (!msg) return [];
    var res = [];
    if (typeof msg !== "string") {
        for(var i = 0; i < msg.length; i++)res[i] = msg[i] | 0;
        return res;
    }
    if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0) msg = "0" + msg;
        for(var i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else for(var i = 0; i < msg.length; i++){
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi) res.push(hi, lo);
        else res.push(lo);
    }
    return res;
}
utils.toArray = toArray;
function zero2(word) {
    if (word.length === 1) return "0" + word;
    else return word;
}
utils.zero2 = zero2;
function toHex(msg) {
    var res = "";
    for(var i = 0; i < msg.length; i++)res += zero2(msg[i].toString(16));
    return res;
}
utils.toHex = toHex;
utils.encode = function encode(arr, enc) {
    if (enc === "hex") return toHex(arr);
    else return arr;
};

},{}],"8FGdh":[function(require,module,exports) {
var r;
module.exports = function rand(len) {
    if (!r) r = new Rand(null);
    return r.generate(len);
};
function Rand(rand) {
    this.rand = rand;
}
module.exports.Rand = Rand;
Rand.prototype.generate = function generate(len) {
    return this._rand(len);
};
// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
    if (this.rand.getBytes) return this.rand.getBytes(n);
    var res = new Uint8Array(n);
    for(var i = 0; i < res.length; i++)res[i] = this.rand.getByte();
    return res;
};
if (typeof self === "object") {
    if (self.crypto && self.crypto.getRandomValues) // Modern browsers
    Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.crypto.getRandomValues(arr);
        return arr;
    };
    else if (self.msCrypto && self.msCrypto.getRandomValues) // IE
    Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.msCrypto.getRandomValues(arr);
        return arr;
    };
    else if (typeof window === "object") // Old junk
    Rand.prototype._rand = function() {
        throw new Error("Not implemented yet");
    };
} else // Node.js or Web worker with no crypto support
try {
    var crypto = require("e8ad0674730919a8");
    if (typeof crypto.randomBytes !== "function") throw new Error("Not supported");
    Rand.prototype._rand = function _rand(n) {
        return crypto.randomBytes(n);
    };
} catch (e) {}

},{"e8ad0674730919a8":"jhUEF"}],"72OoG":[function(require,module,exports) {
"use strict";
var curve = exports;
curve.base = require("59d486bd2037506a");
curve.short = require("eb37617ef6927580");
curve.mont = require("be9c662572da2183");
curve.edwards = require("60763dd06fe64e8d");

},{"59d486bd2037506a":"kvY1a","eb37617ef6927580":"e7TRt","be9c662572da2183":"2JhQH","60763dd06fe64e8d":"3idNZ"}],"kvY1a":[function(require,module,exports) {
"use strict";
var BN = require("70865a568c61cc60");
var utils = require("fb5111a3810a8235");
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;
function BaseCurve(type, conf) {
    this.type = type;
    this.p = new BN(conf.p, 16);
    // Use Montgomery, when there is no fast reduction for the prime
    this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
    // Useful for many curves
    this.zero = new BN(0).toRed(this.red);
    this.one = new BN(1).toRed(this.red);
    this.two = new BN(2).toRed(this.red);
    // Curve configuration, optional
    this.n = conf.n && new BN(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    // Temporary arrays
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    // Generalized Greg Maxwell's trick
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) this.redN = null;
    else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
    }
}
module.exports = BaseCurve;
BaseCurve.prototype.point = function point() {
    throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate() {
    throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    assert(p.precomputed);
    var doubles = p._getDoubles();
    var naf = getNAF(k, 1, this._bitLength);
    var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
    // Translate into more windowed form
    var repr = [];
    var j;
    var nafW;
    for(j = 0; j < naf.length; j += doubles.step){
        nafW = 0;
        for(var l = j + doubles.step - 1; l >= j; l--)nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
    }
    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);
    for(var i = I; i > 0; i--){
        for(j = 0; j < repr.length; j++){
            nafW = repr[j];
            if (nafW === i) b = b.mixedAdd(doubles.points[j]);
            else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
    }
    return a.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    var w = 4;
    // Precompute window
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
    // Get NAF form
    var naf = getNAF(k, w, this._bitLength);
    // Add `this`*(N+1) for every w-NAF index
    var acc = this.jpoint(null, null, null);
    for(var i = naf.length - 1; i >= 0; i--){
        // Count zeroes
        for(var l = 0; i >= 0 && naf[i] === 0; i--)l++;
        if (i >= 0) l++;
        acc = acc.dblp(l);
        if (i < 0) break;
        var z = naf[i];
        assert(z !== 0);
        if (p.type === "affine") {
            // J +- P
            if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]);
            else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else // J +- J
        if (z > 0) acc = acc.add(wnd[z - 1 >> 1]);
        else acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
    return p.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    // Fill all arrays
    var max = 0;
    var i;
    var j;
    var p;
    for(i = 0; i < len; i++){
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
    }
    // Comb small window NAFs
    for(i = len - 1; i >= 1; i -= 2){
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
            max = Math.max(naf[a].length, max);
            max = Math.max(naf[b].length, max);
            continue;
        }
        var comb = [
            points[a],
            /* 1 */ null,
            /* 3 */ null,
            /* 5 */ points[b]
        ];
        // Try to avoid Projective points, if possible
        if (points[a].y.cmp(points[b].y) === 0) {
            comb[1] = points[a].add(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
        } else {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
            -3,
            /* -1 -1 */ -1,
            /* -1 0 */ -5,
            /* -1 1 */ -7,
            /* 0 -1 */ 0,
            /* 0 0 */ 7,
            /* 0 1 */ 5,
            /* 1 -1 */ 1,
            /* 1 0 */ 3
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for(j = 0; j < max; j++){
            var ja = jsf[0][j] | 0;
            var jb = jsf[1][j] | 0;
            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
            naf[b][j] = 0;
            wnd[a] = comb;
        }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for(i = max; i >= 0; i--){
        var k = 0;
        while(i >= 0){
            var zero = true;
            for(j = 0; j < len; j++){
                tmp[j] = naf[j][i] | 0;
                if (tmp[j] !== 0) zero = false;
            }
            if (!zero) break;
            k++;
            i--;
        }
        if (i >= 0) k++;
        acc = acc.dblp(k);
        if (i < 0) break;
        for(j = 0; j < len; j++){
            var z = tmp[j];
            p;
            if (z === 0) continue;
            else if (z > 0) p = wnd[j][z - 1 >> 1];
            else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
            if (p.type === "affine") acc = acc.mixedAdd(p);
            else acc = acc.add(p);
        }
    }
    // Zeroify references
    for(i = 0; i < len; i++)wnd[i] = null;
    if (jacobianResult) return acc;
    else return acc.toP();
};
function BasePoint(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
    throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils.toArray(bytes, enc);
    var len = this.p.byteLength();
    // uncompressed, hybrid-odd, hybrid-even
    if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 0x06) assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 0x07) assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
        return res;
    } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
    throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode(compact) {
    var len = this.curve.p.byteLength();
    var x = this.getX().toArray("be", len);
    if (compact) return [
        this.getY().isEven() ? 0x02 : 0x03
    ].concat(x);
    return [
        0x04
    ].concat(x, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode(enc, compact) {
    return utils.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed) return this;
    var precomputed = {
        doubles: null,
        naf: null,
        beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    if (!this.precomputed) return false;
    var doubles = this.precomputed.doubles;
    if (!doubles) return false;
    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
    var doubles = [
        this
    ];
    var acc = this;
    for(var i = 0; i < power; i += step){
        for(var j = 0; j < step; j++)acc = acc.dbl();
        doubles.push(acc);
    }
    return {
        step: step,
        points: doubles
    };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
    var res = [
        this
    ];
    var max = (1 << wnd) - 1;
    var dbl = max === 1 ? null : this.dbl();
    for(var i = 1; i < max; i++)res[i] = res[i - 1].add(dbl);
    return {
        wnd: wnd,
        points: res
    };
};
BasePoint.prototype._getBeta = function _getBeta() {
    return null;
};
BasePoint.prototype.dblp = function dblp(k) {
    var r = this;
    for(var i = 0; i < k; i++)r = r.dbl();
    return r;
};

},{"70865a568c61cc60":"VopIn","fb5111a3810a8235":"8sNT5"}],"e7TRt":[function(require,module,exports) {
"use strict";
var utils = require("89f794ef417dc31c");
var BN = require("c314b0ac30b69c4a");
var inherits = require("6ac4d7c73f24ab9c");
var Base = require("6e622edb7498c94");
var assert = utils.assert;
function ShortCurve(conf) {
    Base.call(this, "short", conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    // If the curve is endomorphic, precalculate beta and lambda
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    // No efficient endomorphism
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;
    // Compute beta and lambda, that lambda * P = (beta * Px; Py)
    var beta;
    var lambda;
    if (conf.beta) beta = new BN(conf.beta, 16).toRed(this.red);
    else {
        var betas = this._getEndoRoots(this.p);
        // Choose the smallest beta
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
    }
    if (conf.lambda) lambda = new BN(conf.lambda, 16);
    else {
        // Choose the lambda that is matching selected beta
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) lambda = lambdas[0];
        else {
            lambda = lambdas[1];
            assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
    }
    // Get basis vectors, used for balanced length-two representation
    var basis;
    if (conf.basis) basis = conf.basis.map(function(vec) {
        return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
        };
    });
    else basis = this._getEndoBasis(lambda);
    return {
        beta: beta,
        lambda: lambda,
        basis: basis
    };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    // Find roots of for x^2 + x + 1 in F
    // Root = (-1 +- Sqrt(-3)) / 2
    //
    var red = num === this.p ? this.red : BN.mont(num);
    var tinv = new BN(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [
        l1,
        l2
    ];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    // aprxSqrt >= sqrt(this.n)
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    // 3.74
    // Run EGCD, until r(L + 1) < aprxSqrt
    var u = lambda;
    var v = this.n.clone();
    var x1 = new BN(1);
    var y1 = new BN(0);
    var x2 = new BN(0);
    var y2 = new BN(1);
    // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
    var a0;
    var b0;
    // First vector
    var a1;
    var b1;
    // Second vector
    var a2;
    var b2;
    var prevR;
    var i = 0;
    var r;
    var x;
    while(u.cmpn(0) !== 0){
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
            a0 = prevR.neg();
            b0 = x1;
            a1 = r.neg();
            b1 = x;
        } else if (a1 && ++i === 2) break;
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
    }
    a2 = r.neg();
    b2 = x;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
    }
    // Normalize signs
    if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
    }
    if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
    }
    return [
        {
            a: a1,
            b: b1
        },
        {
            a: a2,
            b: b2
        }
    ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k).divRound(this.n);
    var c2 = v1.b.neg().mul(k).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    // Calculate answer
    var k1 = k.sub(p1).sub(p2);
    var k2 = q1.add(q2).neg();
    return {
        k1: k1,
        k2: k2
    };
};
ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red) x = x.toRed(this.red);
    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error("invalid point");
    // XXX Is there any way to tell if the number is odd without converting it
    // to non-red form?
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
    return this.point(x, y);
};
ShortCurve.prototype.validate = function validate(point) {
    if (point.inf) return true;
    var x = point.x;
    var y = point.y;
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for(var i = 0; i < points.length; i++){
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
            split.k1.ineg();
            p = p.neg(true);
        }
        if (split.k2.negative) {
            split.k2.ineg();
            beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
    // Clean-up references to points and coefficients
    for(var j = 0; j < i * 2; j++){
        npoints[j] = null;
        ncoeffs[j] = null;
    }
    return res;
};
function Point(curve, x, y, isRed) {
    Base.BasePoint.call(this, curve, "affine");
    if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
    } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        // Force redgomery representation when loading from JSON
        if (isRed) {
            this.x.forceRed(this.curve.red);
            this.y.forceRed(this.curve.red);
        }
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        this.inf = false;
    }
}
inherits(Point, Base.BasePoint);
ShortCurve.prototype.point = function point(x, y, isRed) {
    return new Point(this, x, y, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo) return;
    var pre = this.precomputed;
    if (pre && pre.beta) return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
            return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
            beta: null,
            naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: pre.naf.points.map(endoMul)
            },
            doubles: pre.doubles && {
                step: pre.doubles.step,
                points: pre.doubles.points.map(endoMul)
            }
        };
    }
    return beta;
};
Point.prototype.toJSON = function toJSON() {
    if (!this.precomputed) return [
        this.x,
        this.y
    ];
    return [
        this.x,
        this.y,
        this.precomputed && {
            doubles: this.precomputed.doubles && {
                step: this.precomputed.doubles.step,
                points: this.precomputed.doubles.points.slice(1)
            },
            naf: this.precomputed.naf && {
                wnd: this.precomputed.naf.wnd,
                points: this.precomputed.naf.points.slice(1)
            }
        }
    ];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === "string") obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2]) return res;
    function obj2point(obj) {
        return curve.point(obj[0], obj[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
            step: pre.doubles.step,
            points: [
                res
            ].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: [
                res
            ].concat(pre.naf.points.map(obj2point))
        }
    };
    return res;
};
Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
};
Point.prototype.add = function add(p) {
    // O + P = P
    if (this.inf) return p;
    // P + O = P
    if (p.inf) return this;
    // P + P = 2P
    if (this.eq(p)) return this.dbl();
    // P + (-P) = O
    if (this.neg().eq(p)) return this.curve.point(null, null);
    // P + Q = O
    if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
    if (this.inf) return this;
    // 2P = O
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
    var a = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
    return this.x.fromRed();
};
Point.prototype.getY = function getY() {
    return this.y.fromRed();
};
Point.prototype.mul = function mul(k) {
    k = new BN(k, 16);
    if (this.isInfinity()) return this;
    else if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);
    else if (this.curve.endo) return this.curve._endoWnafMulAdd([
        this
    ], [
        k
    ]);
    else return this.curve._wnafMul(this, k);
};
Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [
        this,
        p2
    ];
    var coeffs = [
        k1,
        k2
    ];
    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs);
    else return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [
        this,
        p2
    ];
    var coeffs = [
        k1,
        k2
    ];
    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true);
    else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq(p) {
    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
    if (this.inf) return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
            return p.neg();
        };
        res.precomputed = {
            naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: pre.naf.points.map(negate)
            },
            doubles: pre.doubles && {
                step: pre.doubles.step,
                points: pre.doubles.points.map(negate)
            }
        };
    }
    return res;
};
Point.prototype.toJ = function toJ() {
    if (this.inf) return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
};
function JPoint(curve, x, y, z) {
    Base.BasePoint.call(this, curve, "jacobian");
    if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
    } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = new BN(z, 16);
    }
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
};
JPoint.prototype.toP = function toP() {
    if (this.isInfinity()) return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add(p) {
    // O + P = P
    if (this.isInfinity()) return p;
    // P + O = P
    if (p.isInfinity()) return this;
    // 12M + 4S + 7A
    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s2 = p.y.redMul(z2.redMul(this.z));
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
        else return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p.z).redMul(h);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p) {
    // O + P = P
    if (this.isInfinity()) return p.toJ();
    // P + O = P
    if (p.isInfinity()) return this;
    // 8M + 3S + 7A
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s2 = p.y.redMul(z2).redMul(this.z);
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
        else return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0) return this;
    if (this.isInfinity()) return this;
    if (!pow) return this.dbl();
    var i;
    if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for(i = 0; i < pow; i++)r = r.dbl();
        return r;
    }
    // 1M + 2S + 1A + N * (4S + 5M + 8A)
    // N = 1 => 6M + 6S + 9A
    var a = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    // Reuse results
    var jyd = jy.redAdd(jy);
    for(i = 0; i < pow; i++){
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity()) return this;
    if (this.curve.zeroA) return this._zeroDbl();
    else if (this.curve.threeA) return this._threeDbl();
    else return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    // Z = 1
    if (this.zOne) {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
        //     #doubling-mdbl-2007-bl
        // 1M + 5S + 14A
        // XX = X1^2
        var xx = this.x.redSqr();
        // YY = Y1^2
        var yy = this.y.redSqr();
        // YYYY = YY^2
        var yyyy = yy.redSqr();
        // S = 2 * ((X1 + YY)^2 - XX - YYYY)
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        // M = 3 * XX + a; a = 0
        var m = xx.redAdd(xx).redIAdd(xx);
        // T = M ^ 2 - 2*S
        var t = m.redSqr().redISub(s).redISub(s);
        // 8 * YYYY
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        // X3 = T
        nx = t;
        // Y3 = M * (S - T) - 8 * YYYY
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        // Z3 = 2*Y1
        nz = this.y.redAdd(this.y);
    } else {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
        //     #doubling-dbl-2009-l
        // 2M + 5S + 13A
        // A = X1^2
        var a = this.x.redSqr();
        // B = Y1^2
        var b = this.y.redSqr();
        // C = B^2
        var c = b.redSqr();
        // D = 2 * ((X1 + B)^2 - A - C)
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        // E = 3 * A
        var e = a.redAdd(a).redIAdd(a);
        // F = E^2
        var f = e.redSqr();
        // 8 * C
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        // X3 = F - 2 * D
        nx = f.redISub(d).redISub(d);
        // Y3 = E * (D - X3) - 8 * C
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        // Z3 = 2 * Y1 * Z1
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    // Z = 1
    if (this.zOne) {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
        //     #doubling-mdbl-2007-bl
        // 1M + 5S + 15A
        // XX = X1^2
        var xx = this.x.redSqr();
        // YY = Y1^2
        var yy = this.y.redSqr();
        // YYYY = YY^2
        var yyyy = yy.redSqr();
        // S = 2 * ((X1 + YY)^2 - XX - YYYY)
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        // M = 3 * XX + a
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        // T = M^2 - 2 * S
        var t = m.redSqr().redISub(s).redISub(s);
        // X3 = T
        nx = t;
        // Y3 = M * (S - T) - 8 * YYYY
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        // Z3 = 2 * Y1
        nz = this.y.redAdd(this.y);
    } else {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
        // 3M + 5S
        // delta = Z1^2
        var delta = this.z.redSqr();
        // gamma = Y1^2
        var gamma = this.y.redSqr();
        // beta = X1 * gamma
        var beta = this.x.redMul(gamma);
        // alpha = 3 * (X1 - delta) * (X1 + delta)
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        // X3 = alpha^2 - 8 * beta
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        // Z3 = (Y1 + Z1)^2 - gamma - delta
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;
    // 4M + 6S + 10A
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA) return this.dbl().add(this);
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
    // 5M + 10S + ...
    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // ZZ = Z1^2
    var zz = this.z.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // M = 3 * XX + a * ZZ2; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // MM = M^2
    var mm = m.redSqr();
    // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    // EE = E^2
    var ee = e.redSqr();
    // T = 16*YYYY
    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    // U = (M + E)^2 - MM - EE - T
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    // X3 = 4 * (X1 * EE - 4 * YY * U)
    var yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    // Z3 = (Z1 + E)^2 - ZZ - EE
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul(k, kbase) {
    k = new BN(k, kbase);
    return this.curve._wnafMul(this, k);
};
JPoint.prototype.eq = function eq(p) {
    if (p.type === "affine") return this.eq(p.toJ());
    if (this === p) return true;
    // x1 * z2^2 == x2 * z1^2
    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false;
    // y1 * z2^3 == y2 * z1^3
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0) return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(zs);
    for(;;){
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0) return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0) return true;
    }
};
JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC JPoint Infinity>";
    return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.z.cmpn(0) === 0;
};

},{"89f794ef417dc31c":"8sNT5","c314b0ac30b69c4a":"VopIn","6ac4d7c73f24ab9c":"bRL3M","6e622edb7498c94":"kvY1a"}],"2JhQH":[function(require,module,exports) {
"use strict";
var BN = require("ebdf19f04f3ed250");
var inherits = require("cb5bb4841a749f68");
var Base = require("51280941230b3f98");
var utils = require("ea7949a80be00261");
function MontCurve(conf) {
    Base.call(this, "mont", conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.i4 = new BN(4).toRed(this.red).redInvm();
    this.two = new BN(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;
MontCurve.prototype.validate = function validate(point) {
    var x = point.normalize().x;
    var x2 = x.redSqr();
    var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
    var y = rhs.redSqrt();
    return y.redSqr().cmp(rhs) === 0;
};
function Point(curve, x, z) {
    Base.BasePoint.call(this, curve, "projective");
    if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
    } else {
        this.x = new BN(x, 16);
        this.z = new BN(z, 16);
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    }
}
inherits(Point, Base.BasePoint);
MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    return this.point(utils.toArray(bytes, enc), 1);
};
MontCurve.prototype.point = function point(x, z) {
    return new Point(this, x, z);
};
MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
};
Point.prototype.precompute = function precompute() {
// No-op
};
Point.prototype._encode = function _encode() {
    return this.getX().toArray("be", this.curve.p.byteLength());
};
Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1] || curve.one);
};
Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.z.cmpn(0) === 0;
};
Point.prototype.dbl = function dbl() {
    // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
    // 2M + 2S + 4A
    // A = X1 + Z1
    var a = this.x.redAdd(this.z);
    // AA = A^2
    var aa = a.redSqr();
    // B = X1 - Z1
    var b = this.x.redSub(this.z);
    // BB = B^2
    var bb = b.redSqr();
    // C = AA - BB
    var c = aa.redSub(bb);
    // X3 = AA * BB
    var nx = aa.redMul(bb);
    // Z3 = C * (BB + A24 * C)
    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    return this.curve.point(nx, nz);
};
Point.prototype.add = function add() {
    throw new Error("Not supported on Montgomery curve");
};
Point.prototype.diffAdd = function diffAdd(p, diff) {
    // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
    // 4M + 2S + 6A
    // A = X2 + Z2
    var a = this.x.redAdd(this.z);
    // B = X2 - Z2
    var b = this.x.redSub(this.z);
    // C = X3 + Z3
    var c = p.x.redAdd(p.z);
    // D = X3 - Z3
    var d = p.x.redSub(p.z);
    // DA = D * A
    var da = d.redMul(a);
    // CB = C * B
    var cb = c.redMul(b);
    // X5 = Z1 * (DA + CB)^2
    var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    // Z5 = X1 * (DA - CB)^2
    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
};
Point.prototype.mul = function mul(k) {
    var t = k.clone();
    var a = this; // (N / 2) * Q + Q
    var b = this.curve.point(null, null); // (N / 2) * Q
    var c = this; // Q
    for(var bits = []; t.cmpn(0) !== 0; t.iushrn(1))bits.push(t.andln(1));
    for(var i = bits.length - 1; i >= 0; i--)if (bits[i] === 0) {
        // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
        a = a.diffAdd(b, c);
        // N * Q = 2 * ((N / 2) * Q + Q))
        b = b.dbl();
    } else {
        // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
        b = a.diffAdd(b, c);
        // N * Q + Q = 2 * ((N / 2) * Q + Q)
        a = a.dbl();
    }
    return b;
};
Point.prototype.mulAdd = function mulAdd() {
    throw new Error("Not supported on Montgomery curve");
};
Point.prototype.jumlAdd = function jumlAdd() {
    throw new Error("Not supported on Montgomery curve");
};
Point.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
};
Point.prototype.normalize = function normalize() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
};
Point.prototype.getX = function getX() {
    // Normalize coordinates
    this.normalize();
    return this.x.fromRed();
};

},{"ebdf19f04f3ed250":"VopIn","cb5bb4841a749f68":"bRL3M","51280941230b3f98":"kvY1a","ea7949a80be00261":"8sNT5"}],"3idNZ":[function(require,module,exports) {
"use strict";
var utils = require("7bd66a4710450b08");
var BN = require("ccef46dcf03d45c6");
var inherits = require("19937272cbe23c92");
var Base = require("108c8ead5f54502b");
var assert = utils.assert;
function EdwardsCurve(conf) {
    // NOTE: Important as we are creating point in Base.call()
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    Base.call(this, "edwards", conf);
    this.a = new BN(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;
EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA) return num.redNeg();
    else return this.a.redMul(num);
};
EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC) return num;
    else return this.c.redMul(num);
};
// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
    return this.point(x, y, z, t);
};
EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red) x = x.toRed(this.red);
    var x2 = x.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x2));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
    var y2 = rhs.redMul(lhs.redInvm());
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error("invalid point");
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
    return this.point(x, y);
};
EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
    y = new BN(y, 16);
    if (!y.red) y = y.toRed(this.red);
    // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
    var y2 = y.redSqr();
    var lhs = y2.redSub(this.c2);
    var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
    var x2 = lhs.redMul(rhs.redInvm());
    if (x2.cmp(this.zero) === 0) {
        if (odd) throw new Error("invalid point");
        else return this.point(this.zero, y);
    }
    var x = x2.redSqrt();
    if (x.redSqr().redSub(x2).cmp(this.zero) !== 0) throw new Error("invalid point");
    if (x.fromRed().isOdd() !== odd) x = x.redNeg();
    return this.point(x, y);
};
EdwardsCurve.prototype.validate = function validate(point) {
    if (point.isInfinity()) return true;
    // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
    point.normalize();
    var x2 = point.x.redSqr();
    var y2 = point.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y2);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
    return lhs.cmp(rhs) === 0;
};
function Point(curve, x, y, z, t) {
    Base.BasePoint.call(this, curve, "projective");
    if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
    } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = z ? new BN(z, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        // Use extended coordinates
        if (this.curve.extended && !this.t) {
            this.t = this.x.redMul(this.y);
            if (!this.zOne) this.t = this.t.redMul(this.z.redInvm());
        }
    }
}
inherits(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
};
EdwardsCurve.prototype.point = function point(x, y, z, t) {
    return new Point(this, x, y, z, t);
};
Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1], obj[2]);
};
Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function _extDbl() {
    // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     #doubling-dbl-2008-hwcd
    // 4M + 4S
    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = 2 * Z1^2
    var c = this.z.redSqr();
    c = c.redIAdd(c);
    // D = a * A
    var d = this.curve._mulA(a);
    // E = (X1 + Y1)^2 - A - B
    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
    // G = D + B
    var g = d.redAdd(b);
    // F = G - C
    var f = g.redSub(c);
    // H = D - B
    var h = d.redSub(b);
    // X3 = E * F
    var nx = e.redMul(f);
    // Y3 = G * H
    var ny = g.redMul(h);
    // T3 = E * H
    var nt = e.redMul(h);
    // Z3 = F * G
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
};
Point.prototype._projDbl = function _projDbl() {
    // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     #doubling-dbl-2008-bbjlp
    //     #doubling-dbl-2007-bl
    // and others
    // Generally 3M + 4S or 2M + 4S
    // B = (X1 + Y1)^2
    var b = this.x.redAdd(this.y).redSqr();
    // C = X1^2
    var c = this.x.redSqr();
    // D = Y1^2
    var d = this.y.redSqr();
    var nx;
    var ny;
    var nz;
    var e;
    var h;
    var j;
    if (this.curve.twisted) {
        // E = a * C
        e = this.curve._mulA(c);
        // F = E + D
        var f = e.redAdd(d);
        if (this.zOne) {
            // X3 = (B - C - D) * (F - 2)
            nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
            // Y3 = F * (E - D)
            ny = f.redMul(e.redSub(d));
            // Z3 = F^2 - 2 * F
            nz = f.redSqr().redSub(f).redSub(f);
        } else {
            // H = Z1^2
            h = this.z.redSqr();
            // J = F - 2 * H
            j = f.redSub(h).redISub(h);
            // X3 = (B-C-D)*J
            nx = b.redSub(c).redISub(d).redMul(j);
            // Y3 = F * (E - D)
            ny = f.redMul(e.redSub(d));
            // Z3 = F * J
            nz = f.redMul(j);
        }
    } else {
        // E = C + D
        e = c.redAdd(d);
        // H = (c * Z1)^2
        h = this.curve._mulC(this.z).redSqr();
        // J = E - 2 * H
        j = e.redSub(h).redSub(h);
        // X3 = c * (B - E) * J
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        // Y3 = c * E * (C - D)
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        // Z3 = E * J
        nz = e.redMul(j);
    }
    return this.curve.point(nx, ny, nz);
};
Point.prototype.dbl = function dbl() {
    if (this.isInfinity()) return this;
    // Double in extended coordinates
    if (this.curve.extended) return this._extDbl();
    else return this._projDbl();
};
Point.prototype._extAdd = function _extAdd(p) {
    // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     #addition-add-2008-hwcd-3
    // 8M
    // A = (Y1 - X1) * (Y2 - X2)
    var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
    // B = (Y1 + X1) * (Y2 + X2)
    var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
    // C = T1 * k * T2
    var c = this.t.redMul(this.curve.dd).redMul(p.t);
    // D = Z1 * 2 * Z2
    var d = this.z.redMul(p.z.redAdd(p.z));
    // E = B - A
    var e = b.redSub(a);
    // F = D - C
    var f = d.redSub(c);
    // G = D + C
    var g = d.redAdd(c);
    // H = B + A
    var h = b.redAdd(a);
    // X3 = E * F
    var nx = e.redMul(f);
    // Y3 = G * H
    var ny = g.redMul(h);
    // T3 = E * H
    var nt = e.redMul(h);
    // Z3 = F * G
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
};
Point.prototype._projAdd = function _projAdd(p) {
    // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     #addition-add-2008-bbjlp
    //     #addition-add-2007-bl
    // 10M + 1S
    // A = Z1 * Z2
    var a = this.z.redMul(p.z);
    // B = A^2
    var b = a.redSqr();
    // C = X1 * X2
    var c = this.x.redMul(p.x);
    // D = Y1 * Y2
    var d = this.y.redMul(p.y);
    // E = d * C * D
    var e = this.curve.d.redMul(c).redMul(d);
    // F = B - E
    var f = b.redSub(e);
    // G = B + E
    var g = b.redAdd(e);
    // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
    var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
    var nx = a.redMul(f).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
        // Y3 = A * G * (D - a * C)
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        // Z3 = F * G
        nz = f.redMul(g);
    } else {
        // Y3 = A * G * (D - C)
        ny = a.redMul(g).redMul(d.redSub(c));
        // Z3 = c * F * G
        nz = this.curve._mulC(f).redMul(g);
    }
    return this.curve.point(nx, ny, nz);
};
Point.prototype.add = function add(p) {
    if (this.isInfinity()) return p;
    if (p.isInfinity()) return this;
    if (this.curve.extended) return this._extAdd(p);
    else return this._projAdd(p);
};
Point.prototype.mul = function mul(k) {
    if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);
    else return this.curve._wnafMul(this, k);
};
Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [
        this,
        p
    ], [
        k1,
        k2
    ], 2, false);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [
        this,
        p
    ], [
        k1,
        k2
    ], 2, true);
};
Point.prototype.normalize = function normalize() {
    if (this.zOne) return this;
    // Normalize coordinates
    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t) this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
};
Point.prototype.neg = function neg() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
};
Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
};
Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
};
Point.prototype.eq = function eq(other) {
    return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
};
Point.prototype.eqXToP = function eqXToP(x) {
    var rx = x.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0) return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(this.z);
    for(;;){
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0) return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0) return true;
    }
};
// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"7bd66a4710450b08":"8sNT5","ccef46dcf03d45c6":"VopIn","19937272cbe23c92":"bRL3M","108c8ead5f54502b":"kvY1a"}],"6yRo9":[function(require,module,exports) {
"use strict";
var curves = exports;
var hash = require("1c9db357c0845afa");
var curve = require("47ec78745540f875");
var utils = require("e30b16e4a47a5405");
var assert = utils.assert;
function PresetCurve(options) {
    if (options.type === "short") this.curve = new curve.short(options);
    else if (options.type === "edwards") this.curve = new curve.edwards(options);
    else this.curve = new curve.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert(this.g.validate(), "Invalid curve");
    assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
}
curves.PresetCurve = PresetCurve;
function defineCurve(name, options) {
    Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
            var curve = new PresetCurve(options);
            Object.defineProperty(curves, name, {
                configurable: true,
                enumerable: true,
                value: curve
            });
            return curve;
        }
    });
}
defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash.sha256,
    gRed: false,
    g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
});
defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash.sha256,
    gRed: false,
    g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
});
defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash.sha256,
    gRed: false,
    g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
});
defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash.sha384,
    gRed: false,
    g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
});
defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash.sha512,
    gRed: false,
    g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
});
defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash.sha256,
    gRed: false,
    g: [
        "9"
    ]
});
defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash.sha256,
    gRed: false,
    g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
    ]
});
var pre;
try {
    pre = require("9eada5f7049e7dfd");
} catch (e) {
    pre = undefined;
}
defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
        {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
        }
    ],
    gRed: false,
    g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
    ]
});

},{"1c9db357c0845afa":"gOEGU","47ec78745540f875":"72OoG","e30b16e4a47a5405":"8sNT5","9eada5f7049e7dfd":"lgNSV"}],"gOEGU":[function(require,module,exports) {
var hash = exports;
hash.utils = require("38593959f18bd562");
hash.common = require("31a457752237e8ad");
hash.sha = require("3e37816d2a2fd68d");
hash.ripemd = require("ce5a13b5bd10f171");
hash.hmac = require("c32fbac97a361580");
// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"38593959f18bd562":"kfzn2","31a457752237e8ad":"ecAfF","3e37816d2a2fd68d":"8nbee","ce5a13b5bd10f171":"9kyRQ","c32fbac97a361580":"5KrrE"}],"kfzn2":[function(require,module,exports) {
"use strict";
var assert = require("6002b0feade022a4");
var inherits = require("d4826c9d0ff1b1f");
exports.inherits = inherits;
function isSurrogatePair(msg, i) {
    if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) return false;
    if (i < 0 || i + 1 >= msg.length) return false;
    return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}
function toArray(msg, enc) {
    if (Array.isArray(msg)) return msg.slice();
    if (!msg) return [];
    var res = [];
    if (typeof msg === "string") {
        if (!enc) {
            // Inspired by stringToUtf8ByteArray() in closure-library by Google
            // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
            // Apache License 2.0
            // https://github.com/google/closure-library/blob/master/LICENSE
            var p = 0;
            for(var i = 0; i < msg.length; i++){
                var c = msg.charCodeAt(i);
                if (c < 128) res[p++] = c;
                else if (c < 2048) {
                    res[p++] = c >> 6 | 192;
                    res[p++] = c & 63 | 128;
                } else if (isSurrogatePair(msg, i)) {
                    c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
                    res[p++] = c >> 18 | 240;
                    res[p++] = c >> 12 & 63 | 128;
                    res[p++] = c >> 6 & 63 | 128;
                    res[p++] = c & 63 | 128;
                } else {
                    res[p++] = c >> 12 | 224;
                    res[p++] = c >> 6 & 63 | 128;
                    res[p++] = c & 63 | 128;
                }
            }
        } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0) msg = "0" + msg;
            for(i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
    } else for(i = 0; i < msg.length; i++)res[i] = msg[i] | 0;
    return res;
}
exports.toArray = toArray;
function toHex(msg) {
    var res = "";
    for(var i = 0; i < msg.length; i++)res += zero2(msg[i].toString(16));
    return res;
}
exports.toHex = toHex;
function htonl(w) {
    var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;
    return res >>> 0;
}
exports.htonl = htonl;
function toHex32(msg, endian) {
    var res = "";
    for(var i = 0; i < msg.length; i++){
        var w = msg[i];
        if (endian === "little") w = htonl(w);
        res += zero8(w.toString(16));
    }
    return res;
}
exports.toHex32 = toHex32;
function zero2(word) {
    if (word.length === 1) return "0" + word;
    else return word;
}
exports.zero2 = zero2;
function zero8(word) {
    if (word.length === 7) return "0" + word;
    else if (word.length === 6) return "00" + word;
    else if (word.length === 5) return "000" + word;
    else if (word.length === 4) return "0000" + word;
    else if (word.length === 3) return "00000" + word;
    else if (word.length === 2) return "000000" + word;
    else if (word.length === 1) return "0000000" + word;
    else return word;
}
exports.zero8 = zero8;
function join32(msg, start, end, endian) {
    var len = end - start;
    assert(len % 4 === 0);
    var res = new Array(len / 4);
    for(var i = 0, k = start; i < res.length; i++, k += 4){
        var w;
        if (endian === "big") w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
    }
    return res;
}
exports.join32 = join32;
function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for(var i = 0, k = 0; i < msg.length; i++, k += 4){
        var m = msg[i];
        if (endian === "big") {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 0xff;
            res[k + 2] = m >>> 8 & 0xff;
            res[k + 3] = m & 0xff;
        } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 0xff;
            res[k + 1] = m >>> 8 & 0xff;
            res[k] = m & 0xff;
        }
    }
    return res;
}
exports.split32 = split32;
function rotr32(w, b) {
    return w >>> b | w << 32 - b;
}
exports.rotr32 = rotr32;
function rotl32(w, b) {
    return w << b | w >>> 32 - b;
}
exports.rotl32 = rotl32;
function sum32(a, b) {
    return a + b >>> 0;
}
exports.sum32 = sum32;
function sum32_3(a, b, c) {
    return a + b + c >>> 0;
}
exports.sum32_3 = sum32_3;
function sum32_4(a, b, c, d) {
    return a + b + c + d >>> 0;
}
exports.sum32_4 = sum32_4;
function sum32_5(a, b, c, d, e) {
    return a + b + c + d + e >>> 0;
}
exports.sum32_5 = sum32_5;
function sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
}
exports.sum64 = sum64;
function sum64_hi(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
}
exports.sum64_hi = sum64_hi;
function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
}
exports.sum64_lo = sum64_lo;
function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;
function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;
function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;
function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;
function rotr64_hi(ah, al, num) {
    var r = al << 32 - num | ah >>> num;
    return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;
function rotr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;
function shr64_hi(ah, al, num) {
    return ah >>> num;
}
exports.shr64_hi = shr64_hi;
function shr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"6002b0feade022a4":"8OvWh","d4826c9d0ff1b1f":"bRL3M"}],"ecAfF":[function(require,module,exports) {
"use strict";
var utils = require("e9291abdfb47ee4f");
var assert = require("ea8841b701712638");
function BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = "big";
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;
BlockHash.prototype.update = function update(msg, enc) {
    // Convert message to array, pad it, and join into 32bit blocks
    msg = utils.toArray(msg, enc);
    if (!this.pending) this.pending = msg;
    else this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    // Enough data, try updating
    if (this.pending.length >= this._delta8) {
        msg = this.pending;
        // Process pending data in blocks
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0) this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for(var i = 0; i < msg.length; i += this._delta32)this._update(msg, i, i + this._delta32);
    }
    return this;
};
BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert(this.pending === null);
    return this._digest(enc);
};
BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - (len + this.padLength) % bytes;
    var res = new Array(k + this.padLength);
    res[0] = 0x80;
    for(var i = 1; i < k; i++)res[i] = 0;
    // Append length
    len <<= 3;
    if (this.endian === "big") {
        for(var t = 8; t < this.padLength; t++)res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 0xff;
        res[i++] = len >>> 16 & 0xff;
        res[i++] = len >>> 8 & 0xff;
        res[i++] = len & 0xff;
    } else {
        res[i++] = len & 0xff;
        res[i++] = len >>> 8 & 0xff;
        res[i++] = len >>> 16 & 0xff;
        res[i++] = len >>> 24 & 0xff;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for(t = 8; t < this.padLength; t++)res[i++] = 0;
    }
    return res;
};

},{"e9291abdfb47ee4f":"kfzn2","ea8841b701712638":"8OvWh"}],"8nbee":[function(require,module,exports) {
"use strict";
exports.sha1 = require("3835379564860fd7");
exports.sha224 = require("bb9f72f042233648");
exports.sha256 = require("20a3b0fa42e37dfe");
exports.sha384 = require("ad4827efa7d953c2");
exports.sha512 = require("301292595a944c1d");

},{"3835379564860fd7":"fnjyb","bb9f72f042233648":"9x7tY","20a3b0fa42e37dfe":"9bCbT","ad4827efa7d953c2":"lJMiS","301292595a944c1d":"8y482"}],"fnjyb":[function(require,module,exports) {
"use strict";
var utils = require("b75f3c1442bf9100");
var common = require("a29e68029e4c48f8");
var shaCommon = require("1be62f90a237cba5");
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;
var sha1_K = [
    0x5A827999,
    0x6ED9EBA1,
    0x8F1BBCDC,
    0xCA62C1D6
];
function SHA1() {
    if (!(this instanceof SHA1)) return new SHA1();
    BlockHash.call(this);
    this.h = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    this.W = new Array(80);
}
utils.inherits(SHA1, BlockHash);
module.exports = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for(var i = 0; i < 16; i++)W[i] = msg[start + i];
    for(; i < W.length; i++)W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for(i = 0; i < W.length; i++){
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t;
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
};
SHA1.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h, "big");
    else return utils.split32(this.h, "big");
};

},{"b75f3c1442bf9100":"kfzn2","a29e68029e4c48f8":"ecAfF","1be62f90a237cba5":"gzrNi"}],"gzrNi":[function(require,module,exports) {
"use strict";
var utils = require("f0fb61f828bacd0f");
var rotr32 = utils.rotr32;
function ft_1(s, x, y, z) {
    if (s === 0) return ch32(x, y, z);
    if (s === 1 || s === 3) return p32(x, y, z);
    if (s === 2) return maj32(x, y, z);
}
exports.ft_1 = ft_1;
function ch32(x, y, z) {
    return x & y ^ ~x & z;
}
exports.ch32 = ch32;
function maj32(x, y, z) {
    return x & y ^ x & z ^ y & z;
}
exports.maj32 = maj32;
function p32(x, y, z) {
    return x ^ y ^ z;
}
exports.p32 = p32;
function s0_256(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;
function s1_256(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;
function g0_256(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}
exports.g0_256 = g0_256;
function g1_256(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}
exports.g1_256 = g1_256;

},{"f0fb61f828bacd0f":"kfzn2"}],"9x7tY":[function(require,module,exports) {
"use strict";
var utils = require("fe5acd040463c159");
var SHA256 = require("fa3503eda3738d05");
function SHA224() {
    if (!(this instanceof SHA224)) return new SHA224();
    SHA256.call(this);
    this.h = [
        0xc1059ed8,
        0x367cd507,
        0x3070dd17,
        0xf70e5939,
        0xffc00b31,
        0x68581511,
        0x64f98fa7,
        0xbefa4fa4
    ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest(enc) {
    // Just truncate output
    if (enc === "hex") return utils.toHex32(this.h.slice(0, 7), "big");
    else return utils.split32(this.h.slice(0, 7), "big");
};

},{"fe5acd040463c159":"kfzn2","fa3503eda3738d05":"9bCbT"}],"9bCbT":[function(require,module,exports) {
"use strict";
var utils = require("32ad3e510bd41f2a");
var common = require("469ad88ad505772a");
var shaCommon = require("fffa7d1ddf1f0b43");
var assert = require("126369f57b5225ed");
var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash = common.BlockHash;
var sha256_K = [
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
];
function SHA256() {
    if (!(this instanceof SHA256)) return new SHA256();
    BlockHash.call(this);
    this.h = [
        0x6a09e667,
        0xbb67ae85,
        0x3c6ef372,
        0xa54ff53a,
        0x510e527f,
        0x9b05688c,
        0x1f83d9ab,
        0x5be0cd19
    ];
    this.k = sha256_K;
    this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;
SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;
SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
    for(var i = 0; i < 16; i++)W[i] = msg[start + i];
    for(; i < W.length; i++)W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    assert(this.k.length === W.length);
    for(i = 0; i < W.length; i++){
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g;
        g = f;
        f = e;
        e = sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32(T1, T2);
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
    this.h[5] = sum32(this.h[5], f);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h);
};
SHA256.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h, "big");
    else return utils.split32(this.h, "big");
};

},{"32ad3e510bd41f2a":"kfzn2","469ad88ad505772a":"ecAfF","fffa7d1ddf1f0b43":"gzrNi","126369f57b5225ed":"8OvWh"}],"lJMiS":[function(require,module,exports) {
"use strict";
var utils = require("a696ee34c45713da");
var SHA512 = require("fff95253fdaa49ea");
function SHA384() {
    if (!(this instanceof SHA384)) return new SHA384();
    SHA512.call(this);
    this.h = [
        0xcbbb9d5d,
        0xc1059ed8,
        0x629a292a,
        0x367cd507,
        0x9159015a,
        0x3070dd17,
        0x152fecd8,
        0xf70e5939,
        0x67332667,
        0xffc00b31,
        0x8eb44a87,
        0x68581511,
        0xdb0c2e0d,
        0x64f98fa7,
        0x47b5481d,
        0xbefa4fa4
    ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h.slice(0, 12), "big");
    else return utils.split32(this.h.slice(0, 12), "big");
};

},{"a696ee34c45713da":"kfzn2","fff95253fdaa49ea":"8y482"}],"8y482":[function(require,module,exports) {
"use strict";
var utils = require("7753b1fa702fbb54");
var common = require("81b6970d75627ce1");
var assert = require("f660976cede694e2");
var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = common.BlockHash;
var sha512_K = [
    0x428a2f98,
    0xd728ae22,
    0x71374491,
    0x23ef65cd,
    0xb5c0fbcf,
    0xec4d3b2f,
    0xe9b5dba5,
    0x8189dbbc,
    0x3956c25b,
    0xf348b538,
    0x59f111f1,
    0xb605d019,
    0x923f82a4,
    0xaf194f9b,
    0xab1c5ed5,
    0xda6d8118,
    0xd807aa98,
    0xa3030242,
    0x12835b01,
    0x45706fbe,
    0x243185be,
    0x4ee4b28c,
    0x550c7dc3,
    0xd5ffb4e2,
    0x72be5d74,
    0xf27b896f,
    0x80deb1fe,
    0x3b1696b1,
    0x9bdc06a7,
    0x25c71235,
    0xc19bf174,
    0xcf692694,
    0xe49b69c1,
    0x9ef14ad2,
    0xefbe4786,
    0x384f25e3,
    0x0fc19dc6,
    0x8b8cd5b5,
    0x240ca1cc,
    0x77ac9c65,
    0x2de92c6f,
    0x592b0275,
    0x4a7484aa,
    0x6ea6e483,
    0x5cb0a9dc,
    0xbd41fbd4,
    0x76f988da,
    0x831153b5,
    0x983e5152,
    0xee66dfab,
    0xa831c66d,
    0x2db43210,
    0xb00327c8,
    0x98fb213f,
    0xbf597fc7,
    0xbeef0ee4,
    0xc6e00bf3,
    0x3da88fc2,
    0xd5a79147,
    0x930aa725,
    0x06ca6351,
    0xe003826f,
    0x14292967,
    0x0a0e6e70,
    0x27b70a85,
    0x46d22ffc,
    0x2e1b2138,
    0x5c26c926,
    0x4d2c6dfc,
    0x5ac42aed,
    0x53380d13,
    0x9d95b3df,
    0x650a7354,
    0x8baf63de,
    0x766a0abb,
    0x3c77b2a8,
    0x81c2c92e,
    0x47edaee6,
    0x92722c85,
    0x1482353b,
    0xa2bfe8a1,
    0x4cf10364,
    0xa81a664b,
    0xbc423001,
    0xc24b8b70,
    0xd0f89791,
    0xc76c51a3,
    0x0654be30,
    0xd192e819,
    0xd6ef5218,
    0xd6990624,
    0x5565a910,
    0xf40e3585,
    0x5771202a,
    0x106aa070,
    0x32bbd1b8,
    0x19a4c116,
    0xb8d2d0c8,
    0x1e376c08,
    0x5141ab53,
    0x2748774c,
    0xdf8eeb99,
    0x34b0bcb5,
    0xe19b48a8,
    0x391c0cb3,
    0xc5c95a63,
    0x4ed8aa4a,
    0xe3418acb,
    0x5b9cca4f,
    0x7763e373,
    0x682e6ff3,
    0xd6b2b8a3,
    0x748f82ee,
    0x5defb2fc,
    0x78a5636f,
    0x43172f60,
    0x84c87814,
    0xa1f0ab72,
    0x8cc70208,
    0x1a6439ec,
    0x90befffa,
    0x23631e28,
    0xa4506ceb,
    0xde82bde9,
    0xbef9a3f7,
    0xb2c67915,
    0xc67178f2,
    0xe372532b,
    0xca273ece,
    0xea26619c,
    0xd186b8c7,
    0x21c0c207,
    0xeada7dd6,
    0xcde0eb1e,
    0xf57d4f7f,
    0xee6ed178,
    0x06f067aa,
    0x72176fba,
    0x0a637dc5,
    0xa2c898a6,
    0x113f9804,
    0xbef90dae,
    0x1b710b35,
    0x131c471b,
    0x28db77f5,
    0x23047d84,
    0x32caab7b,
    0x40c72493,
    0x3c9ebe0a,
    0x15c9bebc,
    0x431d67c4,
    0x9c100d4c,
    0x4cc5d4be,
    0xcb3e42b6,
    0x597f299c,
    0xfc657e2a,
    0x5fcb6fab,
    0x3ad6faec,
    0x6c44198c,
    0x4a475817
];
function SHA512() {
    if (!(this instanceof SHA512)) return new SHA512();
    BlockHash.call(this);
    this.h = [
        0x6a09e667,
        0xf3bcc908,
        0xbb67ae85,
        0x84caa73b,
        0x3c6ef372,
        0xfe94f82b,
        0xa54ff53a,
        0x5f1d36f1,
        0x510e527f,
        0xade682d1,
        0x9b05688c,
        0x2b3e6c1f,
        0x1f83d9ab,
        0xfb41bd6b,
        0x5be0cd19,
        0x137e2179
    ];
    this.k = sha512_K;
    this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;
SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;
SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    // 32 x 32bit words
    for(var i = 0; i < 32; i++)W[i] = msg[start + i];
    for(; i < W.length; i += 2){
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14]; // i - 7
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32]; // i - 16
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    }
};
SHA512.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert(this.k.length === W.length);
    for(var i = 0; i < W.length; i += 2){
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
};
SHA512.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h, "big");
    else return utils.split32(this.h, "big");
};
function ch64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ ~xh & zh;
    if (r < 0) r += 0x100000000;
    return r;
}
function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ ~xl & zl;
    if (r < 0) r += 0x100000000;
    return r;
}
function maj64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ xh & zh ^ yh & zh;
    if (r < 0) r += 0x100000000;
    return r;
}
function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ xl & zl ^ yl & zl;
    if (r < 0) r += 0x100000000;
    return r;
}
function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2); // 34
    var c2_hi = rotr64_hi(xl, xh, 7); // 39
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2); // 34
    var c2_lo = rotr64_lo(xl, xh, 7); // 39
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9); // 41
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9); // 41
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29); // 61
    var c2_hi = shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29); // 61
    var c2_lo = shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}

},{"7753b1fa702fbb54":"kfzn2","81b6970d75627ce1":"ecAfF","f660976cede694e2":"8OvWh"}],"9kyRQ":[function(require,module,exports) {
"use strict";
var utils = require("36495272d446418f");
var common = require("ad8cf0490e28e8d7");
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
    if (!(this instanceof RIPEMD160)) return new RIPEMD160();
    BlockHash.call(this);
    this.h = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    this.endian = "little";
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for(var j = 0; j < 80; j++){
        var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
};
RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h, "little");
    else return utils.split32(this.h, "little");
};
function f(j, x, y, z) {
    if (j <= 15) return x ^ y ^ z;
    else if (j <= 31) return x & y | ~x & z;
    else if (j <= 47) return (x | ~y) ^ z;
    else if (j <= 63) return x & z | y & ~z;
    else return x ^ (y | ~z);
}
function K(j) {
    if (j <= 15) return 0x00000000;
    else if (j <= 31) return 0x5a827999;
    else if (j <= 47) return 0x6ed9eba1;
    else if (j <= 63) return 0x8f1bbcdc;
    else return 0xa953fd4e;
}
function Kh(j) {
    if (j <= 15) return 0x50a28be6;
    else if (j <= 31) return 0x5c4dd124;
    else if (j <= 47) return 0x6d703ef3;
    else if (j <= 63) return 0x7a6d76e9;
    else return 0x00000000;
}
var r = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
];
var rh = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
];
var s = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
];
var sh = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
];

},{"36495272d446418f":"kfzn2","ad8cf0490e28e8d7":"ecAfF"}],"5KrrE":[function(require,module,exports) {
"use strict";
var utils = require("596c08b6835a6e2d");
var assert = require("be527907d4f06808");
function Hmac(hash, key, enc) {
    if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
    this.Hash = hash;
    this.blockSize = hash.blockSize / 8;
    this.outSize = hash.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils.toArray(key, enc));
}
module.exports = Hmac;
Hmac.prototype._init = function init(key) {
    // Shorten key, if needed
    if (key.length > this.blockSize) key = new this.Hash().update(key).digest();
    assert(key.length <= this.blockSize);
    // Add padding to key
    for(var i = key.length; i < this.blockSize; i++)key.push(0);
    for(i = 0; i < key.length; i++)key[i] ^= 0x36;
    this.inner = new this.Hash().update(key);
    // 0x36 ^ 0x5c = 0x6a
    for(i = 0; i < key.length; i++)key[i] ^= 0x6a;
    this.outer = new this.Hash().update(key);
};
Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
};
Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
};

},{"596c08b6835a6e2d":"kfzn2","be527907d4f06808":"8OvWh"}],"lgNSV":[function(require,module,exports) {
module.exports = {
    doubles: {
        step: 4,
        points: [
            [
                "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
                "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
            ],
            [
                "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
                "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
            ],
            [
                "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
                "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
            ],
            [
                "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
                "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
            ],
            [
                "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
                "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
            ],
            [
                "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
                "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
            ],
            [
                "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
                "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
            ],
            [
                "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
                "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
            ],
            [
                "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
                "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
            ],
            [
                "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
                "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
            ],
            [
                "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
                "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
            ],
            [
                "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
                "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
            ],
            [
                "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
                "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
            ],
            [
                "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
                "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
            ],
            [
                "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
                "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
            ],
            [
                "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
                "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
            ],
            [
                "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
                "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
            ],
            [
                "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
                "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
            ],
            [
                "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
                "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
            ],
            [
                "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
                "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
            ],
            [
                "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
                "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
            ],
            [
                "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
                "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
            ],
            [
                "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
                "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
            ],
            [
                "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
                "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
            ],
            [
                "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
                "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
            ],
            [
                "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
                "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
            ],
            [
                "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
                "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
            ],
            [
                "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
                "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
            ],
            [
                "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
                "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
            ],
            [
                "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
                "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
            ],
            [
                "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
                "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
            ],
            [
                "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
                "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
            ],
            [
                "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
                "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
            ],
            [
                "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
                "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
            ],
            [
                "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
                "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
            ],
            [
                "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
                "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
            ],
            [
                "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
                "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
            ],
            [
                "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
                "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
            ],
            [
                "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
                "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
            ],
            [
                "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
                "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
            ],
            [
                "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
                "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
            ],
            [
                "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
                "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
            ],
            [
                "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
                "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
            ],
            [
                "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
                "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
            ],
            [
                "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
                "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
            ],
            [
                "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
                "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
            ],
            [
                "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
                "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
            ],
            [
                "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
                "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
            ],
            [
                "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
                "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
            ],
            [
                "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
                "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
            ],
            [
                "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
                "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
            ],
            [
                "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
                "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
            ],
            [
                "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
                "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
            ],
            [
                "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
                "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
            ],
            [
                "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
                "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
            ],
            [
                "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
                "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
            ],
            [
                "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
                "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
            ],
            [
                "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
                "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
            ],
            [
                "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
                "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
            ],
            [
                "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
                "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
            ],
            [
                "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
                "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
            ],
            [
                "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
                "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
            ],
            [
                "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
                "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
            ],
            [
                "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
                "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
            ],
            [
                "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
                "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
            ]
        ]
    },
    naf: {
        wnd: 7,
        points: [
            [
                "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
                "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
            ],
            [
                "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
                "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
            ],
            [
                "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
                "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
            ],
            [
                "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
                "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
            ],
            [
                "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
                "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
            ],
            [
                "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
                "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
            ],
            [
                "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
                "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
            ],
            [
                "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
                "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
            ],
            [
                "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
                "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
            ],
            [
                "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
                "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
            ],
            [
                "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
                "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
            ],
            [
                "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
                "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
            ],
            [
                "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
                "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
            ],
            [
                "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
                "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
            ],
            [
                "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
                "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
            ],
            [
                "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
                "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
            ],
            [
                "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
                "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
            ],
            [
                "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
                "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
            ],
            [
                "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
                "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
            ],
            [
                "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
                "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
            ],
            [
                "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
                "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
            ],
            [
                "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
                "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
            ],
            [
                "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
                "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
            ],
            [
                "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
                "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
            ],
            [
                "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
                "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
            ],
            [
                "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
                "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
            ],
            [
                "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
                "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
            ],
            [
                "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
                "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
            ],
            [
                "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
                "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
            ],
            [
                "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
                "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
            ],
            [
                "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
                "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
            ],
            [
                "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
                "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
            ],
            [
                "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
                "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
            ],
            [
                "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
                "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
            ],
            [
                "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
                "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
            ],
            [
                "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
                "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
            ],
            [
                "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
                "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
            ],
            [
                "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
                "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
            ],
            [
                "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
                "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
            ],
            [
                "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
                "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
            ],
            [
                "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
                "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
            ],
            [
                "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
                "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
            ],
            [
                "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
                "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
            ],
            [
                "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
                "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
            ],
            [
                "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
                "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
            ],
            [
                "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
                "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
            ],
            [
                "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
                "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
            ],
            [
                "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
                "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
            ],
            [
                "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
                "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
            ],
            [
                "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
                "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
            ],
            [
                "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
                "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
            ],
            [
                "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
                "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
            ],
            [
                "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
                "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
            ],
            [
                "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
                "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
            ],
            [
                "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
                "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
            ],
            [
                "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
                "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
            ],
            [
                "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
                "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
            ],
            [
                "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
                "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
            ],
            [
                "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
                "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
            ],
            [
                "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
                "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
            ],
            [
                "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
                "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
            ],
            [
                "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
                "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
            ],
            [
                "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
                "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
            ],
            [
                "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
                "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
            ],
            [
                "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
                "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
            ],
            [
                "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
                "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
            ],
            [
                "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
                "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
            ],
            [
                "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
                "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
            ],
            [
                "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
                "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
            ],
            [
                "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
                "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
            ],
            [
                "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
                "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
            ],
            [
                "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
                "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
            ],
            [
                "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
                "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
            ],
            [
                "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
                "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
            ],
            [
                "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
                "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
            ],
            [
                "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
                "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
            ],
            [
                "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
                "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
            ],
            [
                "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
                "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
            ],
            [
                "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
                "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
            ],
            [
                "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
                "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
            ],
            [
                "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
                "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
            ],
            [
                "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
                "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
            ],
            [
                "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
                "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
            ],
            [
                "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
                "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
            ],
            [
                "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
                "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
            ],
            [
                "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
                "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
            ],
            [
                "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
                "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
            ],
            [
                "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
                "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
            ],
            [
                "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
                "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
            ],
            [
                "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
                "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
            ],
            [
                "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
                "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
            ],
            [
                "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
                "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
            ],
            [
                "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
                "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
            ],
            [
                "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
                "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
            ],
            [
                "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
                "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
            ],
            [
                "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
                "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
            ],
            [
                "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
                "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
            ],
            [
                "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
                "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
            ],
            [
                "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
                "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
            ],
            [
                "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
                "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
            ],
            [
                "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
                "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
            ],
            [
                "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
                "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
            ],
            [
                "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
                "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
            ],
            [
                "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
                "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
            ],
            [
                "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
                "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
            ],
            [
                "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
                "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
            ],
            [
                "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
                "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
            ],
            [
                "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
                "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
            ],
            [
                "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
                "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
            ],
            [
                "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
                "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
            ],
            [
                "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
                "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
            ],
            [
                "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
                "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
            ],
            [
                "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
                "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
            ],
            [
                "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
                "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
            ],
            [
                "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
                "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
            ],
            [
                "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
                "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
            ],
            [
                "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
                "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
            ],
            [
                "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
                "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
            ],
            [
                "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
                "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
            ],
            [
                "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
                "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
            ],
            [
                "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
                "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
            ],
            [
                "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
                "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
            ],
            [
                "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
                "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
            ],
            [
                "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
                "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
            ],
            [
                "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
                "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
            ],
            [
                "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
                "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
            ],
            [
                "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
                "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
            ]
        ]
    }
};

},{}],"5gDK1":[function(require,module,exports) {
"use strict";
var BN = require("2e69183faf5285a1");
var HmacDRBG = require("b0cb641292e4911d");
var utils = require("eab3e45147b180ba");
var curves = require("a5ce61d26ce01c4c");
var rand = require("f6342f89ac472937");
var assert = utils.assert;
var KeyPair = require("eb5ba559e423f6e9");
var Signature = require("7c5e2c76c574ce41");
function EC(options) {
    if (!(this instanceof EC)) return new EC(options);
    // Shortcut `elliptic.ec(curve-name)`
    if (typeof options === "string") {
        assert(Object.prototype.hasOwnProperty.call(curves, options), "Unknown curve " + options);
        options = curves[options];
    }
    // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
    if (options instanceof curves.PresetCurve) options = {
        curve: options
    };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    // Point on curve
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    // Hash for function for DRBG
    this.hash = options.hash || options.curve.hash;
}
module.exports = EC;
EC.prototype.keyPair = function keyPair(options) {
    return new KeyPair(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options) options = {};
    // Instantiate Hmac_DRBG
    var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new BN(2));
    for(;;){
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0) continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
    }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0) msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);
    else return msg;
};
EC.prototype.sign = function sign(msg, key, enc, options) {
    if (typeof enc === "object") {
        options = enc;
        enc = null;
    }
    if (!options) options = {};
    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(new BN(msg, 16));
    // Zero-extend key to provide enough entropy
    var bytes = this.n.byteLength();
    var bkey = key.getPrivate().toArray("be", bytes);
    // Zero-extend nonce to have the same byte size as N
    var nonce = msg.toArray("be", bytes);
    // Instantiate Hmac_DRBG
    var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce: nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
    });
    // Number of bytes to generate
    var ns1 = this.n.sub(new BN(1));
    for(var iter = 0;; iter++){
        var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity()) continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0) continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0) continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        // Use complement of `s`, if it is > `n / 2`
        if (options.canonical && s.cmp(this.nh) > 0) {
            s = this.n.sub(s);
            recoveryParam ^= 1;
        }
        return new Signature({
            r: r,
            s: s,
            recoveryParam: recoveryParam
        });
    }
};
EC.prototype.verify = function verify(msg, signature, key, enc) {
    msg = this._truncateToN(new BN(msg, 16));
    key = this.keyFromPublic(key, enc);
    signature = new Signature(signature, "hex");
    // Perform primitive values validation
    var r = signature.r;
    var s = signature.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false;
    // Validate signature
    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
    var p;
    if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity()) return false;
        return p.getX().umod(this.n).cmp(r) === 0;
    }
    // NOTE: Greg Maxwell's trick, inspired by:
    // https://git.io/vad3K
    p = this.g.jmulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity()) return false;
    // Compare `p.x` of Jacobian point with `r`,
    // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
    // inverse of `p.z^2`
    return p.eqXToP(r);
};
EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
    assert((3 & j) === j, "The recovery param is more than two bits");
    signature = new Signature(signature, enc);
    var n = this.n;
    var e = new BN(msg);
    var r = signature.r;
    var s = signature.s;
    // A set LSB signifies that the y-coordinate is odd
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error("Unable to find sencond key candinate");
    // 1.1. Let x = r + jn.
    if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
    else r = this.curve.pointFromX(r, isYOdd);
    var rInv = signature.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s2 = s.mul(rInv).umod(n);
    // 1.6.1 Compute Q = r^-1 (sR -  eG)
    //               Q = r^-1 (sR + -eG)
    return this.g.mulAdd(s1, r, s2);
};
EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
    signature = new Signature(signature, enc);
    if (signature.recoveryParam !== null) return signature.recoveryParam;
    for(var i = 0; i < 4; i++){
        var Qprime;
        try {
            Qprime = this.recoverPubKey(e, signature, i);
        } catch (e) {
            continue;
        }
        if (Qprime.eq(Q)) return i;
    }
    throw new Error("Unable to find valid recovery factor");
};

},{"2e69183faf5285a1":"VopIn","b0cb641292e4911d":"eMMR6","eab3e45147b180ba":"8sNT5","a5ce61d26ce01c4c":"6yRo9","f6342f89ac472937":"8FGdh","eb5ba559e423f6e9":"c4oIH","7c5e2c76c574ce41":"cRuxW"}],"eMMR6":[function(require,module,exports) {
"use strict";
var hash = require("629972fec592198f");
var utils = require("c20531edfb274a2c");
var assert = require("43ff1863ab3fce20");
function HmacDRBG(options) {
    if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
    var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
    var pers = utils.toArray(options.pers, options.persEnc || "hex");
    assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;
HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for(var i = 0; i < this.V.length; i++){
        this.K[i] = 0x00;
        this.V[i] = 0x01;
    }
    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 0x1000000000000; // 2^48
};
HmacDRBG.prototype._hmac = function hmac() {
    return new hash.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([
        0x00
    ]);
    if (seed) kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed) return;
    this.K = this._hmac().update(this.V).update([
        0x01
    ]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    // Optional entropy enc
    if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
    }
    entropy = utils.toArray(entropy, entropyEnc);
    add = utils.toArray(add, addEnc);
    assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._update(entropy.concat(add || []));
    this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
    if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
    // Optional encoding
    if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
    }
    // Optional additional data
    if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
    }
    var temp = [];
    while(temp.length < len){
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len);
    this._update(add);
    this._reseed++;
    return utils.encode(res, enc);
};

},{"629972fec592198f":"gOEGU","c20531edfb274a2c":"6f39G","43ff1863ab3fce20":"8OvWh"}],"c4oIH":[function(require,module,exports) {
"use strict";
var BN = require("55cc33a33cda153d");
var utils = require("bda8b1ff480a7f3");
var assert = utils.assert;
function KeyPair(ec, options) {
    this.ec = ec;
    this.priv = null;
    this.pub = null;
    // KeyPair(ec, { priv: ..., pub: ... })
    if (options.priv) this._importPrivate(options.priv, options.privEnc);
    if (options.pub) this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;
KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
    if (pub instanceof KeyPair) return pub;
    return new KeyPair(ec, {
        pub: pub,
        pubEnc: enc
    });
};
KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
    if (priv instanceof KeyPair) return priv;
    return new KeyPair(ec, {
        priv: priv,
        privEnc: enc
    });
};
KeyPair.prototype.validate = function validate() {
    var pub = this.getPublic();
    if (pub.isInfinity()) return {
        result: false,
        reason: "Invalid public key"
    };
    if (!pub.validate()) return {
        result: false,
        reason: "Public key is not a point"
    };
    if (!pub.mul(this.ec.curve.n).isInfinity()) return {
        result: false,
        reason: "Public key * N != O"
    };
    return {
        result: true,
        reason: null
    };
};
KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    // compact is optional argument
    if (typeof compact === "string") {
        enc = compact;
        compact = null;
    }
    if (!this.pub) this.pub = this.ec.g.mul(this.priv);
    if (!enc) return this.pub;
    return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === "hex") return this.priv.toString(16, 2);
    else return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
    this.priv = new BN(key, enc || 16);
    // Ensure that the priv won't be bigger than n, otherwise we may fail
    // in fixed multiplication method
    this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key, enc) {
    if (key.x || key.y) {
        // Montgomery points only have an `x` coordinate.
        // Weierstrass/Edwards points on the other hand have both `x` and
        // `y` coordinates.
        if (this.ec.curve.type === "mont") assert(key.x, "Need x coordinate");
        else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") assert(key.x && key.y, "Need both x and y coordinate");
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
    }
    this.pub = this.ec.curve.decodePoint(key, enc);
};
// ECDH
KeyPair.prototype.derive = function derive(pub) {
    if (!pub.validate()) assert(pub.validate(), "public point not validated");
    return pub.mul(this.priv).getX();
};
// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature) {
    return this.ec.verify(msg, signature, this);
};
KeyPair.prototype.inspect = function inspect() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};

},{"55cc33a33cda153d":"VopIn","bda8b1ff480a7f3":"8sNT5"}],"cRuxW":[function(require,module,exports) {
"use strict";
var BN = require("a7ae8f0fe39990e7");
var utils = require("5df7da4811374387");
var assert = utils.assert;
function Signature(options, enc) {
    if (options instanceof Signature) return options;
    if (this._importDER(options, enc)) return;
    assert(options.r && options.s, "Signature without r or s");
    this.r = new BN(options.r, 16);
    this.s = new BN(options.s, 16);
    if (options.recoveryParam === undefined) this.recoveryParam = null;
    else this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;
function Position() {
    this.place = 0;
}
function getLength(buf, p) {
    var initial = buf[p.place++];
    if (!(initial & 0x80)) return initial;
    var octetLen = initial & 0xf;
    // Indefinite length or overflow
    if (octetLen === 0 || octetLen > 4) return false;
    if (buf[p.place] === 0x00) return false;
    var val = 0;
    for(var i = 0, off = p.place; i < octetLen; i++, off++){
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
    }
    // Leading zeroes
    if (val <= 0x7f) return false;
    p.place = off;
    return val;
}
function rmPadding(buf) {
    var i = 0;
    var len = buf.length - 1;
    while(!buf[i] && !(buf[i + 1] & 0x80) && i < len)i++;
    if (i === 0) return buf;
    return buf.slice(i);
}
Signature.prototype._importDER = function _importDER(data, enc) {
    data = utils.toArray(data, enc);
    var p = new Position();
    if (data[p.place++] !== 0x30) return false;
    var len = getLength(data, p);
    if (len === false) return false;
    if (len + p.place !== data.length) return false;
    if (data[p.place++] !== 0x02) return false;
    var rlen = getLength(data, p);
    if (rlen === false) return false;
    if ((data[p.place] & 128) !== 0) return false;
    var r = data.slice(p.place, rlen + p.place);
    p.place += rlen;
    if (data[p.place++] !== 0x02) return false;
    var slen = getLength(data, p);
    if (slen === false) return false;
    if (data.length !== slen + p.place) return false;
    if ((data[p.place] & 128) !== 0) return false;
    var s = data.slice(p.place, slen + p.place);
    if (r[0] === 0) {
        if (r[1] & 0x80) r = r.slice(1);
        else // Leading zeroes
        return false;
    }
    if (s[0] === 0) {
        if (s[1] & 0x80) s = s.slice(1);
        else // Leading zeroes
        return false;
    }
    this.r = new BN(r);
    this.s = new BN(s);
    this.recoveryParam = null;
    return true;
};
function constructLength(arr, len) {
    if (len < 0x80) {
        arr.push(len);
        return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 0x80);
    while(--octets)arr.push(len >>> (octets << 3) & 0xff);
    arr.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray();
    // Pad values
    if (r[0] & 0x80) r = [
        0
    ].concat(r);
    // Pad values
    if (s[0] & 0x80) s = [
        0
    ].concat(s);
    r = rmPadding(r);
    s = rmPadding(s);
    while(!s[0] && !(s[1] & 0x80))s = s.slice(1);
    var arr = [
        0x02
    ];
    constructLength(arr, r.length);
    arr = arr.concat(r);
    arr.push(0x02);
    constructLength(arr, s.length);
    var backHalf = arr.concat(s);
    var res = [
        0x30
    ];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils.encode(res, enc);
};

},{"a7ae8f0fe39990e7":"VopIn","5df7da4811374387":"8sNT5"}],"jPbam":[function(require,module,exports) {
"use strict";
var hash = require("50f9bfa8a484d5d8");
var curves = require("68956d27442d6321");
var utils = require("99ec52641eff141d");
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require("2ad2982d76b37f15");
var Signature = require("76c25a1d63d10c1b");
function EDDSA(curve) {
    assert(curve === "ed25519", "only tested with ed25519 so far");
    if (!(this instanceof EDDSA)) return new EDDSA(curve);
    curve = curves[curve].curve;
    this.curve = curve;
    this.g = curve.g;
    this.g.precompute(curve.n.bitLength() + 1);
    this.pointClass = curve.point().constructor;
    this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
    this.hash = hash.sha512;
}
module.exports = EDDSA;
/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/ EDDSA.prototype.sign = function sign(message, secret) {
    message = parseBytes(message);
    var key = this.keyFromSecret(secret);
    var r = this.hashInt(key.messagePrefix(), message);
    var R = this.g.mul(r);
    var Rencoded = this.encodePoint(R);
    var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
    var S = r.add(s_).umod(this.curve.n);
    return this.makeSignature({
        R: R,
        S: S,
        Rencoded: Rencoded
    });
};
/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/ EDDSA.prototype.verify = function verify(message, sig, pub) {
    message = parseBytes(message);
    sig = this.makeSignature(sig);
    if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) return false;
    var key = this.keyFromPublic(pub);
    var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key.pub().mul(h));
    return RplusAh.eq(SG);
};
EDDSA.prototype.hashInt = function hashInt() {
    var hash = this.hash();
    for(var i = 0; i < arguments.length; i++)hash.update(arguments[i]);
    return utils.intFromLE(hash.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return KeyPair.fromPublic(this, pub);
};
EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return KeyPair.fromSecret(this, secret);
};
EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof Signature) return sig;
    return new Signature(this, sig);
};
/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/ EDDSA.prototype.encodePoint = function encodePoint(point) {
    var enc = point.getY().toArray("le", this.encodingLength);
    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
    return enc;
};
EDDSA.prototype.decodePoint = function decodePoint(bytes) {
    bytes = utils.parseBytes(bytes);
    var lastIx = bytes.length - 1;
    var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & -129);
    var xIsOdd = (bytes[lastIx] & 0x80) !== 0;
    var y = utils.intFromLE(normed);
    return this.curve.pointFromY(y, xIsOdd);
};
EDDSA.prototype.encodeInt = function encodeInt(num) {
    return num.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function decodeInt(bytes) {
    return utils.intFromLE(bytes);
};
EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
};

},{"50f9bfa8a484d5d8":"gOEGU","68956d27442d6321":"6yRo9","99ec52641eff141d":"8sNT5","2ad2982d76b37f15":"hOVET","76c25a1d63d10c1b":"a5qj9"}],"hOVET":[function(require,module,exports) {
"use strict";
var utils = require("387ffb9c0bf065ab");
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;
/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/ function KeyPair(eddsa, params) {
    this.eddsa = eddsa;
    this._secret = parseBytes(params.secret);
    if (eddsa.isPoint(params.pub)) this._pub = params.pub;
    else this._pubBytes = parseBytes(params.pub);
}
KeyPair.fromPublic = function fromPublic(eddsa, pub) {
    if (pub instanceof KeyPair) return pub;
    return new KeyPair(eddsa, {
        pub: pub
    });
};
KeyPair.fromSecret = function fromSecret(eddsa, secret) {
    if (secret instanceof KeyPair) return secret;
    return new KeyPair(eddsa, {
        secret: secret
    });
};
KeyPair.prototype.secret = function secret() {
    return this._secret;
};
cachedProperty(KeyPair, "pubBytes", function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
});
cachedProperty(KeyPair, "pub", function pub() {
    if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
});
cachedProperty(KeyPair, "privBytes", function privBytes() {
    var eddsa = this.eddsa;
    var hash = this.hash();
    var lastIx = eddsa.encodingLength - 1;
    var a = hash.slice(0, eddsa.encodingLength);
    a[0] &= 248;
    a[lastIx] &= 127;
    a[lastIx] |= 64;
    return a;
});
cachedProperty(KeyPair, "priv", function priv() {
    return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty(KeyPair, "hash", function hash() {
    return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair.prototype.sign = function sign(message) {
    assert(this._secret, "KeyPair can only verify");
    return this.eddsa.sign(message, this);
};
KeyPair.prototype.verify = function verify(message, sig) {
    return this.eddsa.verify(message, sig, this);
};
KeyPair.prototype.getSecret = function getSecret(enc) {
    assert(this._secret, "KeyPair is public only");
    return utils.encode(this.secret(), enc);
};
KeyPair.prototype.getPublic = function getPublic(enc) {
    return utils.encode(this.pubBytes(), enc);
};
module.exports = KeyPair;

},{"387ffb9c0bf065ab":"8sNT5"}],"a5qj9":[function(require,module,exports) {
"use strict";
var BN = require("696e2c87f819d166");
var utils = require("51b94bcac1dcb2b2");
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;
/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/ function Signature(eddsa, sig) {
    this.eddsa = eddsa;
    if (typeof sig !== "object") sig = parseBytes(sig);
    if (Array.isArray(sig)) {
        assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
        sig = {
            R: sig.slice(0, eddsa.encodingLength),
            S: sig.slice(eddsa.encodingLength)
        };
    }
    assert(sig.R && sig.S, "Signature without R or S");
    if (eddsa.isPoint(sig.R)) this._R = sig.R;
    if (sig.S instanceof BN) this._S = sig.S;
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}
cachedProperty(Signature, "S", function S() {
    return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature, "R", function R() {
    return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature, "Rencoded", function Rencoded() {
    return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature, "Sencoded", function Sencoded() {
    return this.eddsa.encodeInt(this.S());
});
Signature.prototype.toBytes = function toBytes() {
    return this.Rencoded().concat(this.Sencoded());
};
Signature.prototype.toHex = function toHex() {
    return utils.encode(this.toBytes(), "hex").toUpperCase();
};
module.exports = Signature;

},{"696e2c87f819d166":"VopIn","51b94bcac1dcb2b2":"8sNT5"}],"fFC9R":[function(require,module,exports) {
var Buffer = require("aed508cc231766da").Buffer;
const createHmac = require("6954d4e6c8944741");
const ONE1 = Buffer.alloc(1, 1);
const ZERO1 = Buffer.alloc(1, 0);
// https://tools.ietf.org/html/rfc6979#section-3.2
function deterministicGenerateK(hash, x, checkSig, isPrivate, extraEntropy) {
    // Step A, ignored as hash already provided
    // Step B
    // Step C
    let k = Buffer.alloc(32, 0);
    let v = Buffer.alloc(32, 1);
    // Step D
    k = createHmac("sha256", k).update(v).update(ZERO1).update(x).update(hash).update(extraEntropy || "").digest();
    // Step E
    v = createHmac("sha256", k).update(v).digest();
    // Step F
    k = createHmac("sha256", k).update(v).update(ONE1).update(x).update(hash).update(extraEntropy || "").digest();
    // Step G
    v = createHmac("sha256", k).update(v).digest();
    // Step H1/H2a, ignored as tlen === qlen (256 bit)
    // Step H2b
    v = createHmac("sha256", k).update(v).digest();
    let T = v;
    // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA
    while(!isPrivate(T) || !checkSig(T)){
        k = createHmac("sha256", k).update(v).update(ZERO1).digest();
        v = createHmac("sha256", k).update(v).digest();
        // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
        // Step H2b again
        v = createHmac("sha256", k).update(v).digest();
        T = v;
    }
    return T;
}
module.exports = deterministicGenerateK;

},{"aed508cc231766da":"bwvMq","6954d4e6c8944741":"k1utz"}],"86sQP":[function(require,module,exports) {
var ERRORS = require("b6b8244aff228baf");
var NATIVE = require("627493ef8c0ede79");
// short-hand
var tfJSON = ERRORS.tfJSON;
var TfTypeError = ERRORS.TfTypeError;
var TfPropertyTypeError = ERRORS.TfPropertyTypeError;
var tfSubError = ERRORS.tfSubError;
var getValueTypeName = ERRORS.getValueTypeName;
var TYPES = {
    arrayOf: function arrayOf(type, options) {
        type = compile(type);
        options = options || {};
        function _arrayOf(array, strict) {
            if (!NATIVE.Array(array)) return false;
            if (NATIVE.Nil(array)) return false;
            if (options.minLength !== undefined && array.length < options.minLength) return false;
            if (options.maxLength !== undefined && array.length > options.maxLength) return false;
            if (options.length !== undefined && array.length !== options.length) return false;
            return array.every(function(value, i) {
                try {
                    return typeforce(type, value, strict);
                } catch (e) {
                    throw tfSubError(e, i);
                }
            });
        }
        _arrayOf.toJSON = function() {
            var str = "[" + tfJSON(type) + "]";
            if (options.length !== undefined) str += "{" + options.length + "}";
            else if (options.minLength !== undefined || options.maxLength !== undefined) str += "{" + (options.minLength === undefined ? 0 : options.minLength) + "," + (options.maxLength === undefined ? Infinity : options.maxLength) + "}";
            return str;
        };
        return _arrayOf;
    },
    maybe: function maybe(type) {
        type = compile(type);
        function _maybe(value, strict) {
            return NATIVE.Nil(value) || type(value, strict, maybe);
        }
        _maybe.toJSON = function() {
            return "?" + tfJSON(type);
        };
        return _maybe;
    },
    map: function map(propertyType, propertyKeyType) {
        propertyType = compile(propertyType);
        if (propertyKeyType) propertyKeyType = compile(propertyKeyType);
        function _map(value, strict) {
            if (!NATIVE.Object(value)) return false;
            if (NATIVE.Nil(value)) return false;
            for(var propertyName in value){
                try {
                    if (propertyKeyType) typeforce(propertyKeyType, propertyName, strict);
                } catch (e) {
                    throw tfSubError(e, propertyName, "key");
                }
                try {
                    var propertyValue = value[propertyName];
                    typeforce(propertyType, propertyValue, strict);
                } catch (e) {
                    throw tfSubError(e, propertyName);
                }
            }
            return true;
        }
        if (propertyKeyType) _map.toJSON = function() {
            return "{" + tfJSON(propertyKeyType) + ": " + tfJSON(propertyType) + "}";
        };
        else _map.toJSON = function() {
            return "{" + tfJSON(propertyType) + "}";
        };
        return _map;
    },
    object: function object(uncompiled) {
        var type = {};
        for(var typePropertyName in uncompiled)type[typePropertyName] = compile(uncompiled[typePropertyName]);
        function _object(value, strict) {
            if (!NATIVE.Object(value)) return false;
            if (NATIVE.Nil(value)) return false;
            var propertyName;
            try {
                for(propertyName in type){
                    var propertyType = type[propertyName];
                    var propertyValue = value[propertyName];
                    typeforce(propertyType, propertyValue, strict);
                }
            } catch (e) {
                throw tfSubError(e, propertyName);
            }
            if (strict) for(propertyName in value){
                if (type[propertyName]) continue;
                throw new TfPropertyTypeError(undefined, propertyName);
            }
            return true;
        }
        _object.toJSON = function() {
            return tfJSON(type);
        };
        return _object;
    },
    anyOf: function anyOf() {
        var types = [].slice.call(arguments).map(compile);
        function _anyOf(value, strict) {
            return types.some(function(type) {
                try {
                    return typeforce(type, value, strict);
                } catch (e) {
                    return false;
                }
            });
        }
        _anyOf.toJSON = function() {
            return types.map(tfJSON).join("|");
        };
        return _anyOf;
    },
    allOf: function allOf() {
        var types = [].slice.call(arguments).map(compile);
        function _allOf(value, strict) {
            return types.every(function(type) {
                try {
                    return typeforce(type, value, strict);
                } catch (e) {
                    return false;
                }
            });
        }
        _allOf.toJSON = function() {
            return types.map(tfJSON).join(" & ");
        };
        return _allOf;
    },
    quacksLike: function quacksLike(type) {
        function _quacksLike(value) {
            return type === getValueTypeName(value);
        }
        _quacksLike.toJSON = function() {
            return type;
        };
        return _quacksLike;
    },
    tuple: function tuple() {
        var types = [].slice.call(arguments).map(compile);
        function _tuple(values, strict) {
            if (NATIVE.Nil(values)) return false;
            if (NATIVE.Nil(values.length)) return false;
            if (strict && values.length !== types.length) return false;
            return types.every(function(type, i) {
                try {
                    return typeforce(type, values[i], strict);
                } catch (e) {
                    throw tfSubError(e, i);
                }
            });
        }
        _tuple.toJSON = function() {
            return "(" + types.map(tfJSON).join(", ") + ")";
        };
        return _tuple;
    },
    value: function value(expected) {
        function _value(actual) {
            return actual === expected;
        }
        _value.toJSON = function() {
            return expected;
        };
        return _value;
    }
};
// TODO: deprecate
TYPES.oneOf = TYPES.anyOf;
function compile(type) {
    if (NATIVE.String(type)) {
        if (type[0] === "?") return TYPES.maybe(type.slice(1));
        return NATIVE[type] || TYPES.quacksLike(type);
    } else if (type && NATIVE.Object(type)) {
        if (NATIVE.Array(type)) {
            if (type.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
            return TYPES.arrayOf(type[0]);
        }
        return TYPES.object(type);
    } else if (NATIVE.Function(type)) return type;
    return TYPES.value(type);
}
function typeforce(type, value, strict, surrogate) {
    if (NATIVE.Function(type)) {
        if (type(value, strict)) return true;
        throw new TfTypeError(surrogate || type, value);
    }
    // JIT
    return typeforce(compile(type), value, strict);
}
// assign types to typeforce function
for(var typeName in NATIVE)typeforce[typeName] = NATIVE[typeName];
for(typeName in TYPES)typeforce[typeName] = TYPES[typeName];
var EXTRA = require("af9cf6b64343d581");
for(typeName in EXTRA)typeforce[typeName] = EXTRA[typeName];
typeforce.compile = compile;
typeforce.TfTypeError = TfTypeError;
typeforce.TfPropertyTypeError = TfPropertyTypeError;
module.exports = typeforce;

},{"b6b8244aff228baf":"6yFEF","627493ef8c0ede79":"2i9Gd","af9cf6b64343d581":"kiAtF"}],"6yFEF":[function(require,module,exports) {
var native = require("594da27a0c728f6e");
function getTypeName(fn) {
    return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1];
}
function getValueTypeName(value) {
    return native.Nil(value) ? "" : getTypeName(value.constructor);
}
function getValue(value) {
    if (native.Function(value)) return "";
    if (native.String(value)) return JSON.stringify(value);
    if (value && native.Object(value)) return "";
    return value;
}
function captureStackTrace(e, t) {
    if (Error.captureStackTrace) Error.captureStackTrace(e, t);
}
function tfJSON(type) {
    if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type);
    if (native.Array(type)) return "Array";
    if (type && native.Object(type)) return "Object";
    return type !== undefined ? type : "";
}
function tfErrorString(type, value, valueTypeName) {
    var valueJson = getValue(value);
    return "Expected " + tfJSON(type) + ", got" + (valueTypeName !== "" ? " " + valueTypeName : "") + (valueJson !== "" ? " " + valueJson : "");
}
function TfTypeError(type, value, valueTypeName) {
    valueTypeName = valueTypeName || getValueTypeName(value);
    this.message = tfErrorString(type, value, valueTypeName);
    captureStackTrace(this, TfTypeError);
    this.__type = type;
    this.__value = value;
    this.__valueTypeName = valueTypeName;
}
TfTypeError.prototype = Object.create(Error.prototype);
TfTypeError.prototype.constructor = TfTypeError;
function tfPropertyErrorString(type, label, name, value, valueTypeName) {
    var description = '" of type ';
    if (label === "key") description = '" with key type ';
    return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName);
}
function TfPropertyTypeError(type, property, label, value, valueTypeName) {
    if (type) {
        valueTypeName = valueTypeName || getValueTypeName(value);
        this.message = tfPropertyErrorString(type, label, property, value, valueTypeName);
    } else this.message = 'Unexpected property "' + property + '"';
    captureStackTrace(this, TfTypeError);
    this.__label = label;
    this.__property = property;
    this.__type = type;
    this.__value = value;
    this.__valueTypeName = valueTypeName;
}
TfPropertyTypeError.prototype = Object.create(Error.prototype);
TfPropertyTypeError.prototype.constructor = TfTypeError;
function tfCustomError(expected, actual) {
    return new TfTypeError(expected, {}, actual);
}
function tfSubError(e, property, label) {
    // sub child?
    if (e instanceof TfPropertyTypeError) {
        property = property + "." + e.__property;
        e = new TfPropertyTypeError(e.__type, property, e.__label, e.__value, e.__valueTypeName);
    // child?
    } else if (e instanceof TfTypeError) e = new TfPropertyTypeError(e.__type, property, label, e.__value, e.__valueTypeName);
    captureStackTrace(e);
    return e;
}
module.exports = {
    TfTypeError: TfTypeError,
    TfPropertyTypeError: TfPropertyTypeError,
    tfCustomError: tfCustomError,
    tfSubError: tfSubError,
    tfJSON: tfJSON,
    getValueTypeName: getValueTypeName
};

},{"594da27a0c728f6e":"2i9Gd"}],"2i9Gd":[function(require,module,exports) {
var types = {
    Array: function(value) {
        return value !== null && value !== undefined && value.constructor === Array;
    },
    Boolean: function(value) {
        return typeof value === "boolean";
    },
    Function: function(value) {
        return typeof value === "function";
    },
    Nil: function(value) {
        return value === undefined || value === null;
    },
    Number: function(value) {
        return typeof value === "number";
    },
    Object: function(value) {
        return typeof value === "object";
    },
    String: function(value) {
        return typeof value === "string";
    },
    "": function() {
        return true;
    }
};
// TODO: deprecate
types.Null = types.Nil;
for(var typeName in types)types[typeName].toJSON = (function(t) {
    return t;
}).bind(null, typeName);
module.exports = types;

},{}],"kiAtF":[function(require,module,exports) {
var Buffer = require("d58f6654640fbefb").Buffer;
var NATIVE = require("5dc3b5f7dd2c9307");
var ERRORS = require("98ebbf3663d2f194");
function _Buffer(value) {
    return Buffer.isBuffer(value);
}
function Hex(value) {
    return typeof value === "string" && /^([0-9a-f]{2})+$/i.test(value);
}
function _LengthN(type, length) {
    var name = type.toJSON();
    function Length(value) {
        if (!type(value)) return false;
        if (value.length === length) return true;
        throw ERRORS.tfCustomError(name + "(Length: " + length + ")", name + "(Length: " + value.length + ")");
    }
    Length.toJSON = function() {
        return name;
    };
    return Length;
}
var _ArrayN = _LengthN.bind(null, NATIVE.Array);
var _BufferN = _LengthN.bind(null, _Buffer);
var _HexN = _LengthN.bind(null, Hex);
var _StringN = _LengthN.bind(null, NATIVE.String);
function Range(a, b, f) {
    f = f || NATIVE.Number;
    function _range(value, strict) {
        return f(value, strict) && value > a && value < b;
    }
    _range.toJSON = function() {
        return `${f.toJSON()} between [${a}, ${b}]`;
    };
    return _range;
}
var INT53_MAX = Math.pow(2, 53) - 1;
function Finite(value) {
    return typeof value === "number" && isFinite(value);
}
function Int8(value) {
    return value << 24 >> 24 === value;
}
function Int16(value) {
    return value << 16 >> 16 === value;
}
function Int32(value) {
    return (value | 0) === value;
}
function Int53(value) {
    return typeof value === "number" && value >= -INT53_MAX && value <= INT53_MAX && Math.floor(value) === value;
}
function UInt8(value) {
    return (value & 0xff) === value;
}
function UInt16(value) {
    return (value & 0xffff) === value;
}
function UInt32(value) {
    return value >>> 0 === value;
}
function UInt53(value) {
    return typeof value === "number" && value >= 0 && value <= INT53_MAX && Math.floor(value) === value;
}
var types = {
    ArrayN: _ArrayN,
    Buffer: _Buffer,
    BufferN: _BufferN,
    Finite: Finite,
    Hex: Hex,
    HexN: _HexN,
    Int8: Int8,
    Int16: Int16,
    Int32: Int32,
    Int53: Int53,
    Range: Range,
    StringN: _StringN,
    UInt8: UInt8,
    UInt16: UInt16,
    UInt32: UInt32,
    UInt53: UInt53
};
for(var typeName in types)types[typeName].toJSON = (function(t) {
    return t;
}).bind(null, typeName);
module.exports = types;

},{"d58f6654640fbefb":"bwvMq","5dc3b5f7dd2c9307":"2i9Gd","98ebbf3663d2f194":"6yFEF"}],"89Dvm":[function(require,module,exports) {
var Buffer = require("19b618fdd5466574").Buffer;
var bs58check = require("d9f788be23573a8e");
function decodeRaw(buffer, version) {
    // check version only if defined
    if (version !== undefined && buffer[0] !== version) throw new Error("Invalid network version");
    // uncompressed
    if (buffer.length === 33) return {
        version: buffer[0],
        privateKey: buffer.slice(1, 33),
        compressed: false
    };
    // invalid length
    if (buffer.length !== 34) throw new Error("Invalid WIF length");
    // invalid compression flag
    if (buffer[33] !== 0x01) throw new Error("Invalid compression flag");
    return {
        version: buffer[0],
        privateKey: buffer.slice(1, 33),
        compressed: true
    };
}
function encodeRaw(version, privateKey, compressed) {
    var result = new Buffer(compressed ? 34 : 33);
    result.writeUInt8(version, 0);
    privateKey.copy(result, 1);
    if (compressed) result[33] = 0x01;
    return result;
}
function decode(string, version) {
    return decodeRaw(bs58check.decode(string), version);
}
function encode(version, privateKey, compressed) {
    if (typeof version === "number") return bs58check.encode(encodeRaw(version, privateKey, compressed));
    return bs58check.encode(encodeRaw(version.version, version.privateKey, version.compressed));
}
module.exports = {
    decode: decode,
    decodeRaw: decodeRaw,
    encode: encode,
    encodeRaw: encodeRaw
};

},{"19b618fdd5466574":"bwvMq","d9f788be23573a8e":"d8uT8"}],"2Me89":[function(require,module,exports) {
var Buffer = require("1151eb098bb7a030").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const networks = require("e5503de4f312d02f");
const payments = require("9d9899e083f04905");
const bscript = require("1f2ac8b3b271aea8");
const types = require("e26cacb94a21d4c1");
const bech32 = require("e06484115deaf226");
const bs58check = require("d7ce81ef0379eea5");
const typeforce = require("a3fa5ac1e947b3c8");
function fromBase58Check(address) {
    const payload = bs58check.decode(address);
    // TODO: 4.0.0, move to "toOutputScript"
    if (payload.length < 21) throw new TypeError(address + " is too short");
    if (payload.length > 21) throw new TypeError(address + " is too long");
    const version = payload.readUInt8(0);
    const hash = payload.slice(1);
    return {
        version,
        hash
    };
}
exports.fromBase58Check = fromBase58Check;
function fromBech32(address) {
    const result = bech32.decode(address);
    const data = bech32.fromWords(result.words.slice(1));
    return {
        version: result.words[0],
        prefix: result.prefix,
        data: Buffer.from(data)
    };
}
exports.fromBech32 = fromBech32;
function toBase58Check(hash, version) {
    typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);
    const payload = Buffer.allocUnsafe(21);
    payload.writeUInt8(version, 0);
    hash.copy(payload, 1);
    return bs58check.encode(payload);
}
exports.toBase58Check = toBase58Check;
function toBech32(data, version, prefix) {
    const words = bech32.toWords(data);
    words.unshift(version);
    return bech32.encode(prefix, words);
}
exports.toBech32 = toBech32;
function fromOutputScript(output, network) {
    // TODO: Network
    network = network || networks.bitcoin;
    try {
        return payments.p2pkh({
            output,
            network
        }).address;
    } catch (e) {}
    try {
        return payments.p2sh({
            output,
            network
        }).address;
    } catch (e) {}
    try {
        return payments.p2wpkh({
            output,
            network
        }).address;
    } catch (e) {}
    try {
        return payments.p2wsh({
            output,
            network
        }).address;
    } catch (e) {}
    throw new Error(bscript.toASM(output) + " has no matching Address");
}
exports.fromOutputScript = fromOutputScript;
function toOutputScript(address, network) {
    network = network || networks.bitcoin;
    let decodeBase58;
    let decodeBech32;
    try {
        decodeBase58 = fromBase58Check(address);
    } catch (e) {}
    if (decodeBase58) {
        if (decodeBase58.version === network.pubKeyHash) return payments.p2pkh({
            hash: decodeBase58.hash
        }).output;
        if (decodeBase58.version === network.scriptHash) return payments.p2sh({
            hash: decodeBase58.hash
        }).output;
    } else {
        try {
            decodeBech32 = fromBech32(address);
        } catch (e) {}
        if (decodeBech32) {
            if (decodeBech32.prefix !== network.bech32) throw new Error(address + " has an invalid prefix");
            if (decodeBech32.version === 0) {
                if (decodeBech32.data.length === 20) return payments.p2wpkh({
                    hash: decodeBech32.data
                }).output;
                if (decodeBech32.data.length === 32) return payments.p2wsh({
                    hash: decodeBech32.data
                }).output;
            }
        }
    }
    throw new Error(address + " has no matching Script");
}
exports.toOutputScript = toOutputScript;

},{"1151eb098bb7a030":"bwvMq","e5503de4f312d02f":"hpO0s","9d9899e083f04905":"g5Tn6","1f2ac8b3b271aea8":"28LFb","e26cacb94a21d4c1":"eFC2X","e06484115deaf226":"2C5n6","d7ce81ef0379eea5":"d8uT8","a3fa5ac1e947b3c8":"86sQP"}],"hpO0s":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bitcoin = {
    messagePrefix: "\x18Bitcoin Signed Message:\n",
    bech32: "bc",
    bip32: {
        public: 0x0488b21e,
        private: 0x0488ade4
    },
    pubKeyHash: 0x00,
    scriptHash: 0x05,
    wif: 0x80
};
exports.regtest = {
    messagePrefix: "\x18Bitcoin Signed Message:\n",
    bech32: "bcrt",
    bip32: {
        public: 0x043587cf,
        private: 0x04358394
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef
};
exports.testnet = {
    messagePrefix: "\x18Bitcoin Signed Message:\n",
    bech32: "tb",
    bip32: {
        public: 0x043587cf,
        private: 0x04358394
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef
};

},{}],"g5Tn6":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const embed_1 = require("2494b37ccc0d6e77");
exports.embed = embed_1.p2data;
const p2ms_1 = require("93db0ca796737c11");
exports.p2ms = p2ms_1.p2ms;
const p2pk_1 = require("ff65343fd7a4befa");
exports.p2pk = p2pk_1.p2pk;
const p2pkh_1 = require("7b6a4b28b577960a");
exports.p2pkh = p2pkh_1.p2pkh;
const p2sh_1 = require("75de597c28bee3cc");
exports.p2sh = p2sh_1.p2sh;
const p2wpkh_1 = require("e804bde77f0492ef");
exports.p2wpkh = p2wpkh_1.p2wpkh;
const p2wsh_1 = require("789a14e3147c4b3f");
exports.p2wsh = p2wsh_1.p2wsh; // TODO
 // witness commitment

},{"2494b37ccc0d6e77":"iwu0M","93db0ca796737c11":"bzEJW","ff65343fd7a4befa":"dgFqu","7b6a4b28b577960a":"hr95c","75de597c28bee3cc":"gYQTr","e804bde77f0492ef":"6H3XB","789a14e3147c4b3f":"IfDQ0"}],"iwu0M":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const networks_1 = require("9ffab620f56f1d");
const bscript = require("e976e18ff07858d5");
const lazy = require("46c7fdc759d12929");
const typef = require("311b0b031bc5e157");
const OPS = bscript.OPS;
function stacksEqual(a, b) {
    if (a.length !== b.length) return false;
    return a.every((x, i)=>{
        return x.equals(b[i]);
    });
}
// output: OP_RETURN ...
function p2data(a, opts) {
    if (!a.data && !a.output) throw new TypeError("Not enough data");
    opts = Object.assign({
        validate: true
    }, opts || {});
    typef({
        network: typef.maybe(typef.Object),
        output: typef.maybe(typef.Buffer),
        data: typef.maybe(typef.arrayOf(typef.Buffer))
    }, a);
    const network = a.network || networks_1.bitcoin;
    const o = {
        name: "embed",
        network
    };
    lazy.prop(o, "output", ()=>{
        if (!a.data) return;
        return bscript.compile([
            OPS.OP_RETURN
        ].concat(a.data));
    });
    lazy.prop(o, "data", ()=>{
        if (!a.output) return;
        return bscript.decompile(a.output).slice(1);
    });
    // extended validation
    if (opts.validate) {
        if (a.output) {
            const chunks = bscript.decompile(a.output);
            if (chunks[0] !== OPS.OP_RETURN) throw new TypeError("Output is invalid");
            if (!chunks.slice(1).every(typef.Buffer)) throw new TypeError("Output is invalid");
            if (a.data && !stacksEqual(a.data, o.data)) throw new TypeError("Data mismatch");
        }
    }
    return Object.assign(o, a);
}
exports.p2data = p2data;

},{"9ffab620f56f1d":"hpO0s","e976e18ff07858d5":"28LFb","46c7fdc759d12929":"cHER6","311b0b031bc5e157":"86sQP"}],"28LFb":[function(require,module,exports) {
var Buffer = require("8c814422076f049b").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const scriptNumber = require("6964cf95aaccf14e");
const scriptSignature = require("aa6504b1b3c1222a");
const types = require("9416e6598c14cc94");
const bip66 = require("bedd8de3c334506f");
const ecc = require("bbc05c7f790e84b0");
const pushdata = require("8b89b0b9dae24bd8");
const typeforce = require("a87fe090b6f4d463");
exports.OPS = require("d2cdce37ffd194fe");
const REVERSE_OPS = require("671f5ccde5643465");
const OP_INT_BASE = exports.OPS.OP_RESERVED; // OP_1 - 1
function isOPInt(value) {
    return types.Number(value) && (value === exports.OPS.OP_0 || value >= exports.OPS.OP_1 && value <= exports.OPS.OP_16 || value === exports.OPS.OP_1NEGATE);
}
function isPushOnlyChunk(value) {
    return types.Buffer(value) || isOPInt(value);
}
function isPushOnly(value) {
    return types.Array(value) && value.every(isPushOnlyChunk);
}
exports.isPushOnly = isPushOnly;
function asMinimalOP(buffer) {
    if (buffer.length === 0) return exports.OPS.OP_0;
    if (buffer.length !== 1) return;
    if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];
    if (buffer[0] === 0x81) return exports.OPS.OP_1NEGATE;
}
function chunksIsBuffer(buf) {
    return Buffer.isBuffer(buf);
}
function chunksIsArray(buf) {
    return types.Array(buf);
}
function singleChunkIsBuffer(buf) {
    return Buffer.isBuffer(buf);
}
function compile(chunks) {
    // TODO: remove me
    if (chunksIsBuffer(chunks)) return chunks;
    typeforce(types.Array, chunks);
    const bufferSize = chunks.reduce((accum, chunk)=>{
        // data chunk
        if (singleChunkIsBuffer(chunk)) {
            // adhere to BIP62.3, minimal push policy
            if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) return accum + 1;
            return accum + pushdata.encodingLength(chunk.length) + chunk.length;
        }
        // opcode
        return accum + 1;
    }, 0.0);
    const buffer = Buffer.allocUnsafe(bufferSize);
    let offset = 0;
    chunks.forEach((chunk)=>{
        // data chunk
        if (singleChunkIsBuffer(chunk)) {
            // adhere to BIP62.3, minimal push policy
            const opcode = asMinimalOP(chunk);
            if (opcode !== undefined) {
                buffer.writeUInt8(opcode, offset);
                offset += 1;
                return;
            }
            offset += pushdata.encode(buffer, chunk.length, offset);
            chunk.copy(buffer, offset);
            offset += chunk.length;
        // opcode
        } else {
            buffer.writeUInt8(chunk, offset);
            offset += 1;
        }
    });
    if (offset !== buffer.length) throw new Error("Could not decode chunks");
    return buffer;
}
exports.compile = compile;
function decompile(buffer) {
    // TODO: remove me
    if (chunksIsArray(buffer)) return buffer;
    typeforce(types.Buffer, buffer);
    const chunks = [];
    let i = 0;
    while(i < buffer.length){
        const opcode = buffer[i];
        // data chunk
        if (opcode > exports.OPS.OP_0 && opcode <= exports.OPS.OP_PUSHDATA4) {
            const d = pushdata.decode(buffer, i);
            // did reading a pushDataInt fail?
            if (d === null) return null;
            i += d.size;
            // attempt to read too much data?
            if (i + d.number > buffer.length) return null;
            const data = buffer.slice(i, i + d.number);
            i += d.number;
            // decompile minimally
            const op = asMinimalOP(data);
            if (op !== undefined) chunks.push(op);
            else chunks.push(data);
        // opcode
        } else {
            chunks.push(opcode);
            i += 1;
        }
    }
    return chunks;
}
exports.decompile = decompile;
function toASM(chunks) {
    if (chunksIsBuffer(chunks)) chunks = decompile(chunks);
    return chunks.map((chunk)=>{
        // data?
        if (singleChunkIsBuffer(chunk)) {
            const op = asMinimalOP(chunk);
            if (op === undefined) return chunk.toString("hex");
            chunk = op;
        }
        // opcode!
        return REVERSE_OPS[chunk];
    }).join(" ");
}
exports.toASM = toASM;
function fromASM(asm) {
    typeforce(types.String, asm);
    return compile(asm.split(" ").map((chunkStr)=>{
        // opcode?
        if (exports.OPS[chunkStr] !== undefined) return exports.OPS[chunkStr];
        typeforce(types.Hex, chunkStr);
        // data!
        return Buffer.from(chunkStr, "hex");
    }));
}
exports.fromASM = fromASM;
function toStack(chunks) {
    chunks = decompile(chunks);
    typeforce(isPushOnly, chunks);
    return chunks.map((op)=>{
        if (singleChunkIsBuffer(op)) return op;
        if (op === exports.OPS.OP_0) return Buffer.allocUnsafe(0);
        return scriptNumber.encode(op - OP_INT_BASE);
    });
}
exports.toStack = toStack;
function isCanonicalPubKey(buffer) {
    return ecc.isPoint(buffer);
}
exports.isCanonicalPubKey = isCanonicalPubKey;
function isDefinedHashType(hashType) {
    const hashTypeMod = hashType & -129;
    // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE
    return hashTypeMod > 0x00 && hashTypeMod < 0x04;
}
exports.isDefinedHashType = isDefinedHashType;
function isCanonicalScriptSignature(buffer) {
    if (!Buffer.isBuffer(buffer)) return false;
    if (!isDefinedHashType(buffer[buffer.length - 1])) return false;
    return bip66.check(buffer.slice(0, -1));
}
exports.isCanonicalScriptSignature = isCanonicalScriptSignature;
// tslint:disable-next-line variable-name
exports.number = scriptNumber;
exports.signature = scriptSignature;

},{"8c814422076f049b":"bwvMq","6964cf95aaccf14e":"dXm7r","aa6504b1b3c1222a":"cel67","9416e6598c14cc94":"eFC2X","bedd8de3c334506f":"kvzde","bbc05c7f790e84b0":"aaqVm","8b89b0b9dae24bd8":"8a51R","a87fe090b6f4d463":"86sQP","d2cdce37ffd194fe":"hfVdq","671f5ccde5643465":"66bxy"}],"dXm7r":[function(require,module,exports) {
var Buffer = require("3e6b6f0a13264aa6").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function decode(buffer, maxLength, minimal) {
    maxLength = maxLength || 4;
    minimal = minimal === undefined ? true : minimal;
    const length = buffer.length;
    if (length === 0) return 0;
    if (length > maxLength) throw new TypeError("Script number overflow");
    if (minimal) {
        if ((buffer[length - 1] & 0x7f) === 0) {
            if (length <= 1 || (buffer[length - 2] & 0x80) === 0) throw new Error("Non-minimally encoded script number");
        }
    }
    // 40-bit
    if (length === 5) {
        const a = buffer.readUInt32LE(0);
        const b = buffer.readUInt8(4);
        if (b & 0x80) return -((b & -129) * 0x100000000 + a);
        return b * 0x100000000 + a;
    }
    // 32-bit / 24-bit / 16-bit / 8-bit
    let result = 0;
    for(let i = 0; i < length; ++i)result |= buffer[i] << 8 * i;
    if (buffer[length - 1] & 0x80) return -(result & ~(0x80 << 8 * (length - 1)));
    return result;
}
exports.decode = decode;
function scriptNumSize(i) {
    return i > 0x7fffffff ? 5 : i > 0x7fffff ? 4 : i > 0x7fff ? 3 : i > 0x7f ? 2 : i > 0x00 ? 1 : 0;
}
function encode(_number) {
    let value = Math.abs(_number);
    const size = scriptNumSize(value);
    const buffer = Buffer.allocUnsafe(size);
    const negative = _number < 0;
    for(let i = 0; i < size; ++i){
        buffer.writeUInt8(value & 0xff, i);
        value >>= 8;
    }
    if (buffer[size - 1] & 0x80) buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);
    else if (negative) buffer[size - 1] |= 0x80;
    return buffer;
}
exports.encode = encode;

},{"3e6b6f0a13264aa6":"bwvMq"}],"cel67":[function(require,module,exports) {
var Buffer = require("9d0276df3a9f61d8").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const types = require("2c36b22e1bc51145");
const bip66 = require("3c5b1c6bffbce407");
const typeforce = require("4ac18855f31cc203");
const ZERO = Buffer.alloc(1, 0);
function toDER(x) {
    let i = 0;
    while(x[i] === 0)++i;
    if (i === x.length) return ZERO;
    x = x.slice(i);
    if (x[0] & 0x80) return Buffer.concat([
        ZERO,
        x
    ], 1 + x.length);
    return x;
}
function fromDER(x) {
    if (x[0] === 0x00) x = x.slice(1);
    const buffer = Buffer.alloc(32, 0);
    const bstart = Math.max(0, 32 - x.length);
    x.copy(buffer, bstart);
    return buffer;
}
// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)
function decode(buffer) {
    const hashType = buffer.readUInt8(buffer.length - 1);
    const hashTypeMod = hashType & -129;
    if (hashTypeMod <= 0 || hashTypeMod >= 4) throw new Error("Invalid hashType " + hashType);
    const decoded = bip66.decode(buffer.slice(0, -1));
    const r = fromDER(decoded.r);
    const s = fromDER(decoded.s);
    const signature = Buffer.concat([
        r,
        s
    ], 64);
    return {
        signature,
        hashType
    };
}
exports.decode = decode;
function encode(signature, hashType) {
    typeforce({
        signature: types.BufferN(64),
        hashType: types.UInt8
    }, {
        signature,
        hashType
    });
    const hashTypeMod = hashType & -129;
    if (hashTypeMod <= 0 || hashTypeMod >= 4) throw new Error("Invalid hashType " + hashType);
    const hashTypeBuffer = Buffer.allocUnsafe(1);
    hashTypeBuffer.writeUInt8(hashType, 0);
    const r = toDER(signature.slice(0, 32));
    const s = toDER(signature.slice(32, 64));
    return Buffer.concat([
        bip66.encode(r, s),
        hashTypeBuffer
    ]);
}
exports.encode = encode;

},{"9d0276df3a9f61d8":"bwvMq","2c36b22e1bc51145":"eFC2X","3c5b1c6bffbce407":"kvzde","4ac18855f31cc203":"86sQP"}],"eFC2X":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typeforce = require("7c90ee7d0a3cd37");
const UINT31_MAX = Math.pow(2, 31) - 1;
function UInt31(value) {
    return typeforce.UInt32(value) && value <= UINT31_MAX;
}
exports.UInt31 = UInt31;
function BIP32Path(value) {
    return typeforce.String(value) && !!value.match(/^(m\/)?(\d+'?\/)*\d+'?$/);
}
exports.BIP32Path = BIP32Path;
BIP32Path.toJSON = ()=>{
    return "BIP32 derivation path";
};
function Signer(obj) {
    return (typeforce.Buffer(obj.publicKey) || typeof obj.getPublicKey === "function") && typeof obj.sign === "function";
}
exports.Signer = Signer;
const SATOSHI_MAX = 21 * 1e14;
function Satoshi(value) {
    return typeforce.UInt53(value) && value <= SATOSHI_MAX;
}
exports.Satoshi = Satoshi;
// external dependent types
exports.ECPoint = typeforce.quacksLike("Point");
// exposed, external API
exports.Network = typeforce.compile({
    messagePrefix: typeforce.oneOf(typeforce.Buffer, typeforce.String),
    bip32: {
        public: typeforce.UInt32,
        private: typeforce.UInt32
    },
    pubKeyHash: typeforce.UInt8,
    scriptHash: typeforce.UInt8,
    wif: typeforce.UInt8
});
exports.Buffer256bit = typeforce.BufferN(32);
exports.Hash160bit = typeforce.BufferN(20);
exports.Hash256bit = typeforce.BufferN(32);
exports.Number = typeforce.Number; // tslint:disable-line variable-name
exports.Array = typeforce.Array;
exports.Boolean = typeforce.Boolean; // tslint:disable-line variable-name
exports.String = typeforce.String; // tslint:disable-line variable-name
exports.Buffer = typeforce.Buffer;
exports.Hex = typeforce.Hex;
exports.maybe = typeforce.maybe;
exports.tuple = typeforce.tuple;
exports.UInt8 = typeforce.UInt8;
exports.UInt32 = typeforce.UInt32;
exports.Function = typeforce.Function;
exports.BufferN = typeforce.BufferN;
exports.Null = typeforce.Null;
exports.oneOf = typeforce.oneOf;

},{"7c90ee7d0a3cd37":"86sQP"}],"kvzde":[function(require,module,exports) {
// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
// NOTE: SIGHASH byte ignored AND restricted, truncate before use
var Buffer = require("38b4b92f2b3989de").Buffer;
function check(buffer) {
    if (buffer.length < 8) return false;
    if (buffer.length > 72) return false;
    if (buffer[0] !== 0x30) return false;
    if (buffer[1] !== buffer.length - 2) return false;
    if (buffer[2] !== 0x02) return false;
    var lenR = buffer[3];
    if (lenR === 0) return false;
    if (5 + lenR >= buffer.length) return false;
    if (buffer[4 + lenR] !== 0x02) return false;
    var lenS = buffer[5 + lenR];
    if (lenS === 0) return false;
    if (6 + lenR + lenS !== buffer.length) return false;
    if (buffer[4] & 0x80) return false;
    if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) return false;
    if (buffer[lenR + 6] & 0x80) return false;
    if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80)) return false;
    return true;
}
function decode(buffer) {
    if (buffer.length < 8) throw new Error("DER sequence length is too short");
    if (buffer.length > 72) throw new Error("DER sequence length is too long");
    if (buffer[0] !== 0x30) throw new Error("Expected DER sequence");
    if (buffer[1] !== buffer.length - 2) throw new Error("DER sequence length is invalid");
    if (buffer[2] !== 0x02) throw new Error("Expected DER integer");
    var lenR = buffer[3];
    if (lenR === 0) throw new Error("R length is zero");
    if (5 + lenR >= buffer.length) throw new Error("R length is too long");
    if (buffer[4 + lenR] !== 0x02) throw new Error("Expected DER integer (2)");
    var lenS = buffer[5 + lenR];
    if (lenS === 0) throw new Error("S length is zero");
    if (6 + lenR + lenS !== buffer.length) throw new Error("S length is invalid");
    if (buffer[4] & 0x80) throw new Error("R value is negative");
    if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) throw new Error("R value excessively padded");
    if (buffer[lenR + 6] & 0x80) throw new Error("S value is negative");
    if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80)) throw new Error("S value excessively padded");
    // non-BIP66 - extract R, S values
    return {
        r: buffer.slice(4, 4 + lenR),
        s: buffer.slice(6 + lenR)
    };
}
/*
 * Expects r and s to be positive DER integers.
 *
 * The DER format uses the most significant bit as a sign bit (& 0x80).
 * If the significant bit is set AND the integer is positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
*/ function encode(r, s) {
    var lenR = r.length;
    var lenS = s.length;
    if (lenR === 0) throw new Error("R length is zero");
    if (lenS === 0) throw new Error("S length is zero");
    if (lenR > 33) throw new Error("R length is too long");
    if (lenS > 33) throw new Error("S length is too long");
    if (r[0] & 0x80) throw new Error("R value is negative");
    if (s[0] & 0x80) throw new Error("S value is negative");
    if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80)) throw new Error("R value excessively padded");
    if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80)) throw new Error("S value excessively padded");
    var signature = Buffer.allocUnsafe(6 + lenR + lenS);
    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
    signature[0] = 0x30;
    signature[1] = signature.length - 2;
    signature[2] = 0x02;
    signature[3] = r.length;
    r.copy(signature, 4);
    signature[4 + lenR] = 0x02;
    signature[5 + lenR] = s.length;
    s.copy(signature, 6 + lenR);
    return signature;
}
module.exports = {
    check: check,
    decode: decode,
    encode: encode
};

},{"38b4b92f2b3989de":"eW7r9"}],"8a51R":[function(require,module,exports) {
var OPS = require("700ed4fdaa5dcf97");
function encodingLength(i) {
    return i < OPS.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;
}
function encode(buffer, number, offset) {
    var size = encodingLength(number);
    // ~6 bit
    if (size === 1) buffer.writeUInt8(number, offset);
    else if (size === 2) {
        buffer.writeUInt8(OPS.OP_PUSHDATA1, offset);
        buffer.writeUInt8(number, offset + 1);
    // 16 bit
    } else if (size === 3) {
        buffer.writeUInt8(OPS.OP_PUSHDATA2, offset);
        buffer.writeUInt16LE(number, offset + 1);
    // 32 bit
    } else {
        buffer.writeUInt8(OPS.OP_PUSHDATA4, offset);
        buffer.writeUInt32LE(number, offset + 1);
    }
    return size;
}
function decode(buffer, offset) {
    var opcode = buffer.readUInt8(offset);
    var number, size;
    // ~6 bit
    if (opcode < OPS.OP_PUSHDATA1) {
        number = opcode;
        size = 1;
    // 8 bit
    } else if (opcode === OPS.OP_PUSHDATA1) {
        if (offset + 2 > buffer.length) return null;
        number = buffer.readUInt8(offset + 1);
        size = 2;
    // 16 bit
    } else if (opcode === OPS.OP_PUSHDATA2) {
        if (offset + 3 > buffer.length) return null;
        number = buffer.readUInt16LE(offset + 1);
        size = 3;
    // 32 bit
    } else {
        if (offset + 5 > buffer.length) return null;
        if (opcode !== OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
        number = buffer.readUInt32LE(offset + 1);
        size = 5;
    }
    return {
        opcode: opcode,
        number: number,
        size: size
    };
}
module.exports = {
    encodingLength: encodingLength,
    encode: encode,
    decode: decode
};

},{"700ed4fdaa5dcf97":"hfVdq"}],"hfVdq":[function(require,module,exports) {
module.exports = JSON.parse('{"OP_FALSE":0,"OP_0":0,"OP_PUSHDATA1":76,"OP_PUSHDATA2":77,"OP_PUSHDATA4":78,"OP_1NEGATE":79,"OP_RESERVED":80,"OP_TRUE":81,"OP_1":81,"OP_2":82,"OP_3":83,"OP_4":84,"OP_5":85,"OP_6":86,"OP_7":87,"OP_8":88,"OP_9":89,"OP_10":90,"OP_11":91,"OP_12":92,"OP_13":93,"OP_14":94,"OP_15":95,"OP_16":96,"OP_NOP":97,"OP_VER":98,"OP_IF":99,"OP_NOTIF":100,"OP_VERIF":101,"OP_VERNOTIF":102,"OP_ELSE":103,"OP_ENDIF":104,"OP_VERIFY":105,"OP_RETURN":106,"OP_TOALTSTACK":107,"OP_FROMALTSTACK":108,"OP_2DROP":109,"OP_2DUP":110,"OP_3DUP":111,"OP_2OVER":112,"OP_2ROT":113,"OP_2SWAP":114,"OP_IFDUP":115,"OP_DEPTH":116,"OP_DROP":117,"OP_DUP":118,"OP_NIP":119,"OP_OVER":120,"OP_PICK":121,"OP_ROLL":122,"OP_ROT":123,"OP_SWAP":124,"OP_TUCK":125,"OP_CAT":126,"OP_SUBSTR":127,"OP_LEFT":128,"OP_RIGHT":129,"OP_SIZE":130,"OP_INVERT":131,"OP_AND":132,"OP_OR":133,"OP_XOR":134,"OP_EQUAL":135,"OP_EQUALVERIFY":136,"OP_RESERVED1":137,"OP_RESERVED2":138,"OP_1ADD":139,"OP_1SUB":140,"OP_2MUL":141,"OP_2DIV":142,"OP_NEGATE":143,"OP_ABS":144,"OP_NOT":145,"OP_0NOTEQUAL":146,"OP_ADD":147,"OP_SUB":148,"OP_MUL":149,"OP_DIV":150,"OP_MOD":151,"OP_LSHIFT":152,"OP_RSHIFT":153,"OP_BOOLAND":154,"OP_BOOLOR":155,"OP_NUMEQUAL":156,"OP_NUMEQUALVERIFY":157,"OP_NUMNOTEQUAL":158,"OP_LESSTHAN":159,"OP_GREATERTHAN":160,"OP_LESSTHANOREQUAL":161,"OP_GREATERTHANOREQUAL":162,"OP_MIN":163,"OP_MAX":164,"OP_WITHIN":165,"OP_RIPEMD160":166,"OP_SHA1":167,"OP_SHA256":168,"OP_HASH160":169,"OP_HASH256":170,"OP_CODESEPARATOR":171,"OP_CHECKSIG":172,"OP_CHECKSIGVERIFY":173,"OP_CHECKMULTISIG":174,"OP_CHECKMULTISIGVERIFY":175,"OP_NOP1":176,"OP_NOP2":177,"OP_CHECKLOCKTIMEVERIFY":177,"OP_NOP3":178,"OP_CHECKSEQUENCEVERIFY":178,"OP_NOP4":179,"OP_NOP5":180,"OP_NOP6":181,"OP_NOP7":182,"OP_NOP8":183,"OP_NOP9":184,"OP_NOP10":185,"OP_PUBKEYHASH":253,"OP_PUBKEY":254,"OP_INVALIDOPCODE":255}');

},{}],"66bxy":[function(require,module,exports) {
var OPS = require("4436665fb0d00282");
var map = {};
for(var op in OPS){
    var code = OPS[op];
    map[code] = op;
}
module.exports = map;

},{"4436665fb0d00282":"hfVdq"}],"cHER6":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function prop(object, name, f) {
    Object.defineProperty(object, name, {
        configurable: true,
        enumerable: true,
        get () {
            const _value = f.call(this);
            this[name] = _value;
            return _value;
        },
        set (_value) {
            Object.defineProperty(this, name, {
                configurable: true,
                enumerable: true,
                value: _value,
                writable: true
            });
        }
    });
}
exports.prop = prop;
function value(f) {
    let _value;
    return ()=>{
        if (_value !== undefined) return _value;
        _value = f();
        return _value;
    };
}
exports.value = value;

},{}],"bzEJW":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const networks_1 = require("b217898e281f5a04");
const bscript = require("f3961ea8c14a4fb4");
const lazy = require("d2a9502e04ffdd9b");
const OPS = bscript.OPS;
const typef = require("475caf3a929e348f");
const ecc = require("9b26fd1dec5700c6");
const OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1
function stacksEqual(a, b) {
    if (a.length !== b.length) return false;
    return a.every((x, i)=>{
        return x.equals(b[i]);
    });
}
// input: OP_0 [signatures ...]
// output: m [pubKeys ...] n OP_CHECKMULTISIG
function p2ms(a, opts) {
    if (!a.input && !a.output && !(a.pubkeys && a.m !== undefined) && !a.signatures) throw new TypeError("Not enough data");
    opts = Object.assign({
        validate: true
    }, opts || {});
    function isAcceptableSignature(x) {
        return bscript.isCanonicalScriptSignature(x) || (opts.allowIncomplete && x === OPS.OP_0) !== undefined;
    }
    typef({
        network: typef.maybe(typef.Object),
        m: typef.maybe(typef.Number),
        n: typef.maybe(typef.Number),
        output: typef.maybe(typef.Buffer),
        pubkeys: typef.maybe(typef.arrayOf(ecc.isPoint)),
        signatures: typef.maybe(typef.arrayOf(isAcceptableSignature)),
        input: typef.maybe(typef.Buffer)
    }, a);
    const network = a.network || networks_1.bitcoin;
    const o = {
        network
    };
    let chunks = [];
    let decoded = false;
    function decode(output) {
        if (decoded) return;
        decoded = true;
        chunks = bscript.decompile(output);
        o.m = chunks[0] - OP_INT_BASE;
        o.n = chunks[chunks.length - 2] - OP_INT_BASE;
        o.pubkeys = chunks.slice(1, -2);
    }
    lazy.prop(o, "output", ()=>{
        if (!a.m) return;
        if (!o.n) return;
        if (!a.pubkeys) return;
        return bscript.compile([].concat(OP_INT_BASE + a.m, a.pubkeys, OP_INT_BASE + o.n, OPS.OP_CHECKMULTISIG));
    });
    lazy.prop(o, "m", ()=>{
        if (!o.output) return;
        decode(o.output);
        return o.m;
    });
    lazy.prop(o, "n", ()=>{
        if (!o.pubkeys) return;
        return o.pubkeys.length;
    });
    lazy.prop(o, "pubkeys", ()=>{
        if (!a.output) return;
        decode(a.output);
        return o.pubkeys;
    });
    lazy.prop(o, "signatures", ()=>{
        if (!a.input) return;
        return bscript.decompile(a.input).slice(1);
    });
    lazy.prop(o, "input", ()=>{
        if (!a.signatures) return;
        return bscript.compile([
            OPS.OP_0
        ].concat(a.signatures));
    });
    lazy.prop(o, "witness", ()=>{
        if (!o.input) return;
        return [];
    });
    lazy.prop(o, "name", ()=>{
        if (!o.m || !o.n) return;
        return `p2ms(${o.m} of ${o.n})`;
    });
    // extended validation
    if (opts.validate) {
        if (a.output) {
            decode(a.output);
            if (!typef.Number(chunks[0])) throw new TypeError("Output is invalid");
            if (!typef.Number(chunks[chunks.length - 2])) throw new TypeError("Output is invalid");
            if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG) throw new TypeError("Output is invalid");
            if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3) throw new TypeError("Output is invalid");
            if (!o.pubkeys.every((x)=>ecc.isPoint(x))) throw new TypeError("Output is invalid");
            if (a.m !== undefined && a.m !== o.m) throw new TypeError("m mismatch");
            if (a.n !== undefined && a.n !== o.n) throw new TypeError("n mismatch");
            if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys)) throw new TypeError("Pubkeys mismatch");
        }
        if (a.pubkeys) {
            if (a.n !== undefined && a.n !== a.pubkeys.length) throw new TypeError("Pubkey count mismatch");
            o.n = a.pubkeys.length;
            if (o.n < o.m) throw new TypeError("Pubkey count cannot be less than m");
        }
        if (a.signatures) {
            if (a.signatures.length < o.m) throw new TypeError("Not enough signatures provided");
            if (a.signatures.length > o.m) throw new TypeError("Too many signatures provided");
        }
        if (a.input) {
            if (a.input[0] !== OPS.OP_0) throw new TypeError("Input is invalid");
            if (o.signatures.length === 0 || !o.signatures.every(isAcceptableSignature)) throw new TypeError("Input has invalid signature(s)");
            if (a.signatures && !stacksEqual(a.signatures, o.signatures)) throw new TypeError("Signature mismatch");
            if (a.m !== undefined && a.m !== a.signatures.length) throw new TypeError("Signature count mismatch");
        }
    }
    return Object.assign(o, a);
}
exports.p2ms = p2ms;

},{"b217898e281f5a04":"hpO0s","f3961ea8c14a4fb4":"28LFb","d2a9502e04ffdd9b":"cHER6","475caf3a929e348f":"86sQP","9b26fd1dec5700c6":"aaqVm"}],"dgFqu":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const networks_1 = require("9afd0cfa6d72aef9");
const bscript = require("fdd0ac01bab5db7a");
const lazy = require("88587e1ea257d089");
const typef = require("c45ea0aa41c65988");
const OPS = bscript.OPS;
const ecc = require("e5a2fd4ef1d1d17");
// input: {signature}
// output: {pubKey} OP_CHECKSIG
function p2pk(a, opts) {
    if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature) throw new TypeError("Not enough data");
    opts = Object.assign({
        validate: true
    }, opts || {});
    typef({
        network: typef.maybe(typef.Object),
        output: typef.maybe(typef.Buffer),
        pubkey: typef.maybe(ecc.isPoint),
        signature: typef.maybe(bscript.isCanonicalScriptSignature),
        input: typef.maybe(typef.Buffer)
    }, a);
    const _chunks = lazy.value(()=>{
        return bscript.decompile(a.input);
    });
    const network = a.network || networks_1.bitcoin;
    const o = {
        name: "p2pk",
        network
    };
    lazy.prop(o, "output", ()=>{
        if (!a.pubkey) return;
        return bscript.compile([
            a.pubkey,
            OPS.OP_CHECKSIG
        ]);
    });
    lazy.prop(o, "pubkey", ()=>{
        if (!a.output) return;
        return a.output.slice(1, -1);
    });
    lazy.prop(o, "signature", ()=>{
        if (!a.input) return;
        return _chunks()[0];
    });
    lazy.prop(o, "input", ()=>{
        if (!a.signature) return;
        return bscript.compile([
            a.signature
        ]);
    });
    lazy.prop(o, "witness", ()=>{
        if (!o.input) return;
        return [];
    });
    // extended validation
    if (opts.validate) {
        if (a.output) {
            if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG) throw new TypeError("Output is invalid");
            if (!ecc.isPoint(o.pubkey)) throw new TypeError("Output pubkey is invalid");
            if (a.pubkey && !a.pubkey.equals(o.pubkey)) throw new TypeError("Pubkey mismatch");
        }
        if (a.signature) {
            if (a.input && !a.input.equals(o.input)) throw new TypeError("Signature mismatch");
        }
        if (a.input) {
            if (_chunks().length !== 1) throw new TypeError("Input is invalid");
            if (!bscript.isCanonicalScriptSignature(o.signature)) throw new TypeError("Input has invalid signature");
        }
    }
    return Object.assign(o, a);
}
exports.p2pk = p2pk;

},{"9afd0cfa6d72aef9":"hpO0s","fdd0ac01bab5db7a":"28LFb","88587e1ea257d089":"cHER6","c45ea0aa41c65988":"86sQP","e5a2fd4ef1d1d17":"aaqVm"}],"hr95c":[function(require,module,exports) {
var Buffer = require("7cd63e6e4ad49018").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bcrypto = require("2ed83564aa1e3b7e");
const networks_1 = require("93f088a32c181dff");
const bscript = require("8faff36ab611fa24");
const lazy = require("a8c6c65f4f76d29b");
const typef = require("6d855cc5eac5534b");
const OPS = bscript.OPS;
const ecc = require("6ae67344cd6217b2");
const bs58check = require("d9ed3806a3280851");
// input: {signature} {pubkey}
// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG
function p2pkh(a, opts) {
    if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input) throw new TypeError("Not enough data");
    opts = Object.assign({
        validate: true
    }, opts || {});
    typef({
        network: typef.maybe(typef.Object),
        address: typef.maybe(typef.String),
        hash: typef.maybe(typef.BufferN(20)),
        output: typef.maybe(typef.BufferN(25)),
        pubkey: typef.maybe(ecc.isPoint),
        signature: typef.maybe(bscript.isCanonicalScriptSignature),
        input: typef.maybe(typef.Buffer)
    }, a);
    const _address = lazy.value(()=>{
        const payload = bs58check.decode(a.address);
        const version = payload.readUInt8(0);
        const hash = payload.slice(1);
        return {
            version,
            hash
        };
    });
    const _chunks = lazy.value(()=>{
        return bscript.decompile(a.input);
    });
    const network = a.network || networks_1.bitcoin;
    const o = {
        name: "p2pkh",
        network
    };
    lazy.prop(o, "address", ()=>{
        if (!o.hash) return;
        const payload = Buffer.allocUnsafe(21);
        payload.writeUInt8(network.pubKeyHash, 0);
        o.hash.copy(payload, 1);
        return bs58check.encode(payload);
    });
    lazy.prop(o, "hash", ()=>{
        if (a.output) return a.output.slice(3, 23);
        if (a.address) return _address().hash;
        if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
    });
    lazy.prop(o, "output", ()=>{
        if (!o.hash) return;
        return bscript.compile([
            OPS.OP_DUP,
            OPS.OP_HASH160,
            o.hash,
            OPS.OP_EQUALVERIFY,
            OPS.OP_CHECKSIG
        ]);
    });
    lazy.prop(o, "pubkey", ()=>{
        if (!a.input) return;
        return _chunks()[1];
    });
    lazy.prop(o, "signature", ()=>{
        if (!a.input) return;
        return _chunks()[0];
    });
    lazy.prop(o, "input", ()=>{
        if (!a.pubkey) return;
        if (!a.signature) return;
        return bscript.compile([
            a.signature,
            a.pubkey
        ]);
    });
    lazy.prop(o, "witness", ()=>{
        if (!o.input) return;
        return [];
    });
    // extended validation
    if (opts.validate) {
        let hash = Buffer.from([]);
        if (a.address) {
            if (_address().version !== network.pubKeyHash) throw new TypeError("Invalid version or Network mismatch");
            if (_address().hash.length !== 20) throw new TypeError("Invalid address");
            hash = _address().hash;
        }
        if (a.hash) {
            if (hash.length > 0 && !hash.equals(a.hash)) throw new TypeError("Hash mismatch");
            else hash = a.hash;
        }
        if (a.output) {
            if (a.output.length !== 25 || a.output[0] !== OPS.OP_DUP || a.output[1] !== OPS.OP_HASH160 || a.output[2] !== 0x14 || a.output[23] !== OPS.OP_EQUALVERIFY || a.output[24] !== OPS.OP_CHECKSIG) throw new TypeError("Output is invalid");
            const hash2 = a.output.slice(3, 23);
            if (hash.length > 0 && !hash.equals(hash2)) throw new TypeError("Hash mismatch");
            else hash = hash2;
        }
        if (a.pubkey) {
            const pkh = bcrypto.hash160(a.pubkey);
            if (hash.length > 0 && !hash.equals(pkh)) throw new TypeError("Hash mismatch");
            else hash = pkh;
        }
        if (a.input) {
            const chunks = _chunks();
            if (chunks.length !== 2) throw new TypeError("Input is invalid");
            if (!bscript.isCanonicalScriptSignature(chunks[0])) throw new TypeError("Input has invalid signature");
            if (!ecc.isPoint(chunks[1])) throw new TypeError("Input has invalid pubkey");
            if (a.signature && !a.signature.equals(chunks[0])) throw new TypeError("Signature mismatch");
            if (a.pubkey && !a.pubkey.equals(chunks[1])) throw new TypeError("Pubkey mismatch");
            const pkh = bcrypto.hash160(chunks[1]);
            if (hash.length > 0 && !hash.equals(pkh)) throw new TypeError("Hash mismatch");
        }
    }
    return Object.assign(o, a);
}
exports.p2pkh = p2pkh;

},{"7cd63e6e4ad49018":"bwvMq","2ed83564aa1e3b7e":"4BCCF","93f088a32c181dff":"hpO0s","8faff36ab611fa24":"28LFb","a8c6c65f4f76d29b":"cHER6","6d855cc5eac5534b":"86sQP","6ae67344cd6217b2":"aaqVm","d9ed3806a3280851":"d8uT8"}],"4BCCF":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const createHash = require("12edc512a8315ae4");
function ripemd160(buffer) {
    try {
        return createHash("rmd160").update(buffer).digest();
    } catch (err) {
        return createHash("ripemd160").update(buffer).digest();
    }
}
exports.ripemd160 = ripemd160;
function sha1(buffer) {
    return createHash("sha1").update(buffer).digest();
}
exports.sha1 = sha1;
function sha256(buffer) {
    return createHash("sha256").update(buffer).digest();
}
exports.sha256 = sha256;
function hash160(buffer) {
    return ripemd160(sha256(buffer));
}
exports.hash160 = hash160;
function hash256(buffer) {
    return sha256(sha256(buffer));
}
exports.hash256 = hash256;

},{"12edc512a8315ae4":"2WyL8"}],"gYQTr":[function(require,module,exports) {
var Buffer = require("c6b571691afe0e89").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bcrypto = require("91194c2f7e31c985");
const networks_1 = require("9002de76ada6b23c");
const bscript = require("8f74fc4c7d847f80");
const lazy = require("de67a085acdb2528");
const typef = require("e4b68fec44748056");
const OPS = bscript.OPS;
const bs58check = require("ef6a72781420c06f");
function stacksEqual(a, b) {
    if (a.length !== b.length) return false;
    return a.every((x, i)=>{
        return x.equals(b[i]);
    });
}
// input: [redeemScriptSig ...] {redeemScript}
// witness: <?>
// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL
function p2sh(a, opts) {
    if (!a.address && !a.hash && !a.output && !a.redeem && !a.input) throw new TypeError("Not enough data");
    opts = Object.assign({
        validate: true
    }, opts || {});
    typef({
        network: typef.maybe(typef.Object),
        address: typef.maybe(typef.String),
        hash: typef.maybe(typef.BufferN(20)),
        output: typef.maybe(typef.BufferN(23)),
        redeem: typef.maybe({
            network: typef.maybe(typef.Object),
            output: typef.maybe(typef.Buffer),
            input: typef.maybe(typef.Buffer),
            witness: typef.maybe(typef.arrayOf(typef.Buffer))
        }),
        input: typef.maybe(typef.Buffer),
        witness: typef.maybe(typef.arrayOf(typef.Buffer))
    }, a);
    let network = a.network;
    if (!network) network = a.redeem && a.redeem.network || networks_1.bitcoin;
    const o = {
        network
    };
    const _address = lazy.value(()=>{
        const payload = bs58check.decode(a.address);
        const version = payload.readUInt8(0);
        const hash = payload.slice(1);
        return {
            version,
            hash
        };
    });
    const _chunks = lazy.value(()=>{
        return bscript.decompile(a.input);
    });
    const _redeem = lazy.value(()=>{
        const chunks = _chunks();
        return {
            network,
            output: chunks[chunks.length - 1],
            input: bscript.compile(chunks.slice(0, -1)),
            witness: a.witness || []
        };
    });
    // output dependents
    lazy.prop(o, "address", ()=>{
        if (!o.hash) return;
        const payload = Buffer.allocUnsafe(21);
        payload.writeUInt8(o.network.scriptHash, 0);
        o.hash.copy(payload, 1);
        return bs58check.encode(payload);
    });
    lazy.prop(o, "hash", ()=>{
        // in order of least effort
        if (a.output) return a.output.slice(2, 22);
        if (a.address) return _address().hash;
        if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);
    });
    lazy.prop(o, "output", ()=>{
        if (!o.hash) return;
        return bscript.compile([
            OPS.OP_HASH160,
            o.hash,
            OPS.OP_EQUAL
        ]);
    });
    // input dependents
    lazy.prop(o, "redeem", ()=>{
        if (!a.input) return;
        return _redeem();
    });
    lazy.prop(o, "input", ()=>{
        if (!a.redeem || !a.redeem.input || !a.redeem.output) return;
        return bscript.compile([].concat(bscript.decompile(a.redeem.input), a.redeem.output));
    });
    lazy.prop(o, "witness", ()=>{
        if (o.redeem && o.redeem.witness) return o.redeem.witness;
        if (o.input) return [];
    });
    lazy.prop(o, "name", ()=>{
        const nameParts = [
            "p2sh"
        ];
        if (o.redeem !== undefined) nameParts.push(o.redeem.name);
        return nameParts.join("-");
    });
    if (opts.validate) {
        let hash = Buffer.from([]);
        if (a.address) {
            if (_address().version !== network.scriptHash) throw new TypeError("Invalid version or Network mismatch");
            if (_address().hash.length !== 20) throw new TypeError("Invalid address");
            hash = _address().hash;
        }
        if (a.hash) {
            if (hash.length > 0 && !hash.equals(a.hash)) throw new TypeError("Hash mismatch");
            else hash = a.hash;
        }
        if (a.output) {
            if (a.output.length !== 23 || a.output[0] !== OPS.OP_HASH160 || a.output[1] !== 0x14 || a.output[22] !== OPS.OP_EQUAL) throw new TypeError("Output is invalid");
            const hash2 = a.output.slice(2, 22);
            if (hash.length > 0 && !hash.equals(hash2)) throw new TypeError("Hash mismatch");
            else hash = hash2;
        }
        // inlined to prevent 'no-inner-declarations' failing
        const checkRedeem = (redeem)=>{
            // is the redeem output empty/invalid?
            if (redeem.output) {
                const decompile = bscript.decompile(redeem.output);
                if (!decompile || decompile.length < 1) throw new TypeError("Redeem.output too short");
                // match hash against other sources
                const hash2 = bcrypto.hash160(redeem.output);
                if (hash.length > 0 && !hash.equals(hash2)) throw new TypeError("Hash mismatch");
                else hash = hash2;
            }
            if (redeem.input) {
                const hasInput = redeem.input.length > 0;
                const hasWitness = redeem.witness && redeem.witness.length > 0;
                if (!hasInput && !hasWitness) throw new TypeError("Empty input");
                if (hasInput && hasWitness) throw new TypeError("Input and witness provided");
                if (hasInput) {
                    const richunks = bscript.decompile(redeem.input);
                    if (!bscript.isPushOnly(richunks)) throw new TypeError("Non push-only scriptSig");
                }
            }
        };
        if (a.input) {
            const chunks = _chunks();
            if (!chunks || chunks.length < 1) throw new TypeError("Input too short");
            if (!Buffer.isBuffer(_redeem().output)) throw new TypeError("Input is invalid");
            checkRedeem(_redeem());
        }
        if (a.redeem) {
            if (a.redeem.network && a.redeem.network !== network) throw new TypeError("Network mismatch");
            if (a.input) {
                const redeem = _redeem();
                if (a.redeem.output && !a.redeem.output.equals(redeem.output)) throw new TypeError("Redeem.output mismatch");
                if (a.redeem.input && !a.redeem.input.equals(redeem.input)) throw new TypeError("Redeem.input mismatch");
            }
            checkRedeem(a.redeem);
        }
        if (a.witness) {
            if (a.redeem && a.redeem.witness && !stacksEqual(a.redeem.witness, a.witness)) throw new TypeError("Witness and redeem.witness mismatch");
        }
    }
    return Object.assign(o, a);
}
exports.p2sh = p2sh;

},{"c6b571691afe0e89":"bwvMq","91194c2f7e31c985":"4BCCF","9002de76ada6b23c":"hpO0s","8f74fc4c7d847f80":"28LFb","de67a085acdb2528":"cHER6","e4b68fec44748056":"86sQP","ef6a72781420c06f":"d8uT8"}],"6H3XB":[function(require,module,exports) {
var Buffer = require("405049649d0ed172").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bcrypto = require("7d172418db599bc7");
const networks_1 = require("487e81bda7841c55");
const bscript = require("fe665ce0401f37da");
const lazy = require("6134b4e9abd36ea8");
const typef = require("41319bf0aaba1a7b");
const OPS = bscript.OPS;
const ecc = require("665a4f6a3a31b45");
const bech32 = require("82b22dca455ebf20");
const EMPTY_BUFFER = Buffer.alloc(0);
// witness: {signature} {pubKey}
// input: <>
// output: OP_0 {pubKeyHash}
function p2wpkh(a, opts) {
    if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness) throw new TypeError("Not enough data");
    opts = Object.assign({
        validate: true
    }, opts || {});
    typef({
        address: typef.maybe(typef.String),
        hash: typef.maybe(typef.BufferN(20)),
        input: typef.maybe(typef.BufferN(0)),
        network: typef.maybe(typef.Object),
        output: typef.maybe(typef.BufferN(22)),
        pubkey: typef.maybe(ecc.isPoint),
        signature: typef.maybe(bscript.isCanonicalScriptSignature),
        witness: typef.maybe(typef.arrayOf(typef.Buffer))
    }, a);
    const _address = lazy.value(()=>{
        const result = bech32.decode(a.address);
        const version = result.words.shift();
        const data = bech32.fromWords(result.words);
        return {
            version,
            prefix: result.prefix,
            data: Buffer.from(data)
        };
    });
    const network = a.network || networks_1.bitcoin;
    const o = {
        name: "p2wpkh",
        network
    };
    lazy.prop(o, "address", ()=>{
        if (!o.hash) return;
        const words = bech32.toWords(o.hash);
        words.unshift(0x00);
        return bech32.encode(network.bech32, words);
    });
    lazy.prop(o, "hash", ()=>{
        if (a.output) return a.output.slice(2, 22);
        if (a.address) return _address().data;
        if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
    });
    lazy.prop(o, "output", ()=>{
        if (!o.hash) return;
        return bscript.compile([
            OPS.OP_0,
            o.hash
        ]);
    });
    lazy.prop(o, "pubkey", ()=>{
        if (a.pubkey) return a.pubkey;
        if (!a.witness) return;
        return a.witness[1];
    });
    lazy.prop(o, "signature", ()=>{
        if (!a.witness) return;
        return a.witness[0];
    });
    lazy.prop(o, "input", ()=>{
        if (!o.witness) return;
        return EMPTY_BUFFER;
    });
    lazy.prop(o, "witness", ()=>{
        if (!a.pubkey) return;
        if (!a.signature) return;
        return [
            a.signature,
            a.pubkey
        ];
    });
    // extended validation
    if (opts.validate) {
        let hash = Buffer.from([]);
        if (a.address) {
            if (network && network.bech32 !== _address().prefix) throw new TypeError("Invalid prefix or Network mismatch");
            if (_address().version !== 0x00) throw new TypeError("Invalid address version");
            if (_address().data.length !== 20) throw new TypeError("Invalid address data");
            hash = _address().data;
        }
        if (a.hash) {
            if (hash.length > 0 && !hash.equals(a.hash)) throw new TypeError("Hash mismatch");
            else hash = a.hash;
        }
        if (a.output) {
            if (a.output.length !== 22 || a.output[0] !== OPS.OP_0 || a.output[1] !== 0x14) throw new TypeError("Output is invalid");
            if (hash.length > 0 && !hash.equals(a.output.slice(2))) throw new TypeError("Hash mismatch");
            else hash = a.output.slice(2);
        }
        if (a.pubkey) {
            const pkh = bcrypto.hash160(a.pubkey);
            if (hash.length > 0 && !hash.equals(pkh)) throw new TypeError("Hash mismatch");
            else hash = pkh;
            if (!ecc.isPoint(a.pubkey) || a.pubkey.length !== 33) throw new TypeError("Invalid pubkey for p2wpkh");
        }
        if (a.witness) {
            if (a.witness.length !== 2) throw new TypeError("Witness is invalid");
            if (!bscript.isCanonicalScriptSignature(a.witness[0])) throw new TypeError("Witness has invalid signature");
            if (!ecc.isPoint(a.witness[1]) || a.witness[1].length !== 33) throw new TypeError("Witness has invalid pubkey");
            if (a.signature && !a.signature.equals(a.witness[0])) throw new TypeError("Signature mismatch");
            if (a.pubkey && !a.pubkey.equals(a.witness[1])) throw new TypeError("Pubkey mismatch");
            const pkh = bcrypto.hash160(a.witness[1]);
            if (hash.length > 0 && !hash.equals(pkh)) throw new TypeError("Hash mismatch");
        }
    }
    return Object.assign(o, a);
}
exports.p2wpkh = p2wpkh;

},{"405049649d0ed172":"bwvMq","7d172418db599bc7":"4BCCF","487e81bda7841c55":"hpO0s","fe665ce0401f37da":"28LFb","6134b4e9abd36ea8":"cHER6","41319bf0aaba1a7b":"86sQP","665a4f6a3a31b45":"aaqVm","82b22dca455ebf20":"2C5n6"}],"2C5n6":[function(require,module,exports) {
"use strict";
var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
// pre-compute lookup table
var ALPHABET_MAP = {};
for(var z = 0; z < ALPHABET.length; z++){
    var x = ALPHABET.charAt(z);
    if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + " is ambiguous");
    ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
    var b = pre >> 25;
    return (pre & 0x1FFFFFF) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;
}
function prefixChk(prefix) {
    var chk = 1;
    for(var i = 0; i < prefix.length; ++i){
        var c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c >> 5;
    }
    chk = polymodStep(chk);
    for(i = 0; i < prefix.length; ++i){
        var v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 0x1f;
    }
    return chk;
}
function encode(prefix, words, LIMIT) {
    LIMIT = LIMIT || 90;
    if (prefix.length + 7 + words.length > LIMIT) throw new TypeError("Exceeds length limit");
    prefix = prefix.toLowerCase();
    // determine chk mod
    var chk = prefixChk(prefix);
    if (typeof chk === "string") throw new Error(chk);
    var result = prefix + "1";
    for(var i = 0; i < words.length; ++i){
        var x = words[i];
        if (x >> 5 !== 0) throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x;
        result += ALPHABET.charAt(x);
    }
    for(i = 0; i < 6; ++i)chk = polymodStep(chk);
    chk ^= 1;
    for(i = 0; i < 6; ++i){
        var v = chk >> (5 - i) * 5 & 0x1f;
        result += ALPHABET.charAt(v);
    }
    return result;
}
function __decode(str, LIMIT) {
    LIMIT = LIMIT || 90;
    if (str.length < 8) return str + " too short";
    if (str.length > LIMIT) return "Exceeds length limit";
    // don't allow mixed case
    var lowered = str.toLowerCase();
    var uppered = str.toUpperCase();
    if (str !== lowered && str !== uppered) return "Mixed-case string " + str;
    str = lowered;
    var split = str.lastIndexOf("1");
    if (split === -1) return "No separator character for " + str;
    if (split === 0) return "Missing prefix for " + str;
    var prefix = str.slice(0, split);
    var wordChars = str.slice(split + 1);
    if (wordChars.length < 6) return "Data too short";
    var chk = prefixChk(prefix);
    if (typeof chk === "string") return chk;
    var words = [];
    for(var i = 0; i < wordChars.length; ++i){
        var c = wordChars.charAt(i);
        var v = ALPHABET_MAP[c];
        if (v === undefined) return "Unknown character " + c;
        chk = polymodStep(chk) ^ v;
        // not in the checksum?
        if (i + 6 >= wordChars.length) continue;
        words.push(v);
    }
    if (chk !== 1) return "Invalid checksum for " + str;
    return {
        prefix: prefix,
        words: words
    };
}
function decodeUnsafe() {
    var res = __decode.apply(null, arguments);
    if (typeof res === "object") return res;
}
function decode(str) {
    var res = __decode.apply(null, arguments);
    if (typeof res === "object") return res;
    throw new Error(res);
}
function convert(data, inBits, outBits, pad) {
    var value = 0;
    var bits = 0;
    var maxV = (1 << outBits) - 1;
    var result = [];
    for(var i = 0; i < data.length; ++i){
        value = value << inBits | data[i];
        bits += inBits;
        while(bits >= outBits){
            bits -= outBits;
            result.push(value >> bits & maxV);
        }
    }
    if (pad) {
        if (bits > 0) result.push(value << outBits - bits & maxV);
    } else {
        if (bits >= inBits) return "Excess padding";
        if (value << outBits - bits & maxV) return "Non-zero padding";
    }
    return result;
}
function toWordsUnsafe(bytes) {
    var res = convert(bytes, 8, 5, true);
    if (Array.isArray(res)) return res;
}
function toWords(bytes) {
    var res = convert(bytes, 8, 5, true);
    if (Array.isArray(res)) return res;
    throw new Error(res);
}
function fromWordsUnsafe(words) {
    var res = convert(words, 5, 8, false);
    if (Array.isArray(res)) return res;
}
function fromWords(words) {
    var res = convert(words, 5, 8, false);
    if (Array.isArray(res)) return res;
    throw new Error(res);
}
module.exports = {
    decodeUnsafe: decodeUnsafe,
    decode: decode,
    encode: encode,
    toWordsUnsafe: toWordsUnsafe,
    toWords: toWords,
    fromWordsUnsafe: fromWordsUnsafe,
    fromWords: fromWords
};

},{}],"IfDQ0":[function(require,module,exports) {
var Buffer = require("bb9f882c70e1b5bf").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bcrypto = require("d335bb5dae17dfa4");
const networks_1 = require("2a1cc648109dcd25");
const bscript = require("5c43b28c6434a577");
const lazy = require("fdce9f2206aeaf6d");
const typef = require("4651e7474ce37c");
const OPS = bscript.OPS;
const ecc = require("e0e594c51eadafca");
const bech32 = require("a06364c18ec07c74");
const EMPTY_BUFFER = Buffer.alloc(0);
function stacksEqual(a, b) {
    if (a.length !== b.length) return false;
    return a.every((x, i)=>{
        return x.equals(b[i]);
    });
}
function chunkHasUncompressedPubkey(chunk) {
    if (Buffer.isBuffer(chunk) && chunk.length === 65 && chunk[0] === 0x04 && ecc.isPoint(chunk)) return true;
    else return false;
}
// input: <>
// witness: [redeemScriptSig ...] {redeemScript}
// output: OP_0 {sha256(redeemScript)}
function p2wsh(a, opts) {
    if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness) throw new TypeError("Not enough data");
    opts = Object.assign({
        validate: true
    }, opts || {});
    typef({
        network: typef.maybe(typef.Object),
        address: typef.maybe(typef.String),
        hash: typef.maybe(typef.BufferN(32)),
        output: typef.maybe(typef.BufferN(34)),
        redeem: typef.maybe({
            input: typef.maybe(typef.Buffer),
            network: typef.maybe(typef.Object),
            output: typef.maybe(typef.Buffer),
            witness: typef.maybe(typef.arrayOf(typef.Buffer))
        }),
        input: typef.maybe(typef.BufferN(0)),
        witness: typef.maybe(typef.arrayOf(typef.Buffer))
    }, a);
    const _address = lazy.value(()=>{
        const result = bech32.decode(a.address);
        const version = result.words.shift();
        const data = bech32.fromWords(result.words);
        return {
            version,
            prefix: result.prefix,
            data: Buffer.from(data)
        };
    });
    const _rchunks = lazy.value(()=>{
        return bscript.decompile(a.redeem.input);
    });
    let network = a.network;
    if (!network) network = a.redeem && a.redeem.network || networks_1.bitcoin;
    const o = {
        network
    };
    lazy.prop(o, "address", ()=>{
        if (!o.hash) return;
        const words = bech32.toWords(o.hash);
        words.unshift(0x00);
        return bech32.encode(network.bech32, words);
    });
    lazy.prop(o, "hash", ()=>{
        if (a.output) return a.output.slice(2);
        if (a.address) return _address().data;
        if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);
    });
    lazy.prop(o, "output", ()=>{
        if (!o.hash) return;
        return bscript.compile([
            OPS.OP_0,
            o.hash
        ]);
    });
    lazy.prop(o, "redeem", ()=>{
        if (!a.witness) return;
        return {
            output: a.witness[a.witness.length - 1],
            input: EMPTY_BUFFER,
            witness: a.witness.slice(0, -1)
        };
    });
    lazy.prop(o, "input", ()=>{
        if (!o.witness) return;
        return EMPTY_BUFFER;
    });
    lazy.prop(o, "witness", ()=>{
        // transform redeem input to witness stack?
        if (a.redeem && a.redeem.input && a.redeem.input.length > 0 && a.redeem.output && a.redeem.output.length > 0) {
            const stack = bscript.toStack(_rchunks());
            // assign, and blank the existing input
            o.redeem = Object.assign({
                witness: stack
            }, a.redeem);
            o.redeem.input = EMPTY_BUFFER;
            return [].concat(stack, a.redeem.output);
        }
        if (!a.redeem) return;
        if (!a.redeem.output) return;
        if (!a.redeem.witness) return;
        return [].concat(a.redeem.witness, a.redeem.output);
    });
    lazy.prop(o, "name", ()=>{
        const nameParts = [
            "p2wsh"
        ];
        if (o.redeem !== undefined) nameParts.push(o.redeem.name);
        return nameParts.join("-");
    });
    // extended validation
    if (opts.validate) {
        let hash = Buffer.from([]);
        if (a.address) {
            if (_address().prefix !== network.bech32) throw new TypeError("Invalid prefix or Network mismatch");
            if (_address().version !== 0x00) throw new TypeError("Invalid address version");
            if (_address().data.length !== 32) throw new TypeError("Invalid address data");
            hash = _address().data;
        }
        if (a.hash) {
            if (hash.length > 0 && !hash.equals(a.hash)) throw new TypeError("Hash mismatch");
            else hash = a.hash;
        }
        if (a.output) {
            if (a.output.length !== 34 || a.output[0] !== OPS.OP_0 || a.output[1] !== 0x20) throw new TypeError("Output is invalid");
            const hash2 = a.output.slice(2);
            if (hash.length > 0 && !hash.equals(hash2)) throw new TypeError("Hash mismatch");
            else hash = hash2;
        }
        if (a.redeem) {
            if (a.redeem.network && a.redeem.network !== network) throw new TypeError("Network mismatch");
            // is there two redeem sources?
            if (a.redeem.input && a.redeem.input.length > 0 && a.redeem.witness && a.redeem.witness.length > 0) throw new TypeError("Ambiguous witness source");
            // is the redeem output non-empty?
            if (a.redeem.output) {
                if (bscript.decompile(a.redeem.output).length === 0) throw new TypeError("Redeem.output is invalid");
                // match hash against other sources
                const hash2 = bcrypto.sha256(a.redeem.output);
                if (hash.length > 0 && !hash.equals(hash2)) throw new TypeError("Hash mismatch");
                else hash = hash2;
            }
            if (a.redeem.input && !bscript.isPushOnly(_rchunks())) throw new TypeError("Non push-only scriptSig");
            if (a.witness && a.redeem.witness && !stacksEqual(a.witness, a.redeem.witness)) throw new TypeError("Witness and redeem.witness mismatch");
            if (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey) || a.redeem.output && (bscript.decompile(a.redeem.output) || []).some(chunkHasUncompressedPubkey)) throw new TypeError("redeem.input or redeem.output contains uncompressed pubkey");
        }
        if (a.witness && a.witness.length > 0) {
            const wScript = a.witness[a.witness.length - 1];
            if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript)) throw new TypeError("Witness and redeem.output mismatch");
            if (a.witness.some(chunkHasUncompressedPubkey) || (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)) throw new TypeError("Witness contains uncompressed pubkey");
        }
    }
    return Object.assign(o, a);
}
exports.p2wsh = p2wsh;

},{"bb9f882c70e1b5bf":"bwvMq","d335bb5dae17dfa4":"4BCCF","2a1cc648109dcd25":"hpO0s","5c43b28c6434a577":"28LFb","fdce9f2206aeaf6d":"cHER6","4651e7474ce37c":"86sQP","e0e594c51eadafca":"aaqVm","a06364c18ec07c74":"2C5n6"}],"aiXsq":[function(require,module,exports) {
var Buffer = require("12045adc01a7b740").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const NETWORKS = require("9bae410ccb22d4c7");
const types = require("7f3010f45742cf71");
const ecc = require("df55d08bce8c41be");
const randomBytes = require("1ff233ec464df909");
const typeforce = require("52fc57226706ea61");
const wif = require("7560f99ad921c0d5");
const isOptions = typeforce.maybe(typeforce.compile({
    compressed: types.maybe(types.Boolean),
    network: types.maybe(types.Network)
}));
class ECPair {
    constructor(__D, __Q, options){
        this.__D = __D;
        this.__Q = __Q;
        this.lowR = false;
        if (options === undefined) options = {};
        this.compressed = options.compressed === undefined ? true : options.compressed;
        this.network = options.network || NETWORKS.bitcoin;
        if (__Q !== undefined) this.__Q = ecc.pointCompress(__Q, this.compressed);
    }
    get privateKey() {
        return this.__D;
    }
    get publicKey() {
        if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__D, this.compressed);
        return this.__Q;
    }
    toWIF() {
        if (!this.__D) throw new Error("Missing private key");
        return wif.encode(this.network.wif, this.__D, this.compressed);
    }
    sign(hash, lowR) {
        if (!this.__D) throw new Error("Missing private key");
        if (lowR === undefined) lowR = this.lowR;
        if (lowR === false) return ecc.sign(hash, this.__D);
        else {
            let sig = ecc.sign(hash, this.__D);
            const extraData = Buffer.alloc(32, 0);
            let counter = 0;
            // if first try is lowR, skip the loop
            // for second try and on, add extra entropy counting up
            while(sig[0] > 0x7f){
                counter++;
                extraData.writeUIntLE(counter, 0, 6);
                sig = ecc.signWithEntropy(hash, this.__D, extraData);
            }
            return sig;
        }
    }
    verify(hash, signature) {
        return ecc.verify(hash, this.publicKey, signature);
    }
}
function fromPrivateKey(buffer, options) {
    typeforce(types.Buffer256bit, buffer);
    if (!ecc.isPrivate(buffer)) throw new TypeError("Private key not in range [1, n)");
    typeforce(isOptions, options);
    return new ECPair(buffer, undefined, options);
}
exports.fromPrivateKey = fromPrivateKey;
function fromPublicKey(buffer, options) {
    typeforce(ecc.isPoint, buffer);
    typeforce(isOptions, options);
    return new ECPair(undefined, buffer, options);
}
exports.fromPublicKey = fromPublicKey;
function fromWIF(wifString, network) {
    const decoded = wif.decode(wifString);
    const version = decoded.version;
    // list of networks?
    if (types.Array(network)) {
        network = network.filter((x)=>{
            return version === x.wif;
        }).pop();
        if (!network) throw new Error("Unknown network version");
    // otherwise, assume a network object (or default to bitcoin)
    } else {
        network = network || NETWORKS.bitcoin;
        if (version !== network.wif) throw new Error("Invalid network version");
    }
    return fromPrivateKey(decoded.privateKey, {
        compressed: decoded.compressed,
        network: network
    });
}
exports.fromWIF = fromWIF;
function makeRandom(options) {
    typeforce(isOptions, options);
    if (options === undefined) options = {};
    const rng = options.rng || randomBytes;
    let d;
    do {
        d = rng(32);
        typeforce(types.Buffer256bit, d);
    }while (!ecc.isPrivate(d));
    return fromPrivateKey(d, options);
}
exports.makeRandom = makeRandom;

},{"12045adc01a7b740":"bwvMq","9bae410ccb22d4c7":"hpO0s","7f3010f45742cf71":"eFC2X","df55d08bce8c41be":"aaqVm","1ff233ec464df909":"8hjhE","52fc57226706ea61":"86sQP","7560f99ad921c0d5":"89Dvm"}],"8hjhE":[function(require,module,exports) {
var global = arguments[3];
var process = require("9f5c61be6bd9c67a");
"use strict";
// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536;
// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295;
function oldBrowser() {
    throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
}
var Buffer = require("caff9346743c214e").Buffer;
var crypto = global.crypto || global.msCrypto;
if (crypto && crypto.getRandomValues) module.exports = randomBytes;
else module.exports = oldBrowser;
function randomBytes(size, cb) {
    // phantomjs needs to throw
    if (size > MAX_UINT32) throw new RangeError("requested too many random bytes");
    var bytes = Buffer.allocUnsafe(size);
    if (size > 0) {
        if (size > MAX_BYTES) // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
        for(var generated = 0; generated < size; generated += MAX_BYTES)// buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
        else crypto.getRandomValues(bytes);
    }
    if (typeof cb === "function") return process.nextTick(function() {
        cb(null, bytes);
    });
    return bytes;
}

},{"9f5c61be6bd9c67a":"d5jf4","caff9346743c214e":"eW7r9"}],"aVKx9":[function(require,module,exports) {
var Buffer = require("fef6b6883393c515").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bufferutils_1 = require("10eab07fce0d349f");
const bcrypto = require("af0c09a3af6e6266");
const transaction_1 = require("a511779c7da90ef7");
const types = require("23d107f566cf4d90");
const fastMerkleRoot = require("f30799fa1cee4f50");
const typeforce = require("5623ba6035827161");
const varuint = require("83ddb0d1e8848c0f");
const errorMerkleNoTxes = new TypeError("Cannot compute merkle root for zero transactions");
const errorWitnessNotSegwit = new TypeError("Cannot compute witness commit for non-segwit block");
class Block {
    constructor(){
        this.version = 1;
        this.prevHash = undefined;
        this.merkleRoot = undefined;
        this.timestamp = 0;
        this.witnessCommit = undefined;
        this.bits = 0;
        this.nonce = 0;
        this.transactions = undefined;
    }
    static fromBuffer(buffer) {
        if (buffer.length < 80) throw new Error("Buffer too small (< 80 bytes)");
        const bufferReader = new bufferutils_1.BufferReader(buffer);
        const block = new Block();
        block.version = bufferReader.readInt32();
        block.prevHash = bufferReader.readSlice(32);
        block.merkleRoot = bufferReader.readSlice(32);
        block.timestamp = bufferReader.readUInt32();
        block.bits = bufferReader.readUInt32();
        block.nonce = bufferReader.readUInt32();
        if (buffer.length === 80) return block;
        const readTransaction = ()=>{
            const tx = transaction_1.Transaction.fromBuffer(bufferReader.buffer.slice(bufferReader.offset), true);
            bufferReader.offset += tx.byteLength();
            return tx;
        };
        const nTransactions = bufferReader.readVarInt();
        block.transactions = [];
        for(let i = 0; i < nTransactions; ++i){
            const tx = readTransaction();
            block.transactions.push(tx);
        }
        const witnessCommit = block.getWitnessCommit();
        // This Block contains a witness commit
        if (witnessCommit) block.witnessCommit = witnessCommit;
        return block;
    }
    static fromHex(hex) {
        return Block.fromBuffer(Buffer.from(hex, "hex"));
    }
    static calculateTarget(bits) {
        const exponent = ((bits & 0xff000000) >> 24) - 3;
        const mantissa = bits & 0x007fffff;
        const target = Buffer.alloc(32, 0);
        target.writeUIntBE(mantissa, 29 - exponent, 3);
        return target;
    }
    static calculateMerkleRoot(transactions, forWitness) {
        typeforce([
            {
                getHash: types.Function
            }
        ], transactions);
        if (transactions.length === 0) throw errorMerkleNoTxes;
        if (forWitness && !txesHaveWitnessCommit(transactions)) throw errorWitnessNotSegwit;
        const hashes = transactions.map((transaction)=>transaction.getHash(forWitness));
        const rootHash = fastMerkleRoot(hashes, bcrypto.hash256);
        return forWitness ? bcrypto.hash256(Buffer.concat([
            rootHash,
            transactions[0].ins[0].witness[0]
        ])) : rootHash;
    }
    getWitnessCommit() {
        if (!txesHaveWitnessCommit(this.transactions)) return null;
        // The merkle root for the witness data is in an OP_RETURN output.
        // There is no rule for the index of the output, so use filter to find it.
        // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed
        // If multiple commits are found, the output with highest index is assumed.
        const witnessCommits = this.transactions[0].outs.filter((out)=>out.script.slice(0, 6).equals(Buffer.from("6a24aa21a9ed", "hex"))).map((out)=>out.script.slice(6, 38));
        if (witnessCommits.length === 0) return null;
        // Use the commit with the highest output (should only be one though)
        const result = witnessCommits[witnessCommits.length - 1];
        if (!(result instanceof Buffer && result.length === 32)) return null;
        return result;
    }
    hasWitnessCommit() {
        if (this.witnessCommit instanceof Buffer && this.witnessCommit.length === 32) return true;
        if (this.getWitnessCommit() !== null) return true;
        return false;
    }
    hasWitness() {
        return anyTxHasWitness(this.transactions);
    }
    weight() {
        const base = this.byteLength(false, false);
        const total = this.byteLength(false, true);
        return base * 3 + total;
    }
    byteLength(headersOnly, allowWitness = true) {
        if (headersOnly || !this.transactions) return 80;
        return 80 + varuint.encodingLength(this.transactions.length) + this.transactions.reduce((a, x)=>a + x.byteLength(allowWitness), 0);
    }
    getHash() {
        return bcrypto.hash256(this.toBuffer(true));
    }
    getId() {
        return bufferutils_1.reverseBuffer(this.getHash()).toString("hex");
    }
    getUTCDate() {
        const date = new Date(0); // epoch
        date.setUTCSeconds(this.timestamp);
        return date;
    }
    // TODO: buffer, offset compatibility
    toBuffer(headersOnly) {
        const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));
        const bufferWriter = new bufferutils_1.BufferWriter(buffer);
        bufferWriter.writeInt32(this.version);
        bufferWriter.writeSlice(this.prevHash);
        bufferWriter.writeSlice(this.merkleRoot);
        bufferWriter.writeUInt32(this.timestamp);
        bufferWriter.writeUInt32(this.bits);
        bufferWriter.writeUInt32(this.nonce);
        if (headersOnly || !this.transactions) return buffer;
        varuint.encode(this.transactions.length, buffer, bufferWriter.offset);
        bufferWriter.offset += varuint.encode.bytes;
        this.transactions.forEach((tx)=>{
            const txSize = tx.byteLength(); // TODO: extract from toBuffer?
            tx.toBuffer(buffer, bufferWriter.offset);
            bufferWriter.offset += txSize;
        });
        return buffer;
    }
    toHex(headersOnly) {
        return this.toBuffer(headersOnly).toString("hex");
    }
    checkTxRoots() {
        // If the Block has segwit transactions but no witness commit,
        // there's no way it can be valid, so fail the check.
        const hasWitnessCommit = this.hasWitnessCommit();
        if (!hasWitnessCommit && this.hasWitness()) return false;
        return this.__checkMerkleRoot() && (hasWitnessCommit ? this.__checkWitnessCommit() : true);
    }
    checkProofOfWork() {
        const hash = bufferutils_1.reverseBuffer(this.getHash());
        const target = Block.calculateTarget(this.bits);
        return hash.compare(target) <= 0;
    }
    __checkMerkleRoot() {
        if (!this.transactions) throw errorMerkleNoTxes;
        const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);
        return this.merkleRoot.compare(actualMerkleRoot) === 0;
    }
    __checkWitnessCommit() {
        if (!this.transactions) throw errorMerkleNoTxes;
        if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
        const actualWitnessCommit = Block.calculateMerkleRoot(this.transactions, true);
        return this.witnessCommit.compare(actualWitnessCommit) === 0;
    }
}
exports.Block = Block;
function txesHaveWitnessCommit(transactions) {
    return transactions instanceof Array && transactions[0] && transactions[0].ins && transactions[0].ins instanceof Array && transactions[0].ins[0] && transactions[0].ins[0].witness && transactions[0].ins[0].witness instanceof Array && transactions[0].ins[0].witness.length > 0;
}
function anyTxHasWitness(transactions) {
    return transactions instanceof Array && transactions.some((tx)=>typeof tx === "object" && tx.ins instanceof Array && tx.ins.some((input)=>typeof input === "object" && input.witness instanceof Array && input.witness.length > 0));
}

},{"fef6b6883393c515":"bwvMq","10eab07fce0d349f":"jR49q","af0c09a3af6e6266":"4BCCF","a511779c7da90ef7":"arhmj","23d107f566cf4d90":"eFC2X","f30799fa1cee4f50":"6C2pB","5623ba6035827161":"86sQP","83ddb0d1e8848c0f":"amF5b"}],"jR49q":[function(require,module,exports) {
var Buffer = require("f9c7c081959e55ca").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const types = require("900ff40b113a19a8");
const typeforce = require("e5c27ab1ef4432da");
const varuint = require("701e1d136911cf67");
// https://github.com/feross/buffer/blob/master/index.js#L1127
function verifuint(value, max) {
    if (typeof value !== "number") throw new Error("cannot write a non-number as a number");
    if (value < 0) throw new Error("specified a negative value for writing an unsigned value");
    if (value > max) throw new Error("RangeError: value out of range");
    if (Math.floor(value) !== value) throw new Error("value has a fractional component");
}
function readUInt64LE(buffer, offset) {
    const a = buffer.readUInt32LE(offset);
    let b = buffer.readUInt32LE(offset + 4);
    b *= 0x100000000;
    verifuint(b + a, 0x001fffffffffffff);
    return b + a;
}
exports.readUInt64LE = readUInt64LE;
function writeUInt64LE(buffer, value, offset) {
    verifuint(value, 0x001fffffffffffff);
    buffer.writeInt32LE(value & -1, offset);
    buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
    return offset + 8;
}
exports.writeUInt64LE = writeUInt64LE;
function reverseBuffer(buffer) {
    if (buffer.length < 1) return buffer;
    let j = buffer.length - 1;
    let tmp = 0;
    for(let i = 0; i < buffer.length / 2; i++){
        tmp = buffer[i];
        buffer[i] = buffer[j];
        buffer[j] = tmp;
        j--;
    }
    return buffer;
}
exports.reverseBuffer = reverseBuffer;
function cloneBuffer(buffer) {
    const clone = Buffer.allocUnsafe(buffer.length);
    buffer.copy(clone);
    return clone;
}
exports.cloneBuffer = cloneBuffer;
/**
 * Helper class for serialization of bitcoin data types into a pre-allocated buffer.
 */ class BufferWriter {
    constructor(buffer, offset = 0){
        this.buffer = buffer;
        this.offset = offset;
        typeforce(types.tuple(types.Buffer, types.UInt32), [
            buffer,
            offset
        ]);
    }
    writeUInt8(i) {
        this.offset = this.buffer.writeUInt8(i, this.offset);
    }
    writeInt32(i) {
        this.offset = this.buffer.writeInt32LE(i, this.offset);
    }
    writeUInt32(i) {
        this.offset = this.buffer.writeUInt32LE(i, this.offset);
    }
    writeUInt64(i) {
        this.offset = writeUInt64LE(this.buffer, i, this.offset);
    }
    writeVarInt(i) {
        varuint.encode(i, this.buffer, this.offset);
        this.offset += varuint.encode.bytes;
    }
    writeSlice(slice) {
        if (this.buffer.length < this.offset + slice.length) throw new Error("Cannot write slice out of bounds");
        this.offset += slice.copy(this.buffer, this.offset);
    }
    writeVarSlice(slice) {
        this.writeVarInt(slice.length);
        this.writeSlice(slice);
    }
    writeVector(vector) {
        this.writeVarInt(vector.length);
        vector.forEach((buf)=>this.writeVarSlice(buf));
    }
}
exports.BufferWriter = BufferWriter;
/**
 * Helper class for reading of bitcoin data types from a buffer.
 */ class BufferReader {
    constructor(buffer, offset = 0){
        this.buffer = buffer;
        this.offset = offset;
        typeforce(types.tuple(types.Buffer, types.UInt32), [
            buffer,
            offset
        ]);
    }
    readUInt8() {
        const result = this.buffer.readUInt8(this.offset);
        this.offset++;
        return result;
    }
    readInt32() {
        const result = this.buffer.readInt32LE(this.offset);
        this.offset += 4;
        return result;
    }
    readUInt32() {
        const result = this.buffer.readUInt32LE(this.offset);
        this.offset += 4;
        return result;
    }
    readUInt64() {
        const result = readUInt64LE(this.buffer, this.offset);
        this.offset += 8;
        return result;
    }
    readVarInt() {
        const vi = varuint.decode(this.buffer, this.offset);
        this.offset += varuint.decode.bytes;
        return vi;
    }
    readSlice(n) {
        if (this.buffer.length < this.offset + n) throw new Error("Cannot read slice out of bounds");
        const result = this.buffer.slice(this.offset, this.offset + n);
        this.offset += n;
        return result;
    }
    readVarSlice() {
        return this.readSlice(this.readVarInt());
    }
    readVector() {
        const count = this.readVarInt();
        const vector = [];
        for(let i = 0; i < count; i++)vector.push(this.readVarSlice());
        return vector;
    }
}
exports.BufferReader = BufferReader;

},{"f9c7c081959e55ca":"bwvMq","900ff40b113a19a8":"eFC2X","e5c27ab1ef4432da":"86sQP","701e1d136911cf67":"amF5b"}],"amF5b":[function(require,module,exports) {
"use strict";
var Buffer = require("76b962a3a7f16e3a").Buffer;
// Number.MAX_SAFE_INTEGER
var MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(n) {
    if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError("value out of range");
}
function encode(number, buffer, offset) {
    checkUInt53(number);
    if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(number));
    if (!Buffer.isBuffer(buffer)) throw new TypeError("buffer must be a Buffer instance");
    if (!offset) offset = 0;
    // 8 bit
    if (number < 0xfd) {
        buffer.writeUInt8(number, offset);
        encode.bytes = 1;
    // 16 bit
    } else if (number <= 0xffff) {
        buffer.writeUInt8(0xfd, offset);
        buffer.writeUInt16LE(number, offset + 1);
        encode.bytes = 3;
    // 32 bit
    } else if (number <= 0xffffffff) {
        buffer.writeUInt8(0xfe, offset);
        buffer.writeUInt32LE(number, offset + 1);
        encode.bytes = 5;
    // 64 bit
    } else {
        buffer.writeUInt8(0xff, offset);
        buffer.writeUInt32LE(number >>> 0, offset + 1);
        buffer.writeUInt32LE(number / 0x100000000 | 0, offset + 5);
        encode.bytes = 9;
    }
    return buffer;
}
function decode(buffer, offset) {
    if (!Buffer.isBuffer(buffer)) throw new TypeError("buffer must be a Buffer instance");
    if (!offset) offset = 0;
    var first = buffer.readUInt8(offset);
    // 8 bit
    if (first < 0xfd) {
        decode.bytes = 1;
        return first;
    // 16 bit
    } else if (first === 0xfd) {
        decode.bytes = 3;
        return buffer.readUInt16LE(offset + 1);
    // 32 bit
    } else if (first === 0xfe) {
        decode.bytes = 5;
        return buffer.readUInt32LE(offset + 1);
    // 64 bit
    } else {
        decode.bytes = 9;
        var lo = buffer.readUInt32LE(offset + 1);
        var hi = buffer.readUInt32LE(offset + 5);
        var number = hi * 0x0100000000 + lo;
        checkUInt53(number);
        return number;
    }
}
function encodingLength(number) {
    checkUInt53(number);
    return number < 0xfd ? 1 : number <= 0xffff ? 3 : number <= 0xffffffff ? 5 : 9;
}
module.exports = {
    encode: encode,
    decode: decode,
    encodingLength: encodingLength
};

},{"76b962a3a7f16e3a":"eW7r9"}],"arhmj":[function(require,module,exports) {
var Buffer = require("f552bdfda8ba655c").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bufferutils_1 = require("625058161ca49b3");
const bcrypto = require("dabb1ff0618850bf");
const bscript = require("49bb4306cdf0edaf");
const script_1 = require("49bb4306cdf0edaf");
const types = require("89755d038b59b4e0");
const typeforce = require("608af24578d66084");
const varuint = require("d7bf53864da2c0ff");
function varSliceSize(someScript) {
    const length = someScript.length;
    return varuint.encodingLength(length) + length;
}
function vectorSize(someVector) {
    const length = someVector.length;
    return varuint.encodingLength(length) + someVector.reduce((sum, witness)=>{
        return sum + varSliceSize(witness);
    }, 0);
}
const EMPTY_SCRIPT = Buffer.allocUnsafe(0);
const EMPTY_WITNESS = [];
const ZERO = Buffer.from("0000000000000000000000000000000000000000000000000000000000000000", "hex");
const ONE = Buffer.from("0000000000000000000000000000000000000000000000000000000000000001", "hex");
const VALUE_UINT64_MAX = Buffer.from("ffffffffffffffff", "hex");
const BLANK_OUTPUT = {
    script: EMPTY_SCRIPT,
    valueBuffer: VALUE_UINT64_MAX
};
function isOutput(out) {
    return out.value !== undefined;
}
class Transaction {
    constructor(){
        this.version = 1;
        this.locktime = 0;
        this.ins = [];
        this.outs = [];
    }
    static fromBuffer(buffer, _NO_STRICT) {
        const bufferReader = new bufferutils_1.BufferReader(buffer);
        const tx = new Transaction();
        tx.version = bufferReader.readInt32();
        const marker = bufferReader.readUInt8();
        const flag = bufferReader.readUInt8();
        let hasWitnesses = false;
        if (marker === Transaction.ADVANCED_TRANSACTION_MARKER && flag === Transaction.ADVANCED_TRANSACTION_FLAG) hasWitnesses = true;
        else bufferReader.offset -= 2;
        const vinLen = bufferReader.readVarInt();
        for(let i = 0; i < vinLen; ++i)tx.ins.push({
            hash: bufferReader.readSlice(32),
            index: bufferReader.readUInt32(),
            script: bufferReader.readVarSlice(),
            sequence: bufferReader.readUInt32(),
            witness: EMPTY_WITNESS
        });
        const voutLen = bufferReader.readVarInt();
        for(let i = 0; i < voutLen; ++i)tx.outs.push({
            value: bufferReader.readUInt64(),
            script: bufferReader.readVarSlice()
        });
        if (hasWitnesses) {
            for(let i = 0; i < vinLen; ++i)tx.ins[i].witness = bufferReader.readVector();
            // was this pointless?
            if (!tx.hasWitnesses()) throw new Error("Transaction has superfluous witness data");
        }
        tx.locktime = bufferReader.readUInt32();
        if (_NO_STRICT) return tx;
        if (bufferReader.offset !== buffer.length) throw new Error("Transaction has unexpected data");
        return tx;
    }
    static fromHex(hex) {
        return Transaction.fromBuffer(Buffer.from(hex, "hex"), false);
    }
    static isCoinbaseHash(buffer) {
        typeforce(types.Hash256bit, buffer);
        for(let i = 0; i < 32; ++i){
            if (buffer[i] !== 0) return false;
        }
        return true;
    }
    isCoinbase() {
        return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
    }
    addInput(hash, index, sequence, scriptSig) {
        typeforce(types.tuple(types.Hash256bit, types.UInt32, types.maybe(types.UInt32), types.maybe(types.Buffer)), arguments);
        if (types.Null(sequence)) sequence = Transaction.DEFAULT_SEQUENCE;
        // Add the input and return the input's index
        return this.ins.push({
            hash,
            index,
            script: scriptSig || EMPTY_SCRIPT,
            sequence: sequence,
            witness: EMPTY_WITNESS
        }) - 1;
    }
    addOutput(scriptPubKey, value) {
        typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);
        // Add the output and return the output's index
        return this.outs.push({
            script: scriptPubKey,
            value
        }) - 1;
    }
    hasWitnesses() {
        return this.ins.some((x)=>{
            return x.witness.length !== 0;
        });
    }
    weight() {
        const base = this.byteLength(false);
        const total = this.byteLength(true);
        return base * 3 + total;
    }
    virtualSize() {
        return Math.ceil(this.weight() / 4);
    }
    byteLength(_ALLOW_WITNESS = true) {
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        return (hasWitnesses ? 10 : 8) + varuint.encodingLength(this.ins.length) + varuint.encodingLength(this.outs.length) + this.ins.reduce((sum, input)=>{
            return sum + 40 + varSliceSize(input.script);
        }, 0) + this.outs.reduce((sum, output)=>{
            return sum + 8 + varSliceSize(output.script);
        }, 0) + (hasWitnesses ? this.ins.reduce((sum, input)=>{
            return sum + vectorSize(input.witness);
        }, 0) : 0);
    }
    clone() {
        const newTx = new Transaction();
        newTx.version = this.version;
        newTx.locktime = this.locktime;
        newTx.ins = this.ins.map((txIn)=>{
            return {
                hash: txIn.hash,
                index: txIn.index,
                script: txIn.script,
                sequence: txIn.sequence,
                witness: txIn.witness
            };
        });
        newTx.outs = this.outs.map((txOut)=>{
            return {
                script: txOut.script,
                value: txOut.value
            };
        });
        return newTx;
    }
    /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */ hashForSignature(inIndex, prevOutScript, hashType) {
        typeforce(types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number), arguments);
        // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29
        if (inIndex >= this.ins.length) return ONE;
        // ignore OP_CODESEPARATOR
        const ourScript = bscript.compile(bscript.decompile(prevOutScript).filter((x)=>{
            return x !== script_1.OPS.OP_CODESEPARATOR;
        }));
        const txTmp = this.clone();
        // SIGHASH_NONE: ignore all outputs? (wildcard payee)
        if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {
            txTmp.outs = [];
            // ignore sequence numbers (except at inIndex)
            txTmp.ins.forEach((input, i)=>{
                if (i === inIndex) return;
                input.sequence = 0;
            });
        // SIGHASH_SINGLE: ignore all outputs, except at the same index?
        } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {
            // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60
            if (inIndex >= this.outs.length) return ONE;
            // truncate outputs after
            txTmp.outs.length = inIndex + 1;
            // "blank" outputs before
            for(let i = 0; i < inIndex; i++)txTmp.outs[i] = BLANK_OUTPUT;
            // ignore sequence numbers (except at inIndex)
            txTmp.ins.forEach((input, y)=>{
                if (y === inIndex) return;
                input.sequence = 0;
            });
        }
        // SIGHASH_ANYONECANPAY: ignore inputs entirely?
        if (hashType & Transaction.SIGHASH_ANYONECANPAY) {
            txTmp.ins = [
                txTmp.ins[inIndex]
            ];
            txTmp.ins[0].script = ourScript;
        // SIGHASH_ALL: only ignore input scripts
        } else {
            // "blank" others input scripts
            txTmp.ins.forEach((input)=>{
                input.script = EMPTY_SCRIPT;
            });
            txTmp.ins[inIndex].script = ourScript;
        }
        // serialize and hash
        const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);
        buffer.writeInt32LE(hashType, buffer.length - 4);
        txTmp.__toBuffer(buffer, 0, false);
        return bcrypto.hash256(buffer);
    }
    hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
        typeforce(types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32), arguments);
        let tbuffer = Buffer.from([]);
        let bufferWriter;
        let hashOutputs = ZERO;
        let hashPrevouts = ZERO;
        let hashSequence = ZERO;
        if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {
            tbuffer = Buffer.allocUnsafe(36 * this.ins.length);
            bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
            this.ins.forEach((txIn)=>{
                bufferWriter.writeSlice(txIn.hash);
                bufferWriter.writeUInt32(txIn.index);
            });
            hashPrevouts = bcrypto.hash256(tbuffer);
        }
        if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) && (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {
            tbuffer = Buffer.allocUnsafe(4 * this.ins.length);
            bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
            this.ins.forEach((txIn)=>{
                bufferWriter.writeUInt32(txIn.sequence);
            });
            hashSequence = bcrypto.hash256(tbuffer);
        }
        if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {
            const txOutsSize = this.outs.reduce((sum, output)=>{
                return sum + 8 + varSliceSize(output.script);
            }, 0);
            tbuffer = Buffer.allocUnsafe(txOutsSize);
            bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
            this.outs.forEach((out)=>{
                bufferWriter.writeUInt64(out.value);
                bufferWriter.writeVarSlice(out.script);
            });
            hashOutputs = bcrypto.hash256(tbuffer);
        } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {
            const output = this.outs[inIndex];
            tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));
            bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
            bufferWriter.writeUInt64(output.value);
            bufferWriter.writeVarSlice(output.script);
            hashOutputs = bcrypto.hash256(tbuffer);
        }
        tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));
        bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
        const input = this.ins[inIndex];
        bufferWriter.writeUInt32(this.version);
        bufferWriter.writeSlice(hashPrevouts);
        bufferWriter.writeSlice(hashSequence);
        bufferWriter.writeSlice(input.hash);
        bufferWriter.writeUInt32(input.index);
        bufferWriter.writeVarSlice(prevOutScript);
        bufferWriter.writeUInt64(value);
        bufferWriter.writeUInt32(input.sequence);
        bufferWriter.writeSlice(hashOutputs);
        bufferWriter.writeUInt32(this.locktime);
        bufferWriter.writeUInt32(hashType);
        return bcrypto.hash256(tbuffer);
    }
    getHash(forWitness) {
        // wtxid for coinbase is always 32 bytes of 0x00
        if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);
        return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));
    }
    getId() {
        // transaction hash's are displayed in reverse order
        return bufferutils_1.reverseBuffer(this.getHash(false)).toString("hex");
    }
    toBuffer(buffer, initialOffset) {
        return this.__toBuffer(buffer, initialOffset, true);
    }
    toHex() {
        return this.toBuffer(undefined, undefined).toString("hex");
    }
    setInputScript(index, scriptSig) {
        typeforce(types.tuple(types.Number, types.Buffer), arguments);
        this.ins[index].script = scriptSig;
    }
    setWitness(index, witness) {
        typeforce(types.tuple(types.Number, [
            types.Buffer
        ]), arguments);
        this.ins[index].witness = witness;
    }
    __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {
        if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));
        const bufferWriter = new bufferutils_1.BufferWriter(buffer, initialOffset || 0);
        bufferWriter.writeInt32(this.version);
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        if (hasWitnesses) {
            bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);
            bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);
        }
        bufferWriter.writeVarInt(this.ins.length);
        this.ins.forEach((txIn)=>{
            bufferWriter.writeSlice(txIn.hash);
            bufferWriter.writeUInt32(txIn.index);
            bufferWriter.writeVarSlice(txIn.script);
            bufferWriter.writeUInt32(txIn.sequence);
        });
        bufferWriter.writeVarInt(this.outs.length);
        this.outs.forEach((txOut)=>{
            if (isOutput(txOut)) bufferWriter.writeUInt64(txOut.value);
            else bufferWriter.writeSlice(txOut.valueBuffer);
            bufferWriter.writeVarSlice(txOut.script);
        });
        if (hasWitnesses) this.ins.forEach((input)=>{
            bufferWriter.writeVector(input.witness);
        });
        bufferWriter.writeUInt32(this.locktime);
        // avoid slicing unless necessary
        if (initialOffset !== undefined) return buffer.slice(initialOffset, bufferWriter.offset);
        return buffer;
    }
}
Transaction.DEFAULT_SEQUENCE = 0xffffffff;
Transaction.SIGHASH_ALL = 0x01;
Transaction.SIGHASH_NONE = 0x02;
Transaction.SIGHASH_SINGLE = 0x03;
Transaction.SIGHASH_ANYONECANPAY = 0x80;
Transaction.ADVANCED_TRANSACTION_MARKER = 0x00;
Transaction.ADVANCED_TRANSACTION_FLAG = 0x01;
exports.Transaction = Transaction;

},{"f552bdfda8ba655c":"bwvMq","625058161ca49b3":"jR49q","dabb1ff0618850bf":"4BCCF","49bb4306cdf0edaf":"28LFb","89755d038b59b4e0":"eFC2X","608af24578d66084":"86sQP","d7bf53864da2c0ff":"amF5b"}],"6C2pB":[function(require,module,exports) {
// constant-space merkle root calculation algorithm
var Buffer = require("b639cf66b489e70e").Buffer;
module.exports = function fastRoot(values, digestFn) {
    if (!Array.isArray(values)) throw TypeError("Expected values Array");
    if (typeof digestFn !== "function") throw TypeError("Expected digest Function");
    var length = values.length;
    var results = values.concat();
    while(length > 1){
        var j = 0;
        for(var i = 0; i < length; i += 2, ++j){
            var left = results[i];
            var right = i + 1 === length ? left : results[i + 1];
            var data = Buffer.concat([
                left,
                right
            ]);
            results[j] = digestFn(data);
        }
        length = j;
    }
    return results[0];
};

},{"b639cf66b489e70e":"bwvMq"}],"90Km1":[function(require,module,exports) {
var Buffer = require("bd04018dc1652f62").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bip174_1 = require("3cdabce7cf751469");
const varuint = require("7f0c469e1295416c");
const utils_1 = require("15e876c92e186c9a");
const address_1 = require("206460bdf6f8e224");
const bufferutils_1 = require("c66b4b428f6e9b6c");
const crypto_1 = require("2c0de14d737e7f5c");
const ecpair_1 = require("bc92084ba24790e4");
const networks_1 = require("d819d635cf774913");
const payments = require("147d6fa1a977536e");
const bscript = require("2f149948dde5be71");
const transaction_1 = require("a441c63dce14b7a7");
/**
 * These are the default arguments for a Psbt instance.
 */ const DEFAULT_OPTS = {
    /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */ network: networks_1.bitcoin,
    /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */ maximumFeeRate: 5000
};
/**
 * Psbt class can parse and generate a PSBT binary based off of the BIP174.
 * There are 6 roles that this class fulfills. (Explained in BIP174)
 *
 * Creator: This can be done with `new Psbt()`
 * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,
 *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to
 *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,
 *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`
 *   addInput requires hash: Buffer | string; and index: number; as attributes
 *   and can also include any attributes that are used in updateInput method.
 *   addOutput requires script: Buffer; and value: number; and likewise can include
 *   data for updateOutput.
 *   For a list of what attributes should be what types. Check the bip174 library.
 *   Also, check the integration tests for some examples of usage.
 * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input
 *   information for your pubkey or pubkeyhash, and only sign inputs where it finds
 *   your info. Or you can explicitly sign a specific input with signInput and
 *   signInputAsync. For the async methods you can create a SignerAsync object
 *   and use something like a hardware wallet to sign with. (You must implement this)
 * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`
 *   the psbt calling combine will always have precedence when a conflict occurs.
 *   Combine checks if the internal bitcoin transaction is the same, so be sure that
 *   all sequences, version, locktime, etc. are the same before combining.
 * Input Finalizer: This role is fairly important. Not only does it need to construct
 *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.
 *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`
 *   Running any finalize method will delete any data in the input(s) that are no longer
 *   needed due to the finalized scripts containing the information.
 * Transaction Extractor: This role will perform some checks before returning a
 *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.
 */ class Psbt {
    constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())){
        this.data = data;
        // set defaults
        this.opts = Object.assign({}, DEFAULT_OPTS, opts);
        this.__CACHE = {
            __NON_WITNESS_UTXO_TX_CACHE: [],
            __NON_WITNESS_UTXO_BUF_CACHE: [],
            __TX_IN_CACHE: {},
            __TX: this.data.globalMap.unsignedTx.tx,
            // Old TransactionBuilder behavior was to not confirm input values
            // before signing. Even though we highly encourage people to get
            // the full parent transaction to verify values, the ability to
            // sign non-segwit inputs without the full transaction was often
            // requested. So the only way to activate is to use @ts-ignore.
            // We will disable exporting the Psbt when unsafe sign is active.
            // because it is not BIP174 compliant.
            __UNSAFE_SIGN_NONSEGWIT: false
        };
        if (this.data.inputs.length === 0) this.setVersion(2);
        // Make data hidden when enumerating
        const dpew = (obj, attr, enumerable, writable)=>Object.defineProperty(obj, attr, {
                enumerable,
                writable
            });
        dpew(this, "__CACHE", false, true);
        dpew(this, "opts", false, true);
    }
    static fromBase64(data, opts = {}) {
        const buffer = Buffer.from(data, "base64");
        return this.fromBuffer(buffer, opts);
    }
    static fromHex(data, opts = {}) {
        const buffer = Buffer.from(data, "hex");
        return this.fromBuffer(buffer, opts);
    }
    static fromBuffer(buffer, opts = {}) {
        const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);
        const psbt = new Psbt(opts, psbtBase);
        checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);
        return psbt;
    }
    get inputCount() {
        return this.data.inputs.length;
    }
    get version() {
        return this.__CACHE.__TX.version;
    }
    set version(version) {
        this.setVersion(version);
    }
    get locktime() {
        return this.__CACHE.__TX.locktime;
    }
    set locktime(locktime) {
        this.setLocktime(locktime);
    }
    get txInputs() {
        return this.__CACHE.__TX.ins.map((input)=>({
                hash: bufferutils_1.cloneBuffer(input.hash),
                index: input.index,
                sequence: input.sequence
            }));
    }
    get txOutputs() {
        return this.__CACHE.__TX.outs.map((output)=>{
            let address;
            try {
                address = address_1.fromOutputScript(output.script, this.opts.network);
            } catch (_) {}
            return {
                script: bufferutils_1.cloneBuffer(output.script),
                value: output.value,
                address
            };
        });
    }
    combine(...those) {
        this.data.combine(...those.map((o)=>o.data));
        return this;
    }
    clone() {
        // TODO: more efficient cloning
        const res = Psbt.fromBuffer(this.data.toBuffer());
        res.opts = JSON.parse(JSON.stringify(this.opts));
        return res;
    }
    setMaximumFeeRate(satoshiPerByte) {
        check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw
        this.opts.maximumFeeRate = satoshiPerByte;
    }
    setVersion(version) {
        check32Bit(version);
        checkInputsForPartialSig(this.data.inputs, "setVersion");
        const c = this.__CACHE;
        c.__TX.version = version;
        c.__EXTRACTED_TX = undefined;
        return this;
    }
    setLocktime(locktime) {
        check32Bit(locktime);
        checkInputsForPartialSig(this.data.inputs, "setLocktime");
        const c = this.__CACHE;
        c.__TX.locktime = locktime;
        c.__EXTRACTED_TX = undefined;
        return this;
    }
    setInputSequence(inputIndex, sequence) {
        check32Bit(sequence);
        checkInputsForPartialSig(this.data.inputs, "setInputSequence");
        const c = this.__CACHE;
        if (c.__TX.ins.length <= inputIndex) throw new Error("Input index too high");
        c.__TX.ins[inputIndex].sequence = sequence;
        c.__EXTRACTED_TX = undefined;
        return this;
    }
    addInputs(inputDatas) {
        inputDatas.forEach((inputData)=>this.addInput(inputData));
        return this;
    }
    addInput(inputData) {
        if (arguments.length > 1 || !inputData || inputData.hash === undefined || inputData.index === undefined) throw new Error(`Invalid arguments for Psbt.addInput. ` + `Requires single object with at least [hash] and [index]`);
        checkInputsForPartialSig(this.data.inputs, "addInput");
        if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);
        const c = this.__CACHE;
        this.data.addInput(inputData);
        const txIn = c.__TX.ins[c.__TX.ins.length - 1];
        checkTxInputCache(c, txIn);
        const inputIndex = this.data.inputs.length - 1;
        const input = this.data.inputs[inputIndex];
        if (input.nonWitnessUtxo) addNonWitnessTxCache(this.__CACHE, input, inputIndex);
        c.__FEE = undefined;
        c.__FEE_RATE = undefined;
        c.__EXTRACTED_TX = undefined;
        return this;
    }
    addOutputs(outputDatas) {
        outputDatas.forEach((outputData)=>this.addOutput(outputData));
        return this;
    }
    addOutput(outputData) {
        if (arguments.length > 1 || !outputData || outputData.value === undefined || outputData.address === undefined && outputData.script === undefined) throw new Error(`Invalid arguments for Psbt.addOutput. ` + `Requires single object with at least [script or address] and [value]`);
        checkInputsForPartialSig(this.data.inputs, "addOutput");
        const { address } = outputData;
        if (typeof address === "string") {
            const { network } = this.opts;
            const script = address_1.toOutputScript(address, network);
            outputData = Object.assign(outputData, {
                script
            });
        }
        const c = this.__CACHE;
        this.data.addOutput(outputData);
        c.__FEE = undefined;
        c.__FEE_RATE = undefined;
        c.__EXTRACTED_TX = undefined;
        return this;
    }
    extractTransaction(disableFeeCheck) {
        if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
        const c = this.__CACHE;
        if (!disableFeeCheck) checkFees(this, c, this.opts);
        if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;
        const tx = c.__TX.clone();
        inputFinalizeGetAmts(this.data.inputs, tx, c, true);
        return tx;
    }
    getFeeRate() {
        return getTxCacheValue("__FEE_RATE", "fee rate", this.data.inputs, this.__CACHE);
    }
    getFee() {
        return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
    }
    finalizeAllInputs() {
        utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one
        range(this.data.inputs.length).forEach((idx)=>this.finalizeInput(idx));
        return this;
    }
    finalizeInput(inputIndex, finalScriptsFunc = getFinalScripts) {
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(inputIndex, input, this.__CACHE);
        if (!script) throw new Error(`No script found for input #${inputIndex}`);
        checkPartialSigSighashes(input);
        const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(inputIndex, input, script, isSegwit, isP2SH, isP2WSH);
        if (finalScriptSig) this.data.updateInput(inputIndex, {
            finalScriptSig
        });
        if (finalScriptWitness) this.data.updateInput(inputIndex, {
            finalScriptWitness
        });
        if (!finalScriptSig && !finalScriptWitness) throw new Error(`Unknown error finalizing input #${inputIndex}`);
        this.data.clearFinalizedInput(inputIndex);
        return this;
    }
    getInputType(inputIndex) {
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);
        const result = getMeaningfulScript(script, inputIndex, "input", input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig), input.witnessScript || redeemFromFinalWitnessScript(input.finalScriptWitness));
        const type = result.type === "raw" ? "" : result.type + "-";
        const mainType = classifyScript(result.meaningfulScript);
        return type + mainType;
    }
    inputHasPubkey(inputIndex, pubkey) {
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);
    }
    inputHasHDKey(inputIndex, root) {
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        const derivationIsMine = bip32DerivationIsMine(root);
        return !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine);
    }
    outputHasPubkey(outputIndex, pubkey) {
        const output = utils_1.checkForOutput(this.data.outputs, outputIndex);
        return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);
    }
    outputHasHDKey(outputIndex, root) {
        const output = utils_1.checkForOutput(this.data.outputs, outputIndex);
        const derivationIsMine = bip32DerivationIsMine(root);
        return !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine);
    }
    validateSignaturesOfAllInputs() {
        utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one
        const results = range(this.data.inputs.length).map((idx)=>this.validateSignaturesOfInput(idx));
        return results.reduce((final, res)=>res === true && final, true);
    }
    validateSignaturesOfInput(inputIndex, pubkey) {
        const input = this.data.inputs[inputIndex];
        const partialSig = (input || {}).partialSig;
        if (!input || !partialSig || partialSig.length < 1) throw new Error("No signatures to validate");
        const mySigs = pubkey ? partialSig.filter((sig)=>sig.pubkey.equals(pubkey)) : partialSig;
        if (mySigs.length < 1) throw new Error("No signatures for this pubkey");
        const results = [];
        let hashCache;
        let scriptCache;
        let sighashCache;
        for (const pSig of mySigs){
            const sig = bscript.signature.decode(pSig.signature);
            const { hash, script } = sighashCache !== sig.hashType ? getHashForSig(inputIndex, Object.assign({}, input, {
                sighashType: sig.hashType
            }), this.__CACHE, true) : {
                hash: hashCache,
                script: scriptCache
            };
            sighashCache = sig.hashType;
            hashCache = hash;
            scriptCache = script;
            checkScriptForPubkey(pSig.pubkey, script, "verify");
            const keypair = ecpair_1.fromPublicKey(pSig.pubkey);
            results.push(keypair.verify(hash, sig.signature));
        }
        return results.every((res)=>res === true);
    }
    signAllInputsHD(hdKeyPair, sighashTypes = [
        transaction_1.Transaction.SIGHASH_ALL
    ]) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) throw new Error("Need HDSigner to sign input");
        const results = [];
        for (const i of range(this.data.inputs.length))try {
            this.signInputHD(i, hdKeyPair, sighashTypes);
            results.push(true);
        } catch (err) {
            results.push(false);
        }
        if (results.every((v)=>v === false)) throw new Error("No inputs were signed");
        return this;
    }
    signAllInputsHDAsync(hdKeyPair, sighashTypes = [
        transaction_1.Transaction.SIGHASH_ALL
    ]) {
        return new Promise((resolve, reject)=>{
            if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) return reject(new Error("Need HDSigner to sign input"));
            const results = [];
            const promises = [];
            for (const i of range(this.data.inputs.length))promises.push(this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(()=>{
                results.push(true);
            }, ()=>{
                results.push(false);
            }));
            return Promise.all(promises).then(()=>{
                if (results.every((v)=>v === false)) return reject(new Error("No inputs were signed"));
                resolve();
            });
        });
    }
    signInputHD(inputIndex, hdKeyPair, sighashTypes = [
        transaction_1.Transaction.SIGHASH_ALL
    ]) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) throw new Error("Need HDSigner to sign input");
        const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
        signers.forEach((signer)=>this.signInput(inputIndex, signer, sighashTypes));
        return this;
    }
    signInputHDAsync(inputIndex, hdKeyPair, sighashTypes = [
        transaction_1.Transaction.SIGHASH_ALL
    ]) {
        return new Promise((resolve, reject)=>{
            if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) return reject(new Error("Need HDSigner to sign input"));
            const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
            const promises = signers.map((signer)=>this.signInputAsync(inputIndex, signer, sighashTypes));
            return Promise.all(promises).then(()=>{
                resolve();
            }).catch(reject);
        });
    }
    signAllInputs(keyPair, sighashTypes = [
        transaction_1.Transaction.SIGHASH_ALL
    ]) {
        if (!keyPair || !keyPair.publicKey) throw new Error("Need Signer to sign input");
        // TODO: Add a pubkey/pubkeyhash cache to each input
        // as input information is added, then eventually
        // optimize this method.
        const results = [];
        for (const i of range(this.data.inputs.length))try {
            this.signInput(i, keyPair, sighashTypes);
            results.push(true);
        } catch (err) {
            results.push(false);
        }
        if (results.every((v)=>v === false)) throw new Error("No inputs were signed");
        return this;
    }
    signAllInputsAsync(keyPair, sighashTypes = [
        transaction_1.Transaction.SIGHASH_ALL
    ]) {
        return new Promise((resolve, reject)=>{
            if (!keyPair || !keyPair.publicKey) return reject(new Error("Need Signer to sign input"));
            // TODO: Add a pubkey/pubkeyhash cache to each input
            // as input information is added, then eventually
            // optimize this method.
            const results = [];
            const promises = [];
            for (const [i] of this.data.inputs.entries())promises.push(this.signInputAsync(i, keyPair, sighashTypes).then(()=>{
                results.push(true);
            }, ()=>{
                results.push(false);
            }));
            return Promise.all(promises).then(()=>{
                if (results.every((v)=>v === false)) return reject(new Error("No inputs were signed"));
                resolve();
            });
        });
    }
    signInput(inputIndex, keyPair, sighashTypes = [
        transaction_1.Transaction.SIGHASH_ALL
    ]) {
        if (!keyPair || !keyPair.publicKey) throw new Error("Need Signer to sign input");
        const { hash, sighashType } = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes);
        const partialSig = [
            {
                pubkey: keyPair.publicKey,
                signature: bscript.signature.encode(keyPair.sign(hash), sighashType)
            }
        ];
        this.data.updateInput(inputIndex, {
            partialSig
        });
        return this;
    }
    signInputAsync(inputIndex, keyPair, sighashTypes = [
        transaction_1.Transaction.SIGHASH_ALL
    ]) {
        return Promise.resolve().then(()=>{
            if (!keyPair || !keyPair.publicKey) throw new Error("Need Signer to sign input");
            const { hash, sighashType } = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes);
            return Promise.resolve(keyPair.sign(hash)).then((signature)=>{
                const partialSig = [
                    {
                        pubkey: keyPair.publicKey,
                        signature: bscript.signature.encode(signature, sighashType)
                    }
                ];
                this.data.updateInput(inputIndex, {
                    partialSig
                });
            });
        });
    }
    toBuffer() {
        checkCache(this.__CACHE);
        return this.data.toBuffer();
    }
    toHex() {
        checkCache(this.__CACHE);
        return this.data.toHex();
    }
    toBase64() {
        checkCache(this.__CACHE);
        return this.data.toBase64();
    }
    updateGlobal(updateData) {
        this.data.updateGlobal(updateData);
        return this;
    }
    updateInput(inputIndex, updateData) {
        if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);
        this.data.updateInput(inputIndex, updateData);
        if (updateData.nonWitnessUtxo) addNonWitnessTxCache(this.__CACHE, this.data.inputs[inputIndex], inputIndex);
        return this;
    }
    updateOutput(outputIndex, updateData) {
        this.data.updateOutput(outputIndex, updateData);
        return this;
    }
    addUnknownKeyValToGlobal(keyVal) {
        this.data.addUnknownKeyValToGlobal(keyVal);
        return this;
    }
    addUnknownKeyValToInput(inputIndex, keyVal) {
        this.data.addUnknownKeyValToInput(inputIndex, keyVal);
        return this;
    }
    addUnknownKeyValToOutput(outputIndex, keyVal) {
        this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
        return this;
    }
    clearFinalizedInput(inputIndex) {
        this.data.clearFinalizedInput(inputIndex);
        return this;
    }
}
exports.Psbt = Psbt;
/**
 * This function is needed to pass to the bip174 base class's fromBuffer.
 * It takes the "transaction buffer" portion of the psbt buffer and returns a
 * Transaction (From the bip174 library) interface.
 */ const transactionFromBuffer = (buffer)=>new PsbtTransaction(buffer);
/**
 * This class implements the Transaction interface from bip174 library.
 * It contains a bitcoinjs-lib Transaction object.
 */ class PsbtTransaction {
    constructor(buffer = Buffer.from([
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ])){
        this.tx = transaction_1.Transaction.fromBuffer(buffer);
        checkTxEmpty(this.tx);
        Object.defineProperty(this, "tx", {
            enumerable: false,
            writable: true
        });
    }
    getInputOutputCounts() {
        return {
            inputCount: this.tx.ins.length,
            outputCount: this.tx.outs.length
        };
    }
    addInput(input) {
        if (input.hash === undefined || input.index === undefined || !Buffer.isBuffer(input.hash) && typeof input.hash !== "string" || typeof input.index !== "number") throw new Error("Error adding input.");
        const hash = typeof input.hash === "string" ? bufferutils_1.reverseBuffer(Buffer.from(input.hash, "hex")) : input.hash;
        this.tx.addInput(hash, input.index, input.sequence);
    }
    addOutput(output) {
        if (output.script === undefined || output.value === undefined || !Buffer.isBuffer(output.script) || typeof output.value !== "number") throw new Error("Error adding output.");
        this.tx.addOutput(output.script, output.value);
    }
    toBuffer() {
        return this.tx.toBuffer();
    }
}
function canFinalize(input, script, scriptType) {
    switch(scriptType){
        case "pubkey":
        case "pubkeyhash":
        case "witnesspubkeyhash":
            return hasSigs(1, input.partialSig);
        case "multisig":
            const p2ms = payments.p2ms({
                output: script
            });
            return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);
        default:
            return false;
    }
}
function checkCache(cache) {
    if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) throw new Error("Not BIP174 compliant, can not export");
}
function hasSigs(neededSigs, partialSig, pubkeys) {
    if (!partialSig) return false;
    let sigs;
    if (pubkeys) sigs = pubkeys.map((pkey)=>{
        const pubkey = ecpair_1.fromPublicKey(pkey, {
            compressed: true
        }).publicKey;
        return partialSig.find((pSig)=>pSig.pubkey.equals(pubkey));
    }).filter((v)=>!!v);
    else sigs = partialSig;
    if (sigs.length > neededSigs) throw new Error("Too many signatures");
    return sigs.length === neededSigs;
}
function isFinalized(input) {
    return !!input.finalScriptSig || !!input.finalScriptWitness;
}
function isPaymentFactory(payment) {
    return (script)=>{
        try {
            payment({
                output: script
            });
            return true;
        } catch (err) {
            return false;
        }
    };
}
const isP2MS = isPaymentFactory(payments.p2ms);
const isP2PK = isPaymentFactory(payments.p2pk);
const isP2PKH = isPaymentFactory(payments.p2pkh);
const isP2WPKH = isPaymentFactory(payments.p2wpkh);
const isP2WSHScript = isPaymentFactory(payments.p2wsh);
const isP2SHScript = isPaymentFactory(payments.p2sh);
function bip32DerivationIsMine(root) {
    return (d)=>{
        if (!d.masterFingerprint.equals(root.fingerprint)) return false;
        if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;
        return true;
    };
}
function check32Bit(num) {
    if (typeof num !== "number" || num !== Math.floor(num) || num > 0xffffffff || num < 0) throw new Error("Invalid 32 bit integer");
}
function checkFees(psbt, cache, opts) {
    const feeRate = cache.__FEE_RATE || psbt.getFeeRate();
    const vsize = cache.__EXTRACTED_TX.virtualSize();
    const satoshis = feeRate * vsize;
    if (feeRate >= opts.maximumFeeRate) throw new Error(`Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` + `fees, which is ${feeRate} satoshi per byte for a transaction ` + `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` + `byte). Use setMaximumFeeRate method to raise your threshold, or ` + `pass true to the first arg of extractTransaction.`);
}
function checkInputsForPartialSig(inputs, action) {
    inputs.forEach((input)=>{
        let throws = false;
        let pSigs = [];
        if ((input.partialSig || []).length === 0) {
            if (!input.finalScriptSig && !input.finalScriptWitness) return;
            pSigs = getPsigsFromInputFinalScripts(input);
        } else pSigs = input.partialSig;
        pSigs.forEach((pSig)=>{
            const { hashType } = bscript.signature.decode(pSig.signature);
            const whitelist = [];
            const isAnyoneCanPay = hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;
            if (isAnyoneCanPay) whitelist.push("addInput");
            const hashMod = hashType & 0x1f;
            switch(hashMod){
                case transaction_1.Transaction.SIGHASH_ALL:
                    break;
                case transaction_1.Transaction.SIGHASH_SINGLE:
                case transaction_1.Transaction.SIGHASH_NONE:
                    whitelist.push("addOutput");
                    whitelist.push("setInputSequence");
                    break;
            }
            if (whitelist.indexOf(action) === -1) throws = true;
        });
        if (throws) throw new Error("Can not modify transaction, signatures exist.");
    });
}
function checkPartialSigSighashes(input) {
    if (!input.sighashType || !input.partialSig) return;
    const { partialSig, sighashType } = input;
    partialSig.forEach((pSig)=>{
        const { hashType } = bscript.signature.decode(pSig.signature);
        if (sighashType !== hashType) throw new Error("Signature sighash does not match input sighash type");
    });
}
function checkScriptForPubkey(pubkey, script, action) {
    if (!pubkeyInScript(pubkey, script)) throw new Error(`Can not ${action} for this input with the key ${pubkey.toString("hex")}`);
}
function checkTxEmpty(tx) {
    const isEmpty = tx.ins.every((input)=>input.script && input.script.length === 0 && input.witness && input.witness.length === 0);
    if (!isEmpty) throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function checkTxForDupeIns(tx, cache) {
    tx.ins.forEach((input)=>{
        checkTxInputCache(cache, input);
    });
}
function checkTxInputCache(cache, input) {
    const key = bufferutils_1.reverseBuffer(Buffer.from(input.hash)).toString("hex") + ":" + input.index;
    if (cache.__TX_IN_CACHE[key]) throw new Error("Duplicate input detected.");
    cache.__TX_IN_CACHE[key] = 1;
}
function scriptCheckerFactory(payment, paymentScriptName) {
    return (inputIndex, scriptPubKey, redeemScript, ioType)=>{
        const redeemScriptOutput = payment({
            redeem: {
                output: redeemScript
            }
        }).output;
        if (!scriptPubKey.equals(redeemScriptOutput)) throw new Error(`${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`);
    };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script");
const checkWitnessScript = scriptCheckerFactory(payments.p2wsh, "Witness script");
function getTxCacheValue(key, name, inputs, c) {
    if (!inputs.every(isFinalized)) throw new Error(`PSBT must be finalized to calculate ${name}`);
    if (key === "__FEE_RATE" && c.__FEE_RATE) return c.__FEE_RATE;
    if (key === "__FEE" && c.__FEE) return c.__FEE;
    let tx;
    let mustFinalize = true;
    if (c.__EXTRACTED_TX) {
        tx = c.__EXTRACTED_TX;
        mustFinalize = false;
    } else tx = c.__TX.clone();
    inputFinalizeGetAmts(inputs, tx, c, mustFinalize);
    if (key === "__FEE_RATE") return c.__FEE_RATE;
    else if (key === "__FEE") return c.__FEE;
}
function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {
    const scriptType = classifyScript(script);
    if (!canFinalize(input, script, scriptType)) throw new Error(`Can not finalize input #${inputIndex}`);
    return prepareFinalScripts(script, scriptType, input.partialSig, isSegwit, isP2SH, isP2WSH);
}
function prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH) {
    let finalScriptSig;
    let finalScriptWitness;
    // Wow, the payments API is very handy
    const payment = getPayment(script, scriptType, partialSig);
    const p2wsh = !isP2WSH ? null : payments.p2wsh({
        redeem: payment
    });
    const p2sh = !isP2SH ? null : payments.p2sh({
        redeem: p2wsh || payment
    });
    if (isSegwit) {
        if (p2wsh) finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);
        else finalScriptWitness = witnessStackToScriptWitness(payment.witness);
        if (p2sh) finalScriptSig = p2sh.input;
    } else if (p2sh) finalScriptSig = p2sh.input;
    else finalScriptSig = payment.input;
    return {
        finalScriptSig,
        finalScriptWitness
    };
}
function getHashAndSighashType(inputs, inputIndex, pubkey, cache, sighashTypes) {
    const input = utils_1.checkForInput(inputs, inputIndex);
    const { hash, sighashType, script } = getHashForSig(inputIndex, input, cache, false, sighashTypes);
    checkScriptForPubkey(pubkey, script, "sign");
    return {
        hash,
        sighashType
    };
}
function getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {
    const unsignedTx = cache.__TX;
    const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_ALL;
    if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
        const str = sighashTypeToString(sighashType);
        throw new Error(`Sighash type is not allowed. Retry the sign method passing the ` + `sighashTypes array of whitelisted types. Sighash type: ${str}`);
    }
    let hash;
    let prevout;
    if (input.nonWitnessUtxo) {
        const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);
        const prevoutHash = unsignedTx.ins[inputIndex].hash;
        const utxoHash = nonWitnessUtxoTx.getHash();
        // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout
        if (!prevoutHash.equals(utxoHash)) throw new Error(`Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`);
        const prevoutIndex = unsignedTx.ins[inputIndex].index;
        prevout = nonWitnessUtxoTx.outs[prevoutIndex];
    } else if (input.witnessUtxo) prevout = input.witnessUtxo;
    else throw new Error("Need a Utxo input item for signing");
    const { meaningfulScript, type } = getMeaningfulScript(prevout.script, inputIndex, "input", input.redeemScript, input.witnessScript);
    if ([
        "p2sh-p2wsh",
        "p2wsh"
    ].indexOf(type) >= 0) hash = unsignedTx.hashForWitnessV0(inputIndex, meaningfulScript, prevout.value, sighashType);
    else if (isP2WPKH(meaningfulScript)) {
        // P2WPKH uses the P2PKH template for prevoutScript when signing
        const signingScript = payments.p2pkh({
            hash: meaningfulScript.slice(2)
        }).output;
        hash = unsignedTx.hashForWitnessV0(inputIndex, signingScript, prevout.value, sighashType);
    } else {
        // non-segwit
        if (input.nonWitnessUtxo === undefined && cache.__UNSAFE_SIGN_NONSEGWIT === false) throw new Error(`Input #${inputIndex} has witnessUtxo but non-segwit script: ` + `${meaningfulScript.toString("hex")}`);
        if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false) console.warn("Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as the old TransactionBuilder class when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n*********************");
        hash = unsignedTx.hashForSignature(inputIndex, meaningfulScript, sighashType);
    }
    return {
        script: meaningfulScript,
        sighashType,
        hash
    };
}
function getPayment(script, scriptType, partialSig) {
    let payment;
    switch(scriptType){
        case "multisig":
            const sigs = getSortedSigs(script, partialSig);
            payment = payments.p2ms({
                output: script,
                signatures: sigs
            });
            break;
        case "pubkey":
            payment = payments.p2pk({
                output: script,
                signature: partialSig[0].signature
            });
            break;
        case "pubkeyhash":
            payment = payments.p2pkh({
                output: script,
                pubkey: partialSig[0].pubkey,
                signature: partialSig[0].signature
            });
            break;
        case "witnesspubkeyhash":
            payment = payments.p2wpkh({
                output: script,
                pubkey: partialSig[0].pubkey,
                signature: partialSig[0].signature
            });
            break;
    }
    return payment;
}
function getPsigsFromInputFinalScripts(input) {
    const scriptItems = !input.finalScriptSig ? [] : bscript.decompile(input.finalScriptSig) || [];
    const witnessItems = !input.finalScriptWitness ? [] : bscript.decompile(input.finalScriptWitness) || [];
    return scriptItems.concat(witnessItems).filter((item)=>{
        return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);
    }).map((sig)=>({
            signature: sig
        }));
}
function getScriptFromInput(inputIndex, input, cache) {
    const unsignedTx = cache.__TX;
    const res = {
        script: null,
        isSegwit: false,
        isP2SH: false,
        isP2WSH: false
    };
    res.isP2SH = !!input.redeemScript;
    res.isP2WSH = !!input.witnessScript;
    if (input.witnessScript) res.script = input.witnessScript;
    else if (input.redeemScript) res.script = input.redeemScript;
    else {
        if (input.nonWitnessUtxo) {
            const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);
            const prevoutIndex = unsignedTx.ins[inputIndex].index;
            res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
        } else if (input.witnessUtxo) res.script = input.witnessUtxo.script;
    }
    if (input.witnessScript || isP2WPKH(res.script)) res.isSegwit = true;
    return res;
}
function getSignersFromHD(inputIndex, inputs, hdKeyPair) {
    const input = utils_1.checkForInput(inputs, inputIndex);
    if (!input.bip32Derivation || input.bip32Derivation.length === 0) throw new Error("Need bip32Derivation to sign with HD");
    const myDerivations = input.bip32Derivation.map((bipDv)=>{
        if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) return bipDv;
        else return;
    }).filter((v)=>!!v);
    if (myDerivations.length === 0) throw new Error("Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint");
    const signers = myDerivations.map((bipDv)=>{
        const node = hdKeyPair.derivePath(bipDv.path);
        if (!bipDv.pubkey.equals(node.publicKey)) throw new Error("pubkey did not match bip32Derivation");
        return node;
    });
    return signers;
}
function getSortedSigs(script, partialSig) {
    const p2ms = payments.p2ms({
        output: script
    });
    // for each pubkey in order of p2ms script
    return p2ms.pubkeys.map((pk)=>{
        // filter partialSig array by pubkey being equal
        return (partialSig.filter((ps)=>{
            return ps.pubkey.equals(pk);
        })[0] || {}).signature;
    // Any pubkey without a match will return undefined
    // this last filter removes all the undefined items in the array.
    }).filter((v)=>!!v);
}
function scriptWitnessToWitnessStack(buffer) {
    let offset = 0;
    function readSlice(n) {
        offset += n;
        return buffer.slice(offset - n, offset);
    }
    function readVarInt() {
        const vi = varuint.decode(buffer, offset);
        offset += varuint.decode.bytes;
        return vi;
    }
    function readVarSlice() {
        return readSlice(readVarInt());
    }
    function readVector() {
        const count = readVarInt();
        const vector = [];
        for(let i = 0; i < count; i++)vector.push(readVarSlice());
        return vector;
    }
    return readVector();
}
function sighashTypeToString(sighashType) {
    let text = sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
    const sigMod = sighashType & 0x1f;
    switch(sigMod){
        case transaction_1.Transaction.SIGHASH_ALL:
            text += "SIGHASH_ALL";
            break;
        case transaction_1.Transaction.SIGHASH_SINGLE:
            text += "SIGHASH_SINGLE";
            break;
        case transaction_1.Transaction.SIGHASH_NONE:
            text += "SIGHASH_NONE";
            break;
    }
    return text;
}
function witnessStackToScriptWitness(witness) {
    let buffer = Buffer.allocUnsafe(0);
    function writeSlice(slice) {
        buffer = Buffer.concat([
            buffer,
            Buffer.from(slice)
        ]);
    }
    function writeVarInt(i) {
        const currentLen = buffer.length;
        const varintLen = varuint.encodingLength(i);
        buffer = Buffer.concat([
            buffer,
            Buffer.allocUnsafe(varintLen)
        ]);
        varuint.encode(i, buffer, currentLen);
    }
    function writeVarSlice(slice) {
        writeVarInt(slice.length);
        writeSlice(slice);
    }
    function writeVector(vector) {
        writeVarInt(vector.length);
        vector.forEach(writeVarSlice);
    }
    writeVector(witness);
    return buffer;
}
function addNonWitnessTxCache(cache, input, inputIndex) {
    cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;
    const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);
    cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;
    const self = cache;
    const selfIndex = inputIndex;
    delete input.nonWitnessUtxo;
    Object.defineProperty(input, "nonWitnessUtxo", {
        enumerable: true,
        get () {
            const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];
            const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];
            if (buf !== undefined) return buf;
            else {
                const newBuf = txCache.toBuffer();
                self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;
                return newBuf;
            }
        },
        set (data) {
            self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;
        }
    });
}
function inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {
    let inputAmount = 0;
    inputs.forEach((input, idx)=>{
        if (mustFinalize && input.finalScriptSig) tx.ins[idx].script = input.finalScriptSig;
        if (mustFinalize && input.finalScriptWitness) tx.ins[idx].witness = scriptWitnessToWitnessStack(input.finalScriptWitness);
        if (input.witnessUtxo) inputAmount += input.witnessUtxo.value;
        else if (input.nonWitnessUtxo) {
            const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);
            const vout = tx.ins[idx].index;
            const out = nwTx.outs[vout];
            inputAmount += out.value;
        }
    });
    const outputAmount = tx.outs.reduce((total, o)=>total + o.value, 0);
    const fee = inputAmount - outputAmount;
    if (fee < 0) throw new Error("Outputs are spending more than Inputs");
    const bytes = tx.virtualSize();
    cache.__FEE = fee;
    cache.__EXTRACTED_TX = tx;
    cache.__FEE_RATE = Math.floor(fee / bytes);
}
function nonWitnessUtxoTxFromCache(cache, input, inputIndex) {
    const c = cache.__NON_WITNESS_UTXO_TX_CACHE;
    if (!c[inputIndex]) addNonWitnessTxCache(cache, input, inputIndex);
    return c[inputIndex];
}
function getScriptFromUtxo(inputIndex, input, cache) {
    if (input.witnessUtxo !== undefined) return input.witnessUtxo.script;
    else if (input.nonWitnessUtxo !== undefined) {
        const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);
        return nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index].script;
    } else throw new Error("Can't find pubkey in input without Utxo data");
}
function pubkeyInInput(pubkey, input, inputIndex, cache) {
    const script = getScriptFromUtxo(inputIndex, input, cache);
    const { meaningfulScript } = getMeaningfulScript(script, inputIndex, "input", input.redeemScript, input.witnessScript);
    return pubkeyInScript(pubkey, meaningfulScript);
}
function pubkeyInOutput(pubkey, output, outputIndex, cache) {
    const script = cache.__TX.outs[outputIndex].script;
    const { meaningfulScript } = getMeaningfulScript(script, outputIndex, "output", output.redeemScript, output.witnessScript);
    return pubkeyInScript(pubkey, meaningfulScript);
}
function redeemFromFinalScriptSig(finalScript) {
    if (!finalScript) return;
    const decomp = bscript.decompile(finalScript);
    if (!decomp) return;
    const lastItem = decomp[decomp.length - 1];
    if (!Buffer.isBuffer(lastItem) || isPubkeyLike(lastItem) || isSigLike(lastItem)) return;
    const sDecomp = bscript.decompile(lastItem);
    if (!sDecomp) return;
    return lastItem;
}
function redeemFromFinalWitnessScript(finalScript) {
    if (!finalScript) return;
    const decomp = scriptWitnessToWitnessStack(finalScript);
    const lastItem = decomp[decomp.length - 1];
    if (isPubkeyLike(lastItem)) return;
    const sDecomp = bscript.decompile(lastItem);
    if (!sDecomp) return;
    return lastItem;
}
function isPubkeyLike(buf) {
    return buf.length === 33 && bscript.isCanonicalPubKey(buf);
}
function isSigLike(buf) {
    return bscript.isCanonicalScriptSignature(buf);
}
function getMeaningfulScript(script, index, ioType, redeemScript, witnessScript) {
    const isP2SH = isP2SHScript(script);
    const isP2SHP2WSH = isP2SH && redeemScript && isP2WSHScript(redeemScript);
    const isP2WSH = isP2WSHScript(script);
    if (isP2SH && redeemScript === undefined) throw new Error("scriptPubkey is P2SH but redeemScript missing");
    if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined) throw new Error("scriptPubkey or redeemScript is P2WSH but witnessScript missing");
    let meaningfulScript;
    if (isP2SHP2WSH) {
        meaningfulScript = witnessScript;
        checkRedeemScript(index, script, redeemScript, ioType);
        checkWitnessScript(index, redeemScript, witnessScript, ioType);
        checkInvalidP2WSH(meaningfulScript);
    } else if (isP2WSH) {
        meaningfulScript = witnessScript;
        checkWitnessScript(index, script, witnessScript, ioType);
        checkInvalidP2WSH(meaningfulScript);
    } else if (isP2SH) {
        meaningfulScript = redeemScript;
        checkRedeemScript(index, script, redeemScript, ioType);
    } else meaningfulScript = script;
    return {
        meaningfulScript,
        type: isP2SHP2WSH ? "p2sh-p2wsh" : isP2SH ? "p2sh" : isP2WSH ? "p2wsh" : "raw"
    };
}
function checkInvalidP2WSH(script) {
    if (isP2WPKH(script) || isP2SHScript(script)) throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function pubkeyInScript(pubkey, script) {
    const pubkeyHash = crypto_1.hash160(pubkey);
    const decompiled = bscript.decompile(script);
    if (decompiled === null) throw new Error("Unknown script error");
    return decompiled.some((element)=>{
        if (typeof element === "number") return false;
        return element.equals(pubkey) || element.equals(pubkeyHash);
    });
}
function classifyScript(script) {
    if (isP2WPKH(script)) return "witnesspubkeyhash";
    if (isP2PKH(script)) return "pubkeyhash";
    if (isP2MS(script)) return "multisig";
    if (isP2PK(script)) return "pubkey";
    return "nonstandard";
}
function range(n) {
    return [
        ...Array(n).keys()
    ];
}

},{"bd04018dc1652f62":"bwvMq","3cdabce7cf751469":"8k3Hp","7f0c469e1295416c":"1mjPW","15e876c92e186c9a":"f992a","206460bdf6f8e224":"2Me89","c66b4b428f6e9b6c":"jR49q","2c0de14d737e7f5c":"4BCCF","bc92084ba24790e4":"aiXsq","d819d635cf774913":"hpO0s","147d6fa1a977536e":"g5Tn6","2f149948dde5be71":"28LFb","a441c63dce14b7a7":"arhmj"}],"8k3Hp":[function(require,module,exports) {
var Buffer = require("9f7dbb5a1a52093b").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const combiner_1 = require("66e97b846feca30a");
const parser_1 = require("c05d7c91183f6ebd");
const typeFields_1 = require("f50e19d1acfe2b7e");
const utils_1 = require("627662a4106d5e06");
class Psbt {
    constructor(tx){
        this.inputs = [];
        this.outputs = [];
        this.globalMap = {
            unsignedTx: tx
        };
    }
    static fromBase64(data, txFromBuffer) {
        const buffer = Buffer.from(data, "base64");
        return this.fromBuffer(buffer, txFromBuffer);
    }
    static fromHex(data, txFromBuffer) {
        const buffer = Buffer.from(data, "hex");
        return this.fromBuffer(buffer, txFromBuffer);
    }
    static fromBuffer(buffer, txFromBuffer) {
        const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);
        const psbt = new this(results.globalMap.unsignedTx);
        Object.assign(psbt, results);
        return psbt;
    }
    toBase64() {
        const buffer = this.toBuffer();
        return buffer.toString("base64");
    }
    toHex() {
        const buffer = this.toBuffer();
        return buffer.toString("hex");
    }
    toBuffer() {
        return parser_1.psbtToBuffer(this);
    }
    updateGlobal(updateData) {
        utils_1.updateGlobal(updateData, this.globalMap);
        return this;
    }
    updateInput(inputIndex, updateData) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.updateInput(updateData, input);
        return this;
    }
    updateOutput(outputIndex, updateData) {
        const output = utils_1.checkForOutput(this.outputs, outputIndex);
        utils_1.updateOutput(updateData, output);
        return this;
    }
    addUnknownKeyValToGlobal(keyVal) {
        utils_1.checkHasKey(keyVal, this.globalMap.unknownKeyVals, utils_1.getEnumLength(typeFields_1.GlobalTypes));
        if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
        this.globalMap.unknownKeyVals.push(keyVal);
        return this;
    }
    addUnknownKeyValToInput(inputIndex, keyVal) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.checkHasKey(keyVal, input.unknownKeyVals, utils_1.getEnumLength(typeFields_1.InputTypes));
        if (!input.unknownKeyVals) input.unknownKeyVals = [];
        input.unknownKeyVals.push(keyVal);
        return this;
    }
    addUnknownKeyValToOutput(outputIndex, keyVal) {
        const output = utils_1.checkForOutput(this.outputs, outputIndex);
        utils_1.checkHasKey(keyVal, output.unknownKeyVals, utils_1.getEnumLength(typeFields_1.OutputTypes));
        if (!output.unknownKeyVals) output.unknownKeyVals = [];
        output.unknownKeyVals.push(keyVal);
        return this;
    }
    addInput(inputData) {
        this.globalMap.unsignedTx.addInput(inputData);
        this.inputs.push({
            unknownKeyVals: []
        });
        const addKeyVals = inputData.unknownKeyVals || [];
        const inputIndex = this.inputs.length - 1;
        if (!Array.isArray(addKeyVals)) throw new Error("unknownKeyVals must be an Array");
        addKeyVals.forEach((keyVal)=>this.addUnknownKeyValToInput(inputIndex, keyVal));
        utils_1.addInputAttributes(this.inputs, inputData);
        return this;
    }
    addOutput(outputData) {
        this.globalMap.unsignedTx.addOutput(outputData);
        this.outputs.push({
            unknownKeyVals: []
        });
        const addKeyVals = outputData.unknownKeyVals || [];
        const outputIndex = this.outputs.length - 1;
        if (!Array.isArray(addKeyVals)) throw new Error("unknownKeyVals must be an Array");
        addKeyVals.forEach((keyVal)=>this.addUnknownKeyValToOutput(outputIndex, keyVal));
        utils_1.addOutputAttributes(this.outputs, outputData);
        return this;
    }
    clearFinalizedInput(inputIndex) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.inputCheckUncleanFinalized(inputIndex, input);
        for (const key of Object.keys(input))if (![
            "witnessUtxo",
            "nonWitnessUtxo",
            "finalScriptSig",
            "finalScriptWitness",
            "unknownKeyVals"
        ].includes(key)) // @ts-ignore
        delete input[key];
        return this;
    }
    combine(...those) {
        // Combine this with those.
        // Return self for chaining.
        const result = combiner_1.combine([
            this
        ].concat(those));
        Object.assign(this, result);
        return this;
    }
    getTransaction() {
        return this.globalMap.unsignedTx.toBuffer();
    }
}
exports.Psbt = Psbt;

},{"9f7dbb5a1a52093b":"bwvMq","66e97b846feca30a":"aHjAQ","c05d7c91183f6ebd":"2GuBB","f50e19d1acfe2b7e":"3089x","627662a4106d5e06":"f992a"}],"aHjAQ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const parser_1 = require("d12cbe7f1844ffb1");
function combine(psbts) {
    const self = psbts[0];
    const selfKeyVals = parser_1.psbtToKeyVals(self);
    const others = psbts.slice(1);
    if (others.length === 0) throw new Error("Combine: Nothing to combine");
    const selfTx = getTx(self);
    if (selfTx === undefined) throw new Error("Combine: Self missing transaction");
    const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
    const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
    const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
    for (const other of others){
        const otherTx = getTx(other);
        if (otherTx === undefined || !otherTx.toBuffer().equals(selfTx.toBuffer())) throw new Error("Combine: One of the Psbts does not have the same transaction.");
        const otherKeyVals = parser_1.psbtToKeyVals(other);
        const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
        otherGlobalSet.forEach(keyPusher(selfGlobalSet, selfKeyVals.globalKeyVals, otherKeyVals.globalKeyVals));
        const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
        otherInputSets.forEach((inputSet, idx)=>inputSet.forEach(keyPusher(selfInputSets[idx], selfKeyVals.inputKeyVals[idx], otherKeyVals.inputKeyVals[idx])));
        const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
        otherOutputSets.forEach((outputSet, idx)=>outputSet.forEach(keyPusher(selfOutputSets[idx], selfKeyVals.outputKeyVals[idx], otherKeyVals.outputKeyVals[idx])));
    }
    return parser_1.psbtFromKeyVals(selfTx, {
        globalMapKeyVals: selfKeyVals.globalKeyVals,
        inputKeyVals: selfKeyVals.inputKeyVals,
        outputKeyVals: selfKeyVals.outputKeyVals
    });
}
exports.combine = combine;
function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
    return (key)=>{
        if (selfSet.has(key)) return;
        const newKv = otherKeyVals.filter((kv)=>kv.key.toString("hex") === key)[0];
        selfKeyVals.push(newKv);
        selfSet.add(key);
    };
}
function getTx(psbt) {
    return psbt.globalMap.unsignedTx;
}
function getKeySet(keyVals) {
    const set = new Set();
    keyVals.forEach((keyVal)=>{
        const hex = keyVal.key.toString("hex");
        if (set.has(hex)) throw new Error("Combine: KeyValue Map keys should be unique");
        set.add(hex);
    });
    return set;
}

},{"d12cbe7f1844ffb1":"2GuBB"}],"2GuBB":[function(require,module,exports) {
"use strict";
function __export(m) {
    for(var p in m)if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", {
    value: true
});
__export(require("d839361a7fddc552"));
__export(require("35f5b003239d6547"));

},{"d839361a7fddc552":"26X49","35f5b003239d6547":"jUzwk"}],"26X49":[function(require,module,exports) {
var Buffer = require("27cc1123cac1870d").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const convert = require("fa12ea4f9abfc39d");
const tools_1 = require("7ea84d5fdd09890b");
const varuint = require("a37bcc3f403dd8ac");
const typeFields_1 = require("ad0cb35bafe0b747");
function psbtFromBuffer(buffer, txGetter) {
    let offset = 0;
    function varSlice() {
        const keyLen = varuint.decode(buffer, offset);
        offset += varuint.encodingLength(keyLen);
        const key = buffer.slice(offset, offset + keyLen);
        offset += keyLen;
        return key;
    }
    function readUInt32BE() {
        const num = buffer.readUInt32BE(offset);
        offset += 4;
        return num;
    }
    function readUInt8() {
        const num = buffer.readUInt8(offset);
        offset += 1;
        return num;
    }
    function getKeyValue() {
        const key = varSlice();
        const value = varSlice();
        return {
            key,
            value
        };
    }
    function checkEndOfKeyValPairs() {
        if (offset >= buffer.length) throw new Error("Format Error: Unexpected End of PSBT");
        const isEnd = buffer.readUInt8(offset) === 0;
        if (isEnd) offset++;
        return isEnd;
    }
    if (readUInt32BE() !== 0x70736274) throw new Error("Format Error: Invalid Magic Number");
    if (readUInt8() !== 0xff) throw new Error("Format Error: Magic Number must be followed by 0xff separator");
    const globalMapKeyVals = [];
    const globalKeyIndex = {};
    while(!checkEndOfKeyValPairs()){
        const keyVal = getKeyValue();
        const hexKey = keyVal.key.toString("hex");
        if (globalKeyIndex[hexKey]) throw new Error("Format Error: Keys must be unique for global keymap: key " + hexKey);
        globalKeyIndex[hexKey] = 1;
        globalMapKeyVals.push(keyVal);
    }
    const unsignedTxMaps = globalMapKeyVals.filter((keyVal)=>keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX);
    if (unsignedTxMaps.length !== 1) throw new Error("Format Error: Only one UNSIGNED_TX allowed");
    const unsignedTx = txGetter(unsignedTxMaps[0].value);
    // Get input and output counts to loop the respective fields
    const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();
    const inputKeyVals = [];
    const outputKeyVals = [];
    // Get input fields
    for (const index of tools_1.range(inputCount)){
        const inputKeyIndex = {};
        const input = [];
        while(!checkEndOfKeyValPairs()){
            const keyVal = getKeyValue();
            const hexKey = keyVal.key.toString("hex");
            if (inputKeyIndex[hexKey]) throw new Error("Format Error: Keys must be unique for each input: input index " + index + " key " + hexKey);
            inputKeyIndex[hexKey] = 1;
            input.push(keyVal);
        }
        inputKeyVals.push(input);
    }
    for (const index of tools_1.range(outputCount)){
        const outputKeyIndex = {};
        const output = [];
        while(!checkEndOfKeyValPairs()){
            const keyVal = getKeyValue();
            const hexKey = keyVal.key.toString("hex");
            if (outputKeyIndex[hexKey]) throw new Error("Format Error: Keys must be unique for each output: output index " + index + " key " + hexKey);
            outputKeyIndex[hexKey] = 1;
            output.push(keyVal);
        }
        outputKeyVals.push(output);
    }
    return psbtFromKeyVals(unsignedTx, {
        globalMapKeyVals,
        inputKeyVals,
        outputKeyVals
    });
}
exports.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(type, keyBuf, keyNum) {
    if (!keyBuf.equals(Buffer.from([
        keyNum
    ]))) throw new Error(`Format Error: Invalid ${type} key: ${keyBuf.toString("hex")}`);
}
exports.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(unsignedTx, { globalMapKeyVals, inputKeyVals, outputKeyVals }) {
    // That was easy :-)
    const globalMap = {
        unsignedTx
    };
    let txCount = 0;
    for (const keyVal of globalMapKeyVals)// If a globalMap item needs pubkey, uncomment
    // const pubkey = convert.globals.checkPubkey(keyVal);
    switch(keyVal.key[0]){
        case typeFields_1.GlobalTypes.UNSIGNED_TX:
            checkKeyBuffer("global", keyVal.key, typeFields_1.GlobalTypes.UNSIGNED_TX);
            if (txCount > 0) throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
            txCount++;
            break;
        case typeFields_1.GlobalTypes.GLOBAL_XPUB:
            if (globalMap.globalXpub === undefined) globalMap.globalXpub = [];
            globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));
            break;
        default:
            // This will allow inclusion during serialization.
            if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
            globalMap.unknownKeyVals.push(keyVal);
    }
    // Get input and output counts to loop the respective fields
    const inputCount = inputKeyVals.length;
    const outputCount = outputKeyVals.length;
    const inputs = [];
    const outputs = [];
    // Get input fields
    for (const index of tools_1.range(inputCount)){
        const input = {};
        for (const keyVal of inputKeyVals[index]){
            convert.inputs.checkPubkey(keyVal);
            switch(keyVal.key[0]){
                case typeFields_1.InputTypes.NON_WITNESS_UTXO:
                    checkKeyBuffer("input", keyVal.key, typeFields_1.InputTypes.NON_WITNESS_UTXO);
                    if (input.nonWitnessUtxo !== undefined) throw new Error("Format Error: Input has multiple NON_WITNESS_UTXO");
                    input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);
                    break;
                case typeFields_1.InputTypes.WITNESS_UTXO:
                    checkKeyBuffer("input", keyVal.key, typeFields_1.InputTypes.WITNESS_UTXO);
                    if (input.witnessUtxo !== undefined) throw new Error("Format Error: Input has multiple WITNESS_UTXO");
                    input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);
                    break;
                case typeFields_1.InputTypes.PARTIAL_SIG:
                    if (input.partialSig === undefined) input.partialSig = [];
                    input.partialSig.push(convert.inputs.partialSig.decode(keyVal));
                    break;
                case typeFields_1.InputTypes.SIGHASH_TYPE:
                    checkKeyBuffer("input", keyVal.key, typeFields_1.InputTypes.SIGHASH_TYPE);
                    if (input.sighashType !== undefined) throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
                    input.sighashType = convert.inputs.sighashType.decode(keyVal);
                    break;
                case typeFields_1.InputTypes.REDEEM_SCRIPT:
                    checkKeyBuffer("input", keyVal.key, typeFields_1.InputTypes.REDEEM_SCRIPT);
                    if (input.redeemScript !== undefined) throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
                    input.redeemScript = convert.inputs.redeemScript.decode(keyVal);
                    break;
                case typeFields_1.InputTypes.WITNESS_SCRIPT:
                    checkKeyBuffer("input", keyVal.key, typeFields_1.InputTypes.WITNESS_SCRIPT);
                    if (input.witnessScript !== undefined) throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
                    input.witnessScript = convert.inputs.witnessScript.decode(keyVal);
                    break;
                case typeFields_1.InputTypes.BIP32_DERIVATION:
                    if (input.bip32Derivation === undefined) input.bip32Derivation = [];
                    input.bip32Derivation.push(convert.inputs.bip32Derivation.decode(keyVal));
                    break;
                case typeFields_1.InputTypes.FINAL_SCRIPTSIG:
                    checkKeyBuffer("input", keyVal.key, typeFields_1.InputTypes.FINAL_SCRIPTSIG);
                    input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);
                    break;
                case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:
                    checkKeyBuffer("input", keyVal.key, typeFields_1.InputTypes.FINAL_SCRIPTWITNESS);
                    input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(keyVal);
                    break;
                case typeFields_1.InputTypes.POR_COMMITMENT:
                    checkKeyBuffer("input", keyVal.key, typeFields_1.InputTypes.POR_COMMITMENT);
                    input.porCommitment = convert.inputs.porCommitment.decode(keyVal);
                    break;
                case typeFields_1.InputTypes.TAP_KEY_SIG:
                    checkKeyBuffer("input", keyVal.key, typeFields_1.InputTypes.TAP_KEY_SIG);
                    input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);
                    break;
                case typeFields_1.InputTypes.TAP_SCRIPT_SIG:
                    if (input.tapScriptSig === undefined) input.tapScriptSig = [];
                    input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));
                    break;
                case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:
                    if (input.tapLeafScript === undefined) input.tapLeafScript = [];
                    input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));
                    break;
                case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:
                    if (input.tapBip32Derivation === undefined) input.tapBip32Derivation = [];
                    input.tapBip32Derivation.push(convert.inputs.tapBip32Derivation.decode(keyVal));
                    break;
                case typeFields_1.InputTypes.TAP_INTERNAL_KEY:
                    checkKeyBuffer("input", keyVal.key, typeFields_1.InputTypes.TAP_INTERNAL_KEY);
                    input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);
                    break;
                case typeFields_1.InputTypes.TAP_MERKLE_ROOT:
                    checkKeyBuffer("input", keyVal.key, typeFields_1.InputTypes.TAP_MERKLE_ROOT);
                    input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);
                    break;
                default:
                    // This will allow inclusion during serialization.
                    if (!input.unknownKeyVals) input.unknownKeyVals = [];
                    input.unknownKeyVals.push(keyVal);
            }
        }
        inputs.push(input);
    }
    for (const index of tools_1.range(outputCount)){
        const output = {};
        for (const keyVal of outputKeyVals[index]){
            convert.outputs.checkPubkey(keyVal);
            switch(keyVal.key[0]){
                case typeFields_1.OutputTypes.REDEEM_SCRIPT:
                    checkKeyBuffer("output", keyVal.key, typeFields_1.OutputTypes.REDEEM_SCRIPT);
                    if (output.redeemScript !== undefined) throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
                    output.redeemScript = convert.outputs.redeemScript.decode(keyVal);
                    break;
                case typeFields_1.OutputTypes.WITNESS_SCRIPT:
                    checkKeyBuffer("output", keyVal.key, typeFields_1.OutputTypes.WITNESS_SCRIPT);
                    if (output.witnessScript !== undefined) throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
                    output.witnessScript = convert.outputs.witnessScript.decode(keyVal);
                    break;
                case typeFields_1.OutputTypes.BIP32_DERIVATION:
                    if (output.bip32Derivation === undefined) output.bip32Derivation = [];
                    output.bip32Derivation.push(convert.outputs.bip32Derivation.decode(keyVal));
                    break;
                case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:
                    checkKeyBuffer("output", keyVal.key, typeFields_1.OutputTypes.TAP_INTERNAL_KEY);
                    output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);
                    break;
                case typeFields_1.OutputTypes.TAP_TREE:
                    checkKeyBuffer("output", keyVal.key, typeFields_1.OutputTypes.TAP_TREE);
                    output.tapTree = convert.outputs.tapTree.decode(keyVal);
                    break;
                case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:
                    if (output.tapBip32Derivation === undefined) output.tapBip32Derivation = [];
                    output.tapBip32Derivation.push(convert.outputs.tapBip32Derivation.decode(keyVal));
                    break;
                default:
                    if (!output.unknownKeyVals) output.unknownKeyVals = [];
                    output.unknownKeyVals.push(keyVal);
            }
        }
        outputs.push(output);
    }
    return {
        globalMap,
        inputs,
        outputs
    };
}
exports.psbtFromKeyVals = psbtFromKeyVals;

},{"27cc1123cac1870d":"bwvMq","fa12ea4f9abfc39d":"31Gpb","7ea84d5fdd09890b":"5okq8","a37bcc3f403dd8ac":"1mjPW","ad0cb35bafe0b747":"3089x"}],"31Gpb":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typeFields_1 = require("3522f952cc10bc59");
const globalXpub = require("b8c49967535d9e2c");
const unsignedTx = require("ea7255dafabdaf1");
const finalScriptSig = require("7ad3124c9ecb0a60");
const finalScriptWitness = require("4080dc96df0d6c1c");
const nonWitnessUtxo = require("cc4ef1382415d502");
const partialSig = require("29638b609b34702b");
const porCommitment = require("c3dd17aa1c97cd08");
const sighashType = require("bf80a84ca00bbe5e");
const tapKeySig = require("40417eb6e2e958f9");
const tapLeafScript = require("b3a1ec784d0c3a44");
const tapMerkleRoot = require("e46685aeda0dfc52");
const tapScriptSig = require("e524e22b83fbfdcd");
const witnessUtxo = require("c8f2bf08e888d28");
const tapTree = require("61e72e62c776373b");
const bip32Derivation = require("bb73a45394180c7f");
const checkPubkey = require("ee8df50614281766");
const redeemScript = require("f6b2341107e3e835");
const tapBip32Derivation = require("8fe75b166c11db7a");
const tapInternalKey = require("8115fcf8f8cb57b1");
const witnessScript = require("188279375127d353");
const globals = {
    unsignedTx,
    globalXpub,
    // pass an Array of key bytes that require pubkey beside the key
    checkPubkey: checkPubkey.makeChecker([])
};
exports.globals = globals;
const inputs = {
    nonWitnessUtxo,
    partialSig,
    sighashType,
    finalScriptSig,
    finalScriptWitness,
    porCommitment,
    witnessUtxo,
    bip32Derivation: bip32Derivation.makeConverter(typeFields_1.InputTypes.BIP32_DERIVATION),
    redeemScript: redeemScript.makeConverter(typeFields_1.InputTypes.REDEEM_SCRIPT),
    witnessScript: witnessScript.makeConverter(typeFields_1.InputTypes.WITNESS_SCRIPT),
    checkPubkey: checkPubkey.makeChecker([
        typeFields_1.InputTypes.PARTIAL_SIG,
        typeFields_1.InputTypes.BIP32_DERIVATION
    ]),
    tapKeySig,
    tapScriptSig,
    tapLeafScript,
    tapBip32Derivation: tapBip32Derivation.makeConverter(typeFields_1.InputTypes.TAP_BIP32_DERIVATION),
    tapInternalKey: tapInternalKey.makeConverter(typeFields_1.InputTypes.TAP_INTERNAL_KEY),
    tapMerkleRoot
};
exports.inputs = inputs;
const outputs = {
    bip32Derivation: bip32Derivation.makeConverter(typeFields_1.OutputTypes.BIP32_DERIVATION),
    redeemScript: redeemScript.makeConverter(typeFields_1.OutputTypes.REDEEM_SCRIPT),
    witnessScript: witnessScript.makeConverter(typeFields_1.OutputTypes.WITNESS_SCRIPT),
    checkPubkey: checkPubkey.makeChecker([
        typeFields_1.OutputTypes.BIP32_DERIVATION
    ]),
    tapBip32Derivation: tapBip32Derivation.makeConverter(typeFields_1.OutputTypes.TAP_BIP32_DERIVATION),
    tapTree,
    tapInternalKey: tapInternalKey.makeConverter(typeFields_1.OutputTypes.TAP_INTERNAL_KEY)
};
exports.outputs = outputs;

},{"3522f952cc10bc59":"3089x","b8c49967535d9e2c":"eRxnG","ea7255dafabdaf1":"kPyZn","7ad3124c9ecb0a60":"jXPYu","4080dc96df0d6c1c":"4MksQ","cc4ef1382415d502":"djKIf","29638b609b34702b":"4Eb9z","c3dd17aa1c97cd08":"aRknq","bf80a84ca00bbe5e":"bnHKd","40417eb6e2e958f9":"6koTX","b3a1ec784d0c3a44":"lpl9n","e46685aeda0dfc52":"6kUou","e524e22b83fbfdcd":"3DeoD","c8f2bf08e888d28":"kZrBw","61e72e62c776373b":"bS0Du","bb73a45394180c7f":"257pN","ee8df50614281766":"guzzQ","f6b2341107e3e835":"eO5Wf","8fe75b166c11db7a":"4v2dA","8115fcf8f8cb57b1":"cvCQq","188279375127d353":"9pdcz"}],"3089x":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var GlobalTypes;
(function(GlobalTypes) {
    GlobalTypes[GlobalTypes["UNSIGNED_TX"] = 0] = "UNSIGNED_TX";
    GlobalTypes[GlobalTypes["GLOBAL_XPUB"] = 1] = "GLOBAL_XPUB";
})(GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {}));
exports.GLOBAL_TYPE_NAMES = [
    "unsignedTx",
    "globalXpub"
];
var InputTypes;
(function(InputTypes) {
    InputTypes[InputTypes["NON_WITNESS_UTXO"] = 0] = "NON_WITNESS_UTXO";
    InputTypes[InputTypes["WITNESS_UTXO"] = 1] = "WITNESS_UTXO";
    InputTypes[InputTypes["PARTIAL_SIG"] = 2] = "PARTIAL_SIG";
    InputTypes[InputTypes["SIGHASH_TYPE"] = 3] = "SIGHASH_TYPE";
    InputTypes[InputTypes["REDEEM_SCRIPT"] = 4] = "REDEEM_SCRIPT";
    InputTypes[InputTypes["WITNESS_SCRIPT"] = 5] = "WITNESS_SCRIPT";
    InputTypes[InputTypes["BIP32_DERIVATION"] = 6] = "BIP32_DERIVATION";
    InputTypes[InputTypes["FINAL_SCRIPTSIG"] = 7] = "FINAL_SCRIPTSIG";
    InputTypes[InputTypes["FINAL_SCRIPTWITNESS"] = 8] = "FINAL_SCRIPTWITNESS";
    InputTypes[InputTypes["POR_COMMITMENT"] = 9] = "POR_COMMITMENT";
    InputTypes[InputTypes["TAP_KEY_SIG"] = 19] = "TAP_KEY_SIG";
    InputTypes[InputTypes["TAP_SCRIPT_SIG"] = 20] = "TAP_SCRIPT_SIG";
    InputTypes[InputTypes["TAP_LEAF_SCRIPT"] = 21] = "TAP_LEAF_SCRIPT";
    InputTypes[InputTypes["TAP_BIP32_DERIVATION"] = 22] = "TAP_BIP32_DERIVATION";
    InputTypes[InputTypes["TAP_INTERNAL_KEY"] = 23] = "TAP_INTERNAL_KEY";
    InputTypes[InputTypes["TAP_MERKLE_ROOT"] = 24] = "TAP_MERKLE_ROOT";
})(InputTypes = exports.InputTypes || (exports.InputTypes = {}));
exports.INPUT_TYPE_NAMES = [
    "nonWitnessUtxo",
    "witnessUtxo",
    "partialSig",
    "sighashType",
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "finalScriptSig",
    "finalScriptWitness",
    "porCommitment",
    "tapKeySig",
    "tapScriptSig",
    "tapLeafScript",
    "tapBip32Derivation",
    "tapInternalKey",
    "tapMerkleRoot"
];
var OutputTypes;
(function(OutputTypes) {
    OutputTypes[OutputTypes["REDEEM_SCRIPT"] = 0] = "REDEEM_SCRIPT";
    OutputTypes[OutputTypes["WITNESS_SCRIPT"] = 1] = "WITNESS_SCRIPT";
    OutputTypes[OutputTypes["BIP32_DERIVATION"] = 2] = "BIP32_DERIVATION";
    OutputTypes[OutputTypes["TAP_INTERNAL_KEY"] = 5] = "TAP_INTERNAL_KEY";
    OutputTypes[OutputTypes["TAP_TREE"] = 6] = "TAP_TREE";
    OutputTypes[OutputTypes["TAP_BIP32_DERIVATION"] = 7] = "TAP_BIP32_DERIVATION";
})(OutputTypes = exports.OutputTypes || (exports.OutputTypes = {}));
exports.OUTPUT_TYPE_NAMES = [
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "tapInternalKey",
    "tapTree",
    "tapBip32Derivation"
];

},{}],"eRxnG":[function(require,module,exports) {
var Buffer = require("a2ab83522979293b").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typeFields_1 = require("72cdd17df1cb35db");
const range = (n)=>[
        ...Array(n).keys()
    ];
function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) throw new Error("Decode Error: could not decode globalXpub with key 0x" + keyVal.key.toString("hex"));
    if (keyVal.key.length !== 79 || ![
        2,
        3
    ].includes(keyVal.key[46])) throw new Error("Decode Error: globalXpub has invalid extended pubkey in key 0x" + keyVal.key.toString("hex"));
    if (keyVal.value.length / 4 % 1 !== 0) throw new Error("Decode Error: Global GLOBAL_XPUB value length should be multiple of 4");
    const extendedPubkey = keyVal.key.slice(1);
    const data = {
        masterFingerprint: keyVal.value.slice(0, 4),
        extendedPubkey,
        path: "m"
    };
    for (const i of range(keyVal.value.length / 4 - 1)){
        const val = keyVal.value.readUInt32LE(i * 4 + 4);
        const isHard = !!(val & 0x80000000);
        const idx = val & 0x7fffffff;
        data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
    }
    return data;
}
exports.decode = decode;
function encode(data) {
    const head = Buffer.from([
        typeFields_1.GlobalTypes.GLOBAL_XPUB
    ]);
    const key = Buffer.concat([
        head,
        data.extendedPubkey
    ]);
    const splitPath = data.path.split("/");
    const value = Buffer.allocUnsafe(splitPath.length * 4);
    data.masterFingerprint.copy(value, 0);
    let offset = 4;
    splitPath.slice(1).forEach((level)=>{
        const isHard = level.slice(-1) === "'";
        let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
        if (isHard) num += 0x80000000;
        value.writeUInt32LE(num, offset);
        offset += 4;
    });
    return {
        key,
        value
    };
}
exports.encode = encode;
exports.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
function check(data) {
    const epk = data.extendedPubkey;
    const mfp = data.masterFingerprint;
    const p = data.path;
    return Buffer.isBuffer(epk) && epk.length === 78 && [
        2,
        3
    ].indexOf(epk[45]) > -1 && Buffer.isBuffer(mfp) && mfp.length === 4 && typeof p === "string" && !!p.match(/^m(\/\d+'?)*$/);
}
exports.check = check;
function canAddToArray(array, item, dupeSet) {
    const dupeString = item.extendedPubkey.toString("hex");
    if (dupeSet.has(dupeString)) return false;
    dupeSet.add(dupeString);
    return array.filter((v)=>v.extendedPubkey.equals(item.extendedPubkey)).length === 0;
}
exports.canAddToArray = canAddToArray;

},{"a2ab83522979293b":"bwvMq","72cdd17df1cb35db":"3089x"}],"kPyZn":[function(require,module,exports) {
var Buffer = require("a94cdebb019e5fea").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typeFields_1 = require("c321222a52320541");
function encode(data) {
    return {
        key: Buffer.from([
            typeFields_1.GlobalTypes.UNSIGNED_TX
        ]),
        value: data.toBuffer()
    };
}
exports.encode = encode;

},{"a94cdebb019e5fea":"bwvMq","c321222a52320541":"3089x"}],"jXPYu":[function(require,module,exports) {
var Buffer = require("8e9f5dee508c45ae").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typeFields_1 = require("68548f774361c4f7");
function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) throw new Error("Decode Error: could not decode finalScriptSig with key 0x" + keyVal.key.toString("hex"));
    return keyVal.value;
}
exports.decode = decode;
function encode(data) {
    const key = Buffer.from([
        typeFields_1.InputTypes.FINAL_SCRIPTSIG
    ]);
    return {
        key,
        value: data
    };
}
exports.encode = encode;
exports.expected = "Buffer";
function check(data) {
    return Buffer.isBuffer(data);
}
exports.check = check;
function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.finalScriptSig === undefined;
}
exports.canAdd = canAdd;

},{"8e9f5dee508c45ae":"bwvMq","68548f774361c4f7":"3089x"}],"4MksQ":[function(require,module,exports) {
var Buffer = require("f31e1b14ccb200e7").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typeFields_1 = require("845fd5f9f0a63745");
function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) throw new Error("Decode Error: could not decode finalScriptWitness with key 0x" + keyVal.key.toString("hex"));
    return keyVal.value;
}
exports.decode = decode;
function encode(data) {
    const key = Buffer.from([
        typeFields_1.InputTypes.FINAL_SCRIPTWITNESS
    ]);
    return {
        key,
        value: data
    };
}
exports.encode = encode;
exports.expected = "Buffer";
function check(data) {
    return Buffer.isBuffer(data);
}
exports.check = check;
function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.finalScriptWitness === undefined;
}
exports.canAdd = canAdd;

},{"f31e1b14ccb200e7":"bwvMq","845fd5f9f0a63745":"3089x"}],"djKIf":[function(require,module,exports) {
var Buffer = require("7661f74626de43ee").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typeFields_1 = require("4b725b965390e6ad");
function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) throw new Error("Decode Error: could not decode nonWitnessUtxo with key 0x" + keyVal.key.toString("hex"));
    return keyVal.value;
}
exports.decode = decode;
function encode(data) {
    return {
        key: Buffer.from([
            typeFields_1.InputTypes.NON_WITNESS_UTXO
        ]),
        value: data
    };
}
exports.encode = encode;
exports.expected = "Buffer";
function check(data) {
    return Buffer.isBuffer(data);
}
exports.check = check;
function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.nonWitnessUtxo === undefined;
}
exports.canAdd = canAdd;

},{"7661f74626de43ee":"bwvMq","4b725b965390e6ad":"3089x"}],"4Eb9z":[function(require,module,exports) {
var Buffer = require("ab65f4cb1a43027e").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typeFields_1 = require("2319fc790acc3089");
function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) throw new Error("Decode Error: could not decode partialSig with key 0x" + keyVal.key.toString("hex"));
    if (!(keyVal.key.length === 34 || keyVal.key.length === 66) || ![
        2,
        3,
        4
    ].includes(keyVal.key[1])) throw new Error("Decode Error: partialSig has invalid pubkey in key 0x" + keyVal.key.toString("hex"));
    const pubkey = keyVal.key.slice(1);
    return {
        pubkey,
        signature: keyVal.value
    };
}
exports.decode = decode;
function encode(pSig) {
    const head = Buffer.from([
        typeFields_1.InputTypes.PARTIAL_SIG
    ]);
    return {
        key: Buffer.concat([
            head,
            pSig.pubkey
        ]),
        value: pSig.signature
    };
}
exports.encode = encode;
exports.expected = "{ pubkey: Buffer; signature: Buffer; }";
function check(data) {
    return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.signature) && [
        33,
        65
    ].includes(data.pubkey.length) && [
        2,
        3,
        4
    ].includes(data.pubkey[0]) && isDerSigWithSighash(data.signature);
}
exports.check = check;
function isDerSigWithSighash(buf) {
    if (!Buffer.isBuffer(buf) || buf.length < 9) return false;
    if (buf[0] !== 0x30) return false;
    if (buf.length !== buf[1] + 3) return false;
    if (buf[2] !== 0x02) return false;
    const rLen = buf[3];
    if (rLen > 33 || rLen < 1) return false;
    if (buf[3 + rLen + 1] !== 0x02) return false;
    const sLen = buf[3 + rLen + 2];
    if (sLen > 33 || sLen < 1) return false;
    if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;
    return true;
}
function canAddToArray(array, item, dupeSet) {
    const dupeString = item.pubkey.toString("hex");
    if (dupeSet.has(dupeString)) return false;
    dupeSet.add(dupeString);
    return array.filter((v)=>v.pubkey.equals(item.pubkey)).length === 0;
}
exports.canAddToArray = canAddToArray;

},{"ab65f4cb1a43027e":"bwvMq","2319fc790acc3089":"3089x"}],"aRknq":[function(require,module,exports) {
var Buffer = require("d31ec771dff282e9").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typeFields_1 = require("719ea9236a680ec");
function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) throw new Error("Decode Error: could not decode porCommitment with key 0x" + keyVal.key.toString("hex"));
    return keyVal.value.toString("utf8");
}
exports.decode = decode;
function encode(data) {
    const key = Buffer.from([
        typeFields_1.InputTypes.POR_COMMITMENT
    ]);
    return {
        key,
        value: Buffer.from(data, "utf8")
    };
}
exports.encode = encode;
exports.expected = "string";
function check(data) {
    return typeof data === "string";
}
exports.check = check;
function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.porCommitment === undefined;
}
exports.canAdd = canAdd;

},{"d31ec771dff282e9":"bwvMq","719ea9236a680ec":"3089x"}],"bnHKd":[function(require,module,exports) {
var Buffer = require("96d9b72362899a80").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typeFields_1 = require("280e64761d0aef24");
function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) throw new Error("Decode Error: could not decode sighashType with key 0x" + keyVal.key.toString("hex"));
    return keyVal.value.readUInt32LE(0);
}
exports.decode = decode;
function encode(data) {
    const key = Buffer.from([
        typeFields_1.InputTypes.SIGHASH_TYPE
    ]);
    const value = Buffer.allocUnsafe(4);
    value.writeUInt32LE(data, 0);
    return {
        key,
        value
    };
}
exports.encode = encode;
exports.expected = "number";
function check(data) {
    return typeof data === "number";
}
exports.check = check;
function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.sighashType === undefined;
}
exports.canAdd = canAdd;

},{"96d9b72362899a80":"bwvMq","280e64761d0aef24":"3089x"}],"6koTX":[function(require,module,exports) {
var Buffer = require("abeae0f61abbe7e4").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typeFields_1 = require("4ef7e0bcad67ca99");
function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG || keyVal.key.length !== 1) throw new Error("Decode Error: could not decode tapKeySig with key 0x" + keyVal.key.toString("hex"));
    if (!check(keyVal.value)) throw new Error("Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature");
    return keyVal.value;
}
exports.decode = decode;
function encode(value) {
    const key = Buffer.from([
        typeFields_1.InputTypes.TAP_KEY_SIG
    ]);
    return {
        key,
        value
    };
}
exports.encode = encode;
exports.expected = "Buffer";
function check(data) {
    return Buffer.isBuffer(data) && (data.length === 64 || data.length === 65);
}
exports.check = check;
function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.tapKeySig === undefined;
}
exports.canAdd = canAdd;

},{"abeae0f61abbe7e4":"bwvMq","4ef7e0bcad67ca99":"3089x"}],"lpl9n":[function(require,module,exports) {
var Buffer = require("143e5785a75c31f4").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typeFields_1 = require("c9279336d3a74745");
function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) throw new Error("Decode Error: could not decode tapLeafScript with key 0x" + keyVal.key.toString("hex"));
    if ((keyVal.key.length - 2) % 32 !== 0) throw new Error("Decode Error: tapLeafScript has invalid control block in key 0x" + keyVal.key.toString("hex"));
    const leafVersion = keyVal.value[keyVal.value.length - 1];
    if ((keyVal.key[1] & 0xfe) !== leafVersion) throw new Error("Decode Error: tapLeafScript bad leaf version in key 0x" + keyVal.key.toString("hex"));
    const script = keyVal.value.slice(0, -1);
    const controlBlock = keyVal.key.slice(1);
    return {
        controlBlock,
        script,
        leafVersion
    };
}
exports.decode = decode;
function encode(tScript) {
    const head = Buffer.from([
        typeFields_1.InputTypes.TAP_LEAF_SCRIPT
    ]);
    const verBuf = Buffer.from([
        tScript.leafVersion
    ]);
    return {
        key: Buffer.concat([
            head,
            tScript.controlBlock
        ]),
        value: Buffer.concat([
            tScript.script,
            verBuf
        ])
    };
}
exports.encode = encode;
exports.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
function check(data) {
    return Buffer.isBuffer(data.controlBlock) && (data.controlBlock.length - 1) % 32 === 0 && (data.controlBlock[0] & 0xfe) === data.leafVersion && Buffer.isBuffer(data.script);
}
exports.check = check;
function canAddToArray(array, item, dupeSet) {
    const dupeString = item.controlBlock.toString("hex");
    if (dupeSet.has(dupeString)) return false;
    dupeSet.add(dupeString);
    return array.filter((v)=>v.controlBlock.equals(item.controlBlock)).length === 0;
}
exports.canAddToArray = canAddToArray;

},{"143e5785a75c31f4":"bwvMq","c9279336d3a74745":"3089x"}],"6kUou":[function(require,module,exports) {
var Buffer = require("8589f69570a4bdac").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typeFields_1 = require("2cae3356ba7a8de7");
function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT || keyVal.key.length !== 1) throw new Error("Decode Error: could not decode tapMerkleRoot with key 0x" + keyVal.key.toString("hex"));
    if (!check(keyVal.value)) throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
    return keyVal.value;
}
exports.decode = decode;
function encode(value) {
    const key = Buffer.from([
        typeFields_1.InputTypes.TAP_MERKLE_ROOT
    ]);
    return {
        key,
        value
    };
}
exports.encode = encode;
exports.expected = "Buffer";
function check(data) {
    return Buffer.isBuffer(data) && data.length === 32;
}
exports.check = check;
function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.tapMerkleRoot === undefined;
}
exports.canAdd = canAdd;

},{"8589f69570a4bdac":"bwvMq","2cae3356ba7a8de7":"3089x"}],"3DeoD":[function(require,module,exports) {
var Buffer = require("7f168173e8d729f3").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typeFields_1 = require("4b0303628738a9bb");
function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) throw new Error("Decode Error: could not decode tapScriptSig with key 0x" + keyVal.key.toString("hex"));
    if (keyVal.key.length !== 65) throw new Error("Decode Error: tapScriptSig has invalid key 0x" + keyVal.key.toString("hex"));
    if (keyVal.value.length !== 64 && keyVal.value.length !== 65) throw new Error("Decode Error: tapScriptSig has invalid signature in key 0x" + keyVal.key.toString("hex"));
    const pubkey = keyVal.key.slice(1, 33);
    const leafHash = keyVal.key.slice(33);
    return {
        pubkey,
        leafHash,
        signature: keyVal.value
    };
}
exports.decode = decode;
function encode(tSig) {
    const head = Buffer.from([
        typeFields_1.InputTypes.TAP_SCRIPT_SIG
    ]);
    return {
        key: Buffer.concat([
            head,
            tSig.pubkey,
            tSig.leafHash
        ]),
        value: tSig.signature
    };
}
exports.encode = encode;
exports.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
function check(data) {
    return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.leafHash) && Buffer.isBuffer(data.signature) && data.pubkey.length === 32 && data.leafHash.length === 32 && (data.signature.length === 64 || data.signature.length === 65);
}
exports.check = check;
function canAddToArray(array, item, dupeSet) {
    const dupeString = item.pubkey.toString("hex") + item.leafHash.toString("hex");
    if (dupeSet.has(dupeString)) return false;
    dupeSet.add(dupeString);
    return array.filter((v)=>v.pubkey.equals(item.pubkey) && v.leafHash.equals(item.leafHash)).length === 0;
}
exports.canAddToArray = canAddToArray;

},{"7f168173e8d729f3":"bwvMq","4b0303628738a9bb":"3089x"}],"kZrBw":[function(require,module,exports) {
var Buffer = require("a6e6247f8794a6bd").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typeFields_1 = require("8a18eb38147e221e");
const tools_1 = require("1dcac9ee5df22d54");
const varuint = require("2915bb7f19f5fe46");
function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) throw new Error("Decode Error: could not decode witnessUtxo with key 0x" + keyVal.key.toString("hex"));
    const value = tools_1.readUInt64LE(keyVal.value, 0);
    let _offset = 8;
    const scriptLen = varuint.decode(keyVal.value, _offset);
    _offset += varuint.encodingLength(scriptLen);
    const script = keyVal.value.slice(_offset);
    if (script.length !== scriptLen) throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
    return {
        script,
        value
    };
}
exports.decode = decode;
function encode(data) {
    const { script, value } = data;
    const varintLen = varuint.encodingLength(script.length);
    const result = Buffer.allocUnsafe(8 + varintLen + script.length);
    tools_1.writeUInt64LE(result, value, 0);
    varuint.encode(script.length, result, 8);
    script.copy(result, 8 + varintLen);
    return {
        key: Buffer.from([
            typeFields_1.InputTypes.WITNESS_UTXO
        ]),
        value: result
    };
}
exports.encode = encode;
exports.expected = "{ script: Buffer; value: number; }";
function check(data) {
    return Buffer.isBuffer(data.script) && typeof data.value === "number";
}
exports.check = check;
function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.witnessUtxo === undefined;
}
exports.canAdd = canAdd;

},{"a6e6247f8794a6bd":"bwvMq","8a18eb38147e221e":"3089x","1dcac9ee5df22d54":"5okq8","2915bb7f19f5fe46":"1mjPW"}],"5okq8":[function(require,module,exports) {
var Buffer = require("6c809102e8f63b72").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const varuint = require("da35a02d1d632300");
exports.range = (n)=>[
        ...Array(n).keys()
    ];
function reverseBuffer(buffer) {
    if (buffer.length < 1) return buffer;
    let j = buffer.length - 1;
    let tmp = 0;
    for(let i = 0; i < buffer.length / 2; i++){
        tmp = buffer[i];
        buffer[i] = buffer[j];
        buffer[j] = tmp;
        j--;
    }
    return buffer;
}
exports.reverseBuffer = reverseBuffer;
function keyValsToBuffer(keyVals) {
    const buffers = keyVals.map(keyValToBuffer);
    buffers.push(Buffer.from([
        0
    ]));
    return Buffer.concat(buffers);
}
exports.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(keyVal) {
    const keyLen = keyVal.key.length;
    const valLen = keyVal.value.length;
    const keyVarIntLen = varuint.encodingLength(keyLen);
    const valVarIntLen = varuint.encodingLength(valLen);
    const buffer = Buffer.allocUnsafe(keyVarIntLen + keyLen + valVarIntLen + valLen);
    varuint.encode(keyLen, buffer, 0);
    keyVal.key.copy(buffer, keyVarIntLen);
    varuint.encode(valLen, buffer, keyVarIntLen + keyLen);
    keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);
    return buffer;
}
exports.keyValToBuffer = keyValToBuffer;
// https://github.com/feross/buffer/blob/master/index.js#L1127
function verifuint(value, max) {
    if (typeof value !== "number") throw new Error("cannot write a non-number as a number");
    if (value < 0) throw new Error("specified a negative value for writing an unsigned value");
    if (value > max) throw new Error("RangeError: value out of range");
    if (Math.floor(value) !== value) throw new Error("value has a fractional component");
}
function readUInt64LE(buffer, offset) {
    const a = buffer.readUInt32LE(offset);
    let b = buffer.readUInt32LE(offset + 4);
    b *= 0x100000000;
    verifuint(b + a, 0x001fffffffffffff);
    return b + a;
}
exports.readUInt64LE = readUInt64LE;
function writeUInt64LE(buffer, value, offset) {
    verifuint(value, 0x001fffffffffffff);
    buffer.writeInt32LE(value & -1, offset);
    buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
    return offset + 8;
}
exports.writeUInt64LE = writeUInt64LE;

},{"6c809102e8f63b72":"bwvMq","da35a02d1d632300":"1mjPW"}],"1mjPW":[function(require,module,exports) {
var Buffer = require("dbbbaae54d1fc4b3").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
// Number.MAX_SAFE_INTEGER
const MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(n) {
    if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError("value out of range");
}
function encode(_number, buffer, offset) {
    checkUInt53(_number);
    if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));
    if (!Buffer.isBuffer(buffer)) throw new TypeError("buffer must be a Buffer instance");
    if (!offset) offset = 0;
    // 8 bit
    if (_number < 0xfd) {
        buffer.writeUInt8(_number, offset);
        Object.assign(encode, {
            bytes: 1
        });
    // 16 bit
    } else if (_number <= 0xffff) {
        buffer.writeUInt8(0xfd, offset);
        buffer.writeUInt16LE(_number, offset + 1);
        Object.assign(encode, {
            bytes: 3
        });
    // 32 bit
    } else if (_number <= 0xffffffff) {
        buffer.writeUInt8(0xfe, offset);
        buffer.writeUInt32LE(_number, offset + 1);
        Object.assign(encode, {
            bytes: 5
        });
    // 64 bit
    } else {
        buffer.writeUInt8(0xff, offset);
        buffer.writeUInt32LE(_number >>> 0, offset + 1);
        buffer.writeUInt32LE(_number / 0x100000000 | 0, offset + 5);
        Object.assign(encode, {
            bytes: 9
        });
    }
    return buffer;
}
exports.encode = encode;
function decode(buffer, offset) {
    if (!Buffer.isBuffer(buffer)) throw new TypeError("buffer must be a Buffer instance");
    if (!offset) offset = 0;
    const first = buffer.readUInt8(offset);
    // 8 bit
    if (first < 0xfd) {
        Object.assign(decode, {
            bytes: 1
        });
        return first;
    // 16 bit
    } else if (first === 0xfd) {
        Object.assign(decode, {
            bytes: 3
        });
        return buffer.readUInt16LE(offset + 1);
    // 32 bit
    } else if (first === 0xfe) {
        Object.assign(decode, {
            bytes: 5
        });
        return buffer.readUInt32LE(offset + 1);
    // 64 bit
    } else {
        Object.assign(decode, {
            bytes: 9
        });
        const lo = buffer.readUInt32LE(offset + 1);
        const hi = buffer.readUInt32LE(offset + 5);
        const _number = hi * 0x0100000000 + lo;
        checkUInt53(_number);
        return _number;
    }
}
exports.decode = decode;
function encodingLength(_number) {
    checkUInt53(_number);
    return _number < 0xfd ? 1 : _number <= 0xffff ? 3 : _number <= 0xffffffff ? 5 : 9;
}
exports.encodingLength = encodingLength;

},{"dbbbaae54d1fc4b3":"bwvMq"}],"bS0Du":[function(require,module,exports) {
var Buffer = require("408bf6f64e6bc6e").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typeFields_1 = require("4a68f387b600a601");
const varuint = require("11be3cac4fccd00e");
function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE || keyVal.key.length !== 1) throw new Error("Decode Error: could not decode tapTree with key 0x" + keyVal.key.toString("hex"));
    let _offset = 0;
    const data = [];
    while(_offset < keyVal.value.length){
        const depth = keyVal.value[_offset++];
        const leafVersion = keyVal.value[_offset++];
        const scriptLen = varuint.decode(keyVal.value, _offset);
        _offset += varuint.encodingLength(scriptLen);
        data.push({
            depth,
            leafVersion,
            script: keyVal.value.slice(_offset, _offset + scriptLen)
        });
        _offset += scriptLen;
    }
    return {
        leaves: data
    };
}
exports.decode = decode;
function encode(tree) {
    const key = Buffer.from([
        typeFields_1.OutputTypes.TAP_TREE
    ]);
    const bufs = [].concat(...tree.leaves.map((tapLeaf)=>[
            Buffer.of(tapLeaf.depth, tapLeaf.leafVersion),
            varuint.encode(tapLeaf.script.length),
            tapLeaf.script
        ]));
    return {
        key,
        value: Buffer.concat(bufs)
    };
}
exports.encode = encode;
exports.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
function check(data) {
    return Array.isArray(data.leaves) && data.leaves.every((tapLeaf)=>tapLeaf.depth >= 0 && tapLeaf.depth <= 128 && (tapLeaf.leafVersion & 0xfe) === tapLeaf.leafVersion && Buffer.isBuffer(tapLeaf.script));
}
exports.check = check;
function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.tapTree === undefined;
}
exports.canAdd = canAdd;

},{"408bf6f64e6bc6e":"bwvMq","4a68f387b600a601":"3089x","11be3cac4fccd00e":"1mjPW"}],"257pN":[function(require,module,exports) {
var Buffer = require("8d84916f39fa78a2").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const range = (n)=>[
        ...Array(n).keys()
    ];
const isValidDERKey = (pubkey)=>pubkey.length === 33 && [
        2,
        3
    ].includes(pubkey[0]) || pubkey.length === 65 && 4 === pubkey[0];
function makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {
    function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) throw new Error("Decode Error: could not decode bip32Derivation with key 0x" + keyVal.key.toString("hex"));
        const pubkey = keyVal.key.slice(1);
        if (!isValidPubkey(pubkey)) throw new Error("Decode Error: bip32Derivation has invalid pubkey in key 0x" + keyVal.key.toString("hex"));
        if (keyVal.value.length / 4 % 1 !== 0) throw new Error("Decode Error: Input BIP32_DERIVATION value length should be multiple of 4");
        const data = {
            masterFingerprint: keyVal.value.slice(0, 4),
            pubkey,
            path: "m"
        };
        for (const i of range(keyVal.value.length / 4 - 1)){
            const val = keyVal.value.readUInt32LE(i * 4 + 4);
            const isHard = !!(val & 0x80000000);
            const idx = val & 0x7fffffff;
            data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
        }
        return data;
    }
    function encode(data) {
        const head = Buffer.from([
            TYPE_BYTE
        ]);
        const key = Buffer.concat([
            head,
            data.pubkey
        ]);
        const splitPath = data.path.split("/");
        const value = Buffer.allocUnsafe(splitPath.length * 4);
        data.masterFingerprint.copy(value, 0);
        let offset = 4;
        splitPath.slice(1).forEach((level)=>{
            const isHard = level.slice(-1) === "'";
            let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
            if (isHard) num += 0x80000000;
            value.writeUInt32LE(num, offset);
            offset += 4;
        });
        return {
            key,
            value
        };
    }
    const expected = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
    function check(data) {
        return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.masterFingerprint) && typeof data.path === "string" && isValidPubkey(data.pubkey) && data.masterFingerprint.length === 4;
    }
    function canAddToArray(array, item, dupeSet) {
        const dupeString = item.pubkey.toString("hex");
        if (dupeSet.has(dupeString)) return false;
        dupeSet.add(dupeString);
        return array.filter((v)=>v.pubkey.equals(item.pubkey)).length === 0;
    }
    return {
        decode,
        encode,
        check,
        expected,
        canAddToArray
    };
}
exports.makeConverter = makeConverter;

},{"8d84916f39fa78a2":"bwvMq"}],"guzzQ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function makeChecker(pubkeyTypes) {
    return checkPubkey;
    function checkPubkey(keyVal) {
        let pubkey;
        if (pubkeyTypes.includes(keyVal.key[0])) {
            pubkey = keyVal.key.slice(1);
            if (!(pubkey.length === 33 || pubkey.length === 65) || ![
                2,
                3,
                4
            ].includes(pubkey[0])) throw new Error("Format Error: invalid pubkey in key 0x" + keyVal.key.toString("hex"));
        }
        return pubkey;
    }
}
exports.makeChecker = makeChecker;

},{}],"eO5Wf":[function(require,module,exports) {
var Buffer = require("c00a0cff7132dc57").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function makeConverter(TYPE_BYTE) {
    function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) throw new Error("Decode Error: could not decode redeemScript with key 0x" + keyVal.key.toString("hex"));
        return keyVal.value;
    }
    function encode(data) {
        const key = Buffer.from([
            TYPE_BYTE
        ]);
        return {
            key,
            value: data
        };
    }
    const expected = "Buffer";
    function check(data) {
        return Buffer.isBuffer(data);
    }
    function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.redeemScript === undefined;
    }
    return {
        decode,
        encode,
        check,
        expected,
        canAdd
    };
}
exports.makeConverter = makeConverter;

},{"c00a0cff7132dc57":"bwvMq"}],"4v2dA":[function(require,module,exports) {
var Buffer = require("219254e58bfcd582").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const varuint = require("fa8868fa49cf66d6");
const bip32Derivation = require("60a8dc54cbe5d3f2");
const isValidBIP340Key = (pubkey)=>pubkey.length === 32;
function makeConverter(TYPE_BYTE) {
    const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);
    function decode(keyVal) {
        const nHashes = varuint.decode(keyVal.value);
        const nHashesLen = varuint.encodingLength(nHashes);
        const base = parent.decode({
            key: keyVal.key,
            value: keyVal.value.slice(nHashesLen + nHashes * 32)
        });
        const leafHashes = new Array(nHashes);
        for(let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32)leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);
        return Object.assign({}, base, {
            leafHashes
        });
    }
    function encode(data) {
        const base = parent.encode(data);
        const nHashesLen = varuint.encodingLength(data.leafHashes.length);
        const nHashesBuf = Buffer.allocUnsafe(nHashesLen);
        varuint.encode(data.leafHashes.length, nHashesBuf);
        const value = Buffer.concat([
            nHashesBuf,
            ...data.leafHashes,
            base.value
        ]);
        return Object.assign({}, base, {
            value
        });
    }
    const expected = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
    function check(data) {
        return Array.isArray(data.leafHashes) && data.leafHashes.every((leafHash)=>Buffer.isBuffer(leafHash) && leafHash.length === 32) && parent.check(data);
    }
    return {
        decode,
        encode,
        check,
        expected,
        canAddToArray: parent.canAddToArray
    };
}
exports.makeConverter = makeConverter;

},{"219254e58bfcd582":"bwvMq","fa8868fa49cf66d6":"1mjPW","60a8dc54cbe5d3f2":"257pN"}],"cvCQq":[function(require,module,exports) {
var Buffer = require("942bce34a8710cfc").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function makeConverter(TYPE_BYTE) {
    function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) throw new Error("Decode Error: could not decode tapInternalKey with key 0x" + keyVal.key.toString("hex"));
        if (keyVal.value.length !== 32) throw new Error("Decode Error: tapInternalKey not a 32-byte x-only pubkey");
        return keyVal.value;
    }
    function encode(value) {
        const key = Buffer.from([
            TYPE_BYTE
        ]);
        return {
            key,
            value
        };
    }
    const expected = "Buffer";
    function check(data) {
        return Buffer.isBuffer(data) && data.length === 32;
    }
    function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.tapInternalKey === undefined;
    }
    return {
        decode,
        encode,
        check,
        expected,
        canAdd
    };
}
exports.makeConverter = makeConverter;

},{"942bce34a8710cfc":"bwvMq"}],"9pdcz":[function(require,module,exports) {
var Buffer = require("e2201fd1a4ddc4bd").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function makeConverter(TYPE_BYTE) {
    function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) throw new Error("Decode Error: could not decode witnessScript with key 0x" + keyVal.key.toString("hex"));
        return keyVal.value;
    }
    function encode(data) {
        const key = Buffer.from([
            TYPE_BYTE
        ]);
        return {
            key,
            value: data
        };
    }
    const expected = "Buffer";
    function check(data) {
        return Buffer.isBuffer(data);
    }
    function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.witnessScript === undefined;
    }
    return {
        decode,
        encode,
        check,
        expected,
        canAdd
    };
}
exports.makeConverter = makeConverter;

},{"e2201fd1a4ddc4bd":"bwvMq"}],"jUzwk":[function(require,module,exports) {
var Buffer = require("92b568f299bbc988").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const convert = require("2ed8aa87e4b5e66c");
const tools_1 = require("22a4c89c36c959c9");
function psbtToBuffer({ globalMap, inputs, outputs }) {
    const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({
        globalMap,
        inputs,
        outputs
    });
    const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);
    const keyValsOrEmptyToBuffer = (keyVals)=>keyVals.length === 0 ? [
            Buffer.from([
                0
            ])
        ] : keyVals.map(tools_1.keyValsToBuffer);
    const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
    const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
    const header = Buffer.allocUnsafe(5);
    header.writeUIntBE(0x70736274ff, 0, 5);
    return Buffer.concat([
        header,
        globalBuffer
    ].concat(inputBuffers, outputBuffers));
}
exports.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (a, b)=>{
    return a.key.compare(b.key);
};
function keyValsFromMap(keyValMap, converterFactory) {
    const keyHexSet = new Set();
    const keyVals = Object.entries(keyValMap).reduce((result, [key, value])=>{
        if (key === "unknownKeyVals") return result;
        // We are checking for undefined anyways. So ignore TS error
        // @ts-ignore
        const converter = converterFactory[key];
        if (converter === undefined) return result;
        const encodedKeyVals = (Array.isArray(value) ? value : [
            value
        ]).map(converter.encode);
        const keyHexes = encodedKeyVals.map((kv)=>kv.key.toString("hex"));
        keyHexes.forEach((hex)=>{
            if (keyHexSet.has(hex)) throw new Error("Serialize Error: Duplicate key: " + hex);
            keyHexSet.add(hex);
        });
        return result.concat(encodedKeyVals);
    }, []);
    // Get other keyVals that have not yet been gotten
    const otherKeyVals = keyValMap.unknownKeyVals ? keyValMap.unknownKeyVals.filter((keyVal)=>{
        return !keyHexSet.has(keyVal.key.toString("hex"));
    }) : [];
    return keyVals.concat(otherKeyVals).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap, inputs, outputs }) {
    // First parse the global keyVals
    // Get any extra keyvals to pass along
    return {
        globalKeyVals: keyValsFromMap(globalMap, convert.globals),
        inputKeyVals: inputs.map((i)=>keyValsFromMap(i, convert.inputs)),
        outputKeyVals: outputs.map((o)=>keyValsFromMap(o, convert.outputs))
    };
}
exports.psbtToKeyVals = psbtToKeyVals;

},{"92b568f299bbc988":"bwvMq","2ed8aa87e4b5e66c":"31Gpb","22a4c89c36c959c9":"5okq8"}],"f992a":[function(require,module,exports) {
var Buffer = require("2833a8b71f7b13ec").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const converter = require("2bdc21d0bef9f86d");
function checkForInput(inputs, inputIndex) {
    const input = inputs[inputIndex];
    if (input === undefined) throw new Error(`No input #${inputIndex}`);
    return input;
}
exports.checkForInput = checkForInput;
function checkForOutput(outputs, outputIndex) {
    const output = outputs[outputIndex];
    if (output === undefined) throw new Error(`No output #${outputIndex}`);
    return output;
}
exports.checkForOutput = checkForOutput;
function checkHasKey(checkKeyVal, keyVals, enumLength) {
    if (checkKeyVal.key[0] < enumLength) throw new Error(`Use the method for your specific key instead of addUnknownKeyVal*`);
    if (keyVals && keyVals.filter((kv)=>kv.key.equals(checkKeyVal.key)).length !== 0) throw new Error(`Duplicate Key: ${checkKeyVal.key.toString("hex")}`);
}
exports.checkHasKey = checkHasKey;
function getEnumLength(myenum) {
    let count = 0;
    Object.keys(myenum).forEach((val)=>{
        if (Number(isNaN(Number(val)))) count++;
    });
    return count;
}
exports.getEnumLength = getEnumLength;
function inputCheckUncleanFinalized(inputIndex, input) {
    let result = false;
    if (input.nonWitnessUtxo || input.witnessUtxo) {
        const needScriptSig = !!input.redeemScript;
        const needWitnessScript = !!input.witnessScript;
        const scriptSigOK = !needScriptSig || !!input.finalScriptSig;
        const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
        const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
        result = scriptSigOK && witnessScriptOK && hasOneFinal;
    }
    if (result === false) throw new Error(`Input #${inputIndex} has too much or too little data to clean`);
}
exports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;
function throwForUpdateMaker(typeName, name, expected, data) {
    throw new Error(`Data for ${typeName} key ${name} is incorrect: Expected ` + `${expected} and got ${JSON.stringify(data)}`);
}
function updateMaker(typeName) {
    return (updateData, mainData)=>{
        for (const name of Object.keys(updateData)){
            // @ts-ignore
            const data = updateData[name];
            // @ts-ignore
            const { canAdd, canAddToArray, check, expected } = // @ts-ignore
            converter[typeName + "s"][name] || {};
            const isArray = !!canAddToArray;
            // If unknown data. ignore and do not add
            if (check) {
                if (isArray) {
                    if (!Array.isArray(data) || // @ts-ignore
                    mainData[name] && !Array.isArray(mainData[name])) throw new Error(`Key type ${name} must be an array`);
                    if (!data.every(check)) throwForUpdateMaker(typeName, name, expected, data);
                    // @ts-ignore
                    const arr = mainData[name] || [];
                    const dupeCheckSet = new Set();
                    if (!data.every((v)=>canAddToArray(arr, v, dupeCheckSet))) throw new Error("Can not add duplicate data to array");
                    // @ts-ignore
                    mainData[name] = arr.concat(data);
                } else {
                    if (!check(data)) throwForUpdateMaker(typeName, name, expected, data);
                    if (!canAdd(mainData, data)) throw new Error(`Can not add duplicate data to ${typeName}`);
                    // @ts-ignore
                    mainData[name] = data;
                }
            }
        }
    };
}
exports.updateGlobal = updateMaker("global");
exports.updateInput = updateMaker("input");
exports.updateOutput = updateMaker("output");
function addInputAttributes(inputs, data) {
    const index = inputs.length - 1;
    const input = checkForInput(inputs, index);
    exports.updateInput(data, input);
}
exports.addInputAttributes = addInputAttributes;
function addOutputAttributes(outputs, data) {
    const index = outputs.length - 1;
    const output = checkForOutput(outputs, index);
    exports.updateOutput(data, output);
}
exports.addOutputAttributes = addOutputAttributes;
function defaultVersionSetter(version, txBuf) {
    if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) throw new Error("Set Version: Invalid Transaction");
    txBuf.writeUInt32LE(version, 0);
    return txBuf;
}
exports.defaultVersionSetter = defaultVersionSetter;
function defaultLocktimeSetter(locktime, txBuf) {
    if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) throw new Error("Set Locktime: Invalid Transaction");
    txBuf.writeUInt32LE(locktime, txBuf.length - 4);
    return txBuf;
}
exports.defaultLocktimeSetter = defaultLocktimeSetter;

},{"2833a8b71f7b13ec":"bwvMq","2bdc21d0bef9f86d":"31Gpb"}],"ivOLs":[function(require,module,exports) {
var Buffer = require("899c7969573f3d1a").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const baddress = require("d821e82d1f0adb2d");
const bufferutils_1 = require("ce95362deb013974");
const classify = require("a1d0e7ca99bbf224");
const bcrypto = require("585be5af7902ca43");
const ECPair = require("3d998f91003e1f0d");
const networks = require("e74999778bd48497");
const payments = require("3de09dbe5f913c1f");
const bscript = require("8a8e3175a4f7f54d");
const script_1 = require("8a8e3175a4f7f54d");
const transaction_1 = require("eb1d2004a5a108ed");
const types = require("2a20500d3b5c9647");
const typeforce = require("c3033d5fe48ad925");
const SCRIPT_TYPES = classify.types;
const PREVOUT_TYPES = new Set([
    // Raw
    "p2pkh",
    "p2pk",
    "p2wpkh",
    "p2ms",
    // P2SH wrapped
    "p2sh-p2pkh",
    "p2sh-p2pk",
    "p2sh-p2wpkh",
    "p2sh-p2ms",
    // P2WSH wrapped
    "p2wsh-p2pkh",
    "p2wsh-p2pk",
    "p2wsh-p2ms",
    // P2SH-P2WSH wrapper
    "p2sh-p2wsh-p2pkh",
    "p2sh-p2wsh-p2pk",
    "p2sh-p2wsh-p2ms"
]);
function tfMessage(type, value, message) {
    try {
        typeforce(type, value);
    } catch (err) {
        throw new Error(message);
    }
}
function txIsString(tx) {
    return typeof tx === "string" || tx instanceof String;
}
function txIsTransaction(tx) {
    return tx instanceof transaction_1.Transaction;
}
class TransactionBuilder {
    // WARNING: maximumFeeRate is __NOT__ to be relied on,
    //          it's just another potential safety mechanism (safety in-depth)
    constructor(network = networks.bitcoin, maximumFeeRate = 2500){
        this.network = network;
        this.maximumFeeRate = maximumFeeRate;
        this.__PREV_TX_SET = {};
        this.__INPUTS = [];
        this.__TX = new transaction_1.Transaction();
        this.__TX.version = 2;
        this.__USE_LOW_R = false;
        console.warn("Deprecation Warning: TransactionBuilder will be removed in the future. (v6.x.x or later) Please use the Psbt class instead. Examples of usage are available in the transactions-psbt.js integration test file on our Github. A high level explanation is available in the psbt.ts and psbt.js files as well.");
    }
    static fromTransaction(transaction, network) {
        const txb = new TransactionBuilder(network);
        // Copy transaction fields
        txb.setVersion(transaction.version);
        txb.setLockTime(transaction.locktime);
        // Copy outputs (done first to avoid signature invalidation)
        transaction.outs.forEach((txOut)=>{
            txb.addOutput(txOut.script, txOut.value);
        });
        // Copy inputs
        transaction.ins.forEach((txIn)=>{
            txb.__addInputUnsafe(txIn.hash, txIn.index, {
                sequence: txIn.sequence,
                script: txIn.script,
                witness: txIn.witness
            });
        });
        // fix some things not possible through the public API
        txb.__INPUTS.forEach((input, i)=>{
            fixMultisigOrder(input, transaction, i);
        });
        return txb;
    }
    setLowR(setting) {
        typeforce(typeforce.maybe(typeforce.Boolean), setting);
        if (setting === undefined) setting = true;
        this.__USE_LOW_R = setting;
        return setting;
    }
    setLockTime(locktime) {
        typeforce(types.UInt32, locktime);
        // if any signatures exist, throw
        if (this.__INPUTS.some((input)=>{
            if (!input.signatures) return false;
            return input.signatures.some((s)=>s !== undefined);
        })) throw new Error("No, this would invalidate signatures");
        this.__TX.locktime = locktime;
    }
    setVersion(version) {
        typeforce(types.UInt32, version);
        // XXX: this might eventually become more complex depending on what the versions represent
        this.__TX.version = version;
    }
    addInput(txHash, vout, sequence, prevOutScript) {
        if (!this.__canModifyInputs()) throw new Error("No, this would invalidate signatures");
        let value;
        // is it a hex string?
        if (txIsString(txHash)) // transaction hashs's are displayed in reverse order, un-reverse it
        txHash = bufferutils_1.reverseBuffer(Buffer.from(txHash, "hex"));
        else if (txIsTransaction(txHash)) {
            const txOut = txHash.outs[vout];
            prevOutScript = txOut.script;
            value = txOut.value;
            txHash = txHash.getHash(false);
        }
        return this.__addInputUnsafe(txHash, vout, {
            sequence,
            prevOutScript,
            value
        });
    }
    addOutput(scriptPubKey, value) {
        if (!this.__canModifyOutputs()) throw new Error("No, this would invalidate signatures");
        // Attempt to get a script if it's a base58 or bech32 address string
        if (typeof scriptPubKey === "string") scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);
        return this.__TX.addOutput(scriptPubKey, value);
    }
    build() {
        return this.__build(false);
    }
    buildIncomplete() {
        return this.__build(true);
    }
    sign(signParams, keyPair, redeemScript, hashType, witnessValue, witnessScript) {
        trySign(getSigningData(this.network, this.__INPUTS, this.__needsOutputs.bind(this), this.__TX, signParams, keyPair, redeemScript, hashType, witnessValue, witnessScript, this.__USE_LOW_R));
    }
    __addInputUnsafe(txHash, vout, options) {
        if (transaction_1.Transaction.isCoinbaseHash(txHash)) throw new Error("coinbase inputs not supported");
        const prevTxOut = txHash.toString("hex") + ":" + vout;
        if (this.__PREV_TX_SET[prevTxOut] !== undefined) throw new Error("Duplicate TxOut: " + prevTxOut);
        let input = {};
        // derive what we can from the scriptSig
        if (options.script !== undefined) input = expandInput(options.script, options.witness || []);
        // if an input value was given, retain it
        if (options.value !== undefined) input.value = options.value;
        // derive what we can from the previous transactions output script
        if (!input.prevOutScript && options.prevOutScript) {
            let prevOutType;
            if (!input.pubkeys && !input.signatures) {
                const expanded = expandOutput(options.prevOutScript);
                if (expanded.pubkeys) {
                    input.pubkeys = expanded.pubkeys;
                    input.signatures = expanded.signatures;
                }
                prevOutType = expanded.type;
            }
            input.prevOutScript = options.prevOutScript;
            input.prevOutType = prevOutType || classify.output(options.prevOutScript);
        }
        const vin = this.__TX.addInput(txHash, vout, options.sequence, options.scriptSig);
        this.__INPUTS[vin] = input;
        this.__PREV_TX_SET[prevTxOut] = true;
        return vin;
    }
    __build(allowIncomplete) {
        if (!allowIncomplete) {
            if (!this.__TX.ins.length) throw new Error("Transaction has no inputs");
            if (!this.__TX.outs.length) throw new Error("Transaction has no outputs");
        }
        const tx = this.__TX.clone();
        // create script signatures from inputs
        this.__INPUTS.forEach((input, i)=>{
            if (!input.prevOutType && !allowIncomplete) throw new Error("Transaction is not complete");
            const result = build(input.prevOutType, input, allowIncomplete);
            if (!result) {
                if (!allowIncomplete && input.prevOutType === SCRIPT_TYPES.NONSTANDARD) throw new Error("Unknown input type");
                if (!allowIncomplete) throw new Error("Not enough information");
                return;
            }
            tx.setInputScript(i, result.input);
            tx.setWitness(i, result.witness);
        });
        if (!allowIncomplete) {
            // do not rely on this, its merely a last resort
            if (this.__overMaximumFees(tx.virtualSize())) throw new Error("Transaction has absurd fees");
        }
        return tx;
    }
    __canModifyInputs() {
        return this.__INPUTS.every((input)=>{
            if (!input.signatures) return true;
            return input.signatures.every((signature)=>{
                if (!signature) return true;
                const hashType = signatureHashType(signature);
                // if SIGHASH_ANYONECANPAY is set, signatures would not
                // be invalidated by more inputs
                return (hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY) !== 0;
            });
        });
    }
    __needsOutputs(signingHashType) {
        if (signingHashType === transaction_1.Transaction.SIGHASH_ALL) return this.__TX.outs.length === 0;
        // if inputs are being signed with SIGHASH_NONE, we don't strictly need outputs
        // .build() will fail, but .buildIncomplete() is OK
        return this.__TX.outs.length === 0 && this.__INPUTS.some((input)=>{
            if (!input.signatures) return false;
            return input.signatures.some((signature)=>{
                if (!signature) return false; // no signature, no issue
                const hashType = signatureHashType(signature);
                if (hashType & transaction_1.Transaction.SIGHASH_NONE) return false; // SIGHASH_NONE doesn't care about outputs
                return true; // SIGHASH_* does care
            });
        });
    }
    __canModifyOutputs() {
        const nInputs = this.__TX.ins.length;
        const nOutputs = this.__TX.outs.length;
        return this.__INPUTS.every((input)=>{
            if (input.signatures === undefined) return true;
            return input.signatures.every((signature)=>{
                if (!signature) return true;
                const hashType = signatureHashType(signature);
                const hashTypeMod = hashType & 0x1f;
                if (hashTypeMod === transaction_1.Transaction.SIGHASH_NONE) return true;
                if (hashTypeMod === transaction_1.Transaction.SIGHASH_SINGLE) // if SIGHASH_SINGLE is set, and nInputs > nOutputs
                // some signatures would be invalidated by the addition
                // of more outputs
                return nInputs <= nOutputs;
                return false;
            });
        });
    }
    __overMaximumFees(bytes) {
        // not all inputs will have .value defined
        const incoming = this.__INPUTS.reduce((a, x)=>a + (x.value >>> 0), 0);
        // but all outputs do, and if we have any input value
        // we can immediately determine if the outputs are too small
        const outgoing = this.__TX.outs.reduce((a, x)=>a + x.value, 0);
        const fee = incoming - outgoing;
        const feeRate = fee / bytes;
        return feeRate > this.maximumFeeRate;
    }
}
exports.TransactionBuilder = TransactionBuilder;
function expandInput(scriptSig, witnessStack, type, scriptPubKey) {
    if (scriptSig.length === 0 && witnessStack.length === 0) return {};
    if (!type) {
        let ssType = classify.input(scriptSig, true);
        let wsType = classify.witness(witnessStack, true);
        if (ssType === SCRIPT_TYPES.NONSTANDARD) ssType = undefined;
        if (wsType === SCRIPT_TYPES.NONSTANDARD) wsType = undefined;
        type = ssType || wsType;
    }
    switch(type){
        case SCRIPT_TYPES.P2WPKH:
            {
                const { output, pubkey, signature } = payments.p2wpkh({
                    witness: witnessStack
                });
                return {
                    prevOutScript: output,
                    prevOutType: SCRIPT_TYPES.P2WPKH,
                    pubkeys: [
                        pubkey
                    ],
                    signatures: [
                        signature
                    ]
                };
            }
        case SCRIPT_TYPES.P2PKH:
            {
                const { output, pubkey, signature } = payments.p2pkh({
                    input: scriptSig
                });
                return {
                    prevOutScript: output,
                    prevOutType: SCRIPT_TYPES.P2PKH,
                    pubkeys: [
                        pubkey
                    ],
                    signatures: [
                        signature
                    ]
                };
            }
        case SCRIPT_TYPES.P2PK:
            {
                const { signature } = payments.p2pk({
                    input: scriptSig
                });
                return {
                    prevOutType: SCRIPT_TYPES.P2PK,
                    pubkeys: [
                        undefined
                    ],
                    signatures: [
                        signature
                    ]
                };
            }
        case SCRIPT_TYPES.P2MS:
            {
                const { m, pubkeys, signatures } = payments.p2ms({
                    input: scriptSig,
                    output: scriptPubKey
                }, {
                    allowIncomplete: true
                });
                return {
                    prevOutType: SCRIPT_TYPES.P2MS,
                    pubkeys,
                    signatures,
                    maxSignatures: m
                };
            }
    }
    if (type === SCRIPT_TYPES.P2SH) {
        const { output, redeem } = payments.p2sh({
            input: scriptSig,
            witness: witnessStack
        });
        const outputType = classify.output(redeem.output);
        const expanded = expandInput(redeem.input, redeem.witness, outputType, redeem.output);
        if (!expanded.prevOutType) return {};
        return {
            prevOutScript: output,
            prevOutType: SCRIPT_TYPES.P2SH,
            redeemScript: redeem.output,
            redeemScriptType: expanded.prevOutType,
            witnessScript: expanded.witnessScript,
            witnessScriptType: expanded.witnessScriptType,
            pubkeys: expanded.pubkeys,
            signatures: expanded.signatures
        };
    }
    if (type === SCRIPT_TYPES.P2WSH) {
        const { output, redeem } = payments.p2wsh({
            input: scriptSig,
            witness: witnessStack
        });
        const outputType = classify.output(redeem.output);
        let expanded;
        if (outputType === SCRIPT_TYPES.P2WPKH) expanded = expandInput(redeem.input, redeem.witness, outputType);
        else expanded = expandInput(bscript.compile(redeem.witness), [], outputType, redeem.output);
        if (!expanded.prevOutType) return {};
        return {
            prevOutScript: output,
            prevOutType: SCRIPT_TYPES.P2WSH,
            witnessScript: redeem.output,
            witnessScriptType: expanded.prevOutType,
            pubkeys: expanded.pubkeys,
            signatures: expanded.signatures
        };
    }
    return {
        prevOutType: SCRIPT_TYPES.NONSTANDARD,
        prevOutScript: scriptSig
    };
}
// could be done in expandInput, but requires the original Transaction for hashForSignature
function fixMultisigOrder(input, transaction, vin) {
    if (input.redeemScriptType !== SCRIPT_TYPES.P2MS || !input.redeemScript) return;
    if (input.pubkeys.length === input.signatures.length) return;
    const unmatched = input.signatures.concat();
    input.signatures = input.pubkeys.map((pubKey)=>{
        const keyPair = ECPair.fromPublicKey(pubKey);
        let match;
        // check for a signature
        unmatched.some((signature, i)=>{
            // skip if undefined || OP_0
            if (!signature) return false;
            // TODO: avoid O(n) hashForSignature
            const parsed = bscript.signature.decode(signature);
            const hash = transaction.hashForSignature(vin, input.redeemScript, parsed.hashType);
            // skip if signature does not match pubKey
            if (!keyPair.verify(hash, parsed.signature)) return false;
            // remove matched signature from unmatched
            unmatched[i] = undefined;
            match = signature;
            return true;
        });
        return match;
    });
}
function expandOutput(script, ourPubKey) {
    typeforce(types.Buffer, script);
    const type = classify.output(script);
    switch(type){
        case SCRIPT_TYPES.P2PKH:
            {
                if (!ourPubKey) return {
                    type
                };
                // does our hash160(pubKey) match the output scripts?
                const pkh1 = payments.p2pkh({
                    output: script
                }).hash;
                const pkh2 = bcrypto.hash160(ourPubKey);
                if (!pkh1.equals(pkh2)) return {
                    type
                };
                return {
                    type,
                    pubkeys: [
                        ourPubKey
                    ],
                    signatures: [
                        undefined
                    ]
                };
            }
        case SCRIPT_TYPES.P2WPKH:
            {
                if (!ourPubKey) return {
                    type
                };
                // does our hash160(pubKey) match the output scripts?
                const wpkh1 = payments.p2wpkh({
                    output: script
                }).hash;
                const wpkh2 = bcrypto.hash160(ourPubKey);
                if (!wpkh1.equals(wpkh2)) return {
                    type
                };
                return {
                    type,
                    pubkeys: [
                        ourPubKey
                    ],
                    signatures: [
                        undefined
                    ]
                };
            }
        case SCRIPT_TYPES.P2PK:
            {
                const p2pk = payments.p2pk({
                    output: script
                });
                return {
                    type,
                    pubkeys: [
                        p2pk.pubkey
                    ],
                    signatures: [
                        undefined
                    ]
                };
            }
        case SCRIPT_TYPES.P2MS:
            {
                const p2ms = payments.p2ms({
                    output: script
                });
                return {
                    type,
                    pubkeys: p2ms.pubkeys,
                    signatures: p2ms.pubkeys.map(()=>undefined),
                    maxSignatures: p2ms.m
                };
            }
    }
    return {
        type
    };
}
function prepareInput(input, ourPubKey, redeemScript, witnessScript) {
    if (redeemScript && witnessScript) {
        const p2wsh = payments.p2wsh({
            redeem: {
                output: witnessScript
            }
        });
        const p2wshAlt = payments.p2wsh({
            output: redeemScript
        });
        const p2sh = payments.p2sh({
            redeem: {
                output: redeemScript
            }
        });
        const p2shAlt = payments.p2sh({
            redeem: p2wsh
        });
        // enforces P2SH(P2WSH(...))
        if (!p2wsh.hash.equals(p2wshAlt.hash)) throw new Error("Witness script inconsistent with prevOutScript");
        if (!p2sh.hash.equals(p2shAlt.hash)) throw new Error("Redeem script inconsistent with prevOutScript");
        const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);
        if (!expanded.pubkeys) throw new Error(expanded.type + " not supported as witnessScript (" + bscript.toASM(witnessScript) + ")");
        if (input.signatures && input.signatures.some((x)=>x !== undefined)) expanded.signatures = input.signatures;
        const signScript = witnessScript;
        if (expanded.type === SCRIPT_TYPES.P2WPKH) throw new Error("P2SH(P2WSH(P2WPKH)) is a consensus failure");
        return {
            redeemScript,
            redeemScriptType: SCRIPT_TYPES.P2WSH,
            witnessScript,
            witnessScriptType: expanded.type,
            prevOutType: SCRIPT_TYPES.P2SH,
            prevOutScript: p2sh.output,
            hasWitness: true,
            signScript,
            signType: expanded.type,
            pubkeys: expanded.pubkeys,
            signatures: expanded.signatures,
            maxSignatures: expanded.maxSignatures
        };
    }
    if (redeemScript) {
        const p2sh = payments.p2sh({
            redeem: {
                output: redeemScript
            }
        });
        if (input.prevOutScript) {
            let p2shAlt;
            try {
                p2shAlt = payments.p2sh({
                    output: input.prevOutScript
                });
            } catch (e) {
                throw new Error("PrevOutScript must be P2SH");
            }
            if (!p2sh.hash.equals(p2shAlt.hash)) throw new Error("Redeem script inconsistent with prevOutScript");
        }
        const expanded = expandOutput(p2sh.redeem.output, ourPubKey);
        if (!expanded.pubkeys) throw new Error(expanded.type + " not supported as redeemScript (" + bscript.toASM(redeemScript) + ")");
        if (input.signatures && input.signatures.some((x)=>x !== undefined)) expanded.signatures = input.signatures;
        let signScript = redeemScript;
        if (expanded.type === SCRIPT_TYPES.P2WPKH) signScript = payments.p2pkh({
            pubkey: expanded.pubkeys[0]
        }).output;
        return {
            redeemScript,
            redeemScriptType: expanded.type,
            prevOutType: SCRIPT_TYPES.P2SH,
            prevOutScript: p2sh.output,
            hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,
            signScript,
            signType: expanded.type,
            pubkeys: expanded.pubkeys,
            signatures: expanded.signatures,
            maxSignatures: expanded.maxSignatures
        };
    }
    if (witnessScript) {
        const p2wsh = payments.p2wsh({
            redeem: {
                output: witnessScript
            }
        });
        if (input.prevOutScript) {
            const p2wshAlt = payments.p2wsh({
                output: input.prevOutScript
            });
            if (!p2wsh.hash.equals(p2wshAlt.hash)) throw new Error("Witness script inconsistent with prevOutScript");
        }
        const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);
        if (!expanded.pubkeys) throw new Error(expanded.type + " not supported as witnessScript (" + bscript.toASM(witnessScript) + ")");
        if (input.signatures && input.signatures.some((x)=>x !== undefined)) expanded.signatures = input.signatures;
        const signScript = witnessScript;
        if (expanded.type === SCRIPT_TYPES.P2WPKH) throw new Error("P2WSH(P2WPKH) is a consensus failure");
        return {
            witnessScript,
            witnessScriptType: expanded.type,
            prevOutType: SCRIPT_TYPES.P2WSH,
            prevOutScript: p2wsh.output,
            hasWitness: true,
            signScript,
            signType: expanded.type,
            pubkeys: expanded.pubkeys,
            signatures: expanded.signatures,
            maxSignatures: expanded.maxSignatures
        };
    }
    if (input.prevOutType && input.prevOutScript) {
        // embedded scripts are not possible without extra information
        if (input.prevOutType === SCRIPT_TYPES.P2SH) throw new Error("PrevOutScript is " + input.prevOutType + ", requires redeemScript");
        if (input.prevOutType === SCRIPT_TYPES.P2WSH) throw new Error("PrevOutScript is " + input.prevOutType + ", requires witnessScript");
        if (!input.prevOutScript) throw new Error("PrevOutScript is missing");
        const expanded = expandOutput(input.prevOutScript, ourPubKey);
        if (!expanded.pubkeys) throw new Error(expanded.type + " not supported (" + bscript.toASM(input.prevOutScript) + ")");
        if (input.signatures && input.signatures.some((x)=>x !== undefined)) expanded.signatures = input.signatures;
        let signScript = input.prevOutScript;
        if (expanded.type === SCRIPT_TYPES.P2WPKH) signScript = payments.p2pkh({
            pubkey: expanded.pubkeys[0]
        }).output;
        return {
            prevOutType: expanded.type,
            prevOutScript: input.prevOutScript,
            hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,
            signScript,
            signType: expanded.type,
            pubkeys: expanded.pubkeys,
            signatures: expanded.signatures,
            maxSignatures: expanded.maxSignatures
        };
    }
    const prevOutScript = payments.p2pkh({
        pubkey: ourPubKey
    }).output;
    return {
        prevOutType: SCRIPT_TYPES.P2PKH,
        prevOutScript,
        hasWitness: false,
        signScript: prevOutScript,
        signType: SCRIPT_TYPES.P2PKH,
        pubkeys: [
            ourPubKey
        ],
        signatures: [
            undefined
        ]
    };
}
function build(type, input, allowIncomplete) {
    const pubkeys = input.pubkeys || [];
    let signatures = input.signatures || [];
    switch(type){
        case SCRIPT_TYPES.P2PKH:
            if (pubkeys.length === 0) break;
            if (signatures.length === 0) break;
            return payments.p2pkh({
                pubkey: pubkeys[0],
                signature: signatures[0]
            });
        case SCRIPT_TYPES.P2WPKH:
            if (pubkeys.length === 0) break;
            if (signatures.length === 0) break;
            return payments.p2wpkh({
                pubkey: pubkeys[0],
                signature: signatures[0]
            });
        case SCRIPT_TYPES.P2PK:
            if (pubkeys.length === 0) break;
            if (signatures.length === 0) break;
            return payments.p2pk({
                signature: signatures[0]
            });
        case SCRIPT_TYPES.P2MS:
            {
                const m = input.maxSignatures;
                if (allowIncomplete) signatures = signatures.map((x)=>x || script_1.OPS.OP_0);
                else signatures = signatures.filter((x)=>x);
                // if the transaction is not not complete (complete), or if signatures.length === m, validate
                // otherwise, the number of OP_0's may be >= m, so don't validate (boo)
                const validate = !allowIncomplete || m === signatures.length;
                return payments.p2ms({
                    m,
                    pubkeys,
                    signatures
                }, {
                    allowIncomplete,
                    validate
                });
            }
        case SCRIPT_TYPES.P2SH:
            {
                const redeem = build(input.redeemScriptType, input, allowIncomplete);
                if (!redeem) return;
                return payments.p2sh({
                    redeem: {
                        output: redeem.output || input.redeemScript,
                        input: redeem.input,
                        witness: redeem.witness
                    }
                });
            }
        case SCRIPT_TYPES.P2WSH:
            {
                const redeem = build(input.witnessScriptType, input, allowIncomplete);
                if (!redeem) return;
                return payments.p2wsh({
                    redeem: {
                        output: input.witnessScript,
                        input: redeem.input,
                        witness: redeem.witness
                    }
                });
            }
    }
}
function canSign(input) {
    return input.signScript !== undefined && input.signType !== undefined && input.pubkeys !== undefined && input.signatures !== undefined && input.signatures.length === input.pubkeys.length && input.pubkeys.length > 0 && (input.hasWitness === false || input.value !== undefined);
}
function signatureHashType(buffer) {
    return buffer.readUInt8(buffer.length - 1);
}
function checkSignArgs(inputs, signParams) {
    if (!PREVOUT_TYPES.has(signParams.prevOutScriptType)) throw new TypeError(`Unknown prevOutScriptType "${signParams.prevOutScriptType}"`);
    tfMessage(typeforce.Number, signParams.vin, `sign must include vin parameter as Number (input index)`);
    tfMessage(types.Signer, signParams.keyPair, `sign must include keyPair parameter as Signer interface`);
    tfMessage(typeforce.maybe(typeforce.Number), signParams.hashType, `sign hashType parameter must be a number`);
    const prevOutType = (inputs[signParams.vin] || []).prevOutType;
    const posType = signParams.prevOutScriptType;
    switch(posType){
        case "p2pkh":
            if (prevOutType && prevOutType !== "pubkeyhash") throw new TypeError(`input #${signParams.vin} is not of type p2pkh: ${prevOutType}`);
            tfMessage(typeforce.value(undefined), signParams.witnessScript, `${posType} requires NO witnessScript`);
            tfMessage(typeforce.value(undefined), signParams.redeemScript, `${posType} requires NO redeemScript`);
            tfMessage(typeforce.value(undefined), signParams.witnessValue, `${posType} requires NO witnessValue`);
            break;
        case "p2pk":
            if (prevOutType && prevOutType !== "pubkey") throw new TypeError(`input #${signParams.vin} is not of type p2pk: ${prevOutType}`);
            tfMessage(typeforce.value(undefined), signParams.witnessScript, `${posType} requires NO witnessScript`);
            tfMessage(typeforce.value(undefined), signParams.redeemScript, `${posType} requires NO redeemScript`);
            tfMessage(typeforce.value(undefined), signParams.witnessValue, `${posType} requires NO witnessValue`);
            break;
        case "p2wpkh":
            if (prevOutType && prevOutType !== "witnesspubkeyhash") throw new TypeError(`input #${signParams.vin} is not of type p2wpkh: ${prevOutType}`);
            tfMessage(typeforce.value(undefined), signParams.witnessScript, `${posType} requires NO witnessScript`);
            tfMessage(typeforce.value(undefined), signParams.redeemScript, `${posType} requires NO redeemScript`);
            tfMessage(types.Satoshi, signParams.witnessValue, `${posType} requires witnessValue`);
            break;
        case "p2ms":
            if (prevOutType && prevOutType !== "multisig") throw new TypeError(`input #${signParams.vin} is not of type p2ms: ${prevOutType}`);
            tfMessage(typeforce.value(undefined), signParams.witnessScript, `${posType} requires NO witnessScript`);
            tfMessage(typeforce.value(undefined), signParams.redeemScript, `${posType} requires NO redeemScript`);
            tfMessage(typeforce.value(undefined), signParams.witnessValue, `${posType} requires NO witnessValue`);
            break;
        case "p2sh-p2wpkh":
            if (prevOutType && prevOutType !== "scripthash") throw new TypeError(`input #${signParams.vin} is not of type p2sh-p2wpkh: ${prevOutType}`);
            tfMessage(typeforce.value(undefined), signParams.witnessScript, `${posType} requires NO witnessScript`);
            tfMessage(typeforce.Buffer, signParams.redeemScript, `${posType} requires redeemScript`);
            tfMessage(types.Satoshi, signParams.witnessValue, `${posType} requires witnessValue`);
            break;
        case "p2sh-p2ms":
        case "p2sh-p2pk":
        case "p2sh-p2pkh":
            if (prevOutType && prevOutType !== "scripthash") throw new TypeError(`input #${signParams.vin} is not of type ${posType}: ${prevOutType}`);
            tfMessage(typeforce.value(undefined), signParams.witnessScript, `${posType} requires NO witnessScript`);
            tfMessage(typeforce.Buffer, signParams.redeemScript, `${posType} requires redeemScript`);
            tfMessage(typeforce.value(undefined), signParams.witnessValue, `${posType} requires NO witnessValue`);
            break;
        case "p2wsh-p2ms":
        case "p2wsh-p2pk":
        case "p2wsh-p2pkh":
            if (prevOutType && prevOutType !== "witnessscripthash") throw new TypeError(`input #${signParams.vin} is not of type ${posType}: ${prevOutType}`);
            tfMessage(typeforce.Buffer, signParams.witnessScript, `${posType} requires witnessScript`);
            tfMessage(typeforce.value(undefined), signParams.redeemScript, `${posType} requires NO redeemScript`);
            tfMessage(types.Satoshi, signParams.witnessValue, `${posType} requires witnessValue`);
            break;
        case "p2sh-p2wsh-p2ms":
        case "p2sh-p2wsh-p2pk":
        case "p2sh-p2wsh-p2pkh":
            if (prevOutType && prevOutType !== "scripthash") throw new TypeError(`input #${signParams.vin} is not of type ${posType}: ${prevOutType}`);
            tfMessage(typeforce.Buffer, signParams.witnessScript, `${posType} requires witnessScript`);
            tfMessage(typeforce.Buffer, signParams.redeemScript, `${posType} requires witnessScript`);
            tfMessage(types.Satoshi, signParams.witnessValue, `${posType} requires witnessScript`);
            break;
    }
}
function trySign({ input, ourPubKey, keyPair, signatureHash, hashType, useLowR }) {
    // enforce in order signing of public keys
    let signed = false;
    for (const [i, pubKey] of input.pubkeys.entries()){
        if (!ourPubKey.equals(pubKey)) continue;
        if (input.signatures[i]) throw new Error("Signature already exists");
        // TODO: add tests
        if (ourPubKey.length !== 33 && input.hasWitness) throw new Error("BIP143 rejects uncompressed public keys in P2WPKH or P2WSH");
        const signature = keyPair.sign(signatureHash, useLowR);
        input.signatures[i] = bscript.signature.encode(signature, hashType);
        signed = true;
    }
    if (!signed) throw new Error("Key pair cannot sign for this input");
}
function getSigningData(network, inputs, needsOutputs, tx, signParams, keyPair, redeemScript, hashType, witnessValue, witnessScript, useLowR) {
    let vin;
    if (typeof signParams === "number") {
        console.warn("DEPRECATED: TransactionBuilder sign method arguments will change in v6, please use the TxbSignArg interface");
        vin = signParams;
    } else if (typeof signParams === "object") {
        checkSignArgs(inputs, signParams);
        ({ vin, keyPair, redeemScript, hashType, witnessValue, witnessScript } = signParams);
    } else throw new TypeError("TransactionBuilder sign first arg must be TxbSignArg or number");
    if (keyPair === undefined) throw new Error("sign requires keypair");
    // TODO: remove keyPair.network matching in 4.0.0
    if (keyPair.network && keyPair.network !== network) throw new TypeError("Inconsistent network");
    if (!inputs[vin]) throw new Error("No input at index: " + vin);
    hashType = hashType || transaction_1.Transaction.SIGHASH_ALL;
    if (needsOutputs(hashType)) throw new Error("Transaction needs outputs");
    const input = inputs[vin];
    // if redeemScript was previously provided, enforce consistency
    if (input.redeemScript !== undefined && redeemScript && !input.redeemScript.equals(redeemScript)) throw new Error("Inconsistent redeemScript");
    const ourPubKey = keyPair.publicKey || keyPair.getPublicKey && keyPair.getPublicKey();
    if (!canSign(input)) {
        if (witnessValue !== undefined) {
            if (input.value !== undefined && input.value !== witnessValue) throw new Error("Input did not match witnessValue");
            typeforce(types.Satoshi, witnessValue);
            input.value = witnessValue;
        }
        if (!canSign(input)) {
            const prepared = prepareInput(input, ourPubKey, redeemScript, witnessScript);
            // updates inline
            Object.assign(input, prepared);
        }
        if (!canSign(input)) throw Error(input.prevOutType + " not supported");
    }
    // ready to sign
    let signatureHash;
    if (input.hasWitness) signatureHash = tx.hashForWitnessV0(vin, input.signScript, input.value, hashType);
    else signatureHash = tx.hashForSignature(vin, input.signScript, hashType);
    return {
        input,
        ourPubKey,
        keyPair,
        signatureHash,
        hashType,
        useLowR: !!useLowR
    };
}

},{"899c7969573f3d1a":"bwvMq","d821e82d1f0adb2d":"2Me89","ce95362deb013974":"jR49q","a1d0e7ca99bbf224":"ebCN0","585be5af7902ca43":"4BCCF","3d998f91003e1f0d":"aiXsq","e74999778bd48497":"hpO0s","3de09dbe5f913c1f":"g5Tn6","8a8e3175a4f7f54d":"28LFb","eb1d2004a5a108ed":"arhmj","2a20500d3b5c9647":"eFC2X","c3033d5fe48ad925":"86sQP"}],"ebCN0":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const script_1 = require("443280174edd7e04");
const multisig = require("9ed8dfca2efd5609");
const nullData = require("3637a4860af99679");
const pubKey = require("9aa94f0a26a012e4");
const pubKeyHash = require("d5edd68317971948");
const scriptHash = require("46fc1b52406f16b7");
const witnessCommitment = require("24e12587f8d92525");
const witnessPubKeyHash = require("684f690bb0f4b214");
const witnessScriptHash = require("1dadc391e551d24b");
const types = {
    P2MS: "multisig",
    NONSTANDARD: "nonstandard",
    NULLDATA: "nulldata",
    P2PK: "pubkey",
    P2PKH: "pubkeyhash",
    P2SH: "scripthash",
    P2WPKH: "witnesspubkeyhash",
    P2WSH: "witnessscripthash",
    WITNESS_COMMITMENT: "witnesscommitment"
};
exports.types = types;
function classifyOutput(script) {
    if (witnessPubKeyHash.output.check(script)) return types.P2WPKH;
    if (witnessScriptHash.output.check(script)) return types.P2WSH;
    if (pubKeyHash.output.check(script)) return types.P2PKH;
    if (scriptHash.output.check(script)) return types.P2SH;
    // XXX: optimization, below functions .decompile before use
    const chunks = script_1.decompile(script);
    if (!chunks) throw new TypeError("Invalid script");
    if (multisig.output.check(chunks)) return types.P2MS;
    if (pubKey.output.check(chunks)) return types.P2PK;
    if (witnessCommitment.output.check(chunks)) return types.WITNESS_COMMITMENT;
    if (nullData.output.check(chunks)) return types.NULLDATA;
    return types.NONSTANDARD;
}
exports.output = classifyOutput;
function classifyInput(script, allowIncomplete) {
    // XXX: optimization, below functions .decompile before use
    const chunks = script_1.decompile(script);
    if (!chunks) throw new TypeError("Invalid script");
    if (pubKeyHash.input.check(chunks)) return types.P2PKH;
    if (scriptHash.input.check(chunks, allowIncomplete)) return types.P2SH;
    if (multisig.input.check(chunks, allowIncomplete)) return types.P2MS;
    if (pubKey.input.check(chunks)) return types.P2PK;
    return types.NONSTANDARD;
}
exports.input = classifyInput;
function classifyWitness(script, allowIncomplete) {
    // XXX: optimization, below functions .decompile before use
    const chunks = script_1.decompile(script);
    if (!chunks) throw new TypeError("Invalid script");
    if (witnessPubKeyHash.input.check(chunks)) return types.P2WPKH;
    if (witnessScriptHash.input.check(chunks, allowIncomplete)) return types.P2WSH;
    return types.NONSTANDARD;
}
exports.witness = classifyWitness;

},{"443280174edd7e04":"28LFb","9ed8dfca2efd5609":"jWHzs","3637a4860af99679":"llwdn","9aa94f0a26a012e4":"foVSp","d5edd68317971948":"10EtC","46fc1b52406f16b7":"egOCw","24e12587f8d92525":"j1tXa","684f690bb0f4b214":"bV7bK","1dadc391e551d24b":"h6ZXC"}],"jWHzs":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const input = require("45e10b1115f9804");
exports.input = input;
const output = require("da37f587f96e9e3d");
exports.output = output;

},{"45e10b1115f9804":"a7ipX","da37f587f96e9e3d":"c9NzZ"}],"a7ipX":[function(require,module,exports) {
"use strict";
// OP_0 [signatures ...]
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bscript = require("75a890793d408e08");
const script_1 = require("75a890793d408e08");
function partialSignature(value) {
    return value === script_1.OPS.OP_0 || bscript.isCanonicalScriptSignature(value);
}
function check(script, allowIncomplete) {
    const chunks = bscript.decompile(script);
    if (chunks.length < 2) return false;
    if (chunks[0] !== script_1.OPS.OP_0) return false;
    if (allowIncomplete) return chunks.slice(1).every(partialSignature);
    return chunks.slice(1).every(bscript.isCanonicalScriptSignature);
}
exports.check = check;
check.toJSON = ()=>{
    return "multisig input";
};

},{"75a890793d408e08":"28LFb"}],"c9NzZ":[function(require,module,exports) {
"use strict";
// m [pubKeys ...] n OP_CHECKMULTISIG
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bscript = require("7c0ca5c1909672f2");
const script_1 = require("7c0ca5c1909672f2");
const types = require("b3d292dcb7a31852");
const OP_INT_BASE = script_1.OPS.OP_RESERVED; // OP_1 - 1
function check(script, allowIncomplete) {
    const chunks = bscript.decompile(script);
    if (chunks.length < 4) return false;
    if (chunks[chunks.length - 1] !== script_1.OPS.OP_CHECKMULTISIG) return false;
    if (!types.Number(chunks[0])) return false;
    if (!types.Number(chunks[chunks.length - 2])) return false;
    const m = chunks[0] - OP_INT_BASE;
    const n = chunks[chunks.length - 2] - OP_INT_BASE;
    if (m <= 0) return false;
    if (n > 16) return false;
    if (m > n) return false;
    if (n !== chunks.length - 3) return false;
    if (allowIncomplete) return true;
    const keys = chunks.slice(1, -2);
    return keys.every(bscript.isCanonicalPubKey);
}
exports.check = check;
check.toJSON = ()=>{
    return "multi-sig output";
};

},{"7c0ca5c1909672f2":"28LFb","b3d292dcb7a31852":"eFC2X"}],"llwdn":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
// OP_RETURN {data}
const bscript = require("d0bc9b0fc4ef2791");
const OPS = bscript.OPS;
function check(script) {
    const buffer = bscript.compile(script);
    return buffer.length > 1 && buffer[0] === OPS.OP_RETURN;
}
exports.check = check;
check.toJSON = ()=>{
    return "null data output";
};
const output = {
    check
};
exports.output = output;

},{"d0bc9b0fc4ef2791":"28LFb"}],"foVSp":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const input = require("74184332dc4df92a");
exports.input = input;
const output = require("1df77833f5882f25");
exports.output = output;

},{"74184332dc4df92a":"j0pvO","1df77833f5882f25":"2JHWY"}],"j0pvO":[function(require,module,exports) {
"use strict";
// {signature}
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bscript = require("6176e4386f0856fc");
function check(script) {
    const chunks = bscript.decompile(script);
    return chunks.length === 1 && bscript.isCanonicalScriptSignature(chunks[0]);
}
exports.check = check;
check.toJSON = ()=>{
    return "pubKey input";
};

},{"6176e4386f0856fc":"28LFb"}],"2JHWY":[function(require,module,exports) {
"use strict";
// {pubKey} OP_CHECKSIG
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bscript = require("6d7ae659997d3e81");
const script_1 = require("6d7ae659997d3e81");
function check(script) {
    const chunks = bscript.decompile(script);
    return chunks.length === 2 && bscript.isCanonicalPubKey(chunks[0]) && chunks[1] === script_1.OPS.OP_CHECKSIG;
}
exports.check = check;
check.toJSON = ()=>{
    return "pubKey output";
};

},{"6d7ae659997d3e81":"28LFb"}],"10EtC":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const input = require("cf6503baf2286517");
exports.input = input;
const output = require("ae020c338fde37d4");
exports.output = output;

},{"cf6503baf2286517":"5xxwY","ae020c338fde37d4":"eAmT2"}],"5xxwY":[function(require,module,exports) {
"use strict";
// {signature} {pubKey}
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bscript = require("fa825de3e205dbab");
function check(script) {
    const chunks = bscript.decompile(script);
    return chunks.length === 2 && bscript.isCanonicalScriptSignature(chunks[0]) && bscript.isCanonicalPubKey(chunks[1]);
}
exports.check = check;
check.toJSON = ()=>{
    return "pubKeyHash input";
};

},{"fa825de3e205dbab":"28LFb"}],"eAmT2":[function(require,module,exports) {
"use strict";
// OP_DUP OP_HASH160 {pubKeyHash} OP_EQUALVERIFY OP_CHECKSIG
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bscript = require("27fded576dc068ef");
const script_1 = require("27fded576dc068ef");
function check(script) {
    const buffer = bscript.compile(script);
    return buffer.length === 25 && buffer[0] === script_1.OPS.OP_DUP && buffer[1] === script_1.OPS.OP_HASH160 && buffer[2] === 0x14 && buffer[23] === script_1.OPS.OP_EQUALVERIFY && buffer[24] === script_1.OPS.OP_CHECKSIG;
}
exports.check = check;
check.toJSON = ()=>{
    return "pubKeyHash output";
};

},{"27fded576dc068ef":"28LFb"}],"egOCw":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const input = require("b14dd01d52672574");
exports.input = input;
const output = require("daaa9ff912f39f36");
exports.output = output;

},{"b14dd01d52672574":"7YGuP","daaa9ff912f39f36":"KDmhU"}],"7YGuP":[function(require,module,exports) {
var Buffer = require("561c4757286b24a1").Buffer;
"use strict";
// <scriptSig> {serialized scriptPubKey script}
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bscript = require("3af24145bf367e32");
const p2ms = require("6d09f0a7e9023155");
const p2pk = require("9be20a3ad4ad60c2");
const p2pkh = require("658b94803bbaa5a0");
const p2wpkho = require("4aa56c1403bab75b");
const p2wsho = require("57aea1ab25204bed");
function check(script, allowIncomplete) {
    const chunks = bscript.decompile(script);
    if (chunks.length < 1) return false;
    const lastChunk = chunks[chunks.length - 1];
    if (!Buffer.isBuffer(lastChunk)) return false;
    const scriptSigChunks = bscript.decompile(bscript.compile(chunks.slice(0, -1)));
    const redeemScriptChunks = bscript.decompile(lastChunk);
    // is redeemScript a valid script?
    if (!redeemScriptChunks) return false;
    // is redeemScriptSig push only?
    if (!bscript.isPushOnly(scriptSigChunks)) return false;
    // is witness?
    if (chunks.length === 1) return p2wsho.check(redeemScriptChunks) || p2wpkho.check(redeemScriptChunks);
    // match types
    if (p2pkh.input.check(scriptSigChunks) && p2pkh.output.check(redeemScriptChunks)) return true;
    if (p2ms.input.check(scriptSigChunks, allowIncomplete) && p2ms.output.check(redeemScriptChunks)) return true;
    if (p2pk.input.check(scriptSigChunks) && p2pk.output.check(redeemScriptChunks)) return true;
    return false;
}
exports.check = check;
check.toJSON = ()=>{
    return "scriptHash input";
};

},{"561c4757286b24a1":"bwvMq","3af24145bf367e32":"28LFb","6d09f0a7e9023155":"jWHzs","9be20a3ad4ad60c2":"foVSp","658b94803bbaa5a0":"10EtC","4aa56c1403bab75b":"1naSP","57aea1ab25204bed":"deEbp"}],"1naSP":[function(require,module,exports) {
"use strict";
// OP_0 {pubKeyHash}
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bscript = require("63fd62204bece14");
const script_1 = require("63fd62204bece14");
function check(script) {
    const buffer = bscript.compile(script);
    return buffer.length === 22 && buffer[0] === script_1.OPS.OP_0 && buffer[1] === 0x14;
}
exports.check = check;
check.toJSON = ()=>{
    return "Witness pubKeyHash output";
};

},{"63fd62204bece14":"28LFb"}],"deEbp":[function(require,module,exports) {
"use strict";
// OP_0 {scriptHash}
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bscript = require("9e426d8bb7431470");
const script_1 = require("9e426d8bb7431470");
function check(script) {
    const buffer = bscript.compile(script);
    return buffer.length === 34 && buffer[0] === script_1.OPS.OP_0 && buffer[1] === 0x20;
}
exports.check = check;
check.toJSON = ()=>{
    return "Witness scriptHash output";
};

},{"9e426d8bb7431470":"28LFb"}],"KDmhU":[function(require,module,exports) {
"use strict";
// OP_HASH160 {scriptHash} OP_EQUAL
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bscript = require("54d43b3eb597c1b1");
const script_1 = require("54d43b3eb597c1b1");
function check(script) {
    const buffer = bscript.compile(script);
    return buffer.length === 23 && buffer[0] === script_1.OPS.OP_HASH160 && buffer[1] === 0x14 && buffer[22] === script_1.OPS.OP_EQUAL;
}
exports.check = check;
check.toJSON = ()=>{
    return "scriptHash output";
};

},{"54d43b3eb597c1b1":"28LFb"}],"j1tXa":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const output = require("9c894dd0b0421c5a");
exports.output = output;

},{"9c894dd0b0421c5a":"iTgCF"}],"iTgCF":[function(require,module,exports) {
var Buffer = require("4eaef35a50c88789").Buffer;
"use strict";
// OP_RETURN {aa21a9ed} {commitment}
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bscript = require("3f6f20a9dbe84879");
const script_1 = require("3f6f20a9dbe84879");
const types = require("670baf0e948abccd");
const typeforce = require("b63434d77148aa3d");
const HEADER = Buffer.from("aa21a9ed", "hex");
function check(script) {
    const buffer = bscript.compile(script);
    return buffer.length > 37 && buffer[0] === script_1.OPS.OP_RETURN && buffer[1] === 0x24 && buffer.slice(2, 6).equals(HEADER);
}
exports.check = check;
check.toJSON = ()=>{
    return "Witness commitment output";
};
function encode(commitment) {
    typeforce(types.Hash256bit, commitment);
    const buffer = Buffer.allocUnsafe(36);
    HEADER.copy(buffer, 0);
    commitment.copy(buffer, 4);
    return bscript.compile([
        script_1.OPS.OP_RETURN,
        buffer
    ]);
}
exports.encode = encode;
function decode(buffer) {
    typeforce(check, buffer);
    return bscript.decompile(buffer)[1].slice(4, 36);
}
exports.decode = decode;

},{"4eaef35a50c88789":"bwvMq","3f6f20a9dbe84879":"28LFb","670baf0e948abccd":"eFC2X","b63434d77148aa3d":"86sQP"}],"bV7bK":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const input = require("bd2ca0701309f8b9");
exports.input = input;
const output = require("d183f50f031d8a2a");
exports.output = output;

},{"bd2ca0701309f8b9":"6cf9e","d183f50f031d8a2a":"1naSP"}],"6cf9e":[function(require,module,exports) {
"use strict";
// {signature} {pubKey}
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bscript = require("f6309f4757166553");
function isCompressedCanonicalPubKey(pubKey) {
    return bscript.isCanonicalPubKey(pubKey) && pubKey.length === 33;
}
function check(script) {
    const chunks = bscript.decompile(script);
    return chunks.length === 2 && bscript.isCanonicalScriptSignature(chunks[0]) && isCompressedCanonicalPubKey(chunks[1]);
}
exports.check = check;
check.toJSON = ()=>{
    return "witnessPubKeyHash input";
};

},{"f6309f4757166553":"28LFb"}],"h6ZXC":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const input = require("67a799cc1df0dab1");
exports.input = input;
const output = require("702a8118ff9bc98f");
exports.output = output;

},{"67a799cc1df0dab1":"kvstP","702a8118ff9bc98f":"deEbp"}],"kvstP":[function(require,module,exports) {
var Buffer = require("e8b838dd755703fa").Buffer;
"use strict";
// <scriptSig> {serialized scriptPubKey script}
Object.defineProperty(exports, "__esModule", {
    value: true
});
const bscript = require("578bae61332d8f1f");
const typeforce = require("d5123562602372e0");
const p2ms = require("530d6d6312863945");
const p2pk = require("6de09fa4684f4b4e");
const p2pkh = require("23fa5d9cf982dd00");
function check(chunks, allowIncomplete) {
    typeforce(typeforce.Array, chunks);
    if (chunks.length < 1) return false;
    const witnessScript = chunks[chunks.length - 1];
    if (!Buffer.isBuffer(witnessScript)) return false;
    const witnessScriptChunks = bscript.decompile(witnessScript);
    // is witnessScript a valid script?
    if (!witnessScriptChunks || witnessScriptChunks.length === 0) return false;
    const witnessRawScriptSig = bscript.compile(chunks.slice(0, -1));
    // match types
    if (p2pkh.input.check(witnessRawScriptSig) && p2pkh.output.check(witnessScriptChunks)) return true;
    if (p2ms.input.check(witnessRawScriptSig, allowIncomplete) && p2ms.output.check(witnessScriptChunks)) return true;
    if (p2pk.input.check(witnessRawScriptSig) && p2pk.output.check(witnessScriptChunks)) return true;
    return false;
}
exports.check = check;
check.toJSON = ()=>{
    return "witnessScriptHash input";
};

},{"e8b838dd755703fa":"bwvMq","578bae61332d8f1f":"28LFb","d5123562602372e0":"86sQP","530d6d6312863945":"jWHzs","6de09fa4684f4b4e":"foVSp","23fa5d9cf982dd00":"10EtC"}],"hSMer":[function(require,module,exports) {
/**
 * @file bip32.ts
 * @description BIP32 Path Handling for Bitcoin Wallets
 *
 * This file provides utility functions to handle BIP32 paths,
 * which are commonly used in hierarchical deterministic (HD) wallets.
 * It includes functions to convert BIP32 paths to and from different formats,
 * extract components from extended public keys (xpubs), and manipulate path elements.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pathElementsToBuffer", ()=>pathElementsToBuffer);
parcelHelpers.export(exports, "bip32asBuffer", ()=>bip32asBuffer);
parcelHelpers.export(exports, "pathArrayToString", ()=>pathArrayToString);
parcelHelpers.export(exports, "pathStringToArray", ()=>pathStringToArray);
parcelHelpers.export(exports, "pubkeyFromXpub", ()=>pubkeyFromXpub);
parcelHelpers.export(exports, "getXpubComponents", ()=>getXpubComponents);
parcelHelpers.export(exports, "hardenedPathOf", ()=>hardenedPathOf);
var _bip32Path = require("bip32-path");
var _bip32PathDefault = parcelHelpers.interopDefault(_bip32Path);
var _bs58Check = require("bs58check");
var _bs58CheckDefault = parcelHelpers.interopDefault(_bs58Check);
var Buffer = require("5e420757a688a32d").Buffer;
function pathElementsToBuffer(paths) {
    const buffer = Buffer.alloc(1 + paths.length * 4);
    buffer[0] = paths.length;
    paths.forEach((element, index)=>{
        buffer.writeUInt32BE(element, 1 + 4 * index);
    });
    return buffer;
}
function bip32asBuffer(path) {
    const pathElements = !path ? [] : pathStringToArray(path);
    return pathElementsToBuffer(pathElements);
}
function pathArrayToString(pathElements) {
    // Limitation: bippath can't handle and empty path. It shouldn't affect us
    // right now, but might in the future.
    // TODO: Fix support for empty path.
    return (0, _bip32PathDefault.default).fromPathArray(pathElements).toString();
}
function pathStringToArray(path) {
    return (0, _bip32PathDefault.default).fromString(path).toPathArray();
}
function pubkeyFromXpub(xpub) {
    const xpubBuf = (0, _bs58CheckDefault.default).decode(xpub);
    return xpubBuf.slice(xpubBuf.length - 33);
}
function getXpubComponents(xpub) {
    const xpubBuf = (0, _bs58CheckDefault.default).decode(xpub);
    return {
        chaincode: xpubBuf.slice(13, 45),
        pubkey: xpubBuf.slice(xpubBuf.length - 33),
        version: xpubBuf.readUInt32BE(0)
    };
}
function hardenedPathOf(pathElements) {
    for(let i = pathElements.length - 1; i >= 0; i--){
        if (pathElements[i] >= 0x80000000) return pathElements.slice(0, i + 1);
    }
    return [];
}

},{"5e420757a688a32d":"bwvMq","bip32-path":"6n4iS","bs58check":"d8uT8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6n4iS":[function(require,module,exports) {
/*
 * Bitcoin BIP32 path helpers
 * (C) 2016 Alex Beregszaszi
 */ const HARDENED = 0x80000000;
var BIPPath = function(path) {
    if (!Array.isArray(path)) throw new Error("Input must be an Array");
    if (path.length === 0) throw new Error("Path must contain at least one level");
    for(var i = 0; i < path.length; i++){
        if (typeof path[i] !== "number") throw new Error("Path element is not a number");
    }
    this.path = path;
};
BIPPath.validatePathArray = function(path) {
    try {
        BIPPath.fromPathArray(path);
        return true;
    } catch (e) {
        return false;
    }
};
BIPPath.validateString = function(text, reqRoot) {
    try {
        BIPPath.fromString(text, reqRoot);
        return true;
    } catch (e) {
        return false;
    }
};
BIPPath.fromPathArray = function(path) {
    return new BIPPath(path);
};
BIPPath.fromString = function(text, reqRoot) {
    // skip the root
    if (/^m\//i.test(text)) text = text.slice(2);
    else if (reqRoot) throw new Error("Root element is required");
    var path = text.split("/");
    var ret = new Array(path.length);
    for(var i = 0; i < path.length; i++){
        var tmp = /(\d+)([hH\']?)/.exec(path[i]);
        if (tmp === null) throw new Error("Invalid input");
        ret[i] = parseInt(tmp[1], 10);
        if (ret[i] >= HARDENED) throw new Error("Invalid child index");
        if (tmp[2] === "h" || tmp[2] === "H" || tmp[2] === "'") ret[i] += HARDENED;
        else if (tmp[2].length != 0) throw new Error("Invalid modifier");
    }
    return new BIPPath(ret);
};
BIPPath.prototype.toPathArray = function() {
    return this.path;
};
BIPPath.prototype.toString = function(noRoot, oldStyle) {
    var ret = new Array(this.path.length);
    for(var i = 0; i < this.path.length; i++){
        var tmp = this.path[i];
        if (tmp & HARDENED) ret[i] = (tmp & ~HARDENED) + (oldStyle ? "h" : "'");
        else ret[i] = tmp;
    }
    return (noRoot ? "" : "m/") + ret.join("/");
};
BIPPath.prototype.inspect = function() {
    return "BIPPath <" + this.toString() + ">";
};
module.exports = BIPPath;

},{}],"fvT7D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeTo64bitLE", ()=>unsafeTo64bitLE);
parcelHelpers.export(exports, "unsafeFrom64bitLE", ()=>unsafeFrom64bitLE);
parcelHelpers.export(exports, "BufferWriter", ()=>BufferWriter);
parcelHelpers.export(exports, "BufferReader", ()=>BufferReader);
var _varuintBitcoin = require("varuint-bitcoin");
var _varuintBitcoinDefault = parcelHelpers.interopDefault(_varuintBitcoin);
var Buffer = require("9442fd702d288067").Buffer;
function unsafeTo64bitLE(n) {
    // we want to represent the input as a 8-bytes array
    if (n > Number.MAX_SAFE_INTEGER) throw new Error("Can't convert numbers > MAX_SAFE_INT");
    const byteArray = Buffer.alloc(8, 0);
    for(let index = 0; index < byteArray.length; index++){
        const byte = n & 0xff;
        byteArray[index] = byte;
        n = (n - byte) / 256;
    }
    return byteArray;
}
function unsafeFrom64bitLE(byteArray) {
    let value = 0;
    if (byteArray.length != 8) throw new Error("Expected Bufffer of lenght 8");
    if (byteArray[7] != 0) throw new Error("Can't encode numbers > MAX_SAFE_INT");
    if (byteArray[6] > 0x1f) throw new Error("Can't encode numbers > MAX_SAFE_INT");
    for(let i = byteArray.length - 1; i >= 0; i--)value = value * 256 + byteArray[i];
    return value;
}
class BufferWriter {
    constructor(){
        this.bufs = [];
    }
    write(alloc, fn) {
        const b = Buffer.alloc(alloc);
        fn(b);
        this.bufs.push(b);
    }
    writeUInt8(i) {
        this.write(1, (b)=>b.writeUInt8(i, 0));
    }
    writeInt32(i) {
        this.write(4, (b)=>b.writeInt32LE(i, 0));
    }
    writeUInt32(i) {
        this.write(4, (b)=>b.writeUInt32LE(i, 0));
    }
    writeUInt64(i) {
        const bytes = unsafeTo64bitLE(i);
        this.writeSlice(bytes);
    }
    writeVarInt(i) {
        this.bufs.push((0, _varuintBitcoinDefault.default).encode(i));
    }
    writeSlice(slice) {
        this.bufs.push(Buffer.from(slice));
    }
    writeVarSlice(slice) {
        this.writeVarInt(slice.length);
        this.writeSlice(slice);
    }
    buffer() {
        return Buffer.concat(this.bufs);
    }
}
class BufferReader {
    constructor(buffer, offset = 0){
        this.buffer = buffer;
        this.offset = offset;
    }
    available() {
        return this.buffer.length - this.offset;
    }
    readUInt8() {
        const result = this.buffer.readUInt8(this.offset);
        this.offset++;
        return result;
    }
    readInt32() {
        const result = this.buffer.readInt32LE(this.offset);
        this.offset += 4;
        return result;
    }
    readUInt32() {
        const result = this.buffer.readUInt32LE(this.offset);
        this.offset += 4;
        return result;
    }
    readUInt64() {
        const buf = this.readSlice(8);
        const n = unsafeFrom64bitLE(buf);
        return n;
    }
    readVarInt() {
        const vi = (0, _varuintBitcoinDefault.default).decode(this.buffer, this.offset);
        this.offset += (0, _varuintBitcoinDefault.default).decode.bytes;
        return vi;
    }
    readSlice(n) {
        if (this.buffer.length < this.offset + n) throw new Error("Cannot read slice out of bounds");
        const result = this.buffer.slice(this.offset, this.offset + n);
        this.offset += n;
        return result;
    }
    readVarSlice() {
        return this.readSlice(this.readVarInt());
    }
    readVector() {
        const count = this.readVarInt();
        const vector = [];
        for(let i = 0; i < count; i++)vector.push(this.readVarSlice());
        return vector;
    }
}

},{"9442fd702d288067":"bwvMq","varuint-bitcoin":"amF5b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iMehs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "p2pkh", ()=>p2pkh);
parcelHelpers.export(exports, "p2tr", ()=>p2tr);
parcelHelpers.export(exports, "p2wpkhWrapped", ()=>p2wpkhWrapped);
parcelHelpers.export(exports, "p2wpkh", ()=>p2wpkh);
var _bitcoinjsLib = require("bitcoinjs-lib");
var _tinySecp256K1 = require("tiny-secp256k1");
var _buffertools = require("../buffertools");
var _constants = require("../constants");
var _hashPublicKey = require("../hashPublicKey");
var Buffer = require("48af66094b1511ad").Buffer;
class BaseAccount {
    constructor(psbt, masterFp){
        this.psbt = psbt;
        this.masterFp = masterFp;
    }
}
/**
 * Superclass for single signature accounts. This will make sure that the pubkey
 * arrays and path arrays in the method arguments contains exactly one element
 * and calls an abstract method to do the actual work.
 */ class SingleKeyAccount extends BaseAccount {
    spendingCondition(pubkeys) {
        if (pubkeys.length != 1) throw new Error("Expected single key, got " + pubkeys.length);
        return this.singleKeyCondition(pubkeys[0]);
    }
    setInput(i, inputTx, spentOutput, pubkeys, pathElems) {
        if (pubkeys.length != 1) throw new Error("Expected single key, got " + pubkeys.length);
        if (pathElems.length != 1) throw new Error("Expected single path, got " + pathElems.length);
        this.setSingleKeyInput(i, inputTx, spentOutput, pubkeys[0], pathElems[0]);
    }
    setOwnOutput(i, cond, pubkeys, paths) {
        if (pubkeys.length != 1) throw new Error("Expected single key, got " + pubkeys.length);
        if (paths.length != 1) throw new Error("Expected single path, got " + paths.length);
        this.setSingleKeyOutput(i, cond, pubkeys[0], paths[0]);
    }
}
class p2pkh extends SingleKeyAccount {
    singleKeyCondition(pubkey) {
        const buf = new (0, _buffertools.BufferWriter)();
        const pubkeyHash = (0, _hashPublicKey.hashPublicKey)(pubkey);
        buf.writeSlice(Buffer.from([
            (0, _constants.OP_DUP),
            (0, _constants.OP_HASH160),
            (0, _constants.HASH_SIZE)
        ]));
        buf.writeSlice(pubkeyHash);
        buf.writeSlice(Buffer.from([
            (0, _constants.OP_EQUALVERIFY),
            (0, _constants.OP_CHECKSIG)
        ]));
        return {
            scriptPubKey: buf.buffer()
        };
    }
    setSingleKeyInput(i, inputTx, _spentOutput, pubkey, path) {
        if (!inputTx) throw new Error("Full input base transaction required");
        this.psbt.setInputNonWitnessUtxo(i, inputTx);
        this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);
    }
    setSingleKeyOutput(i, cond, pubkey, path) {
        this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);
    }
    getDescriptorTemplate() {
        return "pkh(@0)";
    }
}
class p2tr extends SingleKeyAccount {
    singleKeyCondition(pubkey) {
        const xonlyPubkey = pubkey.slice(1); // x-only pubkey
        const buf = new (0, _buffertools.BufferWriter)();
        const outputKey = this.getTaprootOutputKey(xonlyPubkey);
        buf.writeSlice(Buffer.from([
            0x51,
            32
        ])); // push1, pubkeylen
        buf.writeSlice(outputKey);
        return {
            scriptPubKey: buf.buffer()
        };
    }
    setSingleKeyInput(i, _inputTx, spentOutput, pubkey, path) {
        const xonly = pubkey.slice(1);
        this.psbt.setInputTapBip32Derivation(i, xonly, [], this.masterFp, path);
        this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);
    }
    setSingleKeyOutput(i, cond, pubkey, path) {
        const xonly = pubkey.slice(1);
        this.psbt.setOutputTapBip32Derivation(i, xonly, [], this.masterFp, path);
    }
    getDescriptorTemplate() {
        return "tr(@0)";
    }
    /*
    The following two functions are copied from wallet-btc and adapted.
    They should be moved to a library to avoid code reuse.
    */ hashTapTweak(x) {
        // hash_tag(x) = SHA256(SHA256(tag) || SHA256(tag) || x), see BIP340
        // See https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification
        const h = (0, _bitcoinjsLib.crypto).sha256(Buffer.from("TapTweak", "utf-8"));
        return (0, _bitcoinjsLib.crypto).sha256(Buffer.concat([
            h,
            h,
            x
        ]));
    }
    /**
     * Calculates a taproot output key from an internal key. This output key will be
     * used as witness program in a taproot output. The internal key is tweaked
     * according to recommendation in BIP341:
     * https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_ref-22-0
     *
     * @param internalPubkey A 32 byte x-only taproot internal key
     * @returns The output key
     */ getTaprootOutputKey(internalPubkey) {
        if (internalPubkey.length != 32) throw new Error("Expected 32 byte pubkey. Got " + internalPubkey.length);
        // A BIP32 derived key can be converted to a schnorr pubkey by dropping
        // the first byte, which represent the oddness/evenness. In schnorr all
        // pubkeys are even.
        // https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#public-key-conversion
        const evenEcdsaPubkey = Buffer.concat([
            Buffer.from([
                0x02
            ]),
            internalPubkey
        ]);
        const tweak = this.hashTapTweak(internalPubkey);
        // Q = P + int(hash_TapTweak(bytes(P)))G
        const outputEcdsaKey = Buffer.from((0, _tinySecp256K1.pointAddScalar)(evenEcdsaPubkey, tweak));
        // Convert to schnorr.
        const outputSchnorrKey = outputEcdsaKey.slice(1);
        // Create address
        return outputSchnorrKey;
    }
}
class p2wpkhWrapped extends SingleKeyAccount {
    singleKeyCondition(pubkey) {
        const buf = new (0, _buffertools.BufferWriter)();
        const redeemScript = this.createRedeemScript(pubkey);
        const scriptHash = (0, _hashPublicKey.hashPublicKey)(redeemScript);
        buf.writeSlice(Buffer.from([
            (0, _constants.OP_HASH160),
            (0, _constants.HASH_SIZE)
        ]));
        buf.writeSlice(scriptHash);
        buf.writeUInt8((0, _constants.OP_EQUAL));
        return {
            scriptPubKey: buf.buffer(),
            redeemScript: redeemScript
        };
    }
    setSingleKeyInput(i, inputTx, spentOutput, pubkey, path) {
        if (!inputTx) throw new Error("Full input base transaction required");
        this.psbt.setInputNonWitnessUtxo(i, inputTx);
        this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);
        const userSuppliedRedeemScript = spentOutput.cond.redeemScript;
        const expectedRedeemScript = this.createRedeemScript(pubkey);
        if (userSuppliedRedeemScript && !expectedRedeemScript.equals(userSuppliedRedeemScript)) // At what point might a user set the redeemScript on its own?
        throw new Error(`User-supplied redeemScript ${userSuppliedRedeemScript.toString("hex")} doesn't
       match expected ${expectedRedeemScript.toString("hex")} for input ${i}`);
        this.psbt.setInputRedeemScript(i, expectedRedeemScript);
        this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);
    }
    setSingleKeyOutput(i, cond, pubkey, path) {
        this.psbt.setOutputRedeemScript(i, cond.redeemScript);
        this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);
    }
    getDescriptorTemplate() {
        return "sh(wpkh(@0))";
    }
    createRedeemScript(pubkey) {
        const pubkeyHash = (0, _hashPublicKey.hashPublicKey)(pubkey);
        return Buffer.concat([
            Buffer.from("0014", "hex"),
            pubkeyHash
        ]);
    }
}
class p2wpkh extends SingleKeyAccount {
    singleKeyCondition(pubkey) {
        const buf = new (0, _buffertools.BufferWriter)();
        const pubkeyHash = (0, _hashPublicKey.hashPublicKey)(pubkey);
        buf.writeSlice(Buffer.from([
            0,
            (0, _constants.HASH_SIZE)
        ]));
        buf.writeSlice(pubkeyHash);
        return {
            scriptPubKey: buf.buffer()
        };
    }
    setSingleKeyInput(i, inputTx, spentOutput, pubkey, path) {
        if (!inputTx) throw new Error("Full input base transaction required");
        this.psbt.setInputNonWitnessUtxo(i, inputTx);
        this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);
        this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);
    }
    setSingleKeyOutput(i, cond, pubkey, path) {
        this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);
    }
    getDescriptorTemplate() {
        return "wpkh(@0)";
    }
}

},{"48af66094b1511ad":"bwvMq","bitcoinjs-lib":"cl7fJ","tiny-secp256k1":"aaqVm","../buffertools":"fvT7D","../constants":"6IGza","../hashPublicKey":"8CIgU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6IGza":[function(require,module,exports) {
// the maximum number of bytes allowed in a single chunk when processing bitcoin script data.
// if the Bitcoin script is too large, we will process it in several chunks.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MAX_SCRIPT_BLOCK", ()=>MAX_SCRIPT_BLOCK);
parcelHelpers.export(exports, "DEFAULT_VERSION", ()=>DEFAULT_VERSION);
parcelHelpers.export(exports, "DEFAULT_LOCKTIME", ()=>DEFAULT_LOCKTIME);
parcelHelpers.export(exports, "DEFAULT_SEQUENCE", ()=>DEFAULT_SEQUENCE);
parcelHelpers.export(exports, "SIGHASH_ALL", ()=>SIGHASH_ALL);
parcelHelpers.export(exports, "OP_DUP", ()=>OP_DUP);
parcelHelpers.export(exports, "OP_HASH160", ()=>OP_HASH160);
parcelHelpers.export(exports, "HASH_SIZE", ()=>HASH_SIZE);
parcelHelpers.export(exports, "OP_EQUAL", ()=>OP_EQUAL);
parcelHelpers.export(exports, "OP_EQUALVERIFY", ()=>OP_EQUALVERIFY);
parcelHelpers.export(exports, "OP_CHECKSIG", ()=>OP_CHECKSIG);
parcelHelpers.export(exports, "OP_RETURN", ()=>OP_RETURN);
const MAX_SCRIPT_BLOCK = 50;
const DEFAULT_VERSION = 1;
const DEFAULT_LOCKTIME = 0;
const DEFAULT_SEQUENCE = 0xffffffff;
const SIGHASH_ALL = 1;
const OP_DUP = 0x76;
const OP_HASH160 = 0xa9;
const HASH_SIZE = 0x14;
const OP_EQUAL = 0x87;
const OP_EQUALVERIFY = 0x88;
const OP_CHECKSIG = 0xac;
const OP_RETURN = 0x6a;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8CIgU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hashPublicKey", ()=>hashPublicKey);
var _ripemd160 = require("ripemd160");
var _ripemd160Default = parcelHelpers.interopDefault(_ripemd160);
var _shaJs = require("sha.js");
var _shaJsDefault = parcelHelpers.interopDefault(_shaJs);
function hashPublicKey(buffer) {
    return new (0, _ripemd160Default.default)().update((0, _shaJsDefault.default)("sha256").update(buffer).digest()).digest();
}

},{"ripemd160":"bFDDq","sha.js":"jkn7m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jcnpd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The Bitcon hardware app uses a descriptors-like thing to describe
 * how to construct output scripts from keys. A "Wallet Policy" consists
 * of a "Descriptor Template" and a list of "keys". A key is basically
 * a serialized BIP32 extended public key with some added derivation path
 * information. This is documented at
 * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/wallet.md
 */ parcelHelpers.export(exports, "WalletPolicy", ()=>WalletPolicy);
parcelHelpers.export(exports, "createKey", ()=>createKey);
var _bitcoinjsLib = require("bitcoinjs-lib");
var _bip32 = require("../bip32");
var _buffertools = require("../buffertools");
var _merkle = require("./merkle");
var Buffer = require("2312cd8c99664c51").Buffer;
class WalletPolicy {
    /**
     * For now, we only support default descriptor templates.
     */ constructor(descriptorTemplate, key){
        this.descriptorTemplate = descriptorTemplate;
        this.keys = [
            key
        ];
    }
    getWalletId() {
        // wallet_id (sha256 of the wallet serialization),
        return (0, _bitcoinjsLib.crypto).sha256(this.serialize());
    }
    serialize() {
        const keyBuffers = this.keys.map((k)=>{
            return Buffer.from(k, "ascii");
        });
        const m = new (0, _merkle.Merkle)(keyBuffers.map((k)=>(0, _merkle.hashLeaf)(k)));
        const buf = new (0, _buffertools.BufferWriter)();
        buf.writeUInt8(0x01); // wallet type (policy map)
        buf.writeUInt8(0); // length of wallet name (empty string for default wallets)
        buf.writeVarSlice(Buffer.from(this.descriptorTemplate, "ascii"));
        buf.writeVarInt(this.keys.length), buf.writeSlice(m.getRoot());
        return buf.buffer();
    }
}
function createKey(masterFingerprint, path, xpub) {
    const accountPath = (0, _bip32.pathArrayToString)(path);
    return `[${masterFingerprint.toString("hex")}${accountPath.substring(1)}]${xpub}/**`;
}

},{"2312cd8c99664c51":"bwvMq","bitcoinjs-lib":"cl7fJ","../bip32":"hSMer","../buffertools":"fvT7D","./merkle":"7hIU1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7hIU1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This class implements the merkle tree used by Ledger Bitcoin app v2+,
 * which is documented at
 * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/merkle.md
 */ parcelHelpers.export(exports, "Merkle", ()=>Merkle);
parcelHelpers.export(exports, "hashLeaf", ()=>hashLeaf);
var _bitcoinjsLib = require("bitcoinjs-lib");
var Buffer = require("40326fa452f491b7").Buffer;
class Merkle {
    constructor(leaves, hasher = (0, _bitcoinjsLib.crypto).sha256){
        this.leaves = leaves;
        this.h = hasher;
        const nodes = this.calculateRoot(leaves);
        this.rootNode = nodes.root;
        this.leafNodes = nodes.leaves;
    }
    getRoot() {
        return this.rootNode.hash;
    }
    size() {
        return this.leaves.length;
    }
    getLeaves() {
        return this.leaves;
    }
    getLeafHash(index) {
        return this.leafNodes[index].hash;
    }
    getProof(index) {
        if (index >= this.leaves.length) throw Error("Index out of bounds");
        return proveNode(this.leafNodes[index]);
    }
    calculateRoot(leaves) {
        const n = leaves.length;
        if (n == 0) return {
            root: new Node(undefined, undefined, Buffer.alloc(32, 0)),
            leaves: []
        };
        if (n == 1) {
            const newNode = new Node(undefined, undefined, leaves[0]);
            return {
                root: newNode,
                leaves: [
                    newNode
                ]
            };
        }
        const leftCount = highestPowerOf2LessThan(n);
        const leftBranch = this.calculateRoot(leaves.slice(0, leftCount));
        const rightBranch = this.calculateRoot(leaves.slice(leftCount));
        const leftChild = leftBranch.root;
        const rightChild = rightBranch.root;
        const hash = this.hashNode(leftChild.hash, rightChild.hash);
        const node = new Node(leftChild, rightChild, hash);
        leftChild.parent = node;
        rightChild.parent = node;
        return {
            root: node,
            leaves: leftBranch.leaves.concat(rightBranch.leaves)
        };
    }
    hashNode(left, right) {
        return this.h(Buffer.concat([
            Buffer.from([
                1
            ]),
            left,
            right
        ]));
    }
}
function hashLeaf(buf, hashFunction = (0, _bitcoinjsLib.crypto).sha256) {
    return hashConcat(Buffer.from([
        0
    ]), buf, hashFunction);
}
function hashConcat(bufA, bufB, hashFunction) {
    return hashFunction(Buffer.concat([
        bufA,
        bufB
    ]));
}
class Node {
    constructor(left, right, hash){
        this.leftChild = left;
        this.rightChild = right;
        this.hash = hash;
    }
    isLeaf() {
        return this.leftChild == undefined;
    }
}
function proveNode(node) {
    if (!node.parent) return [];
    if (node.parent.leftChild == node) {
        if (!node.parent.rightChild) throw new Error("Expected right child to exist");
        return [
            node.parent.rightChild.hash,
            ...proveNode(node.parent)
        ];
    } else {
        if (!node.parent.leftChild) throw new Error("Expected left child to exist");
        return [
            node.parent.leftChild.hash,
            ...proveNode(node.parent)
        ];
    }
}
function highestPowerOf2LessThan(n) {
    if (n < 2) throw Error("Expected n >= 2");
    if (isPowerOf2(n)) return n / 2;
    return 1 << Math.floor(Math.log2(n));
}
function isPowerOf2(n) {
    return (n & n - 1) == 0;
}

},{"40326fa452f491b7":"bwvMq","bitcoinjs-lib":"cl7fJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"468CX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This implements the "Transaction Extractor" role of BIP370 (PSBTv2
 * https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#transaction-extractor). However
 * the role is partially documented in BIP174 (PSBTv0
 * https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#transaction-extractor).
 */ parcelHelpers.export(exports, "extract", ()=>extract);
var _buffertools = require("../buffertools");
var Buffer = require("810789617797bbed").Buffer;
function extract(psbt) {
    var _a, _b;
    const tx = new (0, _buffertools.BufferWriter)();
    tx.writeUInt32(psbt.getGlobalTxVersion());
    const isSegwit = !!psbt.getInputWitnessUtxo(0);
    if (isSegwit) tx.writeSlice(Buffer.from([
        0,
        1
    ]));
    const inputCount = psbt.getGlobalInputCount();
    tx.writeVarInt(inputCount);
    const witnessWriter = new (0, _buffertools.BufferWriter)();
    for(let i = 0; i < inputCount; i++){
        tx.writeSlice(psbt.getInputPreviousTxid(i));
        tx.writeUInt32(psbt.getInputOutputIndex(i));
        tx.writeVarSlice((_a = psbt.getInputFinalScriptsig(i)) !== null && _a !== void 0 ? _a : Buffer.from([]));
        tx.writeUInt32(psbt.getInputSequence(i));
        if (isSegwit) witnessWriter.writeSlice(psbt.getInputFinalScriptwitness(i));
    }
    const outputCount = psbt.getGlobalOutputCount();
    tx.writeVarInt(outputCount);
    for(let i = 0; i < outputCount; i++){
        tx.writeUInt64(psbt.getOutputAmount(i));
        tx.writeVarSlice(psbt.getOutputScript(i));
    }
    tx.writeSlice(witnessWriter.buffer());
    tx.writeUInt32((_b = psbt.getGlobalFallbackLocktime()) !== null && _b !== void 0 ? _b : 0);
    return tx.buffer();
}

},{"810789617797bbed":"bwvMq","../buffertools":"fvT7D","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"82GTK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This roughly implements the "input finalizer" role of BIP370 (PSBTv2
 * https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki). However
 * the role is documented in BIP174 (PSBTv0
 * https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki).
 *
 * Verify that all inputs have a signature, and set inputFinalScriptwitness
 * and/or inputFinalScriptSig depending on the type of the spent outputs. Clean
 * fields that aren't useful anymore, partial signatures, redeem script and
 * derivation paths.
 *
 * @param psbt The psbt with all signatures added as partial sigs, either
 * through PSBT_IN_PARTIAL_SIG or PSBT_IN_TAP_KEY_SIG
 */ parcelHelpers.export(exports, "finalize", ()=>finalize);
var _buffertools = require("../buffertools");
var _psbtv2 = require("./psbtv2");
var Buffer = require("2de12fe731997fdf").Buffer;
function finalize(psbt) {
    // First check that each input has a signature
    const inputCount = psbt.getGlobalInputCount();
    for(let i = 0; i < inputCount; i++){
        const legacyPubkeys = psbt.getInputKeyDatas(i, (0, _psbtv2.psbtIn).PARTIAL_SIG);
        const taprootSig = psbt.getInputTapKeySig(i);
        if (legacyPubkeys.length == 0 && !taprootSig) throw Error(`No signature for input ${i} present`);
        if (legacyPubkeys.length > 0) {
            if (legacyPubkeys.length > 1) throw Error(`Expected exactly one signature, got ${legacyPubkeys.length}`);
            if (taprootSig) throw Error("Both taproot and non-taproot signatures present.");
            const isSegwitV0 = !!psbt.getInputWitnessUtxo(i);
            const redeemScript = psbt.getInputRedeemScript(i);
            const isWrappedSegwit = !!redeemScript;
            const signature = psbt.getInputPartialSig(i, legacyPubkeys[0]);
            if (!signature) throw new Error("Expected partial signature for input " + i);
            if (isSegwitV0) {
                const witnessBuf = new (0, _buffertools.BufferWriter)();
                witnessBuf.writeVarInt(2);
                witnessBuf.writeVarInt(signature.length);
                witnessBuf.writeSlice(signature);
                witnessBuf.writeVarInt(legacyPubkeys[0].length);
                witnessBuf.writeSlice(legacyPubkeys[0]);
                psbt.setInputFinalScriptwitness(i, witnessBuf.buffer());
                if (isWrappedSegwit) {
                    if (!redeemScript || redeemScript.length == 0) throw new Error("Expected non-empty redeemscript. Can't finalize intput " + i);
                    const scriptSigBuf = new (0, _buffertools.BufferWriter)();
                    // Push redeemScript length
                    scriptSigBuf.writeUInt8(redeemScript.length);
                    scriptSigBuf.writeSlice(redeemScript);
                    psbt.setInputFinalScriptsig(i, scriptSigBuf.buffer());
                }
            } else {
                // Legacy input
                const scriptSig = new (0, _buffertools.BufferWriter)();
                writePush(scriptSig, signature);
                writePush(scriptSig, legacyPubkeys[0]);
                psbt.setInputFinalScriptsig(i, scriptSig.buffer());
            }
        } else {
            // Taproot input
            const signature = psbt.getInputTapKeySig(i);
            if (!signature) throw Error("No taproot signature found");
            if (signature.length != 64 && signature.length != 65) throw Error("Unexpected length of schnorr signature.");
            const witnessBuf = new (0, _buffertools.BufferWriter)();
            witnessBuf.writeVarInt(1);
            witnessBuf.writeVarSlice(signature);
            psbt.setInputFinalScriptwitness(i, witnessBuf.buffer());
        }
        clearFinalizedInput(psbt, i);
    }
}
/**
 * Deletes fields that are no longer neccesary from the psbt.
 *
 * Note, the spec doesn't say anything about removing ouput fields
 * like PSBT_OUT_BIP32_DERIVATION_PATH and others, so we keep them
 * without actually knowing why. I think we should remove them too.
 */ function clearFinalizedInput(psbt, inputIndex) {
    const keyTypes = [
        (0, _psbtv2.psbtIn).BIP32_DERIVATION,
        (0, _psbtv2.psbtIn).PARTIAL_SIG,
        (0, _psbtv2.psbtIn).TAP_BIP32_DERIVATION,
        (0, _psbtv2.psbtIn).TAP_KEY_SIG
    ];
    const witnessUtxoAvailable = !!psbt.getInputWitnessUtxo(inputIndex);
    const nonWitnessUtxoAvailable = !!psbt.getInputNonWitnessUtxo(inputIndex);
    if (witnessUtxoAvailable && nonWitnessUtxoAvailable) // Remove NON_WITNESS_UTXO for segwit v0 as it's only needed while signing.
    // Segwit v1 doesn't have NON_WITNESS_UTXO set.
    // See https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#cite_note-7
    keyTypes.push((0, _psbtv2.psbtIn).NON_WITNESS_UTXO);
    psbt.deleteInputEntries(inputIndex, keyTypes);
}
/**
 * Writes a script push operation to buf, which looks different
 * depending on the size of the data. See
 * https://en.bitcoin.it/wiki/Script#Constants
 *
 * @param buf the BufferWriter to write to
 * @param data the Buffer to be pushed.
 */ function writePush(buf, data) {
    if (data.length <= 75) buf.writeUInt8(data.length);
    else if (data.length <= 256) {
        buf.writeUInt8(76);
        buf.writeUInt8(data.length);
    } else if (data.length <= 65536) {
        buf.writeUInt8(77);
        const b = Buffer.alloc(2);
        b.writeUInt16LE(data.length, 0);
        buf.writeSlice(b);
    }
    buf.writeSlice(data);
}

},{"2de12fe731997fdf":"bwvMq","../buffertools":"fvT7D","./psbtv2":"hOmf5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hOmf5":[function(require,module,exports) {
/* eslint-disable @typescript-eslint/no-non-null-assertion */ /* eslint-disable @typescript-eslint/explicit-module-boundary-types */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "psbtGlobal", ()=>psbtGlobal);
parcelHelpers.export(exports, "psbtIn", ()=>psbtIn);
parcelHelpers.export(exports, "psbtOut", ()=>psbtOut);
parcelHelpers.export(exports, "NoSuchEntry", ()=>NoSuchEntry);
/**
 * Implements Partially Signed Bitcoin Transaction version 2, BIP370, as
 * documented at https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki
 * and https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki
 *
 * A psbt is a data structure that can carry all relevant information about a
 * transaction through all stages of the signing process. From constructing an
 * unsigned transaction to extracting the final serialized transaction ready for
 * broadcast.
 *
 * This implementation is limited to what's needed in ledgerjs to carry out its
 * duties, which means that support for features like multisig or taproot script
 * path spending are not implemented. Specifically, it supports p2pkh,
 * p2wpkhWrappedInP2sh, p2wpkh and p2tr key path spending.
 *
 * This class is made purposefully dumb, so it's easy to add support for
 * complemantary fields as needed in the future.
 */ parcelHelpers.export(exports, "PsbtV2", ()=>PsbtV2);
var _buffertools = require("../buffertools");
var Buffer = require("dbff9bbb1366e0f8").Buffer;
var psbtGlobal;
(function(psbtGlobal) {
    psbtGlobal[psbtGlobal["TX_VERSION"] = 2] = "TX_VERSION";
    psbtGlobal[psbtGlobal["FALLBACK_LOCKTIME"] = 3] = "FALLBACK_LOCKTIME";
    psbtGlobal[psbtGlobal["INPUT_COUNT"] = 4] = "INPUT_COUNT";
    psbtGlobal[psbtGlobal["OUTPUT_COUNT"] = 5] = "OUTPUT_COUNT";
    psbtGlobal[psbtGlobal["TX_MODIFIABLE"] = 6] = "TX_MODIFIABLE";
    psbtGlobal[psbtGlobal["VERSION"] = 251] = "VERSION";
})(psbtGlobal || (psbtGlobal = {}));
var psbtIn;
(function(psbtIn) {
    psbtIn[psbtIn["NON_WITNESS_UTXO"] = 0] = "NON_WITNESS_UTXO";
    psbtIn[psbtIn["WITNESS_UTXO"] = 1] = "WITNESS_UTXO";
    psbtIn[psbtIn["PARTIAL_SIG"] = 2] = "PARTIAL_SIG";
    psbtIn[psbtIn["SIGHASH_TYPE"] = 3] = "SIGHASH_TYPE";
    psbtIn[psbtIn["REDEEM_SCRIPT"] = 4] = "REDEEM_SCRIPT";
    psbtIn[psbtIn["BIP32_DERIVATION"] = 6] = "BIP32_DERIVATION";
    psbtIn[psbtIn["FINAL_SCRIPTSIG"] = 7] = "FINAL_SCRIPTSIG";
    psbtIn[psbtIn["FINAL_SCRIPTWITNESS"] = 8] = "FINAL_SCRIPTWITNESS";
    psbtIn[psbtIn["PREVIOUS_TXID"] = 14] = "PREVIOUS_TXID";
    psbtIn[psbtIn["OUTPUT_INDEX"] = 15] = "OUTPUT_INDEX";
    psbtIn[psbtIn["SEQUENCE"] = 16] = "SEQUENCE";
    psbtIn[psbtIn["TAP_KEY_SIG"] = 19] = "TAP_KEY_SIG";
    psbtIn[psbtIn["TAP_BIP32_DERIVATION"] = 22] = "TAP_BIP32_DERIVATION";
})(psbtIn || (psbtIn = {}));
var psbtOut;
(function(psbtOut) {
    psbtOut[psbtOut["REDEEM_SCRIPT"] = 0] = "REDEEM_SCRIPT";
    psbtOut[psbtOut["BIP_32_DERIVATION"] = 2] = "BIP_32_DERIVATION";
    psbtOut[psbtOut["AMOUNT"] = 3] = "AMOUNT";
    psbtOut[psbtOut["SCRIPT"] = 4] = "SCRIPT";
    psbtOut[psbtOut["TAP_BIP32_DERIVATION"] = 7] = "TAP_BIP32_DERIVATION";
})(psbtOut || (psbtOut = {}));
const PSBT_MAGIC_BYTES = Buffer.from([
    0x70,
    0x73,
    0x62,
    0x74,
    0xff
]);
class NoSuchEntry extends Error {
}
class PsbtV2 {
    constructor(){
        this.globalMap = new Map();
        this.inputMaps = [];
        this.outputMaps = [];
    }
    setGlobalTxVersion(version) {
        this.setGlobal(psbtGlobal.TX_VERSION, uint32LE(version));
    }
    getGlobalTxVersion() {
        return this.getGlobal(psbtGlobal.TX_VERSION).readUInt32LE(0);
    }
    setGlobalFallbackLocktime(locktime) {
        this.setGlobal(psbtGlobal.FALLBACK_LOCKTIME, uint32LE(locktime));
    }
    getGlobalFallbackLocktime() {
        var _a;
        return (_a = this.getGlobalOptional(psbtGlobal.FALLBACK_LOCKTIME)) === null || _a === void 0 ? void 0 : _a.readUInt32LE(0);
    }
    setGlobalInputCount(inputCount) {
        this.setGlobal(psbtGlobal.INPUT_COUNT, varint(inputCount));
    }
    getGlobalInputCount() {
        return fromVarint(this.getGlobal(psbtGlobal.INPUT_COUNT));
    }
    setGlobalOutputCount(outputCount) {
        this.setGlobal(psbtGlobal.OUTPUT_COUNT, varint(outputCount));
    }
    getGlobalOutputCount() {
        return fromVarint(this.getGlobal(psbtGlobal.OUTPUT_COUNT));
    }
    setGlobalTxModifiable(byte) {
        this.setGlobal(psbtGlobal.TX_MODIFIABLE, byte);
    }
    getGlobalTxModifiable() {
        return this.getGlobalOptional(psbtGlobal.TX_MODIFIABLE);
    }
    setGlobalPsbtVersion(psbtVersion) {
        this.setGlobal(psbtGlobal.VERSION, uint32LE(psbtVersion));
    }
    getGlobalPsbtVersion() {
        return this.getGlobal(psbtGlobal.VERSION).readUInt32LE(0);
    }
    setInputNonWitnessUtxo(inputIndex, transaction) {
        this.setInput(inputIndex, psbtIn.NON_WITNESS_UTXO, b(), transaction);
    }
    getInputNonWitnessUtxo(inputIndex) {
        return this.getInputOptional(inputIndex, psbtIn.NON_WITNESS_UTXO, b());
    }
    setInputWitnessUtxo(inputIndex, amount, scriptPubKey) {
        const buf = new (0, _buffertools.BufferWriter)();
        buf.writeSlice(amount);
        buf.writeVarSlice(scriptPubKey);
        this.setInput(inputIndex, psbtIn.WITNESS_UTXO, b(), buf.buffer());
    }
    getInputWitnessUtxo(inputIndex) {
        const utxo = this.getInputOptional(inputIndex, psbtIn.WITNESS_UTXO, b());
        if (!utxo) return undefined;
        const buf = new (0, _buffertools.BufferReader)(utxo);
        return {
            amount: buf.readSlice(8),
            scriptPubKey: buf.readVarSlice()
        };
    }
    setInputPartialSig(inputIndex, pubkey, signature) {
        this.setInput(inputIndex, psbtIn.PARTIAL_SIG, pubkey, signature);
    }
    getInputPartialSig(inputIndex, pubkey) {
        return this.getInputOptional(inputIndex, psbtIn.PARTIAL_SIG, pubkey);
    }
    setInputSighashType(inputIndex, sigHashtype) {
        this.setInput(inputIndex, psbtIn.SIGHASH_TYPE, b(), uint32LE(sigHashtype));
    }
    getInputSighashType(inputIndex) {
        const result = this.getInputOptional(inputIndex, psbtIn.SIGHASH_TYPE, b());
        if (!result) return undefined;
        return result.readUInt32LE(0);
    }
    setInputRedeemScript(inputIndex, redeemScript) {
        this.setInput(inputIndex, psbtIn.REDEEM_SCRIPT, b(), redeemScript);
    }
    getInputRedeemScript(inputIndex) {
        return this.getInputOptional(inputIndex, psbtIn.REDEEM_SCRIPT, b());
    }
    setInputBip32Derivation(inputIndex, pubkey, masterFingerprint, path) {
        if (pubkey.length != 33) throw new Error("Invalid pubkey length: " + pubkey.length);
        this.setInput(inputIndex, psbtIn.BIP32_DERIVATION, pubkey, this.encodeBip32Derivation(masterFingerprint, path));
    }
    getInputBip32Derivation(inputIndex, pubkey) {
        const buf = this.getInputOptional(inputIndex, psbtIn.BIP32_DERIVATION, pubkey);
        if (!buf) return undefined;
        return this.decodeBip32Derivation(buf);
    }
    setInputFinalScriptsig(inputIndex, scriptSig) {
        this.setInput(inputIndex, psbtIn.FINAL_SCRIPTSIG, b(), scriptSig);
    }
    getInputFinalScriptsig(inputIndex) {
        return this.getInputOptional(inputIndex, psbtIn.FINAL_SCRIPTSIG, b());
    }
    setInputFinalScriptwitness(inputIndex, scriptWitness) {
        this.setInput(inputIndex, psbtIn.FINAL_SCRIPTWITNESS, b(), scriptWitness);
    }
    getInputFinalScriptwitness(inputIndex) {
        return this.getInput(inputIndex, psbtIn.FINAL_SCRIPTWITNESS, b());
    }
    setInputPreviousTxId(inputIndex, txid) {
        this.setInput(inputIndex, psbtIn.PREVIOUS_TXID, b(), txid);
    }
    getInputPreviousTxid(inputIndex) {
        return this.getInput(inputIndex, psbtIn.PREVIOUS_TXID, b());
    }
    setInputOutputIndex(inputIndex, outputIndex) {
        this.setInput(inputIndex, psbtIn.OUTPUT_INDEX, b(), uint32LE(outputIndex));
    }
    getInputOutputIndex(inputIndex) {
        return this.getInput(inputIndex, psbtIn.OUTPUT_INDEX, b()).readUInt32LE(0);
    }
    setInputSequence(inputIndex, sequence) {
        this.setInput(inputIndex, psbtIn.SEQUENCE, b(), uint32LE(sequence));
    }
    getInputSequence(inputIndex) {
        var _a, _b;
        return (_b = (_a = this.getInputOptional(inputIndex, psbtIn.SEQUENCE, b())) === null || _a === void 0 ? void 0 : _a.readUInt32LE(0)) !== null && _b !== void 0 ? _b : 0xffffffff;
    }
    setInputTapKeySig(inputIndex, sig) {
        this.setInput(inputIndex, psbtIn.TAP_KEY_SIG, b(), sig);
    }
    getInputTapKeySig(inputIndex) {
        return this.getInputOptional(inputIndex, psbtIn.TAP_KEY_SIG, b());
    }
    setInputTapBip32Derivation(inputIndex, pubkey, hashes, masterFingerprint, path) {
        if (pubkey.length != 32) throw new Error("Invalid pubkey length: " + pubkey.length);
        const buf = this.encodeTapBip32Derivation(hashes, masterFingerprint, path);
        this.setInput(inputIndex, psbtIn.TAP_BIP32_DERIVATION, pubkey, buf);
    }
    getInputTapBip32Derivation(inputIndex, pubkey) {
        const buf = this.getInput(inputIndex, psbtIn.TAP_BIP32_DERIVATION, pubkey);
        return this.decodeTapBip32Derivation(buf);
    }
    getInputKeyDatas(inputIndex, keyType) {
        return this.getKeyDatas(this.inputMaps[inputIndex], keyType);
    }
    setOutputRedeemScript(outputIndex, redeemScript) {
        this.setOutput(outputIndex, psbtOut.REDEEM_SCRIPT, b(), redeemScript);
    }
    getOutputRedeemScript(outputIndex) {
        return this.getOutput(outputIndex, psbtOut.REDEEM_SCRIPT, b());
    }
    setOutputBip32Derivation(outputIndex, pubkey, masterFingerprint, path) {
        this.setOutput(outputIndex, psbtOut.BIP_32_DERIVATION, pubkey, this.encodeBip32Derivation(masterFingerprint, path));
    }
    getOutputBip32Derivation(outputIndex, pubkey) {
        const buf = this.getOutput(outputIndex, psbtOut.BIP_32_DERIVATION, pubkey);
        return this.decodeBip32Derivation(buf);
    }
    setOutputAmount(outputIndex, amount) {
        this.setOutput(outputIndex, psbtOut.AMOUNT, b(), uint64LE(amount));
    }
    getOutputAmount(outputIndex) {
        const buf = this.getOutput(outputIndex, psbtOut.AMOUNT, b());
        return (0, _buffertools.unsafeFrom64bitLE)(buf);
    }
    setOutputScript(outputIndex, scriptPubKey) {
        this.setOutput(outputIndex, psbtOut.SCRIPT, b(), scriptPubKey);
    }
    getOutputScript(outputIndex) {
        return this.getOutput(outputIndex, psbtOut.SCRIPT, b());
    }
    setOutputTapBip32Derivation(outputIndex, pubkey, hashes, fingerprint, path) {
        const buf = this.encodeTapBip32Derivation(hashes, fingerprint, path);
        this.setOutput(outputIndex, psbtOut.TAP_BIP32_DERIVATION, pubkey, buf);
    }
    getOutputTapBip32Derivation(outputIndex, pubkey) {
        const buf = this.getOutput(outputIndex, psbtOut.TAP_BIP32_DERIVATION, pubkey);
        return this.decodeTapBip32Derivation(buf);
    }
    deleteInputEntries(inputIndex, keyTypes) {
        const map = this.inputMaps[inputIndex];
        map.forEach((_v, k, m)=>{
            if (this.isKeyType(k, keyTypes)) m.delete(k);
        });
    }
    copy(to) {
        this.copyMap(this.globalMap, to.globalMap);
        this.copyMaps(this.inputMaps, to.inputMaps);
        this.copyMaps(this.outputMaps, to.outputMaps);
    }
    copyMaps(from, to) {
        from.forEach((m, index)=>{
            const to_index = new Map();
            this.copyMap(m, to_index);
            to[index] = to_index;
        });
    }
    copyMap(from, to) {
        from.forEach((v, k)=>to.set(k, Buffer.from(v)));
    }
    serialize() {
        const buf = new (0, _buffertools.BufferWriter)();
        buf.writeSlice(Buffer.from([
            0x70,
            0x73,
            0x62,
            0x74,
            0xff
        ]));
        serializeMap(buf, this.globalMap);
        this.inputMaps.forEach((map)=>{
            serializeMap(buf, map);
        });
        this.outputMaps.forEach((map)=>{
            serializeMap(buf, map);
        });
        return buf.buffer();
    }
    deserialize(psbt) {
        const buf = new (0, _buffertools.BufferReader)(psbt);
        if (!buf.readSlice(5).equals(PSBT_MAGIC_BYTES)) throw new Error("Invalid magic bytes");
        while(this.readKeyPair(this.globalMap, buf));
        for(let i = 0; i < this.getGlobalInputCount(); i++){
            this.inputMaps[i] = new Map();
            while(this.readKeyPair(this.inputMaps[i], buf));
        }
        for(let i = 0; i < this.getGlobalOutputCount(); i++){
            this.outputMaps[i] = new Map();
            while(this.readKeyPair(this.outputMaps[i], buf));
        }
    }
    readKeyPair(map, buf) {
        const keyLen = buf.readVarInt();
        if (keyLen == 0) return false;
        const keyType = buf.readUInt8();
        const keyData = buf.readSlice(keyLen - 1);
        const value = buf.readVarSlice();
        set(map, keyType, keyData, value);
        return true;
    }
    getKeyDatas(map, keyType) {
        const result = [];
        map.forEach((_v, k)=>{
            if (this.isKeyType(k, [
                keyType
            ])) result.push(Buffer.from(k.substring(2), "hex"));
        });
        return result;
    }
    isKeyType(hexKey, keyTypes) {
        const keyType = Buffer.from(hexKey.substring(0, 2), "hex").readUInt8(0);
        return keyTypes.some((k)=>k == keyType);
    }
    setGlobal(keyType, value) {
        const key = new Key(keyType, Buffer.from([]));
        this.globalMap.set(key.toString(), value);
    }
    getGlobal(keyType) {
        return get(this.globalMap, keyType, b(), false);
    }
    getGlobalOptional(keyType) {
        return get(this.globalMap, keyType, b(), true);
    }
    setInput(index, keyType, keyData, value) {
        set(this.getMap(index, this.inputMaps), keyType, keyData, value);
    }
    getInput(index, keyType, keyData) {
        return get(this.inputMaps[index], keyType, keyData, false);
    }
    getInputOptional(index, keyType, keyData) {
        return get(this.inputMaps[index], keyType, keyData, true);
    }
    setOutput(index, keyType, keyData, value) {
        set(this.getMap(index, this.outputMaps), keyType, keyData, value);
    }
    getOutput(index, keyType, keyData) {
        return get(this.outputMaps[index], keyType, keyData, false);
    }
    getMap(index, maps) {
        if (maps[index]) return maps[index];
        return maps[index] = new Map();
    }
    encodeBip32Derivation(masterFingerprint, path) {
        const buf = new (0, _buffertools.BufferWriter)();
        this.writeBip32Derivation(buf, masterFingerprint, path);
        return buf.buffer();
    }
    decodeBip32Derivation(buffer) {
        const buf = new (0, _buffertools.BufferReader)(buffer);
        return this.readBip32Derivation(buf);
    }
    writeBip32Derivation(buf, masterFingerprint, path) {
        buf.writeSlice(masterFingerprint);
        path.forEach((element)=>{
            buf.writeUInt32(element);
        });
    }
    readBip32Derivation(buf) {
        const masterFingerprint = buf.readSlice(4);
        const path = [];
        while(buf.offset < buf.buffer.length)path.push(buf.readUInt32());
        return {
            masterFingerprint,
            path
        };
    }
    encodeTapBip32Derivation(hashes, masterFingerprint, path) {
        const buf = new (0, _buffertools.BufferWriter)();
        buf.writeVarInt(hashes.length);
        hashes.forEach((h)=>{
            buf.writeSlice(h);
        });
        this.writeBip32Derivation(buf, masterFingerprint, path);
        return buf.buffer();
    }
    decodeTapBip32Derivation(buffer) {
        const buf = new (0, _buffertools.BufferReader)(buffer);
        const hashCount = buf.readVarInt();
        const hashes = [];
        for(let i = 0; i < hashCount; i++)hashes.push(buf.readSlice(32));
        const deriv = this.readBip32Derivation(buf);
        return Object.assign({
            hashes
        }, deriv);
    }
}
function get(map, keyType, keyData, acceptUndefined) {
    if (!map) throw Error("No such map");
    const key = new Key(keyType, keyData);
    const value = map.get(key.toString());
    if (!value) {
        if (acceptUndefined) return undefined;
        throw new NoSuchEntry(key.toString());
    }
    // Make sure to return a copy, to protect the underlying data.
    return Buffer.from(value);
}
class Key {
    constructor(keyType, keyData){
        this.keyType = keyType;
        this.keyData = keyData;
    }
    toString() {
        const buf = new (0, _buffertools.BufferWriter)();
        this.toBuffer(buf);
        return buf.buffer().toString("hex");
    }
    serialize(buf) {
        buf.writeVarInt(1 + this.keyData.length);
        this.toBuffer(buf);
    }
    toBuffer(buf) {
        buf.writeUInt8(this.keyType);
        buf.writeSlice(this.keyData);
    }
}
class KeyPair {
    constructor(key, value){
        this.key = key;
        this.value = value;
    }
    serialize(buf) {
        this.key.serialize(buf);
        buf.writeVarSlice(this.value);
    }
}
function createKey(buf) {
    return new Key(buf.readUInt8(0), buf.slice(1));
}
function serializeMap(buf, map) {
    for (const k of map.keys()){
        const value = map.get(k);
        const keyPair = new KeyPair(createKey(Buffer.from(k, "hex")), value);
        keyPair.serialize(buf);
    }
    buf.writeUInt8(0);
}
function b() {
    return Buffer.from([]);
}
function set(map, keyType, keyData, value) {
    const key = new Key(keyType, keyData);
    map.set(key.toString(), value);
}
function uint32LE(n) {
    const b = Buffer.alloc(4);
    b.writeUInt32LE(n, 0);
    return b;
}
function uint64LE(n) {
    return (0, _buffertools.unsafeTo64bitLE)(n);
}
function varint(n) {
    const b = new (0, _buffertools.BufferWriter)();
    b.writeVarInt(n);
    return b.buffer();
}
function fromVarint(buf) {
    return new (0, _buffertools.BufferReader)(buf).readVarInt();
}

},{"dbff9bbb1366e0f8":"bwvMq","../buffertools":"fvT7D","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c5bE0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
  @example
const tx1 = btc.splitTransaction("01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000");
const outputScript = btc.serializeTransactionOutputs(tx1).toString('hex');
  */ parcelHelpers.export(exports, "serializeTransactionOutputs", ()=>serializeTransactionOutputs);
parcelHelpers.export(exports, "serializeTransaction", ()=>serializeTransaction);
var _varint = require("./varint");
var Buffer = require("2569f3e5b068b62f").Buffer;
function serializeTransactionOutputs({ outputs }) {
    let outputBuffer = Buffer.alloc(0);
    if (typeof outputs !== "undefined") {
        outputBuffer = Buffer.concat([
            outputBuffer,
            (0, _varint.createVarint)(outputs.length)
        ]);
        outputs.forEach((output)=>{
            outputBuffer = Buffer.concat([
                outputBuffer,
                output.amount,
                (0, _varint.createVarint)(output.script.length),
                output.script
            ]);
        });
    }
    return outputBuffer;
}
function serializeTransaction(transaction, skipWitness, timestamp, additionals = []) {
    const isDecred = additionals.includes("decred");
    const isZcash = additionals.includes("zcash");
    const isBech32 = additionals.includes("bech32");
    let inputBuffer = Buffer.alloc(0);
    const useWitness = typeof transaction["witness"] != "undefined" && !skipWitness;
    transaction.inputs.forEach((input)=>{
        inputBuffer = isDecred || isBech32 ? Buffer.concat([
            inputBuffer,
            input.prevout,
            Buffer.from([
                0x00
            ]),
            input.sequence
        ]) : Buffer.concat([
            inputBuffer,
            input.prevout,
            (0, _varint.createVarint)(input.script.length),
            input.script,
            input.sequence
        ]);
    });
    let outputBuffer = serializeTransactionOutputs(transaction);
    if (typeof transaction.outputs !== "undefined" && typeof transaction.locktime !== "undefined") outputBuffer = Buffer.concat([
        outputBuffer,
        useWitness && transaction.witness || Buffer.alloc(0),
        transaction.locktime,
        transaction.nExpiryHeight || Buffer.alloc(0),
        transaction.extraData || Buffer.alloc(0)
    ]);
    // from to https://zips.z.cash/zip-0225, zcash is different with other coins, the lock_time and nExpiryHeight fields are before the inputs and outputs
    if (isZcash) return Buffer.concat([
        transaction.version,
        transaction.nVersionGroupId || Buffer.alloc(0),
        Buffer.from([
            0xb4,
            0xd0,
            0xd6,
            0xc2
        ]),
        transaction.locktime || Buffer.from([
            0x00,
            0x00,
            0x00,
            0x00
        ]),
        transaction.nExpiryHeight || Buffer.from([
            0x00,
            0x00,
            0x00,
            0x00
        ]),
        useWitness ? Buffer.from("0001", "hex") : Buffer.alloc(0),
        (0, _varint.createVarint)(transaction.inputs.length),
        inputBuffer,
        outputBuffer
    ]);
    return Buffer.concat([
        transaction.version,
        timestamp ? timestamp : Buffer.alloc(0),
        transaction.nVersionGroupId || Buffer.alloc(0),
        useWitness ? Buffer.from("0001", "hex") : Buffer.alloc(0),
        (0, _varint.createVarint)(transaction.inputs.length),
        inputBuffer,
        outputBuffer
    ]);
}

},{"2569f3e5b068b62f":"bwvMq","./varint":"k9xXc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k9xXc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getVarint", ()=>getVarint);
parcelHelpers.export(exports, "createVarint", ()=>createVarint);
var Buffer = require("6f830bdefc01a14f").Buffer;
function getVarint(data, offset) {
    if (data[offset] < 0xfd) return [
        data[offset],
        1
    ];
    if (data[offset] === 0xfd) return [
        (data[offset + 2] << 8) + data[offset + 1],
        3
    ];
    if (data[offset] === 0xfe) return [
        (data[offset + 4] << 24) + (data[offset + 3] << 16) + (data[offset + 2] << 8) + data[offset + 1],
        5
    ];
    throw new Error("getVarint called with unexpected parameters");
}
function createVarint(value) {
    if (value < 0xfd) {
        const buffer = Buffer.alloc(1);
        buffer[0] = value;
        return buffer;
    }
    if (value <= 0xffff) {
        const buffer = Buffer.alloc(3);
        buffer[0] = 0xfd;
        buffer[1] = value & 0xff;
        buffer[2] = value >> 8 & 0xff;
        return buffer;
    }
    const buffer = Buffer.alloc(5);
    buffer[0] = 0xfe;
    buffer[1] = value & 0xff;
    buffer[2] = value >> 8 & 0xff;
    buffer[3] = value >> 16 & 0xff;
    buffer[4] = value >> 24 & 0xff;
    return buffer;
}

},{"6f830bdefc01a14f":"bwvMq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fRGXe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bs58 = require("bs58");
var _bs58Default = parcelHelpers.interopDefault(_bs58);
var _ripemd160 = require("ripemd160");
var _ripemd160Default = parcelHelpers.interopDefault(_ripemd160);
var _shaJs = require("sha.js");
var _shaJsDefault = parcelHelpers.interopDefault(_shaJs);
var _createTransaction = require("./createTransaction");
var _getWalletPublicKey = require("./getWalletPublicKey");
var _bip32 = require("./bip32");
var _signMessage = require("./signMessage");
var Buffer = require("dbc97002bb52bcae").Buffer;
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class BtcOld {
    constructor(transport){
        this.transport = transport;
        this.derivationsCache = {};
    }
    derivatePath(path) {
        return __awaiter(this, void 0, void 0, function*() {
            if (this.derivationsCache[path]) return this.derivationsCache[path];
            const res = yield (0, _getWalletPublicKey.getWalletPublicKey)(this.transport, {
                path
            });
            this.derivationsCache[path] = res;
            return res;
        });
    }
    getWalletXpub(_a) {
        return __awaiter(this, arguments, void 0, function*({ path, xpubVersion }) {
            const pathElements = (0, _bip32.pathStringToArray)(path);
            const parentPath = pathElements.slice(0, -1);
            const parentDerivation = yield this.derivatePath((0, _bip32.pathArrayToString)(parentPath));
            const accountDerivation = yield this.derivatePath(path);
            const fingerprint = makeFingerprint(compressPublicKeySECP256(Buffer.from(parentDerivation.publicKey, "hex")));
            const xpub = makeXpub(xpubVersion, pathElements.length, fingerprint, pathElements[pathElements.length - 1], Buffer.from(accountDerivation.chainCode, "hex"), compressPublicKeySECP256(Buffer.from(accountDerivation.publicKey, "hex")));
            return xpub;
        });
    }
    /**
     * @param path a BIP 32 path
     * @param options an object with optional these fields:
     *
     * - verify (boolean) will ask user to confirm the address on the device
     *
     * - format ("legacy" | "p2sh" | "bech32" | "bech32m" | "cashaddr") to use different bitcoin address formatter.
     *
     * NB The normal usage is to use:
     *
     * - legacy format with 44' paths
     *
     * - p2sh format with 49' paths
     *
     * - bech32 format with 84' paths
     *
     * - bech32m format with 86' paths
     *
     * - cashaddr in case of Bitcoin Cash
     *
     * @example
     * btc.getWalletPublicKey("44'/0'/0'/0/0").then(o => o.bitcoinAddress)
     * btc.getWalletPublicKey("49'/0'/0'/0/0", { format: "p2sh" }).then(o => o.bitcoinAddress)
     */ getWalletPublicKey(path, opts) {
        if ((opts === null || opts === void 0 ? void 0 : opts.format) === "bech32m") throw new Error("Unsupported address format bech32m");
        return (0, _getWalletPublicKey.getWalletPublicKey)(this.transport, Object.assign(Object.assign({}, opts), {
            path
        }));
    }
    /**
     * To sign a transaction involving standard (P2PKH) inputs, call createTransaction with the following parameters
     * @param inputs is an array of [ transaction, output_index, optional redeem script, optional sequence ] where
     *
     * * transaction is the previously computed transaction object for this UTXO
     * * output_index is the output in the transaction used as input for this UTXO (counting from 0)
     * * redeem script is the optional redeem script to use when consuming a Segregated Witness input
     * * sequence is the sequence number to use for this input (when using RBF), or non present
     * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO
     * @param changePath is an optional BIP 32 path pointing to the path to the public key used to compute the change address
     * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign
     * @param lockTime is the optional lockTime of the transaction to sign, or default (0)
     * @param sigHashType is the hash type of the transaction to sign, or default (all)
     * @param segwit is an optional boolean indicating wether to use segwit or not
     * @param additionals list of additionnal options
     *
     * - "bech32" for spending native segwit outputs
     * - "abc" for bch
     * - "gold" for btg
     * - "decred" for decred
     * - "zcash" for zcash
     * - "bipxxx" for using BIPxxx
     * - "sapling" to indicate a zec transaction is supporting sapling (to be set over block 419200)
     * @param expiryHeight is an optional Buffer for zec overwinter / sapling Txs
     * @param useTrustedInputForSegwit trust inputs for segwit transactions
     * @return the signed transaction ready to be broadcast
     * @example
    btc.createTransaction({
     inputs: [ [tx1, 1] ],
     associatedKeysets: ["0'/0/0"],
     outputScriptHex: "01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac"
    }).then(res => ...);
     */ createPaymentTransaction(arg) {
        if (arguments.length > 1) throw new Error("@ledgerhq/hw-app-btc: createPaymentTransaction multi argument signature is deprecated. please switch to named parameters.");
        return (0, _createTransaction.createTransaction)(this.transport, arg);
    }
    signMessage(_a) {
        return __awaiter(this, arguments, void 0, function*({ path, messageHex }) {
            return (0, _signMessage.signMessage)(this.transport, {
                path,
                messageHex
            });
        });
    }
}
exports.default = BtcOld;
function makeFingerprint(compressedPubKey) {
    return hash160(compressedPubKey).slice(0, 4);
}
function asBufferUInt32BE(n) {
    const buf = Buffer.allocUnsafe(4);
    buf.writeUInt32BE(n, 0);
    return buf;
}
const compressPublicKeySECP256 = (publicKey)=>Buffer.concat([
        Buffer.from([
            0x02 + (publicKey[64] & 0x01)
        ]),
        publicKey.slice(1, 33)
    ]);
function makeXpub(version, depth, parentFingerprint, index, chainCode, pubKey) {
    const indexBuffer = asBufferUInt32BE(index);
    indexBuffer[0] |= 0x80;
    const extendedKeyBytes = Buffer.concat([
        asBufferUInt32BE(version),
        Buffer.from([
            depth
        ]),
        parentFingerprint,
        indexBuffer,
        chainCode,
        pubKey
    ]);
    const checksum = hash256(extendedKeyBytes).slice(0, 4);
    return (0, _bs58Default.default).encode(Buffer.concat([
        extendedKeyBytes,
        checksum
    ]));
}
function sha256(buffer) {
    return (0, _shaJsDefault.default)("sha256").update(buffer).digest();
}
function hash256(buffer) {
    return sha256(sha256(buffer));
}
function ripemd160(buffer) {
    return new (0, _ripemd160Default.default)().update(buffer).digest();
}
function hash160(buffer) {
    return ripemd160(sha256(buffer));
}

},{"dbc97002bb52bcae":"bwvMq","bs58":"4ji3p","ripemd160":"bFDDq","sha.js":"jkn7m","./createTransaction":"cs0Wn","./getWalletPublicKey":"3Ipz1","./bip32":"hSMer","./signMessage":"b0Oru","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cs0Wn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createTransaction", ()=>createTransaction);
var _logs = require("@ledgerhq/logs");
var _hashPublicKey = require("./hashPublicKey");
var _getWalletPublicKey = require("./getWalletPublicKey");
var _getTrustedInput = require("./getTrustedInput");
var _startUntrustedHashTransactionInput = require("./startUntrustedHashTransactionInput");
var _serializeTransaction = require("./serializeTransaction");
var _getTrustedInputBIP143 = require("./getTrustedInputBIP143");
var _compressPublicKey = require("./compressPublicKey");
var _signTransaction = require("./signTransaction");
var _finalizeInput = require("./finalizeInput");
var _getAppAndVersion = require("./getAppAndVersion");
var _constants = require("./constants");
var _shouldUseTrustedInputForSegwit = require("./shouldUseTrustedInputForSegwit");
var Buffer = require("e8c5face70df9d93").Buffer;
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const defaultsSignTransaction = {
    lockTime: (0, _constants.DEFAULT_LOCKTIME),
    sigHashType: (0, _constants.SIGHASH_ALL),
    segwit: false,
    additionals: [],
    onDeviceStreaming: (_e)=>{},
    onDeviceSignatureGranted: ()=>{},
    onDeviceSignatureRequested: ()=>{}
};
function createTransaction(transport, arg) {
    return __awaiter(this, void 0, void 0, function*() {
        const signTx = Object.assign(Object.assign({}, defaultsSignTransaction), arg);
        const { inputs, associatedKeysets, changePath, outputScriptHex, lockTime, sigHashType, segwit, additionals, expiryHeight, onDeviceStreaming, onDeviceSignatureGranted, onDeviceSignatureRequested } = signTx;
        let useTrustedInputForSegwit = signTx.useTrustedInputForSegwit;
        if (useTrustedInputForSegwit === undefined) try {
            const a = yield (0, _getAppAndVersion.getAppAndVersion)(transport);
            useTrustedInputForSegwit = (0, _shouldUseTrustedInputForSegwit.shouldUseTrustedInputForSegwit)(a);
        } catch (e) {
            if (e.statusCode === 0x6d00) useTrustedInputForSegwit = false;
            else throw e;
        }
        // loop: 0 or 1 (before and after)
        // i: index of the input being streamed
        // i goes on 0...n, inluding n. in order for the progress value to go to 1
        // we normalize the 2 loops to make a global percentage
        const notify = (loop, i)=>{
            const { length } = inputs;
            if (length < 3) return; // there is not enough significant event to worth notifying (aka just use a spinner)
            const index = length * loop + i;
            const total = 2 * length;
            const progress = index / total;
            onDeviceStreaming({
                progress,
                total,
                index
            });
        };
        const isDecred = additionals.includes("decred");
        const isZcash = additionals.includes("zcash");
        const sapling = additionals.includes("sapling");
        const bech32 = segwit && additionals.includes("bech32");
        const useBip143 = segwit || !!additionals && (additionals.includes("abc") || additionals.includes("gold") || additionals.includes("bip143")) || !!expiryHeight && !isDecred;
        // Inputs are provided as arrays of [transaction, output_index, optional redeem script, optional sequence]
        // associatedKeysets are provided as arrays of [path]
        const lockTimeBuffer = Buffer.alloc(4);
        lockTimeBuffer.writeUInt32LE(lockTime, 0);
        const nullScript = Buffer.alloc(0);
        const nullPrevout = Buffer.alloc(0);
        const defaultVersion = Buffer.alloc(4);
        !!expiryHeight && !isDecred ? defaultVersion.writeUInt32LE(isZcash ? 0x80000005 : sapling ? 0x80000004 : 0x80000003, 0) // v5 format for zcash refer to https://zips.z.cash/zip-0225
         : defaultVersion.writeUInt32LE(1, 0);
        // Default version to 2 for XST not to have timestamp
        const trustedInputs = [];
        const regularOutputs = [];
        const signatures = [];
        const publicKeys = [];
        let firstRun = true;
        const resuming = false;
        const targetTransaction = {
            inputs: [],
            version: defaultVersion,
            timestamp: Buffer.alloc(0)
        };
        const getTrustedInputCall = useBip143 && !useTrustedInputForSegwit ? (0, _getTrustedInputBIP143.getTrustedInputBIP143) : (0, _getTrustedInput.getTrustedInput);
        const outputScript = Buffer.from(outputScriptHex, "hex");
        notify(0, 0);
        // first pass on inputs to get trusted inputs
        for (const input of inputs){
            if (!resuming) {
                const trustedInput = yield getTrustedInputCall(transport, input[1], input[0], additionals);
                (0, _logs.log)("hw", "got trustedInput=" + trustedInput);
                const sequence = Buffer.alloc(4);
                sequence.writeUInt32LE(input.length >= 4 && typeof input[3] === "number" ? input[3] : (0, _constants.DEFAULT_SEQUENCE), 0);
                trustedInputs.push({
                    trustedInput: true,
                    value: Buffer.from(trustedInput, "hex"),
                    sequence
                });
            }
            const { outputs } = input[0];
            const index = input[1];
            if (outputs && index <= outputs.length - 1) regularOutputs.push(outputs[index]);
            if (expiryHeight && !isDecred) {
                targetTransaction.nVersionGroupId = Buffer.from(// nVersionGroupId is 0x26A7270A for zcash NU5 upgrade
                // refer to https://github.com/zcash/zcash/blob/master/src/primitives/transaction.h
                isZcash ? [
                    0x0a,
                    0x27,
                    0xa7,
                    0x26
                ] : sapling ? [
                    0x85,
                    0x20,
                    0x2f,
                    0x89
                ] : [
                    0x70,
                    0x82,
                    0xc4,
                    0x03
                ]);
                targetTransaction.nExpiryHeight = expiryHeight;
                // For sapling : valueBalance (8), nShieldedSpend (1), nShieldedOutput (1), nJoinSplit (1)
                // Overwinter : use nJoinSplit (1)
                targetTransaction.extraData = Buffer.from(sapling ? [
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00
                ] : [
                    0x00
                ]);
            } else if (isDecred) targetTransaction.nExpiryHeight = expiryHeight;
        }
        targetTransaction.inputs = inputs.map((input, idx)=>{
            const sequence = Buffer.alloc(4);
            sequence.writeUInt32LE(input.length >= 4 && typeof input[3] === "number" ? input[3] : (0, _constants.DEFAULT_SEQUENCE), 0);
            return {
                script: isZcash ? regularOutputs[idx].script : nullScript,
                prevout: nullPrevout,
                sequence
            };
        });
        if (!resuming) {
            // Collect public keys
            const result = [];
            for(let i = 0; i < inputs.length; i++){
                const r = yield (0, _getWalletPublicKey.getWalletPublicKey)(transport, {
                    path: associatedKeysets[i]
                });
                notify(0, i + 1);
                result.push(r);
            }
            for(let i = 0; i < result.length; i++)publicKeys.push((0, _compressPublicKey.compressPublicKey)(Buffer.from(result[i].publicKey, "hex")));
        }
        onDeviceSignatureRequested();
        if (useBip143) {
            // Do the first run with all inputs
            yield (0, _startUntrustedHashTransactionInput.startUntrustedHashTransactionInput)(transport, true, targetTransaction, trustedInputs, true, !!expiryHeight, additionals, useTrustedInputForSegwit);
            if (!resuming && changePath) yield (0, _finalizeInput.provideOutputFullChangePath)(transport, changePath);
            yield (0, _finalizeInput.hashOutputFull)(transport, outputScript);
        }
        if (!!expiryHeight && !isDecred) yield (0, _signTransaction.signTransaction)(transport, "", lockTime, (0, _constants.SIGHASH_ALL), expiryHeight);
        // Do the second run with the individual transaction
        for(let i = 0; i < inputs.length; i++){
            const input = inputs[i];
            const script = inputs[i].length >= 3 && typeof input[2] === "string" ? Buffer.from(input[2], "hex") : !segwit ? regularOutputs[i].script : Buffer.concat([
                Buffer.from([
                    (0, _constants.OP_DUP),
                    (0, _constants.OP_HASH160),
                    (0, _constants.HASH_SIZE)
                ]),
                (0, _hashPublicKey.hashPublicKey)(publicKeys[i]),
                Buffer.from([
                    (0, _constants.OP_EQUALVERIFY),
                    (0, _constants.OP_CHECKSIG)
                ])
            ]);
            const pseudoTX = Object.assign({}, targetTransaction);
            const pseudoTrustedInputs = useBip143 ? [
                trustedInputs[i]
            ] : trustedInputs;
            if (useBip143) pseudoTX.inputs = [
                Object.assign(Object.assign({}, pseudoTX.inputs[i]), {
                    script
                })
            ];
            else pseudoTX.inputs[i].script = script;
            yield (0, _startUntrustedHashTransactionInput.startUntrustedHashTransactionInput)(transport, !useBip143 && firstRun, pseudoTX, pseudoTrustedInputs, useBip143, !!expiryHeight && !isDecred, additionals, useTrustedInputForSegwit);
            if (!useBip143) {
                if (!resuming && changePath) yield (0, _finalizeInput.provideOutputFullChangePath)(transport, changePath);
                yield (0, _finalizeInput.hashOutputFull)(transport, outputScript, additionals);
            }
            if (firstRun) {
                onDeviceSignatureGranted();
                notify(1, 0);
            }
            const signature = yield (0, _signTransaction.signTransaction)(transport, associatedKeysets[i], lockTime, sigHashType, expiryHeight, additionals);
            notify(1, i + 1);
            signatures.push(signature);
            targetTransaction.inputs[i].script = nullScript;
            if (firstRun) firstRun = false;
        }
        // Populate the final input scripts
        for(let i = 0; i < inputs.length; i++){
            if (segwit) {
                targetTransaction.witness = Buffer.alloc(0);
                if (!bech32) targetTransaction.inputs[i].script = Buffer.concat([
                    Buffer.from("160014", "hex"),
                    (0, _hashPublicKey.hashPublicKey)(publicKeys[i])
                ]);
            } else {
                const signatureSize = Buffer.alloc(1);
                const keySize = Buffer.alloc(1);
                signatureSize[0] = signatures[i].length;
                keySize[0] = publicKeys[i].length;
                targetTransaction.inputs[i].script = Buffer.concat([
                    signatureSize,
                    signatures[i],
                    keySize,
                    publicKeys[i]
                ]);
            }
            const offset = useBip143 && !useTrustedInputForSegwit ? 0 : 4;
            targetTransaction.inputs[i].prevout = trustedInputs[i].value.slice(offset, offset + 0x24);
        }
        targetTransaction.locktime = lockTimeBuffer;
        let result = Buffer.concat([
            (0, _serializeTransaction.serializeTransaction)(targetTransaction, false, targetTransaction.timestamp, additionals),
            outputScript
        ]);
        if (segwit && !isDecred) {
            let witness = Buffer.alloc(0);
            for(let i = 0; i < inputs.length; i++){
                const tmpScriptData = Buffer.concat([
                    Buffer.from("02", "hex"),
                    Buffer.from([
                        signatures[i].length
                    ]),
                    signatures[i],
                    Buffer.from([
                        publicKeys[i].length
                    ]),
                    publicKeys[i]
                ]);
                witness = Buffer.concat([
                    witness,
                    tmpScriptData
                ]);
            }
            result = Buffer.concat([
                result,
                witness
            ]);
        }
        // from to https://zips.z.cash/zip-0225, zcash is different with other coins, the lock_time and nExpiryHeight fields are before the inputs and outputs
        if (!isZcash) {
            result = Buffer.concat([
                result,
                lockTimeBuffer
            ]);
            if (expiryHeight) result = Buffer.concat([
                result,
                targetTransaction.nExpiryHeight || Buffer.alloc(0),
                targetTransaction.extraData || Buffer.alloc(0)
            ]);
        }
        if (isDecred) {
            let decredWitness = Buffer.from([
                targetTransaction.inputs.length
            ]);
            inputs.forEach((input, inputIndex)=>{
                decredWitness = Buffer.concat([
                    decredWitness,
                    Buffer.from([
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00
                    ]),
                    Buffer.from([
                        0x00,
                        0x00,
                        0x00,
                        0x00
                    ]),
                    Buffer.from([
                        0xff,
                        0xff,
                        0xff,
                        0xff
                    ]),
                    Buffer.from([
                        targetTransaction.inputs[inputIndex].script.length
                    ]),
                    targetTransaction.inputs[inputIndex].script
                ]);
            });
            result = Buffer.concat([
                result,
                decredWitness
            ]);
        }
        if (isZcash) result = Buffer.concat([
            result,
            Buffer.from([
                0x00,
                0x00,
                0x00
            ])
        ]);
        return result.toString("hex");
    });
}

},{"e8c5face70df9d93":"bwvMq","@ledgerhq/logs":"i4OI0","./hashPublicKey":"8CIgU","./getWalletPublicKey":"3Ipz1","./getTrustedInput":"lWTUu","./startUntrustedHashTransactionInput":"efzFk","./serializeTransaction":"c5bE0","./getTrustedInputBIP143":"1HcMu","./compressPublicKey":"7SdGH","./signTransaction":"6fbEP","./finalizeInput":"eE3XW","./getAppAndVersion":"1B9q9","./constants":"6IGza","./shouldUseTrustedInputForSegwit":"5oYO6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Ipz1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getWalletPublicKey", ()=>getWalletPublicKey);
var _bip32 = require("./bip32");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const addressFormatMap = {
    legacy: 0,
    p2sh: 1,
    bech32: 2,
    cashaddr: 3
};
function getWalletPublicKey(transport, options) {
    return __awaiter(this, void 0, void 0, function*() {
        const { path, verify, format } = Object.assign({
            verify: false,
            format: "legacy"
        }, options);
        if (!(format in addressFormatMap)) throw new Error("btc.getWalletPublicKey invalid format=" + format);
        const buffer = (0, _bip32.bip32asBuffer)(path);
        const p1 = verify ? 1 : 0;
        const p2 = addressFormatMap[format];
        const response = yield transport.send(0xe0, 0x40, p1, p2, buffer);
        const publicKeyLength = response[0];
        const addressLength = response[1 + publicKeyLength];
        const publicKey = response.slice(1, 1 + publicKeyLength).toString("hex");
        const bitcoinAddress = response.slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength).toString("ascii");
        const chainCode = response.slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32).toString("hex");
        return {
            publicKey,
            bitcoinAddress,
            chainCode
        };
    });
}

},{"./bip32":"hSMer","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lWTUu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getTrustedInputRaw", ()=>getTrustedInputRaw);
parcelHelpers.export(exports, "getTrustedInput", ()=>getTrustedInput);
var _invariant = require("invariant");
var _invariantDefault = parcelHelpers.interopDefault(_invariant);
var _constants = require("./constants");
var _varint = require("./varint");
var Buffer = require("d6c555f7b8acc4fa").Buffer;
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getTrustedInputRaw(transport, transactionData, indexLookup) {
    return __awaiter(this, void 0, void 0, function*() {
        let data;
        let firstRound = false;
        if (typeof indexLookup === "number") {
            firstRound = true;
            const prefix = Buffer.alloc(4);
            prefix.writeUInt32BE(indexLookup, 0);
            data = Buffer.concat([
                prefix,
                transactionData
            ], transactionData.length + 4);
        } else data = transactionData;
        const trustedInput = yield transport.send(0xe0, 0x42, firstRound ? 0x00 : 0x80, 0x00, data);
        const res = trustedInput.slice(0, trustedInput.length - 2).toString("hex");
        return res;
    });
}
function getTrustedInput(transport_1, indexLookup_1, transaction_1) {
    return __awaiter(this, arguments, void 0, function*(transport, indexLookup, transaction, additionals = []) {
        const { inputs, outputs, locktime, nExpiryHeight, extraData } = transaction;
        if (!outputs || !locktime) throw new Error("getTrustedInput: locktime & outputs is expected");
        const isDecred = additionals.includes("decred");
        const processScriptBlocks = (script, sequence)=>__awaiter(this, void 0, void 0, function*() {
                const seq = sequence || Buffer.alloc(0);
                const scriptBlocks = [];
                let offset = 0;
                while(offset !== script.length){
                    const blockSize = script.length - offset > (0, _constants.MAX_SCRIPT_BLOCK) ? (0, _constants.MAX_SCRIPT_BLOCK) : script.length - offset;
                    if (offset + blockSize !== script.length) scriptBlocks.push(script.slice(offset, offset + blockSize));
                    else scriptBlocks.push(Buffer.concat([
                        script.slice(offset, offset + blockSize),
                        seq
                    ]));
                    offset += blockSize;
                }
                // Handle case when no script length: we still want to pass the sequence
                // relatable: https://github.com/LedgerHQ/ledger-live-desktop/issues/1386
                if (script.length === 0) scriptBlocks.push(seq);
                let res;
                for (const scriptBlock of scriptBlocks)res = yield getTrustedInputRaw(transport, scriptBlock);
                return res;
            });
        const processWholeScriptBlock = (block)=>getTrustedInputRaw(transport, block);
        yield getTrustedInputRaw(transport, Buffer.concat([
            transaction.version,
            transaction.timestamp || Buffer.alloc(0),
            transaction.nVersionGroupId || Buffer.alloc(0),
            (0, _varint.createVarint)(inputs.length)
        ]), indexLookup);
        for (const input of inputs){
            const treeField = isDecred ? input.tree || Buffer.from([
                0x00
            ]) : Buffer.alloc(0);
            const data = Buffer.concat([
                input.prevout,
                treeField,
                (0, _varint.createVarint)(input.script.length)
            ]);
            yield getTrustedInputRaw(transport, data);
            // iteration (eachSeries) ended
            // TODO notify progress
            // deferred.notify("input");
            yield isDecred ? processWholeScriptBlock(Buffer.concat([
                input.script,
                input.sequence
            ])) : processScriptBlocks(input.script, input.sequence);
        }
        yield getTrustedInputRaw(transport, (0, _varint.createVarint)(outputs.length));
        for (const output of outputs){
            const data = Buffer.concat([
                output.amount,
                isDecred ? Buffer.from([
                    0x00,
                    0x00
                ]) : Buffer.alloc(0),
                (0, _varint.createVarint)(output.script.length),
                output.script
            ]);
            yield getTrustedInputRaw(transport, data);
        }
        const endData = [];
        if (nExpiryHeight && nExpiryHeight.length > 0) endData.push(nExpiryHeight);
        if (extraData && extraData.length > 0) endData.push(extraData);
        let extraPart;
        if (endData.length) {
            const data = Buffer.concat(endData);
            extraPart = isDecred ? data : Buffer.concat([
                (0, _varint.createVarint)(data.length),
                data
            ]);
        }
        const res = yield processScriptBlocks(Buffer.concat([
            locktime,
            extraPart || Buffer.alloc(0)
        ]));
        (0, _invariantDefault.default)(res, "missing result in processScriptBlocks");
        return res;
    });
}

},{"d6c555f7b8acc4fa":"bwvMq","invariant":"d1QgR","./constants":"6IGza","./varint":"k9xXc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d1QgR":[function(require,module,exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */ var invariant = function(condition, format, a, b, c, d, e, f) {
    if (format === undefined) throw new Error("invariant requires an error message argument");
    if (!condition) {
        var error;
        if (format === undefined) error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
        else {
            var args = [
                a,
                b,
                c,
                d,
                e,
                f
            ];
            var argIndex = 0;
            error = new Error(format.replace(/%s/g, function() {
                return args[argIndex++];
            }));
            error.name = "Invariant Violation";
        }
        error.framesToPop = 1; // we don't care about invariant's own frame
        throw error;
    }
};
module.exports = invariant;

},{}],"efzFk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "startUntrustedHashTransactionInputRaw", ()=>startUntrustedHashTransactionInputRaw);
parcelHelpers.export(exports, "startUntrustedHashTransactionInput", ()=>startUntrustedHashTransactionInput);
var _varint = require("./varint");
var _constants = require("./constants");
var Buffer = require("3b24aa635a45459f").Buffer;
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function startUntrustedHashTransactionInputRaw(transport, newTransaction, firstRound, transactionData, bip143 = false, overwinter = false, additionals = []) {
    const p2 = additionals.includes("cashaddr") ? 0x03 : bip143 ? additionals.includes("sapling") ? 0x05 : overwinter ? 0x04 : 0x02 : 0x00;
    return transport.send(0xe0, 0x44, firstRound ? 0x00 : 0x80, newTransaction ? p2 : 0x80, transactionData);
}
function startUntrustedHashTransactionInput(transport_1, newTransaction_1, transaction_1, inputs_1) {
    return __awaiter(this, arguments, void 0, function*(transport, newTransaction, transaction, inputs, bip143 = false, overwinter = false, additionals = [], useTrustedInputForSegwit = false) {
        let data = Buffer.concat([
            transaction.version,
            transaction.timestamp || Buffer.alloc(0),
            transaction.nVersionGroupId || Buffer.alloc(0),
            (0, _varint.createVarint)(transaction.inputs.length)
        ]);
        yield startUntrustedHashTransactionInputRaw(transport, newTransaction, true, data, bip143, overwinter, additionals);
        let i = 0;
        const isDecred = additionals.includes("decred");
        for (const input of transaction.inputs){
            let prefix;
            const inputValue = inputs[i].value;
            if (bip143) {
                if (useTrustedInputForSegwit && inputs[i].trustedInput) prefix = Buffer.from([
                    0x01,
                    inputValue.length
                ]);
                else prefix = Buffer.from([
                    0x02
                ]);
            } else if (inputs[i].trustedInput) prefix = Buffer.from([
                0x01,
                inputs[i].value.length
            ]);
            else prefix = Buffer.from([
                0x00
            ]);
            data = Buffer.concat([
                prefix,
                inputValue,
                isDecred ? Buffer.from([
                    0x00
                ]) : Buffer.alloc(0),
                (0, _varint.createVarint)(input.script.length)
            ]);
            yield startUntrustedHashTransactionInputRaw(transport, newTransaction, false, data, bip143, overwinter, additionals);
            const scriptBlocks = [];
            let offset = 0;
            if (input.script.length === 0) scriptBlocks.push(input.sequence);
            else while(offset !== input.script.length){
                const blockSize = input.script.length - offset > (0, _constants.MAX_SCRIPT_BLOCK) ? (0, _constants.MAX_SCRIPT_BLOCK) : input.script.length - offset;
                if (offset + blockSize !== input.script.length) scriptBlocks.push(input.script.slice(offset, offset + blockSize));
                else scriptBlocks.push(Buffer.concat([
                    input.script.slice(offset, offset + blockSize),
                    input.sequence
                ]));
                offset += blockSize;
            }
            for (const scriptBlock of scriptBlocks)yield startUntrustedHashTransactionInputRaw(transport, newTransaction, false, scriptBlock, bip143, overwinter, additionals);
            i++;
        }
    });
}

},{"3b24aa635a45459f":"bwvMq","./varint":"k9xXc","./constants":"6IGza","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1HcMu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getTrustedInputBIP143", ()=>getTrustedInputBIP143);
var _shaJs = require("sha.js");
var _shaJsDefault = parcelHelpers.interopDefault(_shaJs);
var _serializeTransaction = require("./serializeTransaction");
var Buffer = require("8cdf0d4e8dbeef65").Buffer;
function getTrustedInputBIP143(transport, indexLookup, transaction, additionals = []) {
    if (!transaction) throw new Error("getTrustedInputBIP143: missing tx");
    const isDecred = additionals.includes("decred");
    if (isDecred) throw new Error("Decred does not implement BIP143");
    let hash = (0, _shaJsDefault.default)("sha256").update((0, _shaJsDefault.default)("sha256").update((0, _serializeTransaction.serializeTransaction)(transaction, true)).digest()).digest();
    const data = Buffer.alloc(4);
    data.writeUInt32LE(indexLookup, 0);
    const { outputs, locktime } = transaction;
    if (!outputs || !locktime) throw new Error("getTrustedInputBIP143: locktime & outputs is expected");
    if (!outputs[indexLookup]) throw new Error("getTrustedInputBIP143: wrong index");
    hash = Buffer.concat([
        hash,
        data,
        outputs[indexLookup].amount
    ]);
    return hash.toString("hex");
}

},{"8cdf0d4e8dbeef65":"bwvMq","sha.js":"jkn7m","./serializeTransaction":"c5bE0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7SdGH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compressPublicKey", ()=>compressPublicKey);
var Buffer = require("4d1f2ef52237cabc").Buffer;
function compressPublicKey(publicKey) {
    const prefix = (publicKey[64] & 1) !== 0 ? 0x03 : 0x02;
    const prefixBuffer = Buffer.alloc(1);
    prefixBuffer[0] = prefix;
    return Buffer.concat([
        prefixBuffer,
        publicKey.slice(1, 33)
    ]);
}

},{"4d1f2ef52237cabc":"bwvMq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6fbEP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "signTransaction", ()=>signTransaction);
var _bip32 = require("./bip32");
var Buffer = require("f1d8573fd01c00e7").Buffer;
function signTransaction(transport, path, lockTime, sigHashType, expiryHeight, additionals = []) {
    const isDecred = additionals.includes("decred");
    const pathsBuffer = (0, _bip32.bip32asBuffer)(path);
    const lockTimeBuffer = Buffer.alloc(4);
    lockTimeBuffer.writeUInt32BE(lockTime, 0);
    let buffer = isDecred ? Buffer.concat([
        pathsBuffer,
        lockTimeBuffer,
        expiryHeight || Buffer.from([
            0x00,
            0x00,
            0x00,
            0x00
        ]),
        Buffer.from([
            sigHashType
        ])
    ]) : Buffer.concat([
        pathsBuffer,
        Buffer.from([
            0x00
        ]),
        lockTimeBuffer,
        Buffer.from([
            sigHashType
        ])
    ]);
    if (expiryHeight && !isDecred) buffer = Buffer.concat([
        buffer,
        expiryHeight
    ]);
    return transport.send(0xe0, 0x48, 0x00, 0x00, buffer).then((result)=>{
        if (result.length > 0) {
            result[0] = 0x30;
            return result.slice(0, result.length - 2);
        }
        return result;
    });
}

},{"f1d8573fd01c00e7":"bwvMq","./bip32":"hSMer","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eE3XW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "provideOutputFullChangePath", ()=>provideOutputFullChangePath);
parcelHelpers.export(exports, "hashOutputFull", ()=>hashOutputFull);
var _bip32 = require("./bip32");
var _constants = require("./constants");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function provideOutputFullChangePath(transport, path) {
    const buffer = (0, _bip32.bip32asBuffer)(path);
    return transport.send(0xe0, 0x4a, 0xff, 0x00, buffer);
}
function hashOutputFull(transport_1, outputScript_1) {
    return __awaiter(this, arguments, void 0, function*(transport, outputScript, additionals = []) {
        let offset = 0;
        const p1 = Number(0x80);
        const isDecred = additionals.includes("decred");
        ///WARNING: Decred works only with one call (without chunking)
        //TODO: test without this for Decred
        if (isDecred) return transport.send(0xe0, 0x4a, p1, 0x00, outputScript);
        while(offset < outputScript.length){
            const blockSize = offset + (0, _constants.MAX_SCRIPT_BLOCK) >= outputScript.length ? outputScript.length - offset : (0, _constants.MAX_SCRIPT_BLOCK);
            const p1 = offset + blockSize === outputScript.length ? 0x80 : 0x00;
            const data = outputScript.slice(offset, offset + blockSize);
            yield transport.send(0xe0, 0x4a, p1, 0x00, data);
            offset += blockSize;
        }
    });
}

},{"./bip32":"hSMer","./constants":"6IGza","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1B9q9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getAppAndVersion", ()=>getAppAndVersion);
parcelHelpers.export(exports, "checkIsBtcLegacy", ()=>checkIsBtcLegacy);
var _invariant = require("invariant");
var _invariantDefault = parcelHelpers.interopDefault(_invariant);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const getAppAndVersion = (transport)=>__awaiter(void 0, void 0, void 0, function*() {
        const r = yield transport.send(0xb0, 0x01, 0x00, 0x00);
        let i = 0;
        const format = r[i++];
        (0, _invariantDefault.default)(format === 1, "getAppAndVersion: format not supported");
        const nameLength = r[i++];
        const name = r.slice(i, i += nameLength).toString("ascii");
        const versionLength = r[i++];
        const version = r.slice(i, i += versionLength).toString("ascii");
        const flagLength = r[i++];
        const flags = r.slice(i, i += flagLength);
        return {
            name,
            version,
            flags
        };
    });
const checkIsBtcLegacy = (transport)=>__awaiter(void 0, void 0, void 0, function*() {
        try {
            // Call old btc API, it will throw an exception with new btc app. It is a workaround to differentiate new/old btc nano app
            yield transport.send(0xe0, 0xc4, 0, 0);
        } catch (e) {
            return false;
        }
        return true;
    });

},{"invariant":"d1QgR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5oYO6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shouldUseTrustedInputForSegwit", ()=>shouldUseTrustedInputForSegwit);
var _semver = require("semver");
var _semverDefault = parcelHelpers.interopDefault(_semver);
function shouldUseTrustedInputForSegwit({ version, name }) {
    if (name === "Decred") return false;
    if (name === "Exchange") return true;
    return (0, _semverDefault.default).gte(version, "1.4.0");
}

},{"semver":"3th7M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b0Oru":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "signMessage", ()=>signMessage);
var _bip32Path = require("bip32-path");
var _bip32PathDefault = parcelHelpers.interopDefault(_bip32Path);
var _constants = require("./constants");
var Buffer = require("d91a2a9236b213c6").Buffer;
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function signMessage(transport_1, _a) {
    return __awaiter(this, arguments, void 0, function*(transport, { path, messageHex }) {
        const paths = (0, _bip32PathDefault.default).fromString(path).toPathArray();
        const message = Buffer.from(messageHex, "hex");
        let offset = 0;
        while(offset !== message.length){
            const maxChunkSize = offset === 0 ? (0, _constants.MAX_SCRIPT_BLOCK) - 1 - paths.length * 4 - 4 : (0, _constants.MAX_SCRIPT_BLOCK);
            const chunkSize = offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;
            const buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 2 + chunkSize : chunkSize);
            if (offset === 0) {
                buffer[0] = paths.length;
                paths.forEach((element, index)=>{
                    buffer.writeUInt32BE(element, 1 + 4 * index);
                });
                buffer.writeUInt16BE(message.length, 1 + 4 * paths.length);
                message.copy(buffer, 1 + 4 * paths.length + 2, offset, offset + chunkSize);
            } else message.copy(buffer, 0, offset, offset + chunkSize);
            yield transport.send(0xe0, 0x4e, 0x00, offset === 0 ? 0x01 : 0x80, buffer);
            offset += chunkSize;
        }
        const res = yield transport.send(0xe0, 0x4e, 0x80, 0x00, Buffer.from([
            0x00
        ]));
        const v = res[0] - 0x30;
        let r = res.slice(4, 4 + res[3]);
        if (r[0] === 0) r = r.slice(1);
        r = r.toString("hex");
        offset = 4 + res[3] + 2;
        let s = res.slice(offset, offset + res[offset - 1]);
        if (s[0] === 0) s = s.slice(1);
        s = s.toString("hex");
        return {
            v,
            r,
            s
        };
    });
}

},{"d91a2a9236b213c6":"bwvMq","bip32-path":"6n4iS","./constants":"6IGza","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"04eej":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This class encapsulates the APDU protocol documented at
 * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md
 */ parcelHelpers.export(exports, "AppClient", ()=>AppClient);
var _bip32 = require("../bip32");
var _merkelizedPsbt = require("./merkelizedPsbt");
var _clientCommands = require("./clientCommands");
var _varint = require("../varint");
var _merkle = require("./merkle");
var Buffer = require("24be17dfdf566e5e").Buffer;
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const CLA_BTC = 0xe1;
const CLA_FRAMEWORK = 0xf8;
var BitcoinIns;
(function(BitcoinIns) {
    BitcoinIns[BitcoinIns["GET_PUBKEY"] = 0] = "GET_PUBKEY";
    // GET_ADDRESS = 0x01, // Removed from app
    BitcoinIns[BitcoinIns["REGISTER_WALLET"] = 2] = "REGISTER_WALLET";
    BitcoinIns[BitcoinIns["GET_WALLET_ADDRESS"] = 3] = "GET_WALLET_ADDRESS";
    BitcoinIns[BitcoinIns["SIGN_PSBT"] = 4] = "SIGN_PSBT";
    BitcoinIns[BitcoinIns["GET_MASTER_FINGERPRINT"] = 5] = "GET_MASTER_FINGERPRINT";
    BitcoinIns[BitcoinIns["SIGN_MESSAGE"] = 16] = "SIGN_MESSAGE";
})(BitcoinIns || (BitcoinIns = {}));
var FrameworkIns;
(function(FrameworkIns) {
    FrameworkIns[FrameworkIns["CONTINUE_INTERRUPTED"] = 1] = "CONTINUE_INTERRUPTED";
})(FrameworkIns || (FrameworkIns = {}));
class AppClient {
    constructor(transport){
        this.transport = transport;
    }
    makeRequest(ins, data, cci) {
        return __awaiter(this, void 0, void 0, function*() {
            let response = yield this.transport.send(CLA_BTC, ins, 0, 0, data, [
                0x9000,
                0xe000
            ]);
            while(response.readUInt16BE(response.length - 2) === 0xe000){
                if (!cci) throw new Error("Unexpected SW_INTERRUPTED_EXECUTION");
                const hwRequest = response.slice(0, -2);
                const commandResponse = cci.execute(hwRequest);
                response = yield this.transport.send(CLA_FRAMEWORK, FrameworkIns.CONTINUE_INTERRUPTED, 0, 0, commandResponse, [
                    0x9000,
                    0xe000
                ]);
            }
            return response.slice(0, -2); // drop the status word (can only be 0x9000 at this point)
        });
    }
    getExtendedPubkey(display, pathElements) {
        return __awaiter(this, void 0, void 0, function*() {
            if (pathElements.length > 6) throw new Error("Path too long. At most 6 levels allowed.");
            const response = yield this.makeRequest(BitcoinIns.GET_PUBKEY, Buffer.concat([
                Buffer.from(display ? [
                    1
                ] : [
                    0
                ]),
                (0, _bip32.pathElementsToBuffer)(pathElements)
            ]));
            return response.toString("ascii");
        });
    }
    getWalletAddress(walletPolicy, walletHMAC, change, addressIndex, display) {
        return __awaiter(this, void 0, void 0, function*() {
            if (change !== 0 && change !== 1) throw new Error("Change can only be 0 or 1");
            if (addressIndex < 0 || !Number.isInteger(addressIndex)) throw new Error("Invalid address index");
            if (walletHMAC != null && walletHMAC.length != 32) throw new Error("Invalid HMAC length");
            const clientInterpreter = new (0, _clientCommands.ClientCommandInterpreter)(()=>{});
            clientInterpreter.addKnownList(walletPolicy.keys.map((k)=>Buffer.from(k, "ascii")));
            clientInterpreter.addKnownPreimage(walletPolicy.serialize());
            const addressIndexBuffer = Buffer.alloc(4);
            addressIndexBuffer.writeUInt32BE(addressIndex, 0);
            const response = yield this.makeRequest(BitcoinIns.GET_WALLET_ADDRESS, Buffer.concat([
                Buffer.from(display ? [
                    1
                ] : [
                    0
                ]),
                walletPolicy.getWalletId(),
                walletHMAC || Buffer.alloc(32, 0),
                Buffer.from([
                    change
                ]),
                addressIndexBuffer
            ]), clientInterpreter);
            return response.toString("ascii");
        });
    }
    signPsbt(psbt, walletPolicy, walletHMAC, progressCallback) {
        return __awaiter(this, void 0, void 0, function*() {
            const merkelizedPsbt = new (0, _merkelizedPsbt.MerkelizedPsbt)(psbt);
            if (walletHMAC != null && walletHMAC.length != 32) throw new Error("Invalid HMAC length");
            const clientInterpreter = new (0, _clientCommands.ClientCommandInterpreter)(progressCallback);
            // prepare ClientCommandInterpreter
            clientInterpreter.addKnownList(walletPolicy.keys.map((k)=>Buffer.from(k, "ascii")));
            clientInterpreter.addKnownPreimage(walletPolicy.serialize());
            clientInterpreter.addKnownMapping(merkelizedPsbt.globalMerkleMap);
            for (const map of merkelizedPsbt.inputMerkleMaps)clientInterpreter.addKnownMapping(map);
            for (const map of merkelizedPsbt.outputMerkleMaps)clientInterpreter.addKnownMapping(map);
            clientInterpreter.addKnownList(merkelizedPsbt.inputMapCommitments);
            const inputMapsRoot = new (0, _merkle.Merkle)(merkelizedPsbt.inputMapCommitments.map((m)=>(0, _merkle.hashLeaf)(m))).getRoot();
            clientInterpreter.addKnownList(merkelizedPsbt.outputMapCommitments);
            const outputMapsRoot = new (0, _merkle.Merkle)(merkelizedPsbt.outputMapCommitments.map((m)=>(0, _merkle.hashLeaf)(m))).getRoot();
            yield this.makeRequest(BitcoinIns.SIGN_PSBT, Buffer.concat([
                merkelizedPsbt.getGlobalKeysValuesRoot(),
                (0, _varint.createVarint)(merkelizedPsbt.getGlobalInputCount()),
                inputMapsRoot,
                (0, _varint.createVarint)(merkelizedPsbt.getGlobalOutputCount()),
                outputMapsRoot,
                walletPolicy.getWalletId(),
                walletHMAC || Buffer.alloc(32, 0)
            ]), clientInterpreter);
            const yielded = clientInterpreter.getYielded();
            const ret = new Map();
            for (const inputAndSig of yielded)ret.set(inputAndSig[0], inputAndSig.slice(1));
            return ret;
        });
    }
    getMasterFingerprint() {
        return __awaiter(this, void 0, void 0, function*() {
            return this.makeRequest(BitcoinIns.GET_MASTER_FINGERPRINT, Buffer.from([]));
        });
    }
    signMessage(message, pathElements) {
        return __awaiter(this, void 0, void 0, function*() {
            if (pathElements.length > 6) throw new Error("Path too long. At most 6 levels allowed.");
            const clientInterpreter = new (0, _clientCommands.ClientCommandInterpreter)(()=>{});
            // prepare ClientCommandInterpreter
            const nChunks = Math.ceil(message.length / 64);
            const chunks = [];
            for(let i = 0; i < nChunks; i++)chunks.push(message.subarray(64 * i, 64 * i + 64));
            clientInterpreter.addKnownList(chunks);
            const chunksRoot = new (0, _merkle.Merkle)(chunks.map((m)=>(0, _merkle.hashLeaf)(m))).getRoot();
            const response = yield this.makeRequest(BitcoinIns.SIGN_MESSAGE, Buffer.concat([
                (0, _bip32.pathElementsToBuffer)(pathElements),
                (0, _varint.createVarint)(message.length),
                chunksRoot
            ]), clientInterpreter);
            return response.toString("base64");
        });
    }
}

},{"24be17dfdf566e5e":"bwvMq","../bip32":"hSMer","./merkelizedPsbt":"3qgkq","./clientCommands":"agttq","../varint":"k9xXc","./merkle":"7hIU1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3qgkq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This class merkelizes a PSBTv2, by merkelizing the different
 * maps of the psbt. This is used during the transaction signing process,
 * where the hardware app can request specific parts of the psbt from the
 * client code and be sure that the response data actually belong to the psbt.
 * The reason for this is the limited amount of memory available to the app,
 * so it can't always store the full psbt in memory.
 *
 * The signing process is documented at
 * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md#sign_psbt
 */ parcelHelpers.export(exports, "MerkelizedPsbt", ()=>MerkelizedPsbt);
var _merkleMap = require("./merkleMap");
var _psbtv2 = require("./psbtv2");
var Buffer = require("1e49592d5e0e0bf0").Buffer;
class MerkelizedPsbt extends (0, _psbtv2.PsbtV2) {
    constructor(psbt){
        super();
        this.inputMerkleMaps = [];
        this.outputMerkleMaps = [];
        psbt.copy(this);
        this.globalMerkleMap = MerkelizedPsbt.createMerkleMap(this.globalMap);
        for(let i = 0; i < this.getGlobalInputCount(); i++)this.inputMerkleMaps.push(MerkelizedPsbt.createMerkleMap(this.inputMaps[i]));
        this.inputMapCommitments = [
            ...this.inputMerkleMaps.values()
        ].map((v)=>v.commitment());
        for(let i = 0; i < this.getGlobalOutputCount(); i++)this.outputMerkleMaps.push(MerkelizedPsbt.createMerkleMap(this.outputMaps[i]));
        this.outputMapCommitments = [
            ...this.outputMerkleMaps.values()
        ].map((v)=>v.commitment());
    }
    // These public functions are for MerkelizedPsbt.
    getGlobalSize() {
        return this.globalMap.size;
    }
    getGlobalKeysValuesRoot() {
        return this.globalMerkleMap.commitment();
    }
    static createMerkleMap(map) {
        const sortedKeysStrings = [
            ...map.keys()
        ].sort();
        const values = sortedKeysStrings.map((k)=>{
            const v = map.get(k);
            if (!v) throw new Error("No value for key " + k);
            return v;
        });
        const sortedKeys = sortedKeysStrings.map((k)=>Buffer.from(k, "hex"));
        const merkleMap = new (0, _merkleMap.MerkleMap)(sortedKeys, values);
        return merkleMap;
    }
}

},{"1e49592d5e0e0bf0":"bwvMq","./merkleMap":"jdNW8","./psbtv2":"hOmf5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jdNW8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This implements "Merkelized Maps", documented at
 * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/merkle.md#merkleized-maps
 *
 * A merkelized map consist of two merkle trees, one for the keys of
 * a map and one for the values of the same map, thus the two merkle
 * trees have the same shape. The commitment is the number elements
 * in the map followed by the keys' merkle root followed by the
 * values' merkle root.
 */ parcelHelpers.export(exports, "MerkleMap", ()=>MerkleMap);
var _varint = require("../varint");
var _merkle = require("./merkle");
var Buffer = require("14163a53808bfc0e").Buffer;
class MerkleMap {
    /**
     * @param keys Sorted list of (unhashed) keys
     * @param values values, in corresponding order as the keys, and of equal length
     */ constructor(keys, values){
        if (keys.length != values.length) throw new Error("keys and values should have the same length");
        // Sanity check: verify that keys are actually sorted and with no duplicates
        for(let i = 0; i < keys.length - 1; i++){
            if (keys[i].toString("hex") >= keys[i + 1].toString("hex")) throw new Error("keys must be in strictly increasing order");
        }
        this.keys = keys;
        this.keysTree = new (0, _merkle.Merkle)(keys.map((k)=>(0, _merkle.hashLeaf)(k)));
        this.values = values;
        this.valuesTree = new (0, _merkle.Merkle)(values.map((v)=>(0, _merkle.hashLeaf)(v)));
    }
    commitment() {
        // returns a buffer between 65 and 73 (included) bytes long
        return Buffer.concat([
            (0, _varint.createVarint)(this.keys.length),
            this.keysTree.getRoot(),
            this.valuesTree.getRoot()
        ]);
    }
}

},{"14163a53808bfc0e":"bwvMq","../varint":"k9xXc","./merkle":"7hIU1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"agttq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "YieldCommand", ()=>YieldCommand);
parcelHelpers.export(exports, "GetPreimageCommand", ()=>GetPreimageCommand);
parcelHelpers.export(exports, "GetMerkleLeafProofCommand", ()=>GetMerkleLeafProofCommand);
parcelHelpers.export(exports, "GetMerkleLeafIndexCommand", ()=>GetMerkleLeafIndexCommand);
parcelHelpers.export(exports, "GetMoreElementsCommand", ()=>GetMoreElementsCommand);
/**
 * This class will dispatch a client command coming from the hardware device to
 * the appropriate client command implementation. Those client commands
 * typically requests data from a merkle tree or merkelized maps.
 *
 * A ClientCommandInterpreter is prepared by adding the merkle trees and
 * merkelized maps it should be able to serve to the hardware device. This class
 * doesn't know anything about the semantics of the data it holds, it just
 * serves merkle data. It doesn't even know in what context it is being
 * executed, ie SignPsbt, getWalletAddress, etc.
 *
 * If the command yelds results to the client, as signPsbt does, the yielded
 * data will be accessible after the command completed by calling getYielded(),
 * which will return the yields in the same order as they came in.
 */ parcelHelpers.export(exports, "ClientCommandInterpreter", ()=>ClientCommandInterpreter);
var _bitcoinjsLib = require("bitcoinjs-lib");
var _buffertools = require("../buffertools");
var _varint = require("../varint");
var _merkle = require("./merkle");
var Buffer = require("d4cb22f52a6b7add").Buffer;
var ClientCommandCode;
(function(ClientCommandCode) {
    ClientCommandCode[ClientCommandCode["YIELD"] = 16] = "YIELD";
    ClientCommandCode[ClientCommandCode["GET_PREIMAGE"] = 64] = "GET_PREIMAGE";
    ClientCommandCode[ClientCommandCode["GET_MERKLE_LEAF_PROOF"] = 65] = "GET_MERKLE_LEAF_PROOF";
    ClientCommandCode[ClientCommandCode["GET_MERKLE_LEAF_INDEX"] = 66] = "GET_MERKLE_LEAF_INDEX";
    ClientCommandCode[ClientCommandCode["GET_MORE_ELEMENTS"] = 160] = "GET_MORE_ELEMENTS";
})(ClientCommandCode || (ClientCommandCode = {}));
class ClientCommand {
}
class YieldCommand extends ClientCommand {
    constructor(results, progressCallback){
        super();
        this.progressCallback = progressCallback;
        this.code = ClientCommandCode.YIELD;
        this.results = results;
    }
    execute(request) {
        this.results.push(Buffer.from(request.subarray(1)));
        this.progressCallback();
        return Buffer.from("");
    }
}
class GetPreimageCommand extends ClientCommand {
    constructor(known_preimages, queue){
        super();
        this.code = ClientCommandCode.GET_PREIMAGE;
        this.known_preimages = known_preimages;
        this.queue = queue;
    }
    execute(request) {
        const req = Buffer.from(request.subarray(1));
        // we expect no more data to read
        if (req.length != 33) throw new Error("Invalid request, unexpected trailing data");
        if (req[0] != 0) throw new Error("Unsupported request, the first byte should be 0");
        // read the hash
        const hash = Buffer.alloc(32);
        for(let i = 0; i < 32; i++)hash[i] = req[1 + i];
        const req_hash_hex = hash.toString("hex");
        const known_preimage = this.known_preimages.get(req_hash_hex);
        if (known_preimage != undefined) {
            const preimage_len_varint = (0, _varint.createVarint)(known_preimage.length);
            // We can send at most 255 - len(preimage_len_out) - 1 bytes in a single message;
            // the rest will be stored in the queue for GET_MORE_ELEMENTS
            const max_payload_size = 255 - preimage_len_varint.length - 1;
            const payload_size = Math.min(max_payload_size, known_preimage.length);
            if (payload_size < known_preimage.length) for(let i = payload_size; i < known_preimage.length; i++)this.queue.push(Buffer.from([
                known_preimage[i]
            ]));
            return Buffer.concat([
                preimage_len_varint,
                Buffer.from([
                    payload_size
                ]),
                Buffer.from(known_preimage.subarray(0, payload_size))
            ]);
        }
        throw Error(`Requested unknown preimage for: ${req_hash_hex}`);
    }
}
class GetMerkleLeafProofCommand extends ClientCommand {
    constructor(known_trees, queue){
        super();
        this.code = ClientCommandCode.GET_MERKLE_LEAF_PROOF;
        this.known_trees = known_trees;
        this.queue = queue;
    }
    execute(request) {
        const req = Buffer.from(request.subarray(1));
        if (req.length < 34) throw new Error("Invalid request, expected at least 34 bytes");
        const reqBuf = new (0, _buffertools.BufferReader)(req);
        const hash = reqBuf.readSlice(32);
        const hash_hex = hash.toString("hex");
        let tree_size;
        let leaf_index;
        try {
            tree_size = reqBuf.readVarInt();
            leaf_index = reqBuf.readVarInt();
        } catch (e) {
            throw new Error("Invalid request, couldn't parse tree_size or leaf_index");
        }
        const mt = this.known_trees.get(hash_hex);
        if (!mt) throw Error(`Requested Merkle leaf proof for unknown tree: ${hash_hex}`);
        if (leaf_index >= tree_size || mt.size() != tree_size) throw Error("Invalid index or tree size.");
        if (this.queue.length != 0) throw Error("This command should not execute when the queue is not empty.");
        const proof = mt.getProof(leaf_index);
        const n_response_elements = Math.min(Math.floor(6.90625), proof.length);
        const n_leftover_elements = proof.length - n_response_elements;
        // Add to the queue any proof elements that do not fit the response
        if (n_leftover_elements > 0) this.queue.push(...proof.slice(-n_leftover_elements));
        return Buffer.concat([
            mt.getLeafHash(leaf_index),
            Buffer.from([
                proof.length
            ]),
            Buffer.from([
                n_response_elements
            ]),
            ...proof.slice(0, n_response_elements)
        ]);
    }
}
class GetMerkleLeafIndexCommand extends ClientCommand {
    constructor(known_trees){
        super();
        this.code = ClientCommandCode.GET_MERKLE_LEAF_INDEX;
        this.known_trees = known_trees;
    }
    execute(request) {
        const req = Buffer.from(request.subarray(1));
        if (req.length != 64) throw new Error("Invalid request, unexpected trailing data");
        // read the root hash
        const root_hash = Buffer.alloc(32);
        for(let i = 0; i < 32; i++)root_hash[i] = req.readUInt8(i);
        const root_hash_hex = root_hash.toString("hex");
        // read the leaf hash
        const leef_hash = Buffer.alloc(32);
        for(let i = 0; i < 32; i++)leef_hash[i] = req.readUInt8(32 + i);
        const leef_hash_hex = leef_hash.toString("hex");
        const mt = this.known_trees.get(root_hash_hex);
        if (!mt) throw Error(`Requested Merkle leaf index for unknown root: ${root_hash_hex}`);
        let leaf_index = 0;
        let found = 0;
        for(let i = 0; i < mt.size(); i++)if (mt.getLeafHash(i).toString("hex") == leef_hash_hex) {
            found = 1;
            leaf_index = i;
            break;
        }
        return Buffer.concat([
            Buffer.from([
                found
            ]),
            (0, _varint.createVarint)(leaf_index)
        ]);
    }
}
class GetMoreElementsCommand extends ClientCommand {
    constructor(queue){
        super();
        this.code = ClientCommandCode.GET_MORE_ELEMENTS;
        this.queue = queue;
    }
    execute(request) {
        if (request.length != 1) throw new Error("Invalid request, unexpected trailing data");
        if (this.queue.length === 0) throw new Error("No elements to get");
        // all elements should have the same length
        const element_len = this.queue[0].length;
        if (this.queue.some((el)=>el.length != element_len)) throw new Error("The queue contains elements with different byte length, which is not expected");
        const max_elements = Math.floor(253 / element_len);
        const n_returned_elements = Math.min(max_elements, this.queue.length);
        const returned_elements = this.queue.splice(0, n_returned_elements);
        return Buffer.concat([
            Buffer.from([
                n_returned_elements
            ]),
            Buffer.from([
                element_len
            ]),
            ...returned_elements
        ]);
    }
}
class ClientCommandInterpreter {
    constructor(progressCallback){
        this.roots = new Map();
        this.preimages = new Map();
        this.yielded = [];
        this.queue = [];
        this.commands = new Map();
        const commands = [
            new YieldCommand(this.yielded, progressCallback),
            new GetPreimageCommand(this.preimages, this.queue),
            new GetMerkleLeafIndexCommand(this.roots),
            new GetMerkleLeafProofCommand(this.roots, this.queue),
            new GetMoreElementsCommand(this.queue)
        ];
        for (const cmd of commands){
            if (this.commands.has(cmd.code)) throw new Error(`Multiple commands with code ${cmd.code}`);
            this.commands.set(cmd.code, cmd);
        }
    }
    getYielded() {
        return this.yielded;
    }
    addKnownPreimage(preimage) {
        this.preimages.set((0, _bitcoinjsLib.crypto).sha256(preimage).toString("hex"), preimage);
    }
    addKnownList(elements) {
        for (const el of elements){
            const preimage = Buffer.concat([
                Buffer.from([
                    0
                ]),
                el
            ]);
            this.addKnownPreimage(preimage);
        }
        const mt = new (0, _merkle.Merkle)(elements.map((el)=>(0, _merkle.hashLeaf)(el)));
        this.roots.set(mt.getRoot().toString("hex"), mt);
    }
    addKnownMapping(mm) {
        this.addKnownList(mm.keys);
        this.addKnownList(mm.values);
    }
    execute(request) {
        if (request.length == 0) throw new Error("Unexpected empty command");
        const cmdCode = request[0];
        const cmd = this.commands.get(cmdCode);
        if (!cmd) throw new Error(`Unexpected command code ${cmdCode}`);
        return cmd.execute(request);
    }
}

},{"d4cb22f52a6b7add":"bwvMq","bitcoinjs-lib":"cl7fJ","../buffertools":"fvT7D","../varint":"k9xXc","./merkle":"7hIU1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8pUNG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "splitTransaction", ()=>splitTransaction);
var _logs = require("@ledgerhq/logs");
var _varint = require("./varint");
var _debug = require("./debug");
var Buffer = require("d0b3d8a1c14f070c").Buffer;
function splitTransaction(transactionHex, isSegwitSupported = false, hasExtraData = false, additionals = []) {
    const inputs = [];
    const outputs = [];
    let witness = false;
    let offset = 0;
    const timestamp = Buffer.alloc(0);
    let nExpiryHeight = Buffer.alloc(0);
    let nVersionGroupId = Buffer.alloc(0);
    let extraData = Buffer.alloc(0);
    let witnessScript, locktime;
    const isDecred = additionals.includes("decred");
    const isZencash = additionals.includes("zencash");
    const isZcash = additionals.includes("zcash");
    const transaction = Buffer.from(transactionHex, "hex");
    const version = transaction.slice(offset, offset + 4);
    const overwinter = version.equals(Buffer.from([
        0x03,
        0x00,
        0x00,
        0x80
    ])) || version.equals(Buffer.from([
        0x04,
        0x00,
        0x00,
        0x80
    ])) || version.equals(Buffer.from([
        0x05,
        0x00,
        0x00,
        0x80
    ]));
    const isZcashv5 = isZcash && version.equals(Buffer.from([
        0x05,
        0x00,
        0x00,
        0x80
    ]));
    offset += 4;
    if (isSegwitSupported && transaction[offset] === 0 && transaction[offset + 1] !== 0 && !isZencash) {
        offset += 2;
        witness = true;
    }
    if (overwinter) {
        nVersionGroupId = transaction.slice(offset, 4 + offset);
        offset += 4;
    }
    if (isZcashv5) {
        locktime = transaction.slice(offset + 4, offset + 8);
        nExpiryHeight = transaction.slice(offset + 8, offset + 12);
        offset += 12;
    }
    let varint = (0, _varint.getVarint)(transaction, offset);
    const numberInputs = varint[0];
    offset += varint[1];
    for(let i = 0; i < numberInputs; i++){
        const prevout = transaction.slice(offset, offset + 36);
        offset += 36;
        let script = Buffer.alloc(0);
        let tree = Buffer.alloc(0);
        //No script for decred, it has a witness
        if (!isDecred) {
            varint = (0, _varint.getVarint)(transaction, offset);
            offset += varint[1];
            script = transaction.slice(offset, offset + varint[0]);
            offset += varint[0];
        } else {
            //Tree field
            tree = transaction.slice(offset, offset + 1);
            offset += 1;
        }
        const sequence = transaction.slice(offset, offset + 4);
        offset += 4;
        inputs.push({
            prevout,
            script,
            sequence,
            tree
        });
    }
    varint = (0, _varint.getVarint)(transaction, offset);
    const numberOutputs = varint[0];
    offset += varint[1];
    for(let i = 0; i < numberOutputs; i++){
        const amount = transaction.slice(offset, offset + 8);
        offset += 8;
        if (isDecred) //Script version
        offset += 2;
        varint = (0, _varint.getVarint)(transaction, offset);
        offset += varint[1];
        const script = transaction.slice(offset, offset + varint[0]);
        offset += varint[0];
        outputs.push({
            amount,
            script
        });
    }
    if (witness) {
        witnessScript = transaction.slice(offset, -4);
        locktime = transaction.slice(transaction.length - 4);
    } else if (!isZcashv5) locktime = transaction.slice(offset, offset + 4);
    offset += 4;
    if ((overwinter || isDecred) && !isZcashv5) {
        nExpiryHeight = transaction.slice(offset, offset + 4);
        offset += 4;
    }
    if (hasExtraData) extraData = transaction.slice(offset);
    //Get witnesses for Decred
    if (isDecred) {
        varint = (0, _varint.getVarint)(transaction, offset);
        offset += varint[1];
        if (varint[0] !== numberInputs) throw new Error("splitTransaction: incoherent number of witnesses");
        for(let i = 0; i < numberInputs; i++){
            //amount
            offset += 8;
            //block height
            offset += 4;
            //block index
            offset += 4;
            //Script size
            varint = (0, _varint.getVarint)(transaction, offset);
            offset += varint[1];
            const script = transaction.slice(offset, offset + varint[0]);
            offset += varint[0];
            inputs[i].script = script;
        }
    }
    const t = {
        version,
        inputs,
        outputs,
        locktime,
        witness: witnessScript,
        timestamp,
        nVersionGroupId,
        nExpiryHeight,
        extraData
    };
    (0, _logs.log)("btc", `splitTransaction ${transactionHex}:\n${(0, _debug.formatTransactionDebug)(t)}`);
    return t;
}

},{"d0b3d8a1c14f070c":"bwvMq","@ledgerhq/logs":"i4OI0","./varint":"k9xXc","./debug":"b977y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b977y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatTransactionDebug", ()=>formatTransactionDebug);
parcelHelpers.export(exports, "displayTransactionDebug", ()=>displayTransactionDebug);
function formatTransactionDebug(transaction) {
    let str = "TX";
    str += " version " + transaction.version.toString("hex");
    if (transaction.locktime) str += " locktime " + transaction.locktime.toString("hex");
    if (transaction.witness) str += " witness " + transaction.witness.toString("hex");
    if (transaction.timestamp) str += " timestamp " + transaction.timestamp.toString("hex");
    if (transaction.nVersionGroupId) str += " nVersionGroupId " + transaction.nVersionGroupId.toString("hex");
    if (transaction.nExpiryHeight) str += " nExpiryHeight " + transaction.nExpiryHeight.toString("hex");
    if (transaction.extraData) str += " extraData " + transaction.extraData.toString("hex");
    transaction.inputs.forEach(({ prevout, script, sequence }, i)=>{
        str += `\ninput ${i}:`;
        str += ` prevout ${prevout.toString("hex")}`;
        str += ` script ${script.toString("hex")}`;
        str += ` sequence ${sequence.toString("hex")}`;
    });
    (transaction.outputs || []).forEach(({ amount, script }, i)=>{
        str += `\noutput ${i}:`;
        str += ` amount ${amount.toString("hex")}`;
        str += ` script ${script.toString("hex")}`;
    });
    return str;
}
function displayTransactionDebug(transaction) {
    console.log(formatTransactionDebug(transaction));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6cHcv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "signP2SHTransaction", ()=>signP2SHTransaction);
var _getTrustedInput = require("./getTrustedInput");
var _startUntrustedHashTransactionInput = require("./startUntrustedHashTransactionInput");
var _getTrustedInputBIP143 = require("./getTrustedInputBIP143");
var _signTransaction = require("./signTransaction");
var _finalizeInput = require("./finalizeInput");
var _constants = require("./constants");
var Buffer = require("3172675180faf033").Buffer;
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const defaultArg = {
    lockTime: (0, _constants.DEFAULT_LOCKTIME),
    sigHashType: (0, _constants.SIGHASH_ALL),
    segwit: false,
    transactionVersion: (0, _constants.DEFAULT_VERSION)
};
function signP2SHTransaction(transport, arg) {
    return __awaiter(this, void 0, void 0, function*() {
        const { inputs, associatedKeysets, outputScriptHex, lockTime, sigHashType, segwit, transactionVersion } = Object.assign(Object.assign({}, defaultArg), arg);
        // Inputs are provided as arrays of [transaction, output_index, redeem script, optional sequence]
        // associatedKeysets are provided as arrays of [path]
        const nullScript = Buffer.alloc(0);
        const nullPrevout = Buffer.alloc(0);
        const defaultVersion = Buffer.alloc(4);
        defaultVersion.writeUInt32LE(transactionVersion, 0);
        const trustedInputs = [];
        const regularOutputs = [];
        const signatures = [];
        let firstRun = true;
        const resuming = false;
        const targetTransaction = {
            inputs: [],
            version: defaultVersion
        };
        const getTrustedInputCall = segwit ? (0, _getTrustedInputBIP143.getTrustedInputBIP143) : (0, _getTrustedInput.getTrustedInput);
        const outputScript = Buffer.from(outputScriptHex, "hex");
        for (const input of inputs){
            if (!resuming) {
                const trustedInput = yield getTrustedInputCall(transport, input[1], input[0]);
                const sequence = Buffer.alloc(4);
                sequence.writeUInt32LE(input.length >= 4 && typeof input[3] === "number" ? input[3] : (0, _constants.DEFAULT_SEQUENCE), 0);
                trustedInputs.push({
                    trustedInput: false,
                    value: segwit ? Buffer.from(trustedInput, "hex") : Buffer.from(trustedInput, "hex").slice(4, 40),
                    sequence
                });
            }
            const { outputs } = input[0];
            const index = input[1];
            if (outputs && index <= outputs.length - 1) regularOutputs.push(outputs[index]);
        }
        // Pre-build the target transaction
        for(let i = 0; i < inputs.length; i++){
            const sequence = Buffer.alloc(4);
            sequence.writeUInt32LE(inputs[i].length >= 4 && typeof inputs[i][3] === "number" ? inputs[i][3] : (0, _constants.DEFAULT_SEQUENCE), 0);
            targetTransaction.inputs.push({
                script: nullScript,
                prevout: nullPrevout,
                sequence
            });
        }
        if (segwit) {
            yield (0, _startUntrustedHashTransactionInput.startUntrustedHashTransactionInput)(transport, true, targetTransaction, trustedInputs, true);
            yield (0, _finalizeInput.hashOutputFull)(transport, outputScript);
        }
        for(let i = 0; i < inputs.length; i++){
            const input = inputs[i];
            const script = inputs[i].length >= 3 && typeof input[2] === "string" ? Buffer.from(input[2], "hex") : regularOutputs[i].script;
            const pseudoTX = Object.assign({}, targetTransaction);
            const pseudoTrustedInputs = segwit ? [
                trustedInputs[i]
            ] : trustedInputs;
            if (segwit) pseudoTX.inputs = [
                Object.assign(Object.assign({}, pseudoTX.inputs[i]), {
                    script
                })
            ];
            else pseudoTX.inputs[i].script = script;
            yield (0, _startUntrustedHashTransactionInput.startUntrustedHashTransactionInput)(transport, !segwit && firstRun, pseudoTX, pseudoTrustedInputs, segwit);
            if (!segwit) yield (0, _finalizeInput.hashOutputFull)(transport, outputScript);
            const signature = yield (0, _signTransaction.signTransaction)(transport, associatedKeysets[i], lockTime, sigHashType);
            signatures.push(segwit ? signature.toString("hex") : signature.slice(0, signature.length - 1).toString("hex"));
            targetTransaction.inputs[i].script = nullScript;
            if (firstRun) firstRun = false;
        }
        return signatures;
    });
}

},{"3172675180faf033":"bwvMq","./getTrustedInput":"lWTUu","./startUntrustedHashTransactionInput":"efzFk","./getTrustedInputBIP143":"1HcMu","./signTransaction":"6fbEP","./finalizeInput":"eE3XW","./constants":"6IGza","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9zmIA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hwTransport = require("@ledgerhq/hw-transport");
var _hwTransportDefault = parcelHelpers.interopDefault(_hwTransport);
var _hidFraming = require("@ledgerhq/devices/hid-framing");
var _hidFramingDefault = parcelHelpers.interopDefault(_hidFraming);
var _devices = require("@ledgerhq/devices");
var _logs = require("@ledgerhq/logs");
var _errors = require("@ledgerhq/errors");
var _webusb = require("./webusb");
var Buffer = require("2f1c1569be106a3").Buffer;
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const configurationValue = 1;
const endpointNumber = 3;
/**
 * WebUSB Transport implementation
 * @example
 * import TransportWebUSB from "@ledgerhq/hw-transport-webusb";
 * ...
 * TransportWebUSB.create().then(transport => ...)
 */ class TransportWebUSB extends (0, _hwTransportDefault.default) {
    constructor(device, interfaceNumber){
        super();
        this.channel = Math.floor(Math.random() * 0xffff);
        this.packetSize = 64;
        this._disconnectEmitted = false;
        this._emitDisconnect = (e)=>{
            if (this._disconnectEmitted) return;
            this._disconnectEmitted = true;
            this.emit("disconnect", e);
        };
        this.device = device;
        this.interfaceNumber = interfaceNumber;
        this.deviceModel = (0, _devices.identifyUSBProductId)(device.productId);
    }
    /**
     * Similar to create() except it will always display the device permission (even if some devices are already accepted).
     */ static request() {
        return __awaiter(this, void 0, void 0, function*() {
            const device = yield (0, _webusb.requestLedgerDevice)();
            return TransportWebUSB.open(device);
        });
    }
    /**
     * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).
     */ static openConnected() {
        return __awaiter(this, void 0, void 0, function*() {
            const devices = yield (0, _webusb.getLedgerDevices)();
            if (devices.length === 0) return null;
            return TransportWebUSB.open(devices[0]);
        });
    }
    /**
     * Create a Ledger transport with a USBDevice
     */ static open(device) {
        return __awaiter(this, void 0, void 0, function*() {
            yield device.open();
            if (device.configuration === null) yield device.selectConfiguration(configurationValue);
            yield gracefullyResetDevice(device);
            const iface = device.configurations[0].interfaces.find(({ alternates })=>alternates.some((a)=>a.interfaceClass === 255));
            if (!iface) throw new (0, _errors.TransportInterfaceNotAvailable)("No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.");
            const interfaceNumber = iface.interfaceNumber;
            try {
                yield device.claimInterface(interfaceNumber);
            } catch (e) {
                yield device.close();
                throw new (0, _errors.TransportInterfaceNotAvailable)(e.message);
            }
            const transport = new TransportWebUSB(device, interfaceNumber);
            const onDisconnect = (e)=>{
                if (device === e.device) {
                    // $FlowFixMe
                    navigator.usb.removeEventListener("disconnect", onDisconnect);
                    transport._emitDisconnect(new (0, _errors.DisconnectedDevice)());
                }
            };
            // $FlowFixMe
            navigator.usb.addEventListener("disconnect", onDisconnect);
            return transport;
        });
    }
    /**
     * Release the transport device
     */ close() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.exchangeBusyPromise;
            yield this.device.releaseInterface(this.interfaceNumber);
            yield gracefullyResetDevice(this.device);
            yield this.device.close();
        });
    }
    /**
     * Exchange with the device using APDU protocol.
     * @param apdu
     * @returns a promise of apdu response
     */ exchange(apdu) {
        return __awaiter(this, void 0, void 0, function*() {
            const b = yield this.exchangeAtomicImpl(()=>__awaiter(this, void 0, void 0, function*() {
                    const { channel, packetSize } = this;
                    (0, _logs.log)("apdu", "=> " + apdu.toString("hex"));
                    const framing = (0, _hidFramingDefault.default)(channel, packetSize);
                    // Write...
                    const blocks = framing.makeBlocks(apdu);
                    for(let i = 0; i < blocks.length; i++)yield this.device.transferOut(endpointNumber, blocks[i]);
                    // Read...
                    let result;
                    let acc;
                    while(!(result = framing.getReducedResult(acc))){
                        const r = yield this.device.transferIn(endpointNumber, packetSize);
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        const buffer = Buffer.from(r.data.buffer);
                        acc = framing.reduceResponse(acc, buffer);
                    }
                    (0, _logs.log)("apdu", "<= " + result.toString("hex"));
                    return result;
                })).catch((e)=>{
                if (e && e.message && e.message.includes("disconnected")) {
                    this._emitDisconnect(e);
                    throw new (0, _errors.DisconnectedDeviceDuringOperation)(e.message);
                }
                throw e;
            });
            return b;
        });
    }
    setScrambleKey() {}
}
/**
 * Check if WebUSB transport is supported.
 */ TransportWebUSB.isSupported = (0, _webusb.isSupported);
/**
 * List the WebUSB devices that was previously authorized by the user.
 */ TransportWebUSB.list = (0, _webusb.getLedgerDevices);
/**
 * Actively listen to WebUSB devices and emit ONE device
 * that was either accepted before, if not it will trigger the native permission UI.
 *
 * Important: it must be called in the context of a UI click!
 */ TransportWebUSB.listen = (observer)=>{
    let unsubscribed = false;
    (0, _webusb.getFirstLedgerDevice)().then((device)=>{
        if (!unsubscribed) {
            const deviceModel = (0, _devices.identifyUSBProductId)(device.productId);
            observer.next({
                type: "add",
                descriptor: device,
                deviceModel
            });
            observer.complete();
        }
    }, (error)=>{
        if (window.DOMException && error instanceof window.DOMException && error.code === 18) observer.error(new (0, _errors.TransportWebUSBGestureRequired)(error.message));
        else observer.error(new (0, _errors.TransportOpenUserCancelled)(error.message));
    });
    function unsubscribe() {
        unsubscribed = true;
    }
    return {
        unsubscribe
    };
};
exports.default = TransportWebUSB;
function gracefullyResetDevice(device) {
    return __awaiter(this, void 0, void 0, function*() {
        try {
            yield device.reset();
        } catch (err) {
            console.warn(err);
        }
    });
}

},{"2f1c1569be106a3":"bwvMq","@ledgerhq/hw-transport":"59Ey9","@ledgerhq/devices/hid-framing":"3BsQA","@ledgerhq/devices":"fnHxP","@ledgerhq/logs":"i4OI0","@ledgerhq/errors":"EVZMy","./webusb":"7NNG8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"59Ey9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TransportError", ()=>(0, _errors.TransportError));
parcelHelpers.export(exports, "TransportStatusError", ()=>(0, _errors.TransportStatusError));
parcelHelpers.export(exports, "StatusCodes", ()=>(0, _errors.StatusCodes));
parcelHelpers.export(exports, "getAltStatusMessage", ()=>(0, _errors.getAltStatusMessage));
var _events = require("events");
var _eventsDefault = parcelHelpers.interopDefault(_events);
var _errors = require("@ledgerhq/errors");
var _logs = require("@ledgerhq/logs");
var Buffer = require("88b312045e1ca92b").Buffer;
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const DEFAULT_LOG_TYPE = "transport";
/**
 * The Transport class defines a generic interface for communicating with a Ledger hardware wallet.
 * There are different kind of transports based on the technology (channels like U2F, HID, Bluetooth, Webusb) and environment (Node, Web,...).
 * It is an abstract class that needs to be implemented.
 */ class Transport {
    constructor({ context, logType } = {}){
        this.exchangeTimeout = 30000;
        this.unresponsiveTimeout = 15000;
        this.deviceModel = null;
        this._events = new (0, _eventsDefault.default)();
        /**
         * Send data to the device using the higher level API.
         *
         * @param {number} cla - The instruction class for the command.
         * @param {number} ins - The instruction code for the command.
         * @param {number} p1 - The first parameter for the instruction.
         * @param {number} p2 - The second parameter for the instruction.
         * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.
         * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].
         * @param {Object} options - Contains optional options for the exchange function
         *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists
         *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.
         * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.
         */ this.send = (cla_1, ins_1, p1_1, p2_1, ...args_1)=>__awaiter(this, [
                cla_1,
                ins_1,
                p1_1,
                p2_1,
                ...args_1
            ], void 0, function*(cla, ins, p1, p2, data = Buffer.alloc(0), statusList = [
                (0, _errors.StatusCodes).OK
            ], { abortTimeoutMs } = {}) {
                const tracer = this.tracer.withUpdatedContext({
                    function: "send"
                });
                if (data.length >= 256) {
                    tracer.trace("data.length exceeded 256 bytes limit", {
                        dataLength: data.length
                    });
                    throw new (0, _errors.TransportError)("data.length exceed 256 bytes limit. Got: " + data.length, "DataLengthTooBig");
                }
                tracer.trace("Starting an exchange", {
                    abortTimeoutMs
                });
                const response = yield this.exchange(// The size of the data is added in 1 byte just before `data`
                Buffer.concat([
                    Buffer.from([
                        cla,
                        ins,
                        p1,
                        p2
                    ]),
                    Buffer.from([
                        data.length
                    ]),
                    data
                ]), {
                    abortTimeoutMs
                });
                tracer.trace("Received response from exchange");
                const sw = response.readUInt16BE(response.length - 2);
                if (!statusList.some((s)=>s === sw)) throw new (0, _errors.TransportStatusError)(sw);
                return response;
            });
        this._appAPIlock = null;
        this.tracer = new (0, _logs.LocalTracer)(logType !== null && logType !== void 0 ? logType : DEFAULT_LOG_TYPE, context);
    }
    /**
     * Send data to the device using a low level API.
     * It's recommended to use the "send" method for a higher level API.
     * @param {Buffer} apdu - The data to send.
     * @param {Object} options - Contains optional options for the exchange function
     *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists
     *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.
     * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.
     */ exchange(_apdu, { abortTimeoutMs: _abortTimeoutMs } = {}) {
        throw new Error("exchange not implemented");
    }
    /**
     * Send apdus in batch to the device using a low level API.
     * The default implementation is to call exchange for each apdu.
     * @param {Array<Buffer>} apdus - array of apdus to send.
     * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.
     * @returns {Subscription} A Subscription object on which you can call ".unsubscribe()" to stop sending apdus.
     */ exchangeBulk(apdus, observer) {
        let unsubscribed = false;
        const unsubscribe = ()=>{
            unsubscribed = true;
        };
        const main = ()=>__awaiter(this, void 0, void 0, function*() {
                if (unsubscribed) return;
                for (const apdu of apdus){
                    const r = yield this.exchange(apdu);
                    if (unsubscribed) return;
                    const status = r.readUInt16BE(r.length - 2);
                    if (status !== (0, _errors.StatusCodes).OK) throw new (0, _errors.TransportStatusError)(status);
                    observer.next(r);
                }
            });
        main().then(()=>!unsubscribed && observer.complete(), (e)=>!unsubscribed && observer.error(e));
        return {
            unsubscribe
        };
    }
    /**
     * Set the "scramble key" for the next data exchanges with the device.
     * Each app can have a different scramble key and it is set internally during instantiation.
     * @param {string} key - The scramble key to set.
     * deprecated This method is no longer needed for modern transports and should be migrated away from.
     * no @ before deprecated as it breaks documentationjs on version 14.0.2
     * https://github.com/documentationjs/documentation/issues/1596
     */ setScrambleKey(_key) {}
    /**
     * Close the connection with the device.
     *
     * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,
     * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.
     * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.
     *
     * @returns {Promise<void>} A promise that resolves when the transport is closed.
     */ close() {
        return Promise.resolve();
    }
    /**
     * Listen for an event on the transport instance.
     * Transport implementations may have specific events. Common events include:
     * "disconnect" : triggered when the transport is disconnected.
     * @param {string} eventName - The name of the event to listen for.
     * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.
     */ on(eventName, cb) {
        this._events.on(eventName, cb);
    }
    /**
     * Stop listening to an event on an instance of transport.
     */ off(eventName, cb) {
        this._events.removeListener(eventName, cb);
    }
    emit(event, ...args) {
        this._events.emit(event, ...args);
    }
    /**
     * Enable or not logs of the binary exchange
     */ setDebugMode() {
        console.warn("setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.");
    }
    /**
     * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)
     */ setExchangeTimeout(exchangeTimeout) {
        this.exchangeTimeout = exchangeTimeout;
    }
    /**
     * Define the delay before emitting "unresponsive" on an exchange that does not respond
     */ setExchangeUnresponsiveTimeout(unresponsiveTimeout) {
        this.unresponsiveTimeout = unresponsiveTimeout;
    }
    /**
     * create() allows to open the first descriptor available or
     * throw if there is none or if timeout is reached.
     * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)
     * @example
    TransportFoo.create().then(transport => ...)
     */ static create(openTimeout = 3000, listenTimeout) {
        return new Promise((resolve, reject)=>{
            let found = false;
            const sub = this.listen({
                next: (e)=>{
                    found = true;
                    if (sub) sub.unsubscribe();
                    if (listenTimeoutId) clearTimeout(listenTimeoutId);
                    this.open(e.descriptor, openTimeout).then(resolve, reject);
                },
                error: (e)=>{
                    if (listenTimeoutId) clearTimeout(listenTimeoutId);
                    reject(e);
                },
                complete: ()=>{
                    if (listenTimeoutId) clearTimeout(listenTimeoutId);
                    if (!found) reject(new (0, _errors.TransportError)(this.ErrorMessage_NoDeviceFound, "NoDeviceFound"));
                }
            });
            const listenTimeoutId = listenTimeout ? setTimeout(()=>{
                sub.unsubscribe();
                reject(new (0, _errors.TransportError)(this.ErrorMessage_ListenTimeout, "ListenTimeout"));
            }, listenTimeout) : null;
        });
    }
    /**
     * Wrapper to make an exchange "atomic" (blocking any other exchange)
     *
     * It also handles "unresponsiveness" by emitting "unresponsive" and "responsive" events.
     *
     * @param f The exchange job, using the transport to run
     * @returns a Promise resolving with the output of the given job
     */ exchangeAtomicImpl(f) {
        return __awaiter(this, void 0, void 0, function*() {
            const tracer = this.tracer.withUpdatedContext({
                function: "exchangeAtomicImpl",
                unresponsiveTimeout: this.unresponsiveTimeout
            });
            if (this.exchangeBusyPromise) {
                tracer.trace("Atomic exchange is already busy");
                throw new (0, _errors.TransportRaceCondition)("An action was already pending on the Ledger device. Please deny or reconnect.");
            }
            // Sets the atomic guard
            let resolveBusy;
            const busyPromise = new Promise((r)=>{
                resolveBusy = r;
            });
            this.exchangeBusyPromise = busyPromise;
            // The device unresponsiveness handler
            let unresponsiveReached = false;
            const timeout = setTimeout(()=>{
                tracer.trace(`Timeout reached, emitting Transport event "unresponsive"`, {
                    unresponsiveTimeout: this.unresponsiveTimeout
                });
                unresponsiveReached = true;
                this.emit("unresponsive");
            }, this.unresponsiveTimeout);
            try {
                const res = yield f();
                if (unresponsiveReached) {
                    tracer.trace("Device was unresponsive, emitting responsive");
                    this.emit("responsive");
                }
                return res;
            } finally{
                tracer.trace("Finalize, clearing busy guard");
                clearTimeout(timeout);
                if (resolveBusy) resolveBusy();
                this.exchangeBusyPromise = null;
            }
        });
    }
    decorateAppAPIMethods(self, methods, scrambleKey) {
        for (const methodName of methods)self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);
    }
    decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {
        return (...args)=>__awaiter(this, void 0, void 0, function*() {
                const { _appAPIlock } = this;
                if (_appAPIlock) return Promise.reject(new (0, _errors.TransportError)("Ledger Device is busy (lock " + _appAPIlock + ")", "TransportLocked"));
                try {
                    this._appAPIlock = methodName;
                    this.setScrambleKey(scrambleKey);
                    return yield f.apply(ctx, args);
                } finally{
                    this._appAPIlock = null;
                }
            });
    }
    /**
     * Sets the context used by the logging/tracing mechanism
     *
     * Useful when re-using (cached) the same Transport instance,
     * but with a new tracing context.
     *
     * @param context A TraceContext, that can undefined to reset the context
     */ setTraceContext(context) {
        this.tracer = this.tracer.withContext(context);
    }
    /**
     * Updates the context used by the logging/tracing mechanism
     *
     * The update only overrides the key-value that are already defined in the current context.
     *
     * @param contextToAdd A TraceContext that will be added to the current context
     */ updateTraceContext(contextToAdd) {
        this.tracer.updateContext(contextToAdd);
    }
    /**
     * Gets the tracing context of the transport instance
     */ getTraceContext() {
        return this.tracer.getContext();
    }
}
Transport.ErrorMessage_ListenTimeout = "No Ledger device found (timeout)";
Transport.ErrorMessage_NoDeviceFound = "No Ledger device found";
exports.default = Transport;

},{"88b312045e1ca92b":"bwvMq","events":"1VQLm","@ledgerhq/errors":"EVZMy","@ledgerhq/logs":"i4OI0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"EVZMy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "serializeError", ()=>(0, _helpers.serializeError));
parcelHelpers.export(exports, "deserializeError", ()=>(0, _helpers.deserializeError));
parcelHelpers.export(exports, "createCustomErrorClass", ()=>(0, _helpers.createCustomErrorClass));
parcelHelpers.export(exports, "addCustomErrorDeserializer", ()=>(0, _helpers.addCustomErrorDeserializer));
parcelHelpers.export(exports, "AccountNameRequiredError", ()=>AccountNameRequiredError);
parcelHelpers.export(exports, "AccountNotSupported", ()=>AccountNotSupported);
parcelHelpers.export(exports, "AccountAwaitingSendPendingOperations", ()=>AccountAwaitingSendPendingOperations);
parcelHelpers.export(exports, "AmountRequired", ()=>AmountRequired);
parcelHelpers.export(exports, "BluetoothRequired", ()=>BluetoothRequired);
parcelHelpers.export(exports, "BtcUnmatchedApp", ()=>BtcUnmatchedApp);
parcelHelpers.export(exports, "CantOpenDevice", ()=>CantOpenDevice);
parcelHelpers.export(exports, "CashAddrNotSupported", ()=>CashAddrNotSupported);
parcelHelpers.export(exports, "ClaimRewardsFeesWarning", ()=>ClaimRewardsFeesWarning);
parcelHelpers.export(exports, "CurrencyNotSupported", ()=>CurrencyNotSupported);
parcelHelpers.export(exports, "DeviceAppVerifyNotSupported", ()=>DeviceAppVerifyNotSupported);
parcelHelpers.export(exports, "DeviceGenuineSocketEarlyClose", ()=>DeviceGenuineSocketEarlyClose);
parcelHelpers.export(exports, "DeviceNotGenuineError", ()=>DeviceNotGenuineError);
parcelHelpers.export(exports, "DeviceOnDashboardExpected", ()=>DeviceOnDashboardExpected);
parcelHelpers.export(exports, "DeviceOnDashboardUnexpected", ()=>DeviceOnDashboardUnexpected);
parcelHelpers.export(exports, "DeviceInOSUExpected", ()=>DeviceInOSUExpected);
parcelHelpers.export(exports, "DeviceHalted", ()=>DeviceHalted);
parcelHelpers.export(exports, "DeviceNameInvalid", ()=>DeviceNameInvalid);
parcelHelpers.export(exports, "DeviceSocketFail", ()=>DeviceSocketFail);
parcelHelpers.export(exports, "DeviceSocketNoBulkStatus", ()=>DeviceSocketNoBulkStatus);
parcelHelpers.export(exports, "DeviceNeedsRestart", ()=>DeviceNeedsRestart);
parcelHelpers.export(exports, "UnresponsiveDeviceError", ()=>UnresponsiveDeviceError);
parcelHelpers.export(exports, "DisconnectedDevice", ()=>DisconnectedDevice);
parcelHelpers.export(exports, "DisconnectedDeviceDuringOperation", ()=>DisconnectedDeviceDuringOperation);
parcelHelpers.export(exports, "DeviceExtractOnboardingStateError", ()=>DeviceExtractOnboardingStateError);
parcelHelpers.export(exports, "DeviceOnboardingStatePollingError", ()=>DeviceOnboardingStatePollingError);
parcelHelpers.export(exports, "EnpointConfigError", ()=>EnpointConfigError);
parcelHelpers.export(exports, "EthAppPleaseEnableContractData", ()=>EthAppPleaseEnableContractData);
parcelHelpers.export(exports, "FeeEstimationFailed", ()=>FeeEstimationFailed);
parcelHelpers.export(exports, "FirmwareNotRecognized", ()=>FirmwareNotRecognized);
parcelHelpers.export(exports, "HardResetFail", ()=>HardResetFail);
parcelHelpers.export(exports, "InvalidXRPTag", ()=>InvalidXRPTag);
parcelHelpers.export(exports, "InvalidAddress", ()=>InvalidAddress);
parcelHelpers.export(exports, "InvalidNonce", ()=>InvalidNonce);
parcelHelpers.export(exports, "InvalidAddressBecauseDestinationIsAlsoSource", ()=>InvalidAddressBecauseDestinationIsAlsoSource);
parcelHelpers.export(exports, "LatestMCUInstalledError", ()=>LatestMCUInstalledError);
parcelHelpers.export(exports, "UnknownMCU", ()=>UnknownMCU);
parcelHelpers.export(exports, "LedgerAPIError", ()=>LedgerAPIError);
parcelHelpers.export(exports, "LedgerAPIErrorWithMessage", ()=>LedgerAPIErrorWithMessage);
parcelHelpers.export(exports, "LedgerAPINotAvailable", ()=>LedgerAPINotAvailable);
parcelHelpers.export(exports, "ManagerAppAlreadyInstalledError", ()=>ManagerAppAlreadyInstalledError);
parcelHelpers.export(exports, "ManagerAppRelyOnBTCError", ()=>ManagerAppRelyOnBTCError);
parcelHelpers.export(exports, "ManagerAppDepInstallRequired", ()=>ManagerAppDepInstallRequired);
parcelHelpers.export(exports, "ManagerAppDepUninstallRequired", ()=>ManagerAppDepUninstallRequired);
parcelHelpers.export(exports, "ManagerDeviceLockedError", ()=>ManagerDeviceLockedError);
parcelHelpers.export(exports, "ManagerFirmwareNotEnoughSpaceError", ()=>ManagerFirmwareNotEnoughSpaceError);
parcelHelpers.export(exports, "ManagerNotEnoughSpaceError", ()=>ManagerNotEnoughSpaceError);
parcelHelpers.export(exports, "ManagerUninstallBTCDep", ()=>ManagerUninstallBTCDep);
parcelHelpers.export(exports, "NetworkDown", ()=>NetworkDown);
parcelHelpers.export(exports, "NetworkError", ()=>NetworkError);
parcelHelpers.export(exports, "NoAddressesFound", ()=>NoAddressesFound);
parcelHelpers.export(exports, "NotEnoughBalance", ()=>NotEnoughBalance);
parcelHelpers.export(exports, "NotEnoughBalanceSwap", ()=>NotEnoughBalanceSwap);
parcelHelpers.export(exports, "NotEnoughBalanceToDelegate", ()=>NotEnoughBalanceToDelegate);
parcelHelpers.export(exports, "NotEnoughBalanceInParentAccount", ()=>NotEnoughBalanceInParentAccount);
parcelHelpers.export(exports, "NotEnoughSpendableBalance", ()=>NotEnoughSpendableBalance);
parcelHelpers.export(exports, "NotEnoughBalanceBecauseDestinationNotCreated", ()=>NotEnoughBalanceBecauseDestinationNotCreated);
parcelHelpers.export(exports, "NoAccessToCamera", ()=>NoAccessToCamera);
parcelHelpers.export(exports, "NotEnoughGas", ()=>NotEnoughGas);
parcelHelpers.export(exports, "NotEnoughGasSwap", ()=>NotEnoughGasSwap);
parcelHelpers.export(exports, "TronEmptyAccount", ()=>TronEmptyAccount);
parcelHelpers.export(exports, "MaybeKeepTronAccountAlive", ()=>MaybeKeepTronAccountAlive);
parcelHelpers.export(exports, "NotSupportedLegacyAddress", ()=>NotSupportedLegacyAddress);
parcelHelpers.export(exports, "GasLessThanEstimate", ()=>GasLessThanEstimate);
parcelHelpers.export(exports, "PriorityFeeTooLow", ()=>PriorityFeeTooLow);
parcelHelpers.export(exports, "PriorityFeeTooHigh", ()=>PriorityFeeTooHigh);
parcelHelpers.export(exports, "PriorityFeeHigherThanMaxFee", ()=>PriorityFeeHigherThanMaxFee);
parcelHelpers.export(exports, "MaxFeeTooLow", ()=>MaxFeeTooLow);
parcelHelpers.export(exports, "PasswordsDontMatchError", ()=>PasswordsDontMatchError);
parcelHelpers.export(exports, "PasswordIncorrectError", ()=>PasswordIncorrectError);
parcelHelpers.export(exports, "RecommendSubAccountsToEmpty", ()=>RecommendSubAccountsToEmpty);
parcelHelpers.export(exports, "RecommendUndelegation", ()=>RecommendUndelegation);
parcelHelpers.export(exports, "TimeoutTagged", ()=>TimeoutTagged);
parcelHelpers.export(exports, "UnexpectedBootloader", ()=>UnexpectedBootloader);
parcelHelpers.export(exports, "MCUNotGenuineToDashboard", ()=>MCUNotGenuineToDashboard);
parcelHelpers.export(exports, "RecipientRequired", ()=>RecipientRequired);
parcelHelpers.export(exports, "UnavailableTezosOriginatedAccountReceive", ()=>UnavailableTezosOriginatedAccountReceive);
parcelHelpers.export(exports, "UnavailableTezosOriginatedAccountSend", ()=>UnavailableTezosOriginatedAccountSend);
parcelHelpers.export(exports, "UpdateFetchFileFail", ()=>UpdateFetchFileFail);
parcelHelpers.export(exports, "UpdateIncorrectHash", ()=>UpdateIncorrectHash);
parcelHelpers.export(exports, "UpdateIncorrectSig", ()=>UpdateIncorrectSig);
parcelHelpers.export(exports, "UpdateYourApp", ()=>UpdateYourApp);
parcelHelpers.export(exports, "UserRefusedDeviceNameChange", ()=>UserRefusedDeviceNameChange);
parcelHelpers.export(exports, "UserRefusedAddress", ()=>UserRefusedAddress);
parcelHelpers.export(exports, "UserRefusedFirmwareUpdate", ()=>UserRefusedFirmwareUpdate);
parcelHelpers.export(exports, "UserRefusedAllowManager", ()=>UserRefusedAllowManager);
parcelHelpers.export(exports, "UserRefusedOnDevice", ()=>UserRefusedOnDevice);
parcelHelpers.export(exports, "ExpertModeRequired", ()=>ExpertModeRequired);
parcelHelpers.export(exports, "TransportOpenUserCancelled", ()=>TransportOpenUserCancelled);
parcelHelpers.export(exports, "TransportInterfaceNotAvailable", ()=>TransportInterfaceNotAvailable);
parcelHelpers.export(exports, "TransportRaceCondition", ()=>TransportRaceCondition);
parcelHelpers.export(exports, "TransportWebUSBGestureRequired", ()=>TransportWebUSBGestureRequired);
parcelHelpers.export(exports, "TransactionHasBeenValidatedError", ()=>TransactionHasBeenValidatedError);
parcelHelpers.export(exports, "TransportExchangeTimeoutError", ()=>TransportExchangeTimeoutError);
parcelHelpers.export(exports, "DeviceShouldStayInApp", ()=>DeviceShouldStayInApp);
parcelHelpers.export(exports, "WebsocketConnectionError", ()=>WebsocketConnectionError);
parcelHelpers.export(exports, "WebsocketConnectionFailed", ()=>WebsocketConnectionFailed);
parcelHelpers.export(exports, "WrongDeviceForAccount", ()=>WrongDeviceForAccount);
parcelHelpers.export(exports, "WrongDeviceForAccountPayout", ()=>WrongDeviceForAccountPayout);
parcelHelpers.export(exports, "WrongDeviceForAccountRefund", ()=>WrongDeviceForAccountRefund);
parcelHelpers.export(exports, "WrongAppForCurrency", ()=>WrongAppForCurrency);
parcelHelpers.export(exports, "ETHAddressNonEIP", ()=>ETHAddressNonEIP);
parcelHelpers.export(exports, "CantScanQRCode", ()=>CantScanQRCode);
parcelHelpers.export(exports, "FeeNotLoaded", ()=>FeeNotLoaded);
parcelHelpers.export(exports, "FeeNotLoadedSwap", ()=>FeeNotLoadedSwap);
parcelHelpers.export(exports, "FeeRequired", ()=>FeeRequired);
parcelHelpers.export(exports, "FeeTooHigh", ()=>FeeTooHigh);
parcelHelpers.export(exports, "PendingOperation", ()=>PendingOperation);
parcelHelpers.export(exports, "SyncError", ()=>SyncError);
parcelHelpers.export(exports, "PairingFailed", ()=>PairingFailed);
parcelHelpers.export(exports, "PeerRemovedPairing", ()=>PeerRemovedPairing);
parcelHelpers.export(exports, "GenuineCheckFailed", ()=>GenuineCheckFailed);
parcelHelpers.export(exports, "LedgerAPI4xx", ()=>LedgerAPI4xx);
parcelHelpers.export(exports, "LedgerAPI5xx", ()=>LedgerAPI5xx);
parcelHelpers.export(exports, "FirmwareOrAppUpdateRequired", ()=>FirmwareOrAppUpdateRequired);
parcelHelpers.export(exports, "ReplacementTransactionUnderpriced", ()=>ReplacementTransactionUnderpriced);
parcelHelpers.export(exports, "OpReturnDataSizeLimit", ()=>OpReturnDataSizeLimit);
parcelHelpers.export(exports, "DustLimit", ()=>DustLimit);
parcelHelpers.export(exports, "LanguageNotFound", ()=>LanguageNotFound);
parcelHelpers.export(exports, "NoDBPathGiven", ()=>NoDBPathGiven);
parcelHelpers.export(exports, "DBWrongPassword", ()=>DBWrongPassword);
parcelHelpers.export(exports, "DBNotReset", ()=>DBNotReset);
parcelHelpers.export(exports, "SequenceNumberError", ()=>SequenceNumberError);
parcelHelpers.export(exports, "DisabledTransactionBroadcastError", ()=>DisabledTransactionBroadcastError);
parcelHelpers.export(exports, "HwTransportErrorType", ()=>HwTransportErrorType);
/**
 * Represents an error coming from the usage of any Transport implementation.
 *
 * Needed to map a specific implementation error into an error that
 * can be managed by any code unaware of the specific Transport implementation
 * that was used.
 */ parcelHelpers.export(exports, "HwTransportError", ()=>HwTransportError);
/**
 * TransportError is used for any generic transport errors.
 * e.g. Error thrown when data received by exchanges are incorrect or if exchanged failed to communicate with the device for various reason.
 */ parcelHelpers.export(exports, "TransportError", ()=>TransportError);
parcelHelpers.export(exports, "StatusCodes", ()=>StatusCodes);
parcelHelpers.export(exports, "getAltStatusMessage", ()=>getAltStatusMessage);
/**
 * Error thrown when a device returned a non success status.
 * the error.statusCode is one of the `StatusCodes` exported by this library.
 */ parcelHelpers.export(exports, "TransportStatusError", ()=>TransportStatusError);
parcelHelpers.export(exports, "LockedDeviceError", ()=>LockedDeviceError);
var _helpers = require("./helpers");
const AccountNameRequiredError = (0, _helpers.createCustomErrorClass)("AccountNameRequired");
const AccountNotSupported = (0, _helpers.createCustomErrorClass)("AccountNotSupported");
const AccountAwaitingSendPendingOperations = (0, _helpers.createCustomErrorClass)("AccountAwaitingSendPendingOperations");
const AmountRequired = (0, _helpers.createCustomErrorClass)("AmountRequired");
const BluetoothRequired = (0, _helpers.createCustomErrorClass)("BluetoothRequired");
const BtcUnmatchedApp = (0, _helpers.createCustomErrorClass)("BtcUnmatchedApp");
const CantOpenDevice = (0, _helpers.createCustomErrorClass)("CantOpenDevice");
const CashAddrNotSupported = (0, _helpers.createCustomErrorClass)("CashAddrNotSupported");
const ClaimRewardsFeesWarning = (0, _helpers.createCustomErrorClass)("ClaimRewardsFeesWarning");
const CurrencyNotSupported = (0, _helpers.createCustomErrorClass)("CurrencyNotSupported");
const DeviceAppVerifyNotSupported = (0, _helpers.createCustomErrorClass)("DeviceAppVerifyNotSupported");
const DeviceGenuineSocketEarlyClose = (0, _helpers.createCustomErrorClass)("DeviceGenuineSocketEarlyClose");
const DeviceNotGenuineError = (0, _helpers.createCustomErrorClass)("DeviceNotGenuine");
const DeviceOnDashboardExpected = (0, _helpers.createCustomErrorClass)("DeviceOnDashboardExpected");
const DeviceOnDashboardUnexpected = (0, _helpers.createCustomErrorClass)("DeviceOnDashboardUnexpected");
const DeviceInOSUExpected = (0, _helpers.createCustomErrorClass)("DeviceInOSUExpected");
const DeviceHalted = (0, _helpers.createCustomErrorClass)("DeviceHalted");
const DeviceNameInvalid = (0, _helpers.createCustomErrorClass)("DeviceNameInvalid");
const DeviceSocketFail = (0, _helpers.createCustomErrorClass)("DeviceSocketFail");
const DeviceSocketNoBulkStatus = (0, _helpers.createCustomErrorClass)("DeviceSocketNoBulkStatus");
const DeviceNeedsRestart = (0, _helpers.createCustomErrorClass)("DeviceSocketNoBulkStatus");
const UnresponsiveDeviceError = (0, _helpers.createCustomErrorClass)("UnresponsiveDeviceError");
const DisconnectedDevice = (0, _helpers.createCustomErrorClass)("DisconnectedDevice");
const DisconnectedDeviceDuringOperation = (0, _helpers.createCustomErrorClass)("DisconnectedDeviceDuringOperation");
const DeviceExtractOnboardingStateError = (0, _helpers.createCustomErrorClass)("DeviceExtractOnboardingStateError");
const DeviceOnboardingStatePollingError = (0, _helpers.createCustomErrorClass)("DeviceOnboardingStatePollingError");
const EnpointConfigError = (0, _helpers.createCustomErrorClass)("EnpointConfig");
const EthAppPleaseEnableContractData = (0, _helpers.createCustomErrorClass)("EthAppPleaseEnableContractData");
const FeeEstimationFailed = (0, _helpers.createCustomErrorClass)("FeeEstimationFailed");
const FirmwareNotRecognized = (0, _helpers.createCustomErrorClass)("FirmwareNotRecognized");
const HardResetFail = (0, _helpers.createCustomErrorClass)("HardResetFail");
const InvalidXRPTag = (0, _helpers.createCustomErrorClass)("InvalidXRPTag");
const InvalidAddress = (0, _helpers.createCustomErrorClass)("InvalidAddress");
const InvalidNonce = (0, _helpers.createCustomErrorClass)("InvalidNonce");
const InvalidAddressBecauseDestinationIsAlsoSource = (0, _helpers.createCustomErrorClass)("InvalidAddressBecauseDestinationIsAlsoSource");
const LatestMCUInstalledError = (0, _helpers.createCustomErrorClass)("LatestMCUInstalledError");
const UnknownMCU = (0, _helpers.createCustomErrorClass)("UnknownMCU");
const LedgerAPIError = (0, _helpers.createCustomErrorClass)("LedgerAPIError");
const LedgerAPIErrorWithMessage = (0, _helpers.createCustomErrorClass)("LedgerAPIErrorWithMessage");
const LedgerAPINotAvailable = (0, _helpers.createCustomErrorClass)("LedgerAPINotAvailable");
const ManagerAppAlreadyInstalledError = (0, _helpers.createCustomErrorClass)("ManagerAppAlreadyInstalled");
const ManagerAppRelyOnBTCError = (0, _helpers.createCustomErrorClass)("ManagerAppRelyOnBTC");
const ManagerAppDepInstallRequired = (0, _helpers.createCustomErrorClass)("ManagerAppDepInstallRequired");
const ManagerAppDepUninstallRequired = (0, _helpers.createCustomErrorClass)("ManagerAppDepUninstallRequired");
const ManagerDeviceLockedError = (0, _helpers.createCustomErrorClass)("ManagerDeviceLocked");
const ManagerFirmwareNotEnoughSpaceError = (0, _helpers.createCustomErrorClass)("ManagerFirmwareNotEnoughSpace");
const ManagerNotEnoughSpaceError = (0, _helpers.createCustomErrorClass)("ManagerNotEnoughSpace");
const ManagerUninstallBTCDep = (0, _helpers.createCustomErrorClass)("ManagerUninstallBTCDep");
const NetworkDown = (0, _helpers.createCustomErrorClass)("NetworkDown");
const NetworkError = (0, _helpers.createCustomErrorClass)("NetworkError");
const NoAddressesFound = (0, _helpers.createCustomErrorClass)("NoAddressesFound");
const NotEnoughBalance = (0, _helpers.createCustomErrorClass)("NotEnoughBalance");
const NotEnoughBalanceSwap = (0, _helpers.createCustomErrorClass)("NotEnoughBalanceSwap");
const NotEnoughBalanceToDelegate = (0, _helpers.createCustomErrorClass)("NotEnoughBalanceToDelegate");
const NotEnoughBalanceInParentAccount = (0, _helpers.createCustomErrorClass)("NotEnoughBalanceInParentAccount");
const NotEnoughSpendableBalance = (0, _helpers.createCustomErrorClass)("NotEnoughSpendableBalance");
const NotEnoughBalanceBecauseDestinationNotCreated = (0, _helpers.createCustomErrorClass)("NotEnoughBalanceBecauseDestinationNotCreated");
const NoAccessToCamera = (0, _helpers.createCustomErrorClass)("NoAccessToCamera");
const NotEnoughGas = (0, _helpers.createCustomErrorClass)("NotEnoughGas");
const NotEnoughGasSwap = (0, _helpers.createCustomErrorClass)("NotEnoughGasSwap");
const TronEmptyAccount = (0, _helpers.createCustomErrorClass)("TronEmptyAccount");
const MaybeKeepTronAccountAlive = (0, _helpers.createCustomErrorClass)("MaybeKeepTronAccountAlive");
const NotSupportedLegacyAddress = (0, _helpers.createCustomErrorClass)("NotSupportedLegacyAddress");
const GasLessThanEstimate = (0, _helpers.createCustomErrorClass)("GasLessThanEstimate");
const PriorityFeeTooLow = (0, _helpers.createCustomErrorClass)("PriorityFeeTooLow");
const PriorityFeeTooHigh = (0, _helpers.createCustomErrorClass)("PriorityFeeTooHigh");
const PriorityFeeHigherThanMaxFee = (0, _helpers.createCustomErrorClass)("PriorityFeeHigherThanMaxFee");
const MaxFeeTooLow = (0, _helpers.createCustomErrorClass)("MaxFeeTooLow");
const PasswordsDontMatchError = (0, _helpers.createCustomErrorClass)("PasswordsDontMatch");
const PasswordIncorrectError = (0, _helpers.createCustomErrorClass)("PasswordIncorrect");
const RecommendSubAccountsToEmpty = (0, _helpers.createCustomErrorClass)("RecommendSubAccountsToEmpty");
const RecommendUndelegation = (0, _helpers.createCustomErrorClass)("RecommendUndelegation");
const TimeoutTagged = (0, _helpers.createCustomErrorClass)("TimeoutTagged");
const UnexpectedBootloader = (0, _helpers.createCustomErrorClass)("UnexpectedBootloader");
const MCUNotGenuineToDashboard = (0, _helpers.createCustomErrorClass)("MCUNotGenuineToDashboard");
const RecipientRequired = (0, _helpers.createCustomErrorClass)("RecipientRequired");
const UnavailableTezosOriginatedAccountReceive = (0, _helpers.createCustomErrorClass)("UnavailableTezosOriginatedAccountReceive");
const UnavailableTezosOriginatedAccountSend = (0, _helpers.createCustomErrorClass)("UnavailableTezosOriginatedAccountSend");
const UpdateFetchFileFail = (0, _helpers.createCustomErrorClass)("UpdateFetchFileFail");
const UpdateIncorrectHash = (0, _helpers.createCustomErrorClass)("UpdateIncorrectHash");
const UpdateIncorrectSig = (0, _helpers.createCustomErrorClass)("UpdateIncorrectSig");
const UpdateYourApp = (0, _helpers.createCustomErrorClass)("UpdateYourApp");
const UserRefusedDeviceNameChange = (0, _helpers.createCustomErrorClass)("UserRefusedDeviceNameChange");
const UserRefusedAddress = (0, _helpers.createCustomErrorClass)("UserRefusedAddress");
const UserRefusedFirmwareUpdate = (0, _helpers.createCustomErrorClass)("UserRefusedFirmwareUpdate");
const UserRefusedAllowManager = (0, _helpers.createCustomErrorClass)("UserRefusedAllowManager");
const UserRefusedOnDevice = (0, _helpers.createCustomErrorClass)("UserRefusedOnDevice"); // TODO rename because it's just for transaction refusal
const ExpertModeRequired = (0, _helpers.createCustomErrorClass)("ExpertModeRequired");
const TransportOpenUserCancelled = (0, _helpers.createCustomErrorClass)("TransportOpenUserCancelled");
const TransportInterfaceNotAvailable = (0, _helpers.createCustomErrorClass)("TransportInterfaceNotAvailable");
const TransportRaceCondition = (0, _helpers.createCustomErrorClass)("TransportRaceCondition");
const TransportWebUSBGestureRequired = (0, _helpers.createCustomErrorClass)("TransportWebUSBGestureRequired");
const TransactionHasBeenValidatedError = (0, _helpers.createCustomErrorClass)("TransactionHasBeenValidatedError");
const TransportExchangeTimeoutError = (0, _helpers.createCustomErrorClass)("TransportExchangeTimeoutError");
const DeviceShouldStayInApp = (0, _helpers.createCustomErrorClass)("DeviceShouldStayInApp");
const WebsocketConnectionError = (0, _helpers.createCustomErrorClass)("WebsocketConnectionError");
const WebsocketConnectionFailed = (0, _helpers.createCustomErrorClass)("WebsocketConnectionFailed");
const WrongDeviceForAccount = (0, _helpers.createCustomErrorClass)("WrongDeviceForAccount");
const WrongDeviceForAccountPayout = (0, _helpers.createCustomErrorClass)("WrongDeviceForAccountPayout");
const WrongDeviceForAccountRefund = (0, _helpers.createCustomErrorClass)("WrongDeviceForAccountRefund");
const WrongAppForCurrency = (0, _helpers.createCustomErrorClass)("WrongAppForCurrency");
const ETHAddressNonEIP = (0, _helpers.createCustomErrorClass)("ETHAddressNonEIP");
const CantScanQRCode = (0, _helpers.createCustomErrorClass)("CantScanQRCode");
const FeeNotLoaded = (0, _helpers.createCustomErrorClass)("FeeNotLoaded");
const FeeNotLoadedSwap = (0, _helpers.createCustomErrorClass)("FeeNotLoadedSwap");
const FeeRequired = (0, _helpers.createCustomErrorClass)("FeeRequired");
const FeeTooHigh = (0, _helpers.createCustomErrorClass)("FeeTooHigh");
const PendingOperation = (0, _helpers.createCustomErrorClass)("PendingOperation");
const SyncError = (0, _helpers.createCustomErrorClass)("SyncError");
const PairingFailed = (0, _helpers.createCustomErrorClass)("PairingFailed");
const PeerRemovedPairing = (0, _helpers.createCustomErrorClass)("PeerRemovedPairing");
const GenuineCheckFailed = (0, _helpers.createCustomErrorClass)("GenuineCheckFailed");
const LedgerAPI4xx = (0, _helpers.createCustomErrorClass)("LedgerAPI4xx");
const LedgerAPI5xx = (0, _helpers.createCustomErrorClass)("LedgerAPI5xx");
const FirmwareOrAppUpdateRequired = (0, _helpers.createCustomErrorClass)("FirmwareOrAppUpdateRequired");
const ReplacementTransactionUnderpriced = (0, _helpers.createCustomErrorClass)("ReplacementTransactionUnderpriced");
const OpReturnDataSizeLimit = (0, _helpers.createCustomErrorClass)("OpReturnSizeLimit");
const DustLimit = (0, _helpers.createCustomErrorClass)("DustLimit");
const LanguageNotFound = (0, _helpers.createCustomErrorClass)("LanguageNotFound");
const NoDBPathGiven = (0, _helpers.createCustomErrorClass)("NoDBPathGiven");
const DBWrongPassword = (0, _helpers.createCustomErrorClass)("DBWrongPassword");
const DBNotReset = (0, _helpers.createCustomErrorClass)("DBNotReset");
const SequenceNumberError = (0, _helpers.createCustomErrorClass)("SequenceNumberError");
const DisabledTransactionBroadcastError = (0, _helpers.createCustomErrorClass)("DisabledTransactionBroadcastError");
var HwTransportErrorType;
(function(HwTransportErrorType) {
    HwTransportErrorType["Unknown"] = "Unknown";
    HwTransportErrorType["LocationServicesDisabled"] = "LocationServicesDisabled";
    HwTransportErrorType["LocationServicesUnauthorized"] = "LocationServicesUnauthorized";
    HwTransportErrorType["BluetoothScanStartFailed"] = "BluetoothScanStartFailed";
})(HwTransportErrorType || (HwTransportErrorType = {}));
class HwTransportError extends Error {
    constructor(type, message){
        super(message);
        this.name = "HwTransportError";
        this.type = type;
        // Needed as long as we target < ES6
        Object.setPrototypeOf(this, HwTransportError.prototype);
    }
}
class TransportError extends Error {
    constructor(message, id){
        const name = "TransportError";
        super(message || name);
        this.name = name;
        this.message = message;
        this.stack = new Error(message).stack;
        this.id = id;
    }
}
(0, _helpers.addCustomErrorDeserializer)("TransportError", (e)=>new TransportError(e.message, e.id));
const StatusCodes = {
    ACCESS_CONDITION_NOT_FULFILLED: 0x9804,
    ALGORITHM_NOT_SUPPORTED: 0x9484,
    CLA_NOT_SUPPORTED: 0x6e00,
    CODE_BLOCKED: 0x9840,
    CODE_NOT_INITIALIZED: 0x9802,
    COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 0x6981,
    CONDITIONS_OF_USE_NOT_SATISFIED: 0x6985,
    CONTRADICTION_INVALIDATION: 0x9810,
    CONTRADICTION_SECRET_CODE_STATUS: 0x9808,
    DEVICE_IN_RECOVERY_MODE: 0x662f,
    CUSTOM_IMAGE_EMPTY: 0x662e,
    FILE_ALREADY_EXISTS: 0x6a89,
    FILE_NOT_FOUND: 0x9404,
    GP_AUTH_FAILED: 0x6300,
    HALTED: 0x6faa,
    INCONSISTENT_FILE: 0x9408,
    INCORRECT_DATA: 0x6a80,
    INCORRECT_LENGTH: 0x6700,
    INCORRECT_P1_P2: 0x6b00,
    INS_NOT_SUPPORTED: 0x6d00,
    DEVICE_NOT_ONBOARDED: 0x6d07,
    DEVICE_NOT_ONBOARDED_2: 0x6611,
    INVALID_KCV: 0x9485,
    INVALID_OFFSET: 0x9402,
    LICENSING: 0x6f42,
    LOCKED_DEVICE: 0x5515,
    MAX_VALUE_REACHED: 0x9850,
    MEMORY_PROBLEM: 0x9240,
    MISSING_CRITICAL_PARAMETER: 0x6800,
    NO_EF_SELECTED: 0x9400,
    NOT_ENOUGH_MEMORY_SPACE: 0x6a84,
    OK: 0x9000,
    PIN_REMAINING_ATTEMPTS: 0x63c0,
    REFERENCED_DATA_NOT_FOUND: 0x6a88,
    SECURITY_STATUS_NOT_SATISFIED: 0x6982,
    TECHNICAL_PROBLEM: 0x6f00,
    UNKNOWN_APDU: 0x6d02,
    USER_REFUSED_ON_DEVICE: 0x5501,
    NOT_ENOUGH_SPACE: 0x5102,
    APP_NOT_FOUND_OR_INVALID_CONTEXT: 0x5123,
    INVALID_APP_NAME_LENGTH: 0x670a,
    GEN_AES_KEY_FAILED: 0x5419,
    INTERNAL_CRYPTO_OPERATION_FAILED: 0x541a,
    INTERNAL_COMPUTE_AES_CMAC_FAILED: 0x541b,
    ENCRYPT_APP_STORAGE_FAILED: 0x541c,
    INVALID_BACKUP_STATE: 0x6642,
    PIN_NOT_SET: 0x5502,
    INVALID_BACKUP_LENGTH: 0x6733,
    INVALID_RESTORE_STATE: 0x6643,
    INVALID_CHUNK_LENGTH: 0x6734,
    INVALID_BACKUP_HEADER: 0x684a
};
function getAltStatusMessage(code) {
    switch(code){
        // improve text of most common errors
        case 0x6700:
            return "Incorrect length";
        case 0x6800:
            return "Missing critical parameter";
        case 0x6982:
            return "Security not satisfied (dongle locked or have invalid access rights)";
        case 0x6985:
            return "Condition of use not satisfied (denied by the user?)";
        case 0x6a80:
            return "Invalid data received";
        case 0x6b00:
            return "Invalid parameter received";
        case 0x5515:
            return "Locked device";
    }
    if (0x6f00 <= code && code <= 0x6fff) return "Internal error, please report";
}
class TransportStatusError extends Error {
    /**
     * @param statusCode The error status code coming from a Transport implementation
     * @param options containing:
     *  - canBeMappedToChildError: enable the mapping of TransportStatusError to an error extending/inheriting from it
     *  . Ex: LockedDeviceError. Default to true.
     */ constructor(statusCode, { canBeMappedToChildError = true } = {}){
        const statusText = Object.keys(StatusCodes).find((k)=>StatusCodes[k] === statusCode) || "UNKNOWN_ERROR";
        const smsg = getAltStatusMessage(statusCode) || statusText;
        const statusCodeStr = statusCode.toString(16);
        const message = `Ledger device: ${smsg} (0x${statusCodeStr})`;
        super(message);
        this.name = "TransportStatusError";
        this.statusCode = statusCode;
        this.statusText = statusText;
        Object.setPrototypeOf(this, TransportStatusError.prototype);
        // Maps to a LockedDeviceError
        if (canBeMappedToChildError && statusCode === StatusCodes.LOCKED_DEVICE) return new LockedDeviceError(message);
    }
}
class LockedDeviceError extends TransportStatusError {
    constructor(message){
        super(StatusCodes.LOCKED_DEVICE, {
            canBeMappedToChildError: false
        });
        if (message) this.message = message;
        this.name = "LockedDeviceError";
        Object.setPrototypeOf(this, LockedDeviceError.prototype);
    }
}
(0, _helpers.addCustomErrorDeserializer)("TransportStatusError", (e)=>new TransportStatusError(e.statusCode));

},{"./helpers":"blDCg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"blDCg":[function(require,module,exports) {
/* eslint-disable no-continue */ /* eslint-disable no-unused-vars */ /* eslint-disable no-param-reassign */ /* eslint-disable no-prototype-builtins */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addCustomErrorDeserializer", ()=>addCustomErrorDeserializer);
parcelHelpers.export(exports, "createCustomErrorClass", ()=>createCustomErrorClass);
parcelHelpers.export(exports, "deserializeError", ()=>deserializeError);
parcelHelpers.export(exports, "serializeError", ()=>serializeError);
const errorClasses = {};
const deserializers = {};
const addCustomErrorDeserializer = (name, deserializer)=>{
    deserializers[name] = deserializer;
};
const createCustomErrorClass = (name)=>{
    class CustomErrorClass extends Error {
        constructor(message, fields, options){
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            super(message || name, options);
            // Set the prototype explicitly. See https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
            Object.setPrototypeOf(this, CustomErrorClass.prototype);
            this.name = name;
            if (fields) for(const k in fields)// eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            this[k] = fields[k];
            if (options && isObject(options) && "cause" in options && !("cause" in this)) {
                // .cause was specified but the superconstructor
                // did not create an instance property.
                const cause = options.cause;
                this.cause = cause;
                if ("stack" in cause) this.stack = this.stack + "\nCAUSE: " + cause.stack;
            }
        }
    }
    errorClasses[name] = CustomErrorClass;
    return CustomErrorClass;
};
function isObject(value) {
    return typeof value === "object";
}
const deserializeError = (object)=>{
    if (object && typeof object === "object") {
        try {
            if (typeof object.message === "string") {
                const msg = JSON.parse(object.message);
                if (msg.message && msg.name) object = msg;
            }
        } catch (e) {
        // nothing
        }
        let error;
        if (typeof object.name === "string") {
            const { name } = object;
            const des = deserializers[name];
            if (des) error = des(object);
            else {
                let constructor = name === "Error" ? Error : errorClasses[name];
                if (!constructor) {
                    console.warn("deserializing an unknown class '" + name + "'");
                    constructor = createCustomErrorClass(name);
                }
                error = Object.create(constructor.prototype);
                try {
                    for(const prop in object)if (object.hasOwnProperty(prop)) error[prop] = object[prop];
                } catch (e) {
                // sometimes setting a property can fail (e.g. .name)
                }
            }
        } else if (typeof object.message === "string") error = new Error(object.message);
        if (error && !error.stack && Error.captureStackTrace) Error.captureStackTrace(error, deserializeError);
        return error;
    }
    return new Error(String(object));
};
const serializeError = (value)=>{
    if (!value) return value;
    if (typeof value === "object") return destroyCircular(value, []);
    if (typeof value === "function") return `[Function: ${value.name || "anonymous"}]`;
    return value;
};
// https://www.npmjs.com/package/destroy-circular
function destroyCircular(from, seen) {
    const to = {};
    seen.push(from);
    for (const key of Object.keys(from)){
        const value = from[key];
        if (typeof value === "function") continue;
        if (!value || typeof value !== "object") {
            to[key] = value;
            continue;
        }
        if (seen.indexOf(from[key]) === -1) {
            to[key] = destroyCircular(from[key], seen.slice(0));
            continue;
        }
        to[key] = "[Circular]";
    }
    if (typeof from.name === "string") to.name = from.name;
    if (typeof from.message === "string") to.message = from.message;
    if (typeof from.stack === "string") to.stack = from.stack;
    return to;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3BsQA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _errors = require("@ledgerhq/errors");
var Buffer = require("ebb2a684f25c5c57").Buffer;
const Tag = 0x05;
function asUInt16BE(value) {
    const b = Buffer.alloc(2);
    b.writeUInt16BE(value, 0);
    return b;
}
const initialAcc = {
    data: Buffer.alloc(0),
    dataLength: 0,
    sequence: 0
};
/**
 * Object to handle HID frames (encoding and decoding)
 *
 * @param channel
 * @param packetSize The HID protocol packet size in bytes (usually 64)
 */ const createHIDframing = (channel, packetSize)=>{
    return {
        /**
         * Frames/encodes an APDU message into HID USB packets/frames
         *
         * @param apdu The APDU message to send, in a Buffer containing [cla, ins, p1, p2, data length, data(if not empty)]
         * @returns an array of HID USB frames ready to be sent
         */ makeBlocks (apdu) {
            // Encodes the APDU length in 2 bytes before the APDU itself.
            // The length is measured as the number of bytes.
            // As the size of the APDU `data` should have been added in 1 byte just before `data`,
            // the minimum size of an APDU is 5 bytes.
            let data = Buffer.concat([
                asUInt16BE(apdu.length),
                apdu
            ]);
            const blockSize = packetSize - 5;
            const nbBlocks = Math.ceil(data.length / blockSize);
            // Fills data with 0-padding
            data = Buffer.concat([
                data,
                Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)
            ]);
            const blocks = [];
            for(let i = 0; i < nbBlocks; i++){
                const head = Buffer.alloc(5);
                head.writeUInt16BE(channel, 0);
                head.writeUInt8(Tag, 2);
                head.writeUInt16BE(i, 3);
                // `slice` and not `subarray`: this might not be a Node Buffer, but probably only a Uint8Array
                const chunk = data.slice(i * blockSize, (i + 1) * blockSize);
                blocks.push(Buffer.concat([
                    head,
                    chunk
                ]));
            }
            return blocks;
        },
        /**
         * Reduces HID USB packets/frames to one response.
         *
         * @param acc The value resulting from (accumulating) the previous call of reduceResponse.
         *   On first call initialized to `initialAcc`. The accumulator enables handling multi-frames messages.
         * @param chunk Current chunk to reduce into accumulator
         * @returns An accumulator value updated with the current chunk
         */ reduceResponse (acc, chunk) {
            let { data, dataLength, sequence } = acc || initialAcc;
            if (chunk.readUInt16BE(0) !== channel) throw new (0, _errors.TransportError)("Invalid channel", "InvalidChannel");
            if (chunk.readUInt8(2) !== Tag) throw new (0, _errors.TransportError)("Invalid tag", "InvalidTag");
            if (chunk.readUInt16BE(3) !== sequence) throw new (0, _errors.TransportError)("Invalid sequence", "InvalidSequence");
            // Gets the total length of the response from the 1st frame
            if (!acc) dataLength = chunk.readUInt16BE(5);
            sequence++;
            // The total length on the 1st frame takes 2 more bytes
            const chunkData = chunk.slice(acc ? 5 : 7);
            data = Buffer.concat([
                data,
                chunkData
            ]);
            // Removes any 0 padding
            if (data.length > dataLength) data = data.slice(0, dataLength);
            return {
                data,
                dataLength,
                sequence
            };
        },
        /**
         * Returns the response message that has been reduced from the HID USB frames
         *
         * @param acc The accumulator
         * @returns A Buffer containing the cleaned response message, or null if no response message, or undefined if the
         *   accumulator is incorrect (message length is not valid)
         */ getReducedResult (acc) {
            if (acc && acc.dataLength === acc.data.length) return acc.data;
        }
    };
};
exports.default = createHIDframing;

},{"ebb2a684f25c5c57":"bwvMq","@ledgerhq/errors":"EVZMy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fnHxP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IIGenericHID", ()=>IIGenericHID);
parcelHelpers.export(exports, "IIKeyboardHID", ()=>IIKeyboardHID);
parcelHelpers.export(exports, "IIU2F", ()=>IIU2F);
parcelHelpers.export(exports, "IICCID", ()=>IICCID);
parcelHelpers.export(exports, "IIWebUSB", ()=>IIWebUSB);
parcelHelpers.export(exports, "DeviceModelId", ()=>DeviceModelId);
parcelHelpers.export(exports, "ledgerUSBVendorId", ()=>ledgerUSBVendorId);
parcelHelpers.export(exports, "getDeviceModel", ()=>getDeviceModel);
parcelHelpers.export(exports, "identifyTargetId", ()=>identifyTargetId);
parcelHelpers.export(exports, "identifyUSBProductId", ()=>identifyUSBProductId);
parcelHelpers.export(exports, "identifyProductName", ()=>identifyProductName);
parcelHelpers.export(exports, "getBluetoothServiceUuids", ()=>getBluetoothServiceUuids);
parcelHelpers.export(exports, "getInfosForServiceUuid", ()=>getInfosForServiceUuid);
var _semver = require("semver");
var _semverDefault = parcelHelpers.interopDefault(_semver);
const IIGenericHID = 0x01;
const IIKeyboardHID = 0x02;
const IIU2F = 0x04;
const IICCID = 0x08;
const IIWebUSB = 0x10;
var DeviceModelId;
(function(DeviceModelId) {
    /** Ledger Blue */ DeviceModelId["blue"] = "blue";
    /** Ledger Nano S */ DeviceModelId["nanoS"] = "nanoS";
    /** Ledger Nano S Plus */ DeviceModelId["nanoSP"] = "nanoSP";
    /** Ledger Nano X */ DeviceModelId["nanoX"] = "nanoX";
    /** Ledger Stax */ DeviceModelId["stax"] = "stax";
    /** Ledger Flex ("europa" is the internal name) */ DeviceModelId["europa"] = "europa";
})(DeviceModelId || (DeviceModelId = {}));
const devices = {
    [DeviceModelId.blue]: {
        id: DeviceModelId.blue,
        productName: "Ledger\xa0Blue",
        productIdMM: 0x00,
        legacyUsbProductId: 0x0000,
        usbOnly: true,
        memorySize: 491520,
        masks: [
            0x31000000,
            0x31010000
        ],
        getBlockSize: (_firwareVersion)=>4096
    },
    [DeviceModelId.nanoS]: {
        id: DeviceModelId.nanoS,
        productName: "Ledger\xa0Nano\xa0S",
        productIdMM: 0x10,
        legacyUsbProductId: 0x0001,
        usbOnly: true,
        memorySize: 327680,
        masks: [
            0x31100000
        ],
        getBlockSize: (firmwareVersion)=>{
            var _a;
            return (0, _semverDefault.default).lt((_a = (0, _semverDefault.default).coerce(firmwareVersion)) !== null && _a !== void 0 ? _a : "", "2.0.0") ? 4096 : 2048;
        }
    },
    [DeviceModelId.nanoX]: {
        id: DeviceModelId.nanoX,
        productName: "Ledger\xa0Nano\xa0X",
        productIdMM: 0x40,
        legacyUsbProductId: 0x0004,
        usbOnly: false,
        memorySize: 2097152,
        masks: [
            0x33000000
        ],
        getBlockSize: (_firwareVersion)=>4096,
        bluetoothSpec: [
            {
                serviceUuid: "13d63400-2c97-0004-0000-4c6564676572",
                notifyUuid: "13d63400-2c97-0004-0001-4c6564676572",
                writeUuid: "13d63400-2c97-0004-0002-4c6564676572",
                writeCmdUuid: "13d63400-2c97-0004-0003-4c6564676572"
            }
        ]
    },
    [DeviceModelId.nanoSP]: {
        id: DeviceModelId.nanoSP,
        productName: "Ledger Nano S Plus",
        productIdMM: 0x50,
        legacyUsbProductId: 0x0005,
        usbOnly: true,
        memorySize: 1569792,
        masks: [
            0x33100000
        ],
        getBlockSize: (_firmwareVersion)=>32
    },
    [DeviceModelId.stax]: {
        id: DeviceModelId.stax,
        productName: "Ledger\xa0Stax",
        productIdMM: 0x60,
        legacyUsbProductId: 0x0006,
        usbOnly: false,
        memorySize: 1569792,
        masks: [
            0x33200000
        ],
        getBlockSize: (_firmwareVersion)=>32,
        bluetoothSpec: [
            {
                serviceUuid: "13d63400-2c97-6004-0000-4c6564676572",
                notifyUuid: "13d63400-2c97-6004-0001-4c6564676572",
                writeUuid: "13d63400-2c97-6004-0002-4c6564676572",
                writeCmdUuid: "13d63400-2c97-6004-0003-4c6564676572"
            }
        ]
    },
    [DeviceModelId.europa]: {
        id: DeviceModelId.europa,
        productName: "Ledger\xa0Flex",
        productIdMM: 0x70,
        legacyUsbProductId: 0x0007,
        usbOnly: false,
        memorySize: 1569792,
        masks: [
            0x33300000
        ],
        getBlockSize: (_firmwareVersion)=>32,
        bluetoothSpec: [
            {
                serviceUuid: "13d63400-2c97-3004-0000-4c6564676572",
                notifyUuid: "13d63400-2c97-3004-0001-4c6564676572",
                writeUuid: "13d63400-2c97-3004-0002-4c6564676572",
                writeCmdUuid: "13d63400-2c97-3004-0003-4c6564676572"
            }
        ]
    }
};
const productMap = {
    Blue: DeviceModelId.blue,
    "Nano S": DeviceModelId.nanoS,
    "Nano S Plus": DeviceModelId.nanoSP,
    "Nano X": DeviceModelId.nanoX,
    Stax: DeviceModelId.stax,
    Europa: DeviceModelId.europa
};
const devicesList = Object.values(devices);
const ledgerUSBVendorId = 0x2c97;
const getDeviceModel = (id)=>{
    const info = devices[id];
    if (!info) throw new Error("device '" + id + "' does not exist");
    return info;
};
const identifyTargetId = (targetId)=>{
    const deviceModel = devicesList.find(({ masks })=>masks.find((mask)=>(targetId & 0xffff0000) === mask));
    return deviceModel;
};
const identifyUSBProductId = (usbProductId)=>{
    const legacy = devicesList.find((d)=>d.legacyUsbProductId === usbProductId);
    if (legacy) return legacy;
    const mm = usbProductId >> 8;
    const deviceModel = devicesList.find((d)=>d.productIdMM === mm);
    return deviceModel;
};
const identifyProductName = (productName)=>{
    const deviceModel = devicesList.find((d)=>d.id === productMap[productName]);
    return deviceModel;
};
const bluetoothServices = [];
const serviceUuidToInfos = {};
for(const id in devices){
    const deviceModel = devices[id];
    const { bluetoothSpec } = deviceModel;
    if (bluetoothSpec) for(let i = 0; i < bluetoothSpec.length; i++){
        const spec = bluetoothSpec[i];
        bluetoothServices.push(spec.serviceUuid);
        serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, "")] = Object.assign({
            deviceModel
        }, spec);
    }
}
const getBluetoothServiceUuids = ()=>bluetoothServices;
const getInfosForServiceUuid = (uuid)=>serviceUuidToInfos[uuid.toLowerCase()];

},{"semver":"3th7M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7NNG8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "requestLedgerDevice", ()=>requestLedgerDevice);
parcelHelpers.export(exports, "getLedgerDevices", ()=>getLedgerDevices);
parcelHelpers.export(exports, "getFirstLedgerDevice", ()=>getFirstLedgerDevice);
parcelHelpers.export(exports, "isSupported", ()=>isSupported);
var _devices = require("@ledgerhq/devices");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const ledgerDevices = [
    {
        vendorId: (0, _devices.ledgerUSBVendorId)
    }
];
function requestLedgerDevice() {
    return __awaiter(this, void 0, void 0, function*() {
        const device = yield navigator.usb.requestDevice({
            filters: ledgerDevices
        });
        return device;
    });
}
function getLedgerDevices() {
    return __awaiter(this, void 0, void 0, function*() {
        const devices = yield navigator.usb.getDevices();
        return devices.filter((d)=>d.vendorId === (0, _devices.ledgerUSBVendorId));
    });
}
function getFirstLedgerDevice() {
    return __awaiter(this, void 0, void 0, function*() {
        const existingDevices = yield getLedgerDevices();
        if (existingDevices.length > 0) return existingDevices[0];
        return requestLedgerDevice();
    });
}
const isSupported = ()=>Promise.resolve(!!navigator && !!navigator.usb && typeof navigator.usb.getDevices === "function");

},{"@ledgerhq/devices":"fnHxP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2JAI7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getMoneroAddress", ()=>getMoneroAddress);
parcelHelpers.export(exports, "sum", ()=>sum);
var _esnextMapGroupByJs = require("core-js/modules/esnext.map.group-by.js");
var _esnextSymbolDisposeJs = require("core-js/modules/esnext.symbol.dispose.js");
var _webImmediateJs = require("core-js/modules/web.immediate.js");
var _logs = require("@ledgerhq/logs");
var _hwTransportWebhid = require("@ledgerhq/hw-transport-webhid");
var _hwTransportWebhidDefault = parcelHelpers.interopDefault(_hwTransportWebhid);
async function getMoneroAddress(app) {
    try {
        console.log("Attempting to get Monero address now...");
        // Request access to the Ledger device
        const transport = await (0, _hwTransportWebhidDefault.default).create();
        // Define APDU command parameters
        const cla = 0xE0; // Class byte for Ledger Monero app
        const ins = 0x46; // INS_DERIVE_SUBADDRESS_PUBLIC_KEY
        const p1 = 0x00; // First parameter
        const p2 = 0x00; // Second parameter
        // Derivation path: 44'/128'/0'/0/0
        const derivationPath = [
            0x8000002c,
            0x80000080,
            0x80000000,
            0x00000000,
            0x00000000
        ];
        const data = serializeDerivationPath(derivationPath);
        console.log("Serialized Derivation Path:", data);
        // Send the APDU command to the Ledger device
        const response = await transport.send(cla, ins, p1, p2, data);
        // Listen to Ledger logs for debugging
        (0, _logs.listen)((log)=>console.log(log));
        //console.log("Monero Address Response:", response);
        if (response.length > 2) {
            const statusCode = response.slice(-2); // Last 2 bytes are the status word
            if (statusCode[0] === 0x90 && statusCode[1] === 0x00) console.log("Success:", response);
            else console.error("Error with status code:", statusCode);
        }
    } catch (error) {
        console.error("Error getting Monero address:", error);
    }
}
// Helper function to serialize the derivation path
function serializeDerivationPath(path) {
    const buffer = new ArrayBuffer(1 + path.length * 4); // 1 byte for path length + 4 bytes for each path element
    const dataView = new DataView(buffer);
    dataView.setUint8(0, path.length); // First byte: path length
    path.forEach((element, index)=>{
        dataView.setUint32(1 + index * 4, element);
    });
    return new Uint8Array(buffer);
}
function sum(a, b) {
    return a + b;
}

},{"core-js/modules/esnext.map.group-by.js":"3AR1K","core-js/modules/esnext.symbol.dispose.js":"b9ez5","core-js/modules/web.immediate.js":"49tUX","@ledgerhq/logs":"i4OI0","@ledgerhq/hw-transport-webhid":"8O295","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8O295":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hwTransport = require("@ledgerhq/hw-transport");
var _hwTransportDefault = parcelHelpers.interopDefault(_hwTransport);
var _hidFraming = require("@ledgerhq/devices/hid-framing");
var _hidFramingDefault = parcelHelpers.interopDefault(_hidFraming);
var _devices = require("@ledgerhq/devices");
var _logs = require("@ledgerhq/logs");
var _errors = require("@ledgerhq/errors");
var Buffer = require("3666b9e986722ce4").Buffer;
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const ledgerDevices = [
    {
        vendorId: (0, _devices.ledgerUSBVendorId)
    }
];
const isSupported = ()=>Promise.resolve(!!(window.navigator && window.navigator.hid));
const getHID = ()=>{
    // $FlowFixMe
    const { hid } = navigator;
    if (!hid) throw new (0, _errors.TransportError)("navigator.hid is not supported", "HIDNotSupported");
    return hid;
};
function requestLedgerDevices() {
    return __awaiter(this, void 0, void 0, function*() {
        const device = yield getHID().requestDevice({
            filters: ledgerDevices
        });
        if (Array.isArray(device)) return device;
        return [
            device
        ];
    });
}
function getLedgerDevices() {
    return __awaiter(this, void 0, void 0, function*() {
        const devices = yield getHID().getDevices();
        return devices.filter((d)=>d.vendorId === (0, _devices.ledgerUSBVendorId));
    });
}
function getFirstLedgerDevice() {
    return __awaiter(this, void 0, void 0, function*() {
        const existingDevices = yield getLedgerDevices();
        if (existingDevices.length > 0) return existingDevices[0];
        const devices = yield requestLedgerDevices();
        return devices[0];
    });
}
/**
 * WebHID Transport implementation
 * @example
 * import TransportWebHID from "@ledgerhq/hw-transport-webhid";
 * ...
 * TransportWebHID.create().then(transport => ...)
 */ class TransportWebHID extends (0, _hwTransportDefault.default) {
    constructor(device){
        super();
        this.channel = Math.floor(Math.random() * 0xffff);
        this.packetSize = 64;
        this.inputs = [];
        this.read = ()=>{
            if (this.inputs.length) return Promise.resolve(this.inputs.shift());
            return new Promise((success)=>{
                this.inputCallback = success;
            });
        };
        this.onInputReport = (e)=>{
            const buffer = Buffer.from(e.data.buffer);
            if (this.inputCallback) {
                this.inputCallback(buffer);
                this.inputCallback = null;
            } else this.inputs.push(buffer);
        };
        this._disconnectEmitted = false;
        this._emitDisconnect = (e)=>{
            if (this._disconnectEmitted) return;
            this._disconnectEmitted = true;
            this.emit("disconnect", e);
        };
        /**
         * Exchange with the device using APDU protocol.
         * @param apdu
         * @returns a promise of apdu response
         */ this.exchange = (apdu)=>__awaiter(this, void 0, void 0, function*() {
                const b = yield this.exchangeAtomicImpl(()=>__awaiter(this, void 0, void 0, function*() {
                        const { channel, packetSize } = this;
                        (0, _logs.log)("apdu", "=> " + apdu.toString("hex"));
                        const framing = (0, _hidFramingDefault.default)(channel, packetSize);
                        // Write...
                        const blocks = framing.makeBlocks(apdu);
                        for(let i = 0; i < blocks.length; i++)yield this.device.sendReport(0, blocks[i]);
                        // Read...
                        let result;
                        let acc;
                        while(!(result = framing.getReducedResult(acc))){
                            const buffer = yield this.read();
                            acc = framing.reduceResponse(acc, buffer);
                        }
                        (0, _logs.log)("apdu", "<= " + result.toString("hex"));
                        return result;
                    })).catch((e)=>{
                    if (e && e.message && e.message.includes("write")) {
                        this._emitDisconnect(e);
                        throw new (0, _errors.DisconnectedDeviceDuringOperation)(e.message);
                    }
                    throw e;
                });
                return b;
            });
        this.device = device;
        this.deviceModel = typeof device.productId === "number" ? (0, _devices.identifyUSBProductId)(device.productId) : undefined;
        device.addEventListener("inputreport", this.onInputReport);
    }
    /**
     * Similar to create() except it will always display the device permission (even if some devices are already accepted).
     */ static request() {
        return __awaiter(this, void 0, void 0, function*() {
            const [device] = yield requestLedgerDevices();
            return TransportWebHID.open(device);
        });
    }
    /**
     * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).
     */ static openConnected() {
        return __awaiter(this, void 0, void 0, function*() {
            const devices = yield getLedgerDevices();
            if (devices.length === 0) return null;
            return TransportWebHID.open(devices[0]);
        });
    }
    /**
     * Create a Ledger transport with a HIDDevice
     */ static open(device) {
        return __awaiter(this, void 0, void 0, function*() {
            yield device.open();
            const transport = new TransportWebHID(device);
            const onDisconnect = (e)=>{
                if (device === e.device) {
                    getHID().removeEventListener("disconnect", onDisconnect);
                    transport._emitDisconnect(new (0, _errors.DisconnectedDevice)());
                }
            };
            getHID().addEventListener("disconnect", onDisconnect);
            return transport;
        });
    }
    /**
     * Release the transport device
     */ close() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.exchangeBusyPromise;
            this.device.removeEventListener("inputreport", this.onInputReport);
            yield this.device.close();
        });
    }
    setScrambleKey() {}
}
/**
 * Check if WebUSB transport is supported.
 */ TransportWebHID.isSupported = isSupported;
/**
 * List the WebUSB devices that was previously authorized by the user.
 */ TransportWebHID.list = getLedgerDevices;
/**
 * Actively listen to WebUSB devices and emit ONE device
 * that was either accepted before, if not it will trigger the native permission UI.
 *
 * Important: it must be called in the context of a UI click!
 */ TransportWebHID.listen = (observer)=>{
    let unsubscribed = false;
    getFirstLedgerDevice().then((device)=>{
        if (!device) observer.error(new (0, _errors.TransportOpenUserCancelled)("Access denied to use Ledger device"));
        else if (!unsubscribed) {
            const deviceModel = typeof device.productId === "number" ? (0, _devices.identifyUSBProductId)(device.productId) : undefined;
            observer.next({
                type: "add",
                descriptor: device,
                deviceModel
            });
            observer.complete();
        }
    }, (error)=>{
        observer.error(new (0, _errors.TransportOpenUserCancelled)(error.message));
    });
    function unsubscribe() {
        unsubscribed = true;
    }
    return {
        unsubscribe
    };
};
exports.default = TransportWebHID;

},{"3666b9e986722ce4":"bwvMq","@ledgerhq/hw-transport":"59Ey9","@ledgerhq/devices/hid-framing":"3BsQA","@ledgerhq/devices":"fnHxP","@ledgerhq/logs":"i4OI0","@ledgerhq/errors":"EVZMy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2sLhv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "checkDeviceConnection", ()=>checkDeviceConnection) //checkDeviceConnection();
;
var _hwTransportWebhid = require("@ledgerhq/hw-transport-webhid");
var _hwTransportWebhidDefault = parcelHelpers.interopDefault(_hwTransportWebhid);
async function checkDeviceConnection(app) {
    try {
        // Request access to the Ledger device
        const transport = await (0, _hwTransportWebhidDefault.default).create();
        console.log("Device connected:", transport);
        console.log("Device Model:", transport.deviceModel);
        console.log("Device Model ID:", transport.deviceModel ? transport.deviceModel.id : "Not Available");
        // Define the Get Device Version APDU command
        const cla = 0x00; // Class byte
        const ins = 0x01; // Instruction byte for Get Device Version
        const p1 = 0x00; // Parameter 1
        const p2 = 0x00; // Parameter 2
        const data = new Uint8Array([]); // No data needed
        // Send the command to the Ledger device
        /* const response = await transport.send(cla, ins, p1, p2, data);

        // Process the response
        console.log("Device Response:", response.deviceModel.id);
        console.log("Device Model:", response.deviceModel);
        console.log("Device Model ID:", response.deviceModel ? response.deviceModel.id : 'Not Available'); */ const response = "";
        try {
            const message = {
                operationEventMsg: transport.deviceModel.id
            };
            console.log("Sending message:", message);
            app.ports.receiveMessageFromJs.send(message);
        } catch (error) {
            const errorMessage = {
                Err: error.message
            };
            console.log("Sending error message:", errorMessage);
            app.ports.receiveMessageFromJs.send(errorMessage);
        }
    } catch (error) {
        console.error("Error:", error);
    }
}

},{"@ledgerhq/hw-transport-webhid":"8O295","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"X1LcC":[function(require,module,exports) {
$(window).on("scroll", function() {
    if ($(window).scrollTop() > 50) {
        $("div.nav-section-above800px").addClass("headeronscrolldown");
        $("nav ul").addClass("ulonscrolldown");
        $("nav img").addClass("logoImageShrink");
        /* NOTE: For class selector make sure you have '.'' */ $(".topLinks-flex-container").addClass("topLinks-transition");
        /* Remove */ $("nav img").removeClass("logoImageExpand");
    } else {
        $("div.nav-section-above800px").removeClass("headeronscrolldown");
        $("nav ul").removeClass("ulonscrolldown");
        $("nav img").removeClass("logoImageShrink");
        $(".topLinks-flex-container").removeClass("topLinks-transition");
        /* Add */ $("nav img").addClass("logoImageExpand");
    }
});

},{}]},["gDk1O","8NmNK"], "8NmNK", "parcelRequire1e94")

//# sourceMappingURL=index.bada3e25.js.map
